[
  {
    "content": "The `nonBlockingRead` method of the `ClusterMsgHandler` class is part of a networking wrapper designed to manage communication between multiple computing nodes in a cluster environment. It provides an asynchronous mechanism for checking and reading incoming datagrams from a queued connection reader, enabling efficient non-blocking data retrieval while maintaining message tracking through packet numbers. This functionality supports seamless multi-pipe networking operations, ensuring that data handling remains responsive and scalable across distributed systems.\n\nclass ClusterMsgHandler:\n    \"\"\"ClusterMsgHandler: wrapper for PC clusters/multi-piping networking\"\"\"\n    def __init__(self, packetStart, notify):\n        # packetStart can be used to distinguish which ClusterMsgHandler\n        # sends a given packet.\n        self.packetNumber = packetStart\n        self.notify = notify\n\n    def nonBlockingRead(self, qcr):\n        \"\"\"\n        Return a datagram iterator and type if data is available on the\n        queued connection reader\n        \"\"\"\n        if qcr.dataAvailable():\n            datagram = NetDatagram()\n            if qcr.getData(datagram):\n                (dgi, dtype) = self.readHeader(datagram)\n            else:\n                dgi = None\n                dtype = CLUSTER_NONE\n                self.notify.warning(\"getData returned false\")\n        else:\n            datagram = None\n            dgi = None\n            dtype = CLUSTER_NONE\n        # Note, return datagram to keep a handle on the data\n        return (datagram, dgi, dtype)",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 50
  },
  {
    "content": "This code chunk is part of a class that handles network communication using datagrams. The `blockingRead` method ensures that the application waits until data is available on a queued connection reader before processing it, facilitating reliable data retrieval for network operations.\n\ndef blockingRead(self, qcr):\n        \"\"\"\n        Block until data is available on the queued connection reader.\n        Returns a datagram iterator and type\n        \"\"\"\n        while not qcr.dataAvailable():\n            # The following may not be necessary.\n            # I just wanted some\n            # time given to the operating system while\n            # busy waiting.\n            time.sleep(0.002)\n        # Data is available, create a datagram iterator\n        datagram = NetDatagram()\n        if qcr.getData(datagram):\n            (dgi, dtype) = self.readHeader(datagram)\n        else:\n            (dgi, dtype) = (None, CLUSTER_NONE)\n            self.notify.warning(\"getData returned false\")\n        # Note, return datagram to keep a handle on the data\n        return (datagram, dgi, dtype)",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 51
  },
  {
    "content": "The provided chunk introduces two new methods within a class that manages datagram creation and parsing for cluster communication. \n\n1. `readHeader`: A utility method to extract header information (packet number and type) from incoming datagrams, aiding in message processing.\n2. `makeCamOffsetDatagram`: Creates a datagram for transmitting camera offset data, expanding the existing set of camera-related messages.\n\nThese additions enhance the class's functionality by adding support for new message types and improving code organization through reusable header parsing logic.\n\ndef readHeader(self, datagram):\n        dgi = PyDatagramIterator(datagram)\n        number = dgi.getUint32()\n        dtype = dgi.getUint8()\n        self.notify.debug(\"Packet %d type %d received\" % (number, dtype))\n        return (dgi, dtype)\n\n    def makeCamOffsetDatagram(self, xyz, hpr):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_CAM_OFFSET)\n        datagram.addFloat32(xyz[0])\n        datagram.addFloat32(xyz[1])\n        datagram.addFloat32(xyz[2])\n        datagram.addFloat32(hpr[0])\n        datagram.addFloat32(hpr[1])\n        datagram.addFloat32(hpr[2])\n        return datagram",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 52
  },
  {
    "content": "These functions handle cluster-specific camera offset and frustum data transmission. `parseCamOffsetDatagram` parses incoming camera offset parameters including position and rotation values, while `makeCamFrustumDatagram` constructs a message containing camera frustum configuration details like focal length, film size, and offset. These methods facilitate low-level network communication for rendering synchronization across distributed cluster nodes.\n\ndef parseCamOffsetDatagram(self, dgi):\n        x=dgi.getFloat32()\n        y=dgi.getFloat32()\n        z=dgi.getFloat32()\n        h=dgi.getFloat32()\n        p=dgi.getFloat32()\n        r=dgi.getFloat32()\n        self.notify.debug('new offset=%f %f %f  %f %f %f' % (x, y, z, h, p, r))\n        return (x, y, z, h, p, r)\n\n    def makeCamFrustumDatagram(self, focalLength, filmSize, filmOffset):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_CAM_FRUSTUM)\n        datagram.addFloat32(focalLength)\n        datagram.addFloat32(filmSize[0])\n        datagram.addFloat32(filmSize[1])\n        datagram.addFloat32(filmOffset[0])\n        datagram.addFloat32(filmOffset[1])\n        return datagram",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 53
  },
  {
    "content": "The provided chunk introduces two new methods: `parseCamFrustumDatagram` and `makeCamMovementDatagram`. These functions are designed to handle camera-specific datagrams in a networked or distributed system. The `parseCamFrustumDatagram` method is used to parse incoming datagrams containing camera frustum data, such as focal length, film size, and offset, which is essential for maintaining consistent camera settings across different nodes in the cluster. On the other hand, the `makeCamMovementDatagram` method constructs outgoing datagrams that include the camera's position (xyz coordinates) and orientation (hpr - heading, pitch, roll), enabling synchronization of camera movements between nodes. These additions enhance the system's ability to manage and synchronize camera-related operations within the cluster environment.\n\ndef parseCamFrustumDatagram(self, dgi):\n        focalLength = dgi.getFloat32()\n        filmSize    = (dgi.getFloat32(), dgi.getFloat32())\n        filmOffset  = (dgi.getFloat32(), dgi.getFloat32())\n        self.notify.debug('fl, fs, fo=%f, (%f, %f), (%f, %f)' %\n                          (focalLength, filmSize[0], filmSize[1],\n                           filmOffset[0], filmOffset[1]))\n        return (focalLength, filmSize, filmOffset)\n\n    def makeCamMovementDatagram(self, xyz, hpr):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_CAM_MOVEMENT)\n        datagram.addFloat32(xyz[0])\n        datagram.addFloat32(xyz[1])\n        datagram.addFloat32(xyz[2])\n        datagram.addFloat32(hpr[0])\n        datagram.addFloat32(hpr[1])\n        datagram.addFloat32(hpr[2])\n        return datagram\n\n\n    def makeNamedMovementDone(self):",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 54
  },
  {
    "content": "The `makeNamedMovementDone` method is part of a collection of functions designed to generate network messages (datagrams) for controlling and coordinating actions across a distributed system or application. These functions handle various operations such as movement commands, command strings, synchronization events, time data updates, and exit signals, enabling efficient communication and coordination between different components or nodes in the cluster.\n\ndef makeNamedMovementDone(self):\n\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_NAMED_MOVEMENT_DONE)\n        return datagram",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 55
  },
  {
    "content": "This code chunk is part of a class that implements methods for creating various types of network messages (datagrams) used in a distributed or multi-client system. The `makeNamedObjectMovementDatagram` method specifically constructs a message containing the position, orientation, scale, color, and visibility state of a named object, which can be sent over a network to synchronize object states across multiple clients or servers.\n\ndef makeNamedObjectMovementDatagram(self, xyz, hpr, scale, color, hidden, name):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_NAMED_OBJECT_MOVEMENT)\n        datagram.addString(name)\n        datagram.addFloat32(xyz[0])\n        datagram.addFloat32(xyz[1])\n        datagram.addFloat32(xyz[2])\n        datagram.addFloat32(hpr[0])\n        datagram.addFloat32(hpr[1])\n        datagram.addFloat32(hpr[2])\n        datagram.addFloat32(scale[0])\n        datagram.addFloat32(scale[1])\n        datagram.addFloat32(scale[2])\n        datagram.addFloat32(color[0])\n        datagram.addFloat32(color[1])\n        datagram.addFloat32(color[2])\n        datagram.addFloat32(color[3])\n        datagram.addBool(hidden)\n        return datagram",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 56
  },
  {
    "content": "The provided code chunk consists of two methods within a Python class that handle parsing of specific types of network data packets (datagrams). These methods are `parseCamMovementDatagram` and `parseNamedMovementDatagram`, which decode incoming data related to camera movements and object transformations, respectively. \n\n- **`parseCamMovementDatagram`**: Extracts position (`x, y, z`) and rotation (`h, p, r`) values from a data input object (dgi). It logs these values for debugging purposes and returns them as a tuple.\n  \n- **`parseNamedMovementDatagram`**: Retrieves more comprehensive movement data including an object's name, position (`x, y, z`), rotation (`h, p, r`), scaling factors (`sx, sy, sz`), color components (`red, g, b, a`), and a hidden status flag. It returns all these values as a tuple.\n\nThese methods are part of a broader set of functions designed for creating and parsing various types of network messages, including commands, synchronization data, swap signals, and exit commands, facilitating real-time communication between different nodes in a distributed system.\n\ndef parseCamMovementDatagram(self, dgi):\n        x=dgi.getFloat32()\n        y=dgi.getFloat32()\n        z=dgi.getFloat32()\n        h=dgi.getFloat32()\n        p=dgi.getFloat32()\n        r=dgi.getFloat32()\n        self.notify.debug(('  new position=%f %f %f  %f %f %f' %\n                           (x, y, z, h, p, r)))\n        return (x, y, z, h, p, r)\n\n    def parseNamedMovementDatagram(self, dgi):\n        name = dgi.getString()\n        x=dgi.getFloat32()\n        y=dgi.getFloat32()\n        z=dgi.getFloat32()\n        h=dgi.getFloat32()\n        p=dgi.getFloat32()\n        r=dgi.getFloat32()\n        sx = dgi.getFloat32()\n        sy = dgi.getFloat32()\n        sz = dgi.getFloat32()\n        red = dgi.getFloat32()\n        g = dgi.getFloat32()\n        b = dgi.getFloat32()\n        a = dgi.getFloat32()\n        hidden = dgi.getBool()\n        return (name,x, y, z, h, p, r, sx, sy, sz, red, g, b, a, hidden)",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 57
  },
  {
    "content": "The `makeSelectedMovementDatagram` method constructs a PyDatagram containing transformation (position, rotation, scale) data for selected objects, used to synchronize movements across the network in a distributed environment.\n\ndef makeSelectedMovementDatagram(self, xyz, hpr, scale):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_SELECTED_MOVEMENT)\n        datagram.addFloat32(xyz[0])\n        datagram.addFloat32(xyz[1])\n        datagram.addFloat32(xyz[2])\n        datagram.addFloat32(hpr[0])\n        datagram.addFloat32(hpr[1])\n        datagram.addFloat32(hpr[2])\n        datagram.addFloat32(scale[0])\n        datagram.addFloat32(scale[1])\n        datagram.addFloat32(scale[2])\n        #datagram.addBool(hidden)\n        return datagram",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 58
  },
  {
    "content": "The code chunk comprises methods for parsing and creating specific datagram types (SelectedMovement and CommandString) within a larger inter-process communication framework designed for cluster synchronization and management.\n\ndef parseSelectedMovementDatagram(self, dgi):\n        x=dgi.getFloat32()\n        y=dgi.getFloat32()\n        z=dgi.getFloat32()\n        h=dgi.getFloat32()\n        p=dgi.getFloat32()\n        r=dgi.getFloat32()\n        sx=dgi.getFloat32()\n        sy=dgi.getFloat32()\n        sz=dgi.getFloat32()\n        self.notify.debug('  new position=%f %f %f  %f %f %f %f %f %f' %\n                          (x, y, z, h, p, r, sx, sy, sz))\n        return (x, y, z, h, p, r, sx, sy, sz)\n\n    def makeCommandStringDatagram(self, commandString):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_COMMAND_STRING)\n        datagram.addString(commandString)\n        return datagram\n\n    def parseCommandStringDatagram(self, dgi):\n        command = dgi.getString()\n        return command",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 59
  },
  {
    "content": "The provided code defines methods in a class responsible for generating and interpreting network packets (datagrams) used to manage cluster operations, including command execution, state transitions like swapping, and termination signals.\n\ndef parseCommandStringDatagram(self, dgi):\n        command = dgi.getString()\n        return command\n\n    def makeSwapNowDatagram(self):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_SWAP_NOW)\n        return datagram\n\n    def makeSwapReadyDatagram(self):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_SWAP_READY)\n        return datagram\n\n    def makeExitDatagram(self):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_EXIT)\n        return datagram",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 60
  },
  {
    "content": "The provided code chunk is part of a class responsible for creating and parsing network datagrams in Python, used for inter-process communication or networking. The methods `makeTimeDataDatagram` and `parseTimeDataDatagram` specifically handle serialization/deserialization of timing information (frame count, frame time, delta time) to facilitate synchronization or performance tracking between connected nodes.\n\ndef makeTimeDataDatagram(self, frameCount, frameTime, dt):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_TIME_DATA)\n        datagram.addUint32(frameCount)\n        datagram.addFloat32(frameTime)\n        datagram.addFloat32(dt)\n        return datagram\n\n    def parseTimeDataDatagram(self, dgi):\n        frameCount=dgi.getUint32()\n        frameTime=dgi.getFloat32()\n        dt=dgi.getFloat32()\n        self.notify.debug('time data=%f %f' % (frameTime, dt))\n        return (frameCount, frameTime, dt)",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 61
  },
  {
    "content": "The Chunk defines the message type constants used in the `ClusterMsgs` module, which provides communication primitives for a distributed rendering system between a ClusterClient and a ClusterServer.\n\n\"\"\"ClusterMsgs module: Message types for Cluster rendering\"\"\"\n\n# This module is intended to supply routines and dataformats common to\n# both ClusterClient and ClusterServer.\n\nfrom panda3d.net import NetDatagram\nfrom direct.distributed.PyDatagram import PyDatagram\nfrom direct.distributed.PyDatagramIterator import PyDatagramIterator\nimport time\n\n#these are the types of messages that are currently supported.\nCLUSTER_NONE                  = 0\nCLUSTER_CAM_OFFSET            = 1\nCLUSTER_CAM_FRUSTUM           = 2\nCLUSTER_CAM_MOVEMENT          = 3\nCLUSTER_SWAP_READY            = 4\nCLUSTER_SWAP_NOW              = 5\nCLUSTER_COMMAND_STRING        = 6\nCLUSTER_SELECTED_MOVEMENT     = 7\nCLUSTER_TIME_DATA             = 8\nCLUSTER_NAMED_OBJECT_MOVEMENT = 9\nCLUSTER_NAMED_MOVEMENT_DONE   = 10\nCLUSTER_EXIT                  = 100",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "simplified_code",
      "language": "python"
    },
    "chunk_index": 62
  },
  {
    "content": "The provided code defines essential configuration parameters and message handling functions for a Panda3D-based distributed rendering system, enabling multi-process communication during cluster rendering.\n\n#Port number for cluster rendering\n# DAEMON PORT IS PORT USED FOR STARTUP MESSAGE EXCHANGE\n# CAN BE OVERRIDEN WITH cluster-daemon-client-port for client\n# and cluster-daemon-server-port for server\nCLUSTER_DAEMON_PORT = 8001\n# THIS IS THE TCP PORT USED FOR EXCHANGE OF DATA ONCE STARTUP IS COMPLETE\nCLUSTER_SERVER_PORT = 1970\n\n# Precede command string with ! to tell server to execute command string\n# Note, this startup string obviates the need to set any cluster related\n# config variables in the client Configrc files\nSERVER_STARTUP_STRING = (\n    '!bash ppython -c ' +\n    '\"import builtins; ' +\n    'builtins.clusterMode = \\'server\\';' +\n    'builtins.clusterServerPort = %s;' +\n    'builtins.clusterSyncFlag = %d;' +\n    'builtins.clusterDaemonClient = \\'%s\\';' +\n    'builtins.clusterDaemonPort = %d;'\n    'from direct.directbase.DirectStart import *; run()\"')\n\n# Code for: class ClusterMsgHandler:",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterMsgs.py",
      "content_type": "simplified_code",
      "language": "python"
    },
    "chunk_index": 63
  }
]