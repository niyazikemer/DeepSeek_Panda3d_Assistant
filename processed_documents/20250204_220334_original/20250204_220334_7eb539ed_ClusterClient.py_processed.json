[
  {
    "content": "class ClusterClient(DirectObject.DirectObject):\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"ClusterClient\")\n    MGR_NUM = 1000000\n\n    def __init__(self, configList, clusterSyncFlag):\n        # Set name so cluster __call__ function can be used in Intervals\n        self.__name__ = 'cluster'\n        # First start up servers using direct daemon\n        # What is the name of the client machine?\n        clusterClientDaemonHost = base.config.GetString(\n            'cluster-client-daemon', 'None')\n        if clusterClientDaemonHost == 'None':\n            clusterClientDaemonHost = os.popen('uname -n').read()\n            clusterClientDaemonHost = clusterClientDaemonHost.replace('\\n', '')\n        # What daemon port are we using to communicate between client/servers\n        clusterClientDaemonPort = base.config.GetInt(\n            'cluster-client-daemon-port', CLUSTER_DAEMON_PORT)\n        # Create a daemon\n        self.daemon = DirectD()\n        # Start listening for the response\n        self.daemon.listenTo(clusterClientDaemonPort)\n        # Contact server daemons and start up remote server application\n        for serverConfig in configList:\n            # First kill existing application\n            self.daemon.tellServer(serverConfig.serverName,\n                                   serverConfig.serverDaemonPort,\n                                   'ka')\n            # Now start up new application\n            serverCommand = (SERVER_STARTUP_STRING %\n                             (serverConfig.serverMsgPort,\n                              clusterSyncFlag,\n                              clusterClientDaemonHost,\n                              clusterClientDaemonPort))\n            self.daemon.tellServer(serverConfig.serverName,\n                                   serverConfig.serverDaemonPort,\n                                   serverCommand)\n        print('Begin waitForServers')\n        if not self.daemon.waitForServers(len(configList)):\n            print('Cluster Client, no response from servers')\n        print('End waitForServers')\n        self.qcm=QueuedConnectionManager()\n        self.serverList = []\n        self.serverQueues = []\n        self.msgHandler = ClusterMsgHandler(ClusterClient.MGR_NUM, self.notify)\n\n        # A dictionary of objects that can be accessed by name\n        self.objectMappings  = {}\n        self.objectHasColor  = {}\n\n        # a dictionary of name objects and the corresponding names of\n        # objects they are to control on the server side\n        self.controlMappings = {}\n        self.controlOffsets  = {}\n        self.taggedObjects   = {}\n        self.controlPriorities = {}\n        self.sortedControlMappings = []\n\n        for serverConfig in configList:\n            server = DisplayConnection(\n                self.qcm, serverConfig.serverName,\n                serverConfig.serverMsgPort, self.msgHandler)\n            if server is None:\n                self.notify.error('Could not open %s on %s port %d' %\n                                  (serverConfig.serverConfigName,\n                                   serverConfig.serverName,\n                                   serverConfig.serverMsgPort))\n            else:\n                self.notify.debug('send cam pos')\n                #server.sendMoveCam(Point3(0), Vec3(0))\n                self.notify.debug('send cam offset')\n                server.sendCamOffset(serverConfig.xyz, serverConfig.hpr)\n                if serverConfig.fFrustum:\n                    self.notify.debug('send cam frustum')\n                    server.sendCamFrustum(serverConfig.focalLength,\n                                          serverConfig.filmSize,\n                                          serverConfig.filmOffset)\n                self.serverList.append(server)\n                self.serverQueues.append([])\n        self.notify.debug('pre startTimeTask')\n        self.startSynchronizeTimeTask()\n        self.notify.debug('pre startMoveCam')\n        self.startMoveCamTask()\n        self.notify.debug('post startMoveCam')\n        self.startMoveSelectedTask()\n\n    def startReaderPollTask(self):\n        \"\"\" Task to handle datagrams from server \"\"\"\n        # Run this task just after the listener poll task\n        taskMgr.add(self._readerPollTask, \"clientReaderPollTask\", -39)\n\n    def _readerPollTask(self, state):\n        \"\"\" Non blocking task to read all available datagrams \"\"\"\n\n        for i in range(len(self.serverList)):\n            server = self.serverList[i]\n            datagrams = server.poll()\n            for data in datagrams:\n                self.handleDatagram(data[0],data[1],i)\n\n        return Task.cont\n\n    def startControlObjectTask(self):\n        self.notify.debug(\"moving control objects\")\n        taskMgr.add(self.controlObjectTask,\"controlObjectTask\",50)\n\n    def startSynchronizeTimeTask(self):\n        self.notify.debug('broadcasting frame time')\n        taskMgr.add(self.synchronizeTimeTask, \"synchronizeTimeTask\", -40)\n\n    def synchronizeTimeTask(self, task):\n        clock = ClockObject.getGlobalClock()\n        frameCount = clock.getFrameCount()\n        frameTime = clock.getFrameTime()\n        dt = clock.dt\n        for server in self.serverList:\n            server.sendTimeData(frameCount, frameTime, dt)\n        return Task.cont\n\n    def startMoveCamTask(self):\n        self.notify.debug('adding move cam')\n        taskMgr.add(self.moveCameraTask, \"moveCamTask\", 49)\n\n    def controlObjectTask(self, task):\n        for pair in self.sortedControlMappings:\n            object     = pair[1]\n            name       = self.controlMappings[object][0]\n            serverList = self.controlMappings[object][1]\n            if object in self.objectMappings:\n                self.moveObject(self.objectMappings[object],name,serverList,\n                                self.controlOffsets[object], self.objectHasColor[object])\n        self.sendNamedMovementDone()\n        return Task.cont\n\n    def sendNamedMovementDone(self, serverList = None):\n        if serverList is None:\n            serverList = range(len(self.serverList))\n\n        for server in serverList:\n            self.serverList[server].sendNamedMovementDone()\n\n    def redoSortedPriorities(self):\n        self.sortedControlMappings = sorted(\n            [self.controlPriorities[key], key] for key in self.controlMappings\n        )\n\n    def moveObject(self, nodePath, object, serverList, offset, hasColor = True):\n        self.notify.debug('moving object '+object)\n        xyz = nodePath.getPos(render) + offset\n        hpr = nodePath.getHpr(render)\n        scale = nodePath.getScale(render)\n        hidden = nodePath.isHidden()\n        if hasColor:\n            color = nodePath.getColor()\n        else:\n            color = [1,1,1,1]\n        for server in serverList:\n            self.serverList[server].sendMoveNamedObject(xyz,hpr,scale,color,hidden,object)\n\n    def moveCameraTask(self, task):\n        self.moveCamera(\n            base.camera.getPos(render),\n            base.camera.getHpr(render))\n        return Task.cont\n\n    def moveCamera(self, xyz, hpr):\n        self.notify.debug('moving unsynced camera')\n        for server in self.serverList:\n            server.sendMoveCam(xyz, hpr)\n\n    def startMoveSelectedTask(self):\n        taskMgr.add(self.moveSelectedTask, \"moveSelectedTask\", 48)\n\n    def moveSelectedTask(self, state):\n        # Update cluster if current display is a cluster client\n        if last is not None:\n            self.notify.debug('moving selected node path')\n            xyz = Point3(0)\n            hpr = VBase3(0)\n            scale = VBase3(1)\n            decomposeMatrix(last.getMat(), scale, hpr, xyz)\n            for server in self.serverList:\n                server.sendMoveSelected(xyz, hpr, scale)\n        return Task.cont\n\n    def addNamedObjectMapping(self, object, name, hasColor = True):\n        if name not in self.objectMappings:\n            self.objectMappings[name] = object\n            self.objectHasColor[name] = hasColor\n        else:\n            self.notify.debug('attempt to add duplicate named object: '+name)\n\n    def removeObjectMapping(self,name):\n        if name in self.objectMappings:\n            self.objectMappings.pop(name)\n\n    def addControlMapping(self, objectName, controlledName, serverList = None,\n                          offset = None, priority = 0):\n        if objectName not in self.controlMappings:\n            if serverList is None:\n                serverList = range(len(self.serverList))\n            if offset is None:\n                offset = Vec3(0,0,0)\n\n            self.controlMappings[objectName] = [controlledName,serverList]\n            self.controlOffsets[objectName]  = offset\n            self.controlPriorities[objectName] = priority\n        else:\n            oldList = self.controlMappings[objectName]\n            mergedList = []\n            for item in oldList:\n                mergedList.append(item)\n            for item in serverList:\n                if item not in mergedList:\n                    mergedList.append(item)\n\n        self.redoSortedPriorities()\n            #self.notify.debug('attempt to add duplicate controlled object: '+name)\n\n    def setControlMappingOffset(self, objectName, offset):\n        if objectName in self.controlMappings:\n            self.controlOffsets[objectName] = offset\n\n    def removeControlMapping(self, name, serverList = None):\n        if name in self.controlMappings:\n            if serverList is None:\n                self.controlMappings.pop(name)\n                self.controlPriorities.pop(name)\n            else:\n                oldList = self.controlMappings[key][1]\n                newList = []\n                for server in oldList:\n                    if server not in serverList:\n                        newList.append(server)\n                self.controlMappings[key][1] = newList\n                if len(newList) == 0:\n                    self.controlMappings.pop(name)\n                    self.controlPriorities.pop(name)\n        self.redoSortedPriorities()\n\n    def getNodePathFindCmd(self, nodePath):\n        pathString = repr(nodePath)\n        index = pathString.find('/')\n        if index != -1:\n            rootName = pathString[:index]\n            searchString = pathString[index+1:]\n            return rootName + ('.find(\"%s\")' % searchString)\n        else:\n            return rootName\n\n    def getNodePathName(self, nodePath):\n        pathString = repr(nodePath)\n        index = pathString.find('/')\n        if index != -1:\n            name = pathString[index+1:]\n            return name\n        else:\n            return pathString\n\n    def addObjectTag(self,object,selectFunction,deselectFunction,selectArgs,deselectArgs):\n        newTag = {}\n        newTag[\"selectFunction\"] = selectFunction\n        newTag[\"selectArgs\"]     = selectArgs\n        newTag[\"deselectFunction\"] = deselectFunction\n        newTag[\"deselectArgs\"]     = deselectArgs\n        self.taggedObjects[object] = newTag\n\n    def removeObjectTag(self,object):\n\n        self.taggedObjects.pop(object)\n\n    def selectNodePath(self, nodePath):\n        name = self.getNodePathName(nodePath)\n        if name in self.taggedObjects:\n            taskMgr.remove(\"moveSelectedTask\")\n            tag = self.taggedObjects[name]\n            function = tag[\"selectFunction\"]\n            args     = tag[\"selectArgs\"]\n            if function is not None:\n                function(*args)\n        else:\n            self(self.getNodePathFindCmd(nodePath) + '.select()', 0)\n\n    def deselectNodePath(self, nodePath):\n        name = self.getNodePathName(nodePath)\n        if name in self.taggedObjects:\n            tag = self.taggedObjects[name]\n            function = tag[\"deselectFunction\"]\n            args     = tag[\"deselectArgs\"]\n            if function is not None:\n                function(*args)\n            self.startMoveSelectedTask()\n        self(self.getNodePathFindCmd(nodePath) + '.deselect()', 0)\n\n    def sendCamFrustum(self, focalLength, filmSize, filmOffset, indexList=[]):\n        if indexList:\n            serverList = [self.serverList[i] for i in indexList]\n        else:\n            serverList = self.serverList\n        for server in serverList:\n            self.notify.debug('updating camera frustum')\n            server.sendCamFrustum(focalLength, filmSize, filmOffset)\n\n    def loadModel(self, nodePath):\n        pass\n\n    def __call__(self, commandString, fLocally = 1, serverList = []):\n        # Execute remotely\n        if serverList:\n            # Passed in list of servers\n            for serverNum in serverList:\n                self.serverList[serverNum].sendCommandString(commandString)\n        else:\n            # All servers\n            for server in self.serverList:\n                server.sendCommandString(commandString)\n        if fLocally:\n            # Execute locally\n            exec(commandString, __builtins__)\n\n    def handleDatagram(self,dgi,type,server):\n        if type == CLUSTER_NONE:\n            pass\n        elif type == CLUSTER_NAMED_OBJECT_MOVEMENT:\n            self.serverQueues[server].append(self.msgHandler.parseNamedMovementDatagram(dgi))\n            #self.handleNamedMovement(dgi)\n        # when we recieve a 'named movement done' packet from a server we handle\n        # all of its messages\n        elif type == CLUSTER_NAMED_MOVEMENT_DONE:\n            self.handleMessageQueue(server)\n        else:\n            self.notify.warning(\"Received unsupported packet type:\" % type)\n        return type\n\n    def handleMessageQueue(self,server):\n        queue = self.serverQueues[server]\n        # handle all messages in the queue\n        for data in queue:\n            #print dgi\n            self.handleNamedMovement(data)\n\n        # clear the queue\n        self.serverQueues[server] = []\n\n    def handleNamedMovement(self, data):\n        \"\"\" Update cameraJig position to reflect latest position \"\"\"\n\n        (name,x, y, z, h, p, r, sx, sy, sz,red,g,b,a, hidden) = data\n        #print \"name\"\n        #if name == \"camNode\":\n        #    print x,y,z,h,p,r, sx, sy, sz,red,g,b,a, hidden\n        if name in self.objectMappings:\n            self.objectMappings[name].setPosHpr(render, x, y, z, h, p, r)\n            self.objectMappings[name].setScale(render,sx,sy,sz)\n            if self.objectHasColor[name]:\n                self.objectMappings[name].setColor(red,g,b,a)\n            if hidden:\n                self.objectMappings[name].hide()\n            else:\n                self.objectMappings[name].show()\n        else:\n            self.notify.debug(\"recieved unknown named object command: \"+name)\n\n    def exit(self):\n        # Execute remotely\n        for server in self.serverList:\n            server.sendExit()\n        # Execute locally\n        import sys\n        sys.exit()",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterClient.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 0
  },
  {
    "content": "class ClusterClientSync(ClusterClient):\n    def __init__(self, configList, clusterSyncFlag):\n        ClusterClient.__init__(self, configList, clusterSyncFlag)\n        #I probably don't need this\n        self.waitForSwap = 0\n        self.ready = 0\n        print(\"creating synced client\")\n        self.startSwapCoordinatorTask()\n\n    def startSwapCoordinatorTask(self):\n        taskMgr.add(self.swapCoordinator, \"clientSwapCoordinator\", 51)\n\n    def swapCoordinator(self, task):\n        self.ready = 1\n        if self.waitForSwap:\n            self.waitForSwap=0\n            self.notify.debug(\n                \"START get swaps----------------------------------\")\n            for server in self.serverList:\n                server.getSwapReady()\n            self.notify.debug(\n                \"----------------START swap now--------------------\")\n            for server in self.serverList:\n                server.sendSwapNow()\n            self.notify.debug(\n                \"------------------------------START swap----------\")\n            base.graphicsEngine.flipFrame()\n            self.notify.debug(\n                \"------------------------------------------END swap\")\n\n        #print \"syncing\"\n        return Task.cont\n\n    def moveCamera(self, xyz, hpr):\n        if self.ready:\n            self.notify.debug('moving synced camera')\n            ClusterClient.moveCamera(self, xyz, hpr)\n            self.waitForSwap=1",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterClient.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 1
  },
  {
    "content": "class DisplayConnection:\n    def __init__(self, qcm, serverName, port, msgHandler):\n        self.msgHandler = msgHandler\n        gameServerTimeoutMs = base.config.GetInt(\n            \"cluster-server-timeout-ms\", 300000)\n        # A giant 300 second timeout.\n        self.tcpConn = qcm.openTCPClientConnection(\n            serverName, port, gameServerTimeoutMs)\n        # Test for bad connection\n        if self.tcpConn is None:\n            return None\n        else:\n            self.tcpConn.setNoDelay(1)\n            self.qcr=QueuedConnectionReader(qcm, 0)\n            self.qcr.addConnection(self.tcpConn)\n            self.cw=ConnectionWriter(qcm, 0)\n\n    def poll(self):\n        \"\"\" Non blocking task to read all available datagrams \"\"\"\n        dataGrams = []\n        while 1:\n            (datagram, dgi, type) = self.msgHandler.nonBlockingRead(self.qcr)\n            # Queue is empty, done for now\n            if type is CLUSTER_NONE:\n                break\n            else:\n                # Got a datagram, add it to the list\n                dataGrams.append([dgi, type, datagram])\n\n        return dataGrams\n\n    def sendCamOffset(self, xyz, hpr):\n        ClusterClient.notify.debug(\"send cam offset...\")\n        ClusterClient.notify.debug((\"packet %d xyz, hpr=%f %f %f %f %f %f\" %\n             (self.msgHandler.packetNumber, xyz[0], xyz[1], xyz[2],\n             hpr[0], hpr[1], hpr[2])))\n        datagram = self.msgHandler.makeCamOffsetDatagram(xyz, hpr)\n        self.cw.send(datagram, self.tcpConn)\n\n    def sendCamFrustum(self, focalLength, filmSize, filmOffset):\n        ClusterClient.notify.info(\"send cam frustum...\")\n        ClusterClient.notify.info(\n            ((\"packet %d\" % self.msgHandler.packetNumber) +\n             (\" fl, fs, fo=%0.3f, (%0.3f, %0.3f), (%0.3f, %0.3f)\" %\n              (focalLength, filmSize[0], filmSize[1],\n               filmOffset[0], filmOffset[1])))\n        )\n        datagram = self.msgHandler.makeCamFrustumDatagram(\n            focalLength, filmSize, filmOffset)\n        self.cw.send(datagram, self.tcpConn)\n\n    def sendNamedMovementDone(self):\n\n        datagram = self.msgHandler.makeNamedMovementDone()\n        self.cw.send(datagram, self.tcpConn)\n\n    def sendMoveNamedObject(self, xyz, hpr, scale, color, hidden, name):\n        ClusterClient.notify.debug(\"send named object move...\")\n        ClusterClient.notify.debug((\"packet %d xyz, hpr=%f %f %f %f %f %f\" %\n             (self.msgHandler.packetNumber, xyz[0], xyz[1], xyz[2],\n             hpr[0], hpr[1], hpr[2])))\n        datagram = self.msgHandler.makeNamedObjectMovementDatagram(xyz,hpr,scale,\n                                                                   color,hidden,\n                                                                   name)\n        self.cw.send(datagram, self.tcpConn)\n\n    def sendMoveCam(self, xyz, hpr):\n        ClusterClient.notify.debug(\"send cam move...\")\n        ClusterClient.notify.debug((\"packet %d xyz, hpr=%f %f %f %f %f %f\" %\n             (self.msgHandler.packetNumber, xyz[0], xyz[1], xyz[2],\n             hpr[0], hpr[1], hpr[2])))\n        datagram = self.msgHandler.makeCamMovementDatagram(xyz, hpr)\n        self.cw.send(datagram, self.tcpConn)\n\n    def sendMoveSelected(self, xyz, hpr, scale):\n        ClusterClient.notify.debug(\"send move selected...\")\n        ClusterClient.notify.debug(\n            \"packet %d xyz, hpr=%f %f %f %f %f %f %f %f %f\" %\n            (self.msgHandler.packetNumber,\n             xyz[0], xyz[1], xyz[2],\n             hpr[0], hpr[1], hpr[2],\n             scale[0], scale[1], scale[2]))\n        datagram = self.msgHandler.makeSelectedMovementDatagram(xyz, hpr, scale)\n        self.cw.send(datagram, self.tcpConn)\n\n    # the following should only be called by a synchronized cluster manger\n    def getSwapReady(self):\n        while 1:\n            (datagram, dgi, type) = self.msgHandler.blockingRead(self.qcr)\n            if type == CLUSTER_SWAP_READY:\n                break\n            else:\n                self.notify.warning('was expecting SWAP_READY, got %d' % type)\n\n    # the following should only be called by a synchronized cluster manger\n    def sendSwapNow(self):\n        ClusterClient.notify.debug(\n            \"display connect send swap now, packet %d\" %\n            self.msgHandler.packetNumber)\n        datagram = self.msgHandler.makeSwapNowDatagram()\n        self.cw.send(datagram, self.tcpConn)\n\n    def sendCommandString(self, commandString):\n        ClusterClient.notify.debug(\"send command string: %s\" % commandString)\n        datagram = self.msgHandler.makeCommandStringDatagram(commandString)\n        self.cw.send(datagram, self.tcpConn)\n\n    def sendExit(self):\n        ClusterClient.notify.debug(\n            \"display connect send exit, packet %d\" %\n            self.msgHandler.packetNumber)\n        datagram = self.msgHandler.makeExitDatagram()\n        self.cw.send(datagram, self.tcpConn)\n\n    def sendTimeData(self, frameCount, frameTime, dt):\n        ClusterClient.notify.debug(\"send time data...\")\n        datagram = self.msgHandler.makeTimeDataDatagram(\n            frameCount, frameTime, dt)\n        self.cw.send(datagram, self.tcpConn)",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterClient.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 2
  },
  {
    "content": "class ClusterConfigItem:\n    def __init__(self, serverConfigName, serverName,\n                 serverDaemonPort, serverMsgPort):\n        self.serverConfigName = serverConfigName\n        self.serverName = serverName\n        self.serverDaemonPort = serverDaemonPort\n        self.serverMsgPort = serverMsgPort\n        # Camera Offset\n        self.xyz = Vec3(0)\n        self.hpr = Vec3(0)\n        # Camera Frustum Data\n        self.fFrustum = 0\n        self.focalLength = None\n        self.filmSize = None\n        self.filmOffset = None\n\n    def setCamOffset(self, xyz, hpr):\n        self.xyz = xyz\n        self.hpr = hpr\n\n    def setCamFrustum(self, focalLength, filmSize, filmOffset):\n        self.fFrustum = 1\n        self.focalLength = focalLength\n        self.filmSize = filmSize\n        self.filmOffset = filmOffset",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterClient.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 3
  },
  {
    "content": "def createClusterClient():\n    # setup camera offsets based on cluster-config\n    clusterConfig = base.config.GetString('cluster-config', 'single-server')\n    # No cluster config specified!\n    if clusterConfig not in ClientConfigs:\n        base.notify.warning(\n            'createClusterClient: %s cluster-config is undefined.' %\n            clusterConfig)\n        return None\n    # Get display config for each server in the cluster\n    displayConfigs = []\n    configList = ClientConfigs[clusterConfig]\n    numConfigs = len(configList)\n    for i in range(numConfigs):\n        configData = configList[i]\n        displayName = configData.get('display name', ('display%d' % i))\n        displayMode = configData.get('display mode', 'server')\n        # Init Cam Offset\n        pos = configData.get('pos', Vec3(0))\n        hpr = configData.get('hpr', Vec3(0))\n        # Init Frustum if specified\n        fl = configData.get('focal length', None)\n        fs = configData.get('film size', None)\n        fo = configData.get('film offset', None)\n        if displayMode == 'client':\n            #lens.setInterocularDistance(pos[0])\n            base.cam.setPos(pos)\n            lens = base.cam.node().getLens()\n            lens.setViewHpr(hpr)\n            if fl is not None:\n                lens.setFocalLength(fl)\n            if fs is not None:\n                lens.setFilmSize(fs[0], fs[1])\n            if fo is not None:\n                lens.setFilmOffset(fo[0], fo[1])\n        else:\n            serverConfigName = 'cluster-server-%s' % displayName\n            serverName = base.config.GetString(serverConfigName, '')\n            if serverName == '':\n                base.notify.warning(\n                    '%s undefined in Configrc: expected by %s display client.'%\n                    (serverConfigName, clusterConfig))\n                base.notify.warning('%s will not be used.' % serverConfigName)\n            else:\n                # Daemon port\n                serverDaemonPortConfigName = (\n                    'cluster-server-daemon-port-%s' % displayName)\n                serverDaemonPort = base.config.GetInt(\n                    serverDaemonPortConfigName,\n                    CLUSTER_DAEMON_PORT)\n                # TCP Server port\n                serverMsgPortConfigName = (\n                    'cluster-server-msg-port-%s' % displayName)\n                serverMsgPort = base.config.GetInt(serverMsgPortConfigName,\n                                                   CLUSTER_SERVER_PORT)\n                cci = ClusterConfigItem(\n                    serverConfigName,\n                    serverName,\n                    serverDaemonPort,\n                    serverMsgPort)\n                # Init cam offset\n                cci.setCamOffset(pos, hpr)\n                # Init frustum if specified\n                if fl and fs and fo:\n                    cci.setCamFrustum(fl, fs, fo)\n                displayConfigs.append(cci)\n    # Create Cluster Managers (opening connections to servers)\n    # Are the servers going to be synced?\n    if base.clusterSyncFlag:\n        base.notify.warning('autoflip')\n        base.graphicsEngine.setAutoFlip(0)\n        base.notify.warning('ClusterClientSync')\n        return ClusterClientSync(displayConfigs, base.clusterSyncFlag)\n    else:\n        return ClusterClient(displayConfigs, base.clusterSyncFlag)",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterClient.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 4
  },
  {
    "content": "class DummyClusterClient(DirectObject.DirectObject):\n    \"\"\" Dummy class to handle command strings when not in cluster mode \"\"\"\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"DummyClusterClient\")\n\n    def __init__(self):\n        pass\n\n    def __call__(self, commandString, fLocally = 1, serverList = None):\n        if fLocally:\n            # Execute locally\n            exec(commandString, __builtins__)",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterClient.py",
      "content_type": "functions_classes",
      "language": "python"
    },
    "chunk_index": 5
  },
  {
    "content": "\"\"\"ClusterClient: Master for multi-piping or PC clusters.\"\"\"\n\nfrom panda3d.core import (\n    ClockObject,\n    Point3,\n    VBase3,\n    Vec3,\n    decomposeMatrix,\n)\nfrom panda3d.net import (\n    ConnectionWriter,\n    QueuedConnectionManager,\n    QueuedConnectionReader,\n)\nfrom .ClusterMsgs import (\n    CLUSTER_DAEMON_PORT,\n    CLUSTER_NAMED_MOVEMENT_DONE,\n    CLUSTER_NAMED_OBJECT_MOVEMENT,\n    CLUSTER_NONE,\n    CLUSTER_SERVER_PORT,\n    CLUSTER_SWAP_READY,\n    SERVER_STARTUP_STRING,\n    ClusterMsgHandler,\n)\nfrom .ClusterConfig import ClientConfigs\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.showbase import DirectObject\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nimport os\n\n\n# Code for: class ClusterClient(DirectObject.DirectObject):\n\n\n# Code for: class ClusterClientSync(ClusterClient):\n\n\n# Code for: class DisplayConnection:\n\n\n# Code for: class ClusterConfigItem:\n\n\n# Code for: def createClusterClient():\n\n\n# Code for: class DummyClusterClient(DirectObject.DirectObject):",
    "metadata": {
      "source": "_test_source_code/cluster/ClusterClient.py",
      "content_type": "simplified_code",
      "language": "python"
    },
    "chunk_index": 6
  }
]