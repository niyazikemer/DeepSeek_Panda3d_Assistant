{
  "content": "\"\"\"Contains the EventManager class.  See :mod:`.EventManagerGlobal` for the\nglobal eventMgr instance.\"\"\"\n\n__all__ = ['EventManager']\n\n\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.showbase.MessengerGlobal import messenger\nfrom panda3d.core import PStatCollector, EventQueue, EventHandler\nfrom panda3d.core import ConfigVariableBool\n\n\nclass EventManager:\n\n    notify = None\n\n    def __init__(self, eventQueue = None):\n        \"\"\"\n        Create a C++ event queue and handler\n        \"\"\"\n        # Make a notify category for this class (unless there already is one)\n        if EventManager.notify is None:\n            EventManager.notify = directNotify.newCategory(\"EventManager\")\n\n        self.eventQueue = eventQueue\n        self.eventHandler = None\n\n        self._wantPstats = ConfigVariableBool('pstats-eventmanager', False)\n\n    def doEvents(self):\n        \"\"\"\n        Process all the events on the C++ event queue\n        \"\"\"\n        # use different methods for handling events with and without pstats tracking\n        # for efficiency\n        if self._wantPstats:\n            processFunc = self.processEventPstats\n        else:\n            processFunc = self.processEvent\n        isEmptyFunc = self.eventQueue.isQueueEmpty\n        dequeueFunc = self.eventQueue.dequeueEvent\n        while not isEmptyFunc():\n            processFunc(dequeueFunc())\n\n    def eventLoopTask(self, task):\n        \"\"\"\n        Process all the events on the C++ event queue\n        \"\"\"\n        self.doEvents()\n        messenger.send(\"event-loop-done\")\n        return task.cont\n\n    def parseEventParameter(self, eventParameter):\n        \"\"\"\n        Extract the actual data from the eventParameter\n        \"\"\"\n        if eventParameter.isInt():\n            return eventParameter.getIntValue()\n        elif eventParameter.isDouble():\n            return eventParameter.getDoubleValue()\n        elif eventParameter.isString():\n            return eventParameter.getStringValue()\n        elif eventParameter.isWstring():\n            return eventParameter.getWstringValue()\n        elif eventParameter.isTypedRefCount():\n            return eventParameter.getTypedRefCountValue()\n        elif eventParameter.isEmpty():\n            return None\n        else:\n            # Must be some user defined type, return the ptr\n            # which will be downcast to that type.\n            return eventParameter.getPtr()\n\n    def processEvent(self, event):\n        \"\"\"\n        Process a C++ event\n        Duplicate any changes in processEventPstats\n        \"\"\"\n        # **************************************************************\n        # ******** Duplicate any changes in processEventPstats *********\n        # **************************************************************\n        # Get the event name\n        eventName = event.name\n        if eventName:\n            paramList = []\n            for eventParameter in event.parameters:\n                eventParameterData = self.parseEventParameter(eventParameter)\n                paramList.append(eventParameterData)\n\n            # Do not print the new frame debug, it is too noisy!\n            if EventManager.notify.getDebug() and eventName != 'NewFrame':\n                EventManager.notify.debug('received C++ event named: ' + eventName +\n                                          ' parameters: ' + repr(paramList))\n            # **************************************************************\n            # ******** Duplicate any changes in processEventPstats *********\n            # **************************************************************\n            # Send the event, we used to send it with the event\n            # name as a parameter, but now you can use extraArgs for that\n            messenger.send(eventName, paramList)\n\n            # Also send the event down into C++ land\n            handler = self.eventHandler\n            if handler:\n                handler.dispatchEvent(event)\n\n        else:\n            # An unnamed event from C++ is probably a bad thing\n            EventManager.notify.warning('unnamed event in processEvent')\n\n    def processEventPstats(self, event):\n        \"\"\"\n        Process a C++ event with pstats tracking\n        Duplicate any changes in processEvent\n        \"\"\"\n        # ********************************************************\n        # ******** Duplicate any changes in processEvent *********\n        # ********************************************************\n        # Get the event name\n        eventName = event.name\n        if eventName:\n            paramList = []\n            for eventParameter in event.parameters:\n                eventParameterData = self.parseEventParameter(eventParameter)\n                paramList.append(eventParameterData)\n\n            # Do not print the new frame debug, it is too noisy!\n            if EventManager.notify.getDebug() and eventName != 'NewFrame':\n                EventManager.notify.debug('received C++ event named: ' + eventName +\n                                          ' parameters: ' + repr(paramList))\n            # Send the event, we used to send it with the event\n            # name as a parameter, but now you can use extraArgs for that\n            # ********************************************************\n            # ******** Duplicate any changes in processEvent *********\n            # ********************************************************\n            name = eventName\n            hyphen = name.find('-')\n            if hyphen >= 0:\n                name = name[0:hyphen]\n            pstatCollector = PStatCollector('App:Tasks:eventManager:' + name)\n            pstatCollector.start()\n            if self.eventHandler:\n                cppPstatCollector = PStatCollector(\n                    'App:Tasks:eventManager:' + name + ':C++')\n\n            messenger.send(eventName, paramList)\n\n            # Also send the event down into C++ land\n            handler = self.eventHandler\n            if handler:\n                cppPstatCollector.start()\n                handler.dispatchEvent(event)\n                cppPstatCollector.stop()\n\n            pstatCollector.stop()\n\n        else:\n            # An unnamed event from C++ is probably a bad thing\n            EventManager.notify.warning('unnamed event in processEvent')\n\n    def restart(self):\n        if self.eventQueue is None:\n            self.eventQueue = EventQueue.getGlobalEventQueue()\n\n        if self.eventHandler is None:\n            if self.eventQueue == EventQueue.getGlobalEventQueue():\n                # If we are using the global event queue, then we also\n                # want to use the global event handler.\n                self.eventHandler = EventHandler.getGlobalEventHandler()\n            else:\n                # Otherwise, we need our own event handler.\n                self.eventHandler = EventHandler(self.eventQueue)\n\n        taskMgr.add(self.eventLoopTask, 'eventManager')\n\n    def shutdown(self):\n        taskMgr.remove('eventManager')\n\n        # Flush the event queue.  We do this after removing the task\n        # since the task removal itself might also fire off an event.\n        if self.eventQueue is not None:\n            self.eventQueue.clear()\n\n    do_events = doEvents\n    process_event = processEvent\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/EventManager.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/05bbcb22_EventManager.json",
    "doc_id": "doc_237"
  }
}