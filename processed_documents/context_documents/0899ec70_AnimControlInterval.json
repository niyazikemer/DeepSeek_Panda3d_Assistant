{
  "content": "\"\"\"AnimControlInterval module: contains the AnimControlInterval class\"\"\"\n\n__all__ = ['AnimControlInterval']\n\nfrom panda3d.core import AnimControl, AnimControlCollection, ConfigVariableBool\nfrom panda3d.direct import CInterval\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom . import Interval\nimport math\n\nclass AnimControlInterval(Interval.Interval):\n\n    # create AnimControlInterval DirectNotify category\n    notify = directNotify.newCategory('AnimControlInterval')\n\n    # Name counter\n    animNum = 1\n    # Class methods\n\n    # Plays an animation.  The subrange of the animation\n    # to be played may be specified via frames (startFrame up to and\n    # including endFrame) or seconds (startTime up to and including\n    # endTime).  If neither is specified, the default is the entire\n    # range of the animation.\n\n    # this class requires either an AnimControl, or an AnimControlCollection\n    # (in which case, each anim control must be the same length)\n\n    # The duration may be implicit or explicit.  If it is omitted, it\n    # is taken to be endTime - startTime.  There's not much point in\n    # specifying otherwise unless you also specify loop=1, which will\n    # loop the animation over its frame range during the duration of\n    # the interval.\n\n    # Note: if loop == 0 and duration > anim duration then the\n    # animation will play once and then hold its final pose for the\n    # remainder of the interval.\n\n    # loop = 1 implies a loop within the entire range of animation,\n    # while constrainedLoop = 1 implies a loop within startFrame and\n    # endFrame only.\n\n    def __init__(self, controls, loop=0, constrainedLoop=0,\n                 duration=None, startTime=None, endTime=None,\n                 startFrame=None, endFrame=None,\n                 playRate=1.0, name=None):\n        # Generate unique id\n        id = 'AnimControl-%d' % (AnimControlInterval.animNum)\n        AnimControlInterval.animNum += 1\n        # Record class specific variables\n\n        if isinstance(controls, AnimControlCollection):\n            self.controls = controls\n            if ConfigVariableBool(\"strict-anim-ival\", 0):\n                checkSz = self.controls.getAnim(0).getNumFrames()\n                for i in range(1,self.controls.getNumAnims()):\n                    if checkSz != self.controls.getAnim(i).getNumFrames():\n                        self.notify.error(\"anim controls don't have the same number of frames!\")\n        elif isinstance(controls, AnimControl):\n            self.controls = AnimControlCollection()\n            self.controls.storeAnim(controls,\"\")\n        else:\n            self.notify.error(\"invalid input control(s) for AnimControlInterval\")\n\n        self.loopAnim = loop\n        self.constrainedLoop = constrainedLoop\n        self.playRate = playRate\n\n        # If no name specified, use id as name\n        if name is None:\n            name = id\n\n        self.frameRate = self.controls.getAnim(0).getFrameRate() * abs(playRate)\n        # Compute start and end frames.\n        if startFrame is not None:\n            self.startFrame = startFrame\n        elif startTime is not None:\n            self.startFrame = startTime * self.frameRate\n        else:\n            self.startFrame = 0\n\n        if endFrame is not None:\n            self.endFrame = endFrame\n        elif endTime is not None:\n            self.endFrame = endTime * self.frameRate\n        elif duration is not None:\n            if startTime is None:\n                startTime = float(self.startFrame) / float(self.frameRate)\n            endTime = startTime + duration\n            self.endFrame = duration * self.frameRate\n        else:\n            # No end frame specified.  Choose the maximum of all\n            # of the controls' numbers of frames.\n            numFrames = self.controls.getAnim(0).getNumFrames()\n            self.endFrame = numFrames - 1\n\n        # Must we play the animation backwards?  We play backwards if\n        # either (or both) of the following is true: the playRate is\n        # negative, or endFrame is before startFrame.\n        self.reverse = playRate < 0\n        if self.endFrame < self.startFrame:\n            self.reverse = 1\n            t = self.endFrame\n            self.endFrame = self.startFrame\n            self.startFrame = t\n\n        self.numFrames = self.endFrame - self.startFrame + 1\n\n        # Compute duration if no duration specified\n        self.implicitDuration = 0\n        if duration is None:\n            self.implicitDuration = 1\n            duration = float(self.numFrames) / self.frameRate\n\n        # Initialize superclass\n        Interval.Interval.__init__(self, name, duration)\n\n    def getCurrentFrame(self):\n        \"\"\"Calculate the current frame playing in this interval.\n\n        returns a float value between startFrame and endFrame, inclusive\n        returns None if there are any problems\n        \"\"\"\n        retval = None\n        if not self.isStopped():\n            framesPlayed = self.numFrames * self.currT\n            retval = self.startFrame + framesPlayed\n        return retval\n\n    def privStep(self, t):\n        frameCount = t * self.frameRate\n        if self.constrainedLoop:\n            frameCount = frameCount % self.numFrames\n\n        if self.reverse:\n            absFrame = self.endFrame - frameCount\n        else:\n            absFrame = self.startFrame + frameCount\n\n        # Calc integer frame number\n        intFrame = int(math.floor(absFrame + 0.0001))\n\n        # Pose anim\n\n        # We use our pre-computed list of animControls for\n        # efficiency's sake, rather than going through the relatively\n        # expensive Actor interface every frame.\n\n        # Each animControl might have a different number of frames.\n        numFrames = self.controls.getAnim(0).getNumFrames()\n        if self.loopAnim:\n            frame = (intFrame % numFrames) + (absFrame - intFrame)\n        else:\n            frame = max(min(absFrame, numFrames - 1), 0)\n\n        self.controls.poseAll(frame)\n\n        self.state = CInterval.SStarted\n        self.currT = t\n\n    def privFinalize(self):\n        if self.implicitDuration and not self.loopAnim:\n            # As a special case, we ensure we end up posed to the last\n            # frame of the animation if the original duration was\n            # implicit.  This is necessary only to guard against\n            # possible roundoff error in computing the final frame\n            # from the duration.  We don't do this in the case of a\n            # looping animation, however, because this would introduce\n            # a hitch in the animation when it plays back-to-back with\n            # the next cycle.\n            if self.reverse:\n                self.controls.poseAll(self.startFrame)\n            else:\n                self.controls.poseAll(self.endFrame)\n\n        else:\n            # Otherwise, the user-specified duration determines which\n            # is our final frame.\n            self.privStep(self.getDuration())\n\n        self.state = CInterval.SFinal\n        self.intervalDone()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/interval/AnimControlInterval.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/0899ec70_AnimControlInterval.json",
    "doc_id": "doc_165"
  }
}