{
  "content": "\"\"\"\nNonPhysicsWalker.py is for avatars.\n\nA walker control such as this one provides:\n\n- creation of the collision nodes\n- handling the keyboard and mouse input for avatar movement\n- moving the avatar\n\nit does not:\n\n- play sounds\n- play animations\n\nalthough it does send messages that allow a listener to play sounds or\nanimations based on walker events.\n\"\"\"\n\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.showbase import DirectObject\nfrom direct.controls.ControlManager import CollisionHandlerRayStart\nfrom direct.showbase.InputStateGlobal import inputState\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.task.Task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom panda3d.core import (\n    BitMask32,\n    ClockObject,\n    CollisionHandlerFloor,\n    CollisionHandlerPusher,\n    CollisionNode,\n    CollisionRay,\n    CollisionSphere,\n    CollisionTraverser,\n    ConfigVariableBool,\n    Mat3,\n    Point3,\n    Vec3,\n)\n\nclass NonPhysicsWalker(DirectObject.DirectObject):\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"NonPhysicsWalker\")\n    wantDebugIndicator = ConfigVariableBool('want-avatar-physics-indicator', False)\n\n    # Ghost mode overrides this:\n    slideName = \"slide-is-disabled\"\n\n    # special methods\n    def __init__(self):\n        DirectObject.DirectObject.__init__(self)\n        self.worldVelocity = Vec3.zero()\n        self.collisionsActive = 0\n        self.speed=0.0\n        self.rotationSpeed=0.0\n        self.slideSpeed=0.0\n        self.vel=Vec3(0.0, 0.0, 0.0)\n        self.stopThisFrame = 0\n\n    def setWalkSpeed(self, forward, jump, reverse, rotate):\n        assert self.debugPrint(\"setWalkSpeed()\")\n        self.avatarControlForwardSpeed=forward\n        #self.avatarControlJumpForce=jump\n        self.avatarControlReverseSpeed=reverse\n        self.avatarControlRotateSpeed=rotate\n\n    def getSpeeds(self):\n        #assert self.debugPrint(\"getSpeeds()\")\n        return (self.speed, self.rotationSpeed, self.slideSpeed)\n\n    def setAvatar(self, avatar):\n        self.avatar = avatar\n        if avatar is not None:\n            pass # setup the avatar\n\n    def setAirborneHeightFunc(self, getAirborneHeight):\n        self.getAirborneHeight = getAirborneHeight\n\n    def setWallBitMask(self, bitMask):\n        self.cSphereBitMask = bitMask\n\n    def setFloorBitMask(self, bitMask):\n        self.cRayBitMask = bitMask\n\n    def swapFloorBitMask(self, oldMask, newMask):\n        self.cRayBitMask = self.cRayBitMask &~ oldMask\n        self.cRayBitMask |= newMask\n\n        if self.cRayNodePath and not self.cRayNodePath.isEmpty():\n            self.cRayNodePath.node().setFromCollideMask(self.cRayBitMask)\n\n    def initializeCollisions(self, collisionTraverser, avatarNodePath,\n            avatarRadius = 1.4, floorOffset = 1.0, reach = 1.0):\n        \"\"\"\n        Set up the avatar for collisions\n        \"\"\"\n        assert not avatarNodePath.isEmpty()\n\n        self.cTrav = collisionTraverser\n        self.avatarNodePath = avatarNodePath\n\n        # Set up the collision sphere\n        # This is a sphere on the ground to detect barrier collisions\n        self.cSphere = CollisionSphere(0.0, 0.0, 0.0, avatarRadius)\n        cSphereNode = CollisionNode('NPW.cSphereNode')\n        cSphereNode.addSolid(self.cSphere)\n        self.cSphereNodePath = avatarNodePath.attachNewNode(cSphereNode)\n\n        cSphereNode.setFromCollideMask(self.cSphereBitMask)\n        cSphereNode.setIntoCollideMask(BitMask32.allOff())\n\n        # Set up the collison ray\n        # This is a ray cast from your head down to detect floor polygons.\n        # This ray start is arbitrarily high in the air.  Feel free to use\n        # a higher or lower value depending on whether you want an avatar\n        # that is outside of the world to step up to the floor when they\n        # get under valid floor:\n        self.cRay = CollisionRay(0.0, 0.0, CollisionHandlerRayStart, 0.0, 0.0, -1.0)\n        cRayNode = CollisionNode('NPW.cRayNode')\n        cRayNode.addSolid(self.cRay)\n        self.cRayNodePath = avatarNodePath.attachNewNode(cRayNode)\n        cRayNode.setFromCollideMask(self.cRayBitMask)\n        cRayNode.setIntoCollideMask(BitMask32.allOff())\n\n        # set up wall collision mechanism\n        self.pusher = CollisionHandlerPusher()\n        self.pusher.setInPattern(\"enter%in\")\n        self.pusher.setOutPattern(\"exit%in\")\n\n        # set up floor collision mechanism\n        self.lifter = CollisionHandlerFloor()\n        self.lifter.setInPattern(\"on-floor\")\n        self.lifter.setOutPattern(\"off-floor\")\n        self.lifter.setOffset(floorOffset)\n        self.lifter.setReach(reach)\n\n        # Limit our rate-of-fall with the lifter.\n        # If this is too low, we actually \"fall\" off steep stairs\n        # and float above them as we go down. I increased this\n        # from 8.0 to 16.0 to prevent this\n        self.lifter.setMaxVelocity(16.0)\n\n        self.pusher.addCollider(self.cSphereNodePath, avatarNodePath)\n        self.lifter.addCollider(self.cRayNodePath, avatarNodePath)\n\n        # activate the collider with the traverser and pusher\n        self.setCollisionsActive(1)\n\n    def deleteCollisions(self):\n        del self.cTrav\n\n        del self.cSphere\n        self.cSphereNodePath.removeNode()\n        del self.cSphereNodePath\n\n        del self.cRay\n        self.cRayNodePath.removeNode()\n        del self.cRayNodePath\n\n        del self.pusher\n        del self.lifter\n\n    def setTag(self, key, value):\n        self.cSphereNodePath.setTag(key, value)\n\n    def setCollisionsActive(self, active = 1):\n        assert self.debugPrint(\"setCollisionsActive(active%s)\"%(active,))\n        if self.collisionsActive != active:\n            self.collisionsActive = active\n            if active:\n                self.cTrav.addCollider(self.cSphereNodePath, self.pusher)\n                self.cTrav.addCollider(self.cRayNodePath, self.lifter)\n            else:\n                self.cTrav.removeCollider(self.cSphereNodePath)\n                self.cTrav.removeCollider(self.cRayNodePath)\n\n                # Now that we have disabled collisions, make one more pass\n                # right now to ensure we aren't standing in a wall.\n                self.oneTimeCollide()\n\n    def placeOnFloor(self):\n        \"\"\"\n        Make a reasonable effor to place the avatar on the ground.\n        For example, this is useful when switching away from the\n        current walker.\n        \"\"\"\n        # With these on, getAirborneHeight is not returning the correct value so\n        # when we open our book while swimming we pop down underneath the ground\n        # self.oneTimeCollide()\n        # self.avatarNodePath.setZ(self.avatarNodePath.getZ()-self.getAirborneHeight())\n        # Since this is the non physics walker - wont they already be on the ground?\n        return\n\n    def oneTimeCollide(self):\n        \"\"\"\n        Makes one quick collision pass for the avatar, for instance as\n        a one-time straighten-things-up operation after collisions\n        have been disabled.\n        \"\"\"\n        tempCTrav = CollisionTraverser(\"oneTimeCollide\")\n        tempCTrav.addCollider(self.cSphereNodePath, self.pusher)\n        tempCTrav.addCollider(self.cRayNodePath, self.lifter)\n        tempCTrav.traverse(base.render)\n\n    def addBlastForce(self, vector):\n        pass\n\n    def displayDebugInfo(self):\n        \"\"\"\n        For debug use.\n        \"\"\"\n        onScreenDebug.add(\"controls\", \"NonPhysicsWalker\")\n\n    def _calcSpeeds(self):\n        # get the button states:\n        forward = inputState.isSet(\"forward\")\n        reverse = inputState.isSet(\"reverse\")\n        turnLeft = inputState.isSet(\"turnLeft\")\n        turnRight = inputState.isSet(\"turnRight\")\n        slide = inputState.isSet(self.slideName) or 0\n        #jump = inputState.isSet(\"jump\")\n\n        # Check for Auto-Run\n        if base.localAvatar.getAutoRun():\n            forward = 1\n            reverse = 0\n\n        # Determine what the speeds are based on the buttons:\n        self.speed=(forward and self.avatarControlForwardSpeed or\n                    reverse and -self.avatarControlReverseSpeed)\n        # Should fSlide be renamed slideButton?\n        self.slideSpeed=slide and ((reverse and turnLeft and -self.avatarControlReverseSpeed*(0.75)) or\n                                   (reverse and turnRight and self.avatarControlReverseSpeed*(0.75)) or\n                                   (turnLeft and -self.avatarControlForwardSpeed*(0.75)) or\n                                   (turnRight and self.avatarControlForwardSpeed*(0.75)))\n        self.rotationSpeed=not slide and (\n                (turnLeft and self.avatarControlRotateSpeed) or\n                (turnRight and -self.avatarControlRotateSpeed))\n\n    def handleAvatarControls(self, task):\n        \"\"\"\n        Check on the arrow keys and update the avatar.\n        \"\"\"\n        if not self.lifter.hasContact():\n            # hack fix for falling through the floor:\n            messenger.send(\"walkerIsOutOfWorld\", [self.avatarNodePath])\n\n        self._calcSpeeds()\n\n        if __debug__:\n            debugRunning = inputState.isSet(\"debugRunning\")\n            if debugRunning:\n                self.speed*=4.0\n                self.slideSpeed*=4.0\n                self.rotationSpeed*=1.25\n\n        if self.wantDebugIndicator:\n            self.displayDebugInfo()\n        # How far did we move based on the amount of time elapsed?\n        dt=ClockObject.getGlobalClock().getDt()\n        # Check to see if we're moving at all:\n        if self.speed or self.slideSpeed or self.rotationSpeed:\n            if self.stopThisFrame:\n                distance = 0.0\n                slideDistance = 0.0\n                rotation = 0.0\n                self.stopThisFrame = 0\n            else:\n                distance = dt * self.speed\n                slideDistance = dt * self.slideSpeed\n                rotation = dt * self.rotationSpeed\n\n            # Take a step in the direction of our previous heading.\n            self.vel=Vec3(Vec3.forward() * distance +\n                          Vec3.right() * slideDistance)\n            if self.vel != Vec3.zero():\n                # rotMat is the rotation matrix corresponding to\n                # our previous heading.\n                rotMat=Mat3.rotateMatNormaxis(self.avatarNodePath.getH(), Vec3.up())\n                step=rotMat.xform(self.vel)\n                self.avatarNodePath.setFluidPos(Point3(self.avatarNodePath.getPos()+step))\n            self.avatarNodePath.setH(self.avatarNodePath.getH()+rotation)\n            messenger.send(\"avatarMoving\")\n        else:\n            self.vel.set(0.0, 0.0, 0.0)\n\n        self.__oldPosDelta = self.avatarNodePath.getPosDelta(base.render)\n        self.__oldDt = dt\n\n        if self.__oldDt != 0:\n            self.worldVelocity = self.__oldPosDelta * (1 / self.__oldDt)\n        else:\n            # divide by zero\n            self.worldVelocity = 0\n\n        return Task.cont\n\n    def doDeltaPos(self):\n        assert self.debugPrint(\"doDeltaPos()\")\n\n    def reset(self):\n        assert self.debugPrint(\"reset()\")\n\n    def getVelocity(self):\n        return self.vel\n\n    def enableAvatarControls(self):\n        \"\"\"\n        Activate the arrow keys, etc.\n        \"\"\"\n        assert self.debugPrint(\"enableAvatarControls\")\n        assert self.collisionsActive\n\n        taskName = \"AvatarControls-%s\"%(id(self),)\n        # remove any old\n        taskMgr.remove(taskName)\n        # spawn the new task\n        taskMgr.add(self.handleAvatarControls, taskName)\n\n    def disableAvatarControls(self):\n        \"\"\"\n        Ignore the arrow keys, etc.\n        \"\"\"\n        assert self.debugPrint(\"disableAvatarControls\")\n        taskName = \"AvatarControls-%s\"%(id(self),)\n        taskMgr.remove(taskName)\n\n    def flushEventHandlers(self):\n        if hasattr(self, 'cTrav'):\n            self.pusher.flush()\n        self.lifter.flush() # not currently defined or needed\n\n    if __debug__:\n        def debugPrint(self, message):\n            \"\"\"for debugging\"\"\"\n            return self.notify.debug(\n                    str(id(self))+' '+message)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/controls/NonPhysicsWalker.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/a0f2d386_NonPhysicsWalker.json",
    "doc_id": "doc_236"
  }
}