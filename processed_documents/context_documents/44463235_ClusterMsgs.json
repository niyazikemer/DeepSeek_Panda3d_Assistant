{
  "content": "\"\"\"ClusterMsgs module: Message types for Cluster rendering\"\"\"\n\n# This module is intended to supply routines and dataformats common to\n# both ClusterClient and ClusterServer.\n\nfrom panda3d.net import NetDatagram\nfrom direct.distributed.PyDatagram import PyDatagram\nfrom direct.distributed.PyDatagramIterator import PyDatagramIterator\nimport time\n\n#these are the types of messages that are currently supported.\nCLUSTER_NONE                  = 0\nCLUSTER_CAM_OFFSET            = 1\nCLUSTER_CAM_FRUSTUM           = 2\nCLUSTER_CAM_MOVEMENT          = 3\nCLUSTER_SWAP_READY            = 4\nCLUSTER_SWAP_NOW              = 5\nCLUSTER_COMMAND_STRING        = 6\nCLUSTER_SELECTED_MOVEMENT     = 7\nCLUSTER_TIME_DATA             = 8\nCLUSTER_NAMED_OBJECT_MOVEMENT = 9\nCLUSTER_NAMED_MOVEMENT_DONE   = 10\nCLUSTER_EXIT                  = 100\n\n#Port number for cluster rendering\n# DAEMON PORT IS PORT USED FOR STARTUP MESSAGE EXCHANGE\n# CAN BE OVERRIDEN WITH cluster-daemon-client-port for client\n# and cluster-daemon-server-port for server\nCLUSTER_DAEMON_PORT = 8001\n# THIS IS THE TCP PORT USED FOR EXCHANGE OF DATA ONCE STARTUP IS COMPLETE\nCLUSTER_SERVER_PORT = 1970\n\n# Precede command string with ! to tell server to execute command string\n# Note, this startup string obviates the need to set any cluster related\n# config variables in the client Configrc files\nSERVER_STARTUP_STRING = (\n    '!bash ppython -c ' +\n    '\"import builtins; ' +\n    'builtins.clusterMode = \\'server\\';' +\n    'builtins.clusterServerPort = %s;' +\n    'builtins.clusterSyncFlag = %d;' +\n    'builtins.clusterDaemonClient = \\'%s\\';' +\n    'builtins.clusterDaemonPort = %d;'\n    'from direct.directbase.DirectStart import *; run()\"')\n\nclass ClusterMsgHandler:\n    \"\"\"ClusterMsgHandler: wrapper for PC clusters/multi-piping networking\"\"\"\n    def __init__(self, packetStart, notify):\n        # packetStart can be used to distinguish which ClusterMsgHandler\n        # sends a given packet.\n        self.packetNumber = packetStart\n        self.notify = notify\n\n    def nonBlockingRead(self, qcr):\n        \"\"\"\n        Return a datagram iterator and type if data is available on the\n        queued connection reader\n        \"\"\"\n        if qcr.dataAvailable():\n            datagram = NetDatagram()\n            if qcr.getData(datagram):\n                (dgi, dtype) = self.readHeader(datagram)\n            else:\n                dgi = None\n                dtype = CLUSTER_NONE\n                self.notify.warning(\"getData returned false\")\n        else:\n            datagram = None\n            dgi = None\n            dtype = CLUSTER_NONE\n        # Note, return datagram to keep a handle on the data\n        return (datagram, dgi, dtype)\n\n    def blockingRead(self, qcr):\n        \"\"\"\n        Block until data is available on the queued connection reader.\n        Returns a datagram iterator and type\n        \"\"\"\n        while not qcr.dataAvailable():\n            # The following may not be necessary.\n            # I just wanted some\n            # time given to the operating system while\n            # busy waiting.\n            time.sleep(0.002)\n        # Data is available, create a datagram iterator\n        datagram = NetDatagram()\n        if qcr.getData(datagram):\n            (dgi, dtype) = self.readHeader(datagram)\n        else:\n            (dgi, dtype) = (None, CLUSTER_NONE)\n            self.notify.warning(\"getData returned false\")\n        # Note, return datagram to keep a handle on the data\n        return (datagram, dgi, dtype)\n\n    def readHeader(self, datagram):\n        dgi = PyDatagramIterator(datagram)\n        number = dgi.getUint32()\n        dtype = dgi.getUint8()\n        self.notify.debug(\"Packet %d type %d received\" % (number, dtype))\n        return (dgi, dtype)\n\n    def makeCamOffsetDatagram(self, xyz, hpr):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_CAM_OFFSET)\n        datagram.addFloat32(xyz[0])\n        datagram.addFloat32(xyz[1])\n        datagram.addFloat32(xyz[2])\n        datagram.addFloat32(hpr[0])\n        datagram.addFloat32(hpr[1])\n        datagram.addFloat32(hpr[2])\n        return datagram\n\n    def parseCamOffsetDatagram(self, dgi):\n        x=dgi.getFloat32()\n        y=dgi.getFloat32()\n        z=dgi.getFloat32()\n        h=dgi.getFloat32()\n        p=dgi.getFloat32()\n        r=dgi.getFloat32()\n        self.notify.debug('new offset=%f %f %f  %f %f %f' % (x, y, z, h, p, r))\n        return (x, y, z, h, p, r)\n\n    def makeCamFrustumDatagram(self, focalLength, filmSize, filmOffset):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_CAM_FRUSTUM)\n        datagram.addFloat32(focalLength)\n        datagram.addFloat32(filmSize[0])\n        datagram.addFloat32(filmSize[1])\n        datagram.addFloat32(filmOffset[0])\n        datagram.addFloat32(filmOffset[1])\n        return datagram\n\n    def parseCamFrustumDatagram(self, dgi):\n        focalLength = dgi.getFloat32()\n        filmSize    = (dgi.getFloat32(), dgi.getFloat32())\n        filmOffset  = (dgi.getFloat32(), dgi.getFloat32())\n        self.notify.debug('fl, fs, fo=%f, (%f, %f), (%f, %f)' %\n                          (focalLength, filmSize[0], filmSize[1],\n                           filmOffset[0], filmOffset[1]))\n        return (focalLength, filmSize, filmOffset)\n\n    def makeCamMovementDatagram(self, xyz, hpr):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_CAM_MOVEMENT)\n        datagram.addFloat32(xyz[0])\n        datagram.addFloat32(xyz[1])\n        datagram.addFloat32(xyz[2])\n        datagram.addFloat32(hpr[0])\n        datagram.addFloat32(hpr[1])\n        datagram.addFloat32(hpr[2])\n        return datagram\n\n\n    def makeNamedMovementDone(self):\n\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_NAMED_MOVEMENT_DONE)\n        return datagram\n\n\n    def makeNamedObjectMovementDatagram(self, xyz, hpr, scale, color, hidden, name):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_NAMED_OBJECT_MOVEMENT)\n        datagram.addString(name)\n        datagram.addFloat32(xyz[0])\n        datagram.addFloat32(xyz[1])\n        datagram.addFloat32(xyz[2])\n        datagram.addFloat32(hpr[0])\n        datagram.addFloat32(hpr[1])\n        datagram.addFloat32(hpr[2])\n        datagram.addFloat32(scale[0])\n        datagram.addFloat32(scale[1])\n        datagram.addFloat32(scale[2])\n        datagram.addFloat32(color[0])\n        datagram.addFloat32(color[1])\n        datagram.addFloat32(color[2])\n        datagram.addFloat32(color[3])\n        datagram.addBool(hidden)\n        return datagram\n\n    def parseCamMovementDatagram(self, dgi):\n        x=dgi.getFloat32()\n        y=dgi.getFloat32()\n        z=dgi.getFloat32()\n        h=dgi.getFloat32()\n        p=dgi.getFloat32()\n        r=dgi.getFloat32()\n        self.notify.debug(('  new position=%f %f %f  %f %f %f' %\n                           (x, y, z, h, p, r)))\n        return (x, y, z, h, p, r)\n\n    def parseNamedMovementDatagram(self, dgi):\n        name = dgi.getString()\n        x=dgi.getFloat32()\n        y=dgi.getFloat32()\n        z=dgi.getFloat32()\n        h=dgi.getFloat32()\n        p=dgi.getFloat32()\n        r=dgi.getFloat32()\n        sx = dgi.getFloat32()\n        sy = dgi.getFloat32()\n        sz = dgi.getFloat32()\n        red = dgi.getFloat32()\n        g = dgi.getFloat32()\n        b = dgi.getFloat32()\n        a = dgi.getFloat32()\n        hidden = dgi.getBool()\n        return (name,x, y, z, h, p, r, sx, sy, sz, red, g, b, a, hidden)\n\n\n    def makeSelectedMovementDatagram(self, xyz, hpr, scale):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_SELECTED_MOVEMENT)\n        datagram.addFloat32(xyz[0])\n        datagram.addFloat32(xyz[1])\n        datagram.addFloat32(xyz[2])\n        datagram.addFloat32(hpr[0])\n        datagram.addFloat32(hpr[1])\n        datagram.addFloat32(hpr[2])\n        datagram.addFloat32(scale[0])\n        datagram.addFloat32(scale[1])\n        datagram.addFloat32(scale[2])\n        #datagram.addBool(hidden)\n        return datagram\n\n    def parseSelectedMovementDatagram(self, dgi):\n        x=dgi.getFloat32()\n        y=dgi.getFloat32()\n        z=dgi.getFloat32()\n        h=dgi.getFloat32()\n        p=dgi.getFloat32()\n        r=dgi.getFloat32()\n        sx=dgi.getFloat32()\n        sy=dgi.getFloat32()\n        sz=dgi.getFloat32()\n        self.notify.debug('  new position=%f %f %f  %f %f %f %f %f %f' %\n                          (x, y, z, h, p, r, sx, sy, sz))\n        return (x, y, z, h, p, r, sx, sy, sz)\n\n    def makeCommandStringDatagram(self, commandString):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_COMMAND_STRING)\n        datagram.addString(commandString)\n        return datagram\n\n    def parseCommandStringDatagram(self, dgi):\n        command = dgi.getString()\n        return command\n\n    def makeSwapNowDatagram(self):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_SWAP_NOW)\n        return datagram\n\n    def makeSwapReadyDatagram(self):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_SWAP_READY)\n        return datagram\n\n    def makeExitDatagram(self):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_EXIT)\n        return datagram\n\n    def makeTimeDataDatagram(self, frameCount, frameTime, dt):\n        datagram = PyDatagram()\n        datagram.addUint32(self.packetNumber)\n        self.packetNumber = self.packetNumber + 1\n        datagram.addUint8(CLUSTER_TIME_DATA)\n        datagram.addUint32(frameCount)\n        datagram.addFloat32(frameTime)\n        datagram.addFloat32(dt)\n        return datagram\n\n    def parseTimeDataDatagram(self, dgi):\n        frameCount=dgi.getUint32()\n        frameTime=dgi.getFloat32()\n        dt=dgi.getFloat32()\n        self.notify.debug('time data=%f %f' % (frameTime, dt))\n        return (frameCount, frameTime, dt)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/cluster/ClusterMsgs.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/44463235_ClusterMsgs.json",
    "doc_id": "doc_108"
  }
}