{
  "content": "\"\"\" This module reimplements Python's native threading module using Panda\nthreading constructs.  It's designed as a drop-in replacement for the\nthreading module for code that works with Panda; it is necessary because\nin some compilation models, Panda's threading constructs are\nincompatible with the OS-provided threads used by Python's thread\nmodule.\n\nUnlike threading.py, this module is a more explicit implementation of\nPython's threading model, designed to more precisely emulate Python's\nstandard threading semantics.  In fact, this is a bald-face copy of\nPython's threading module from Python 2.5, with a few lines at the top\nto import Panda's thread reimplementation instead of the system thread\nmodule, and so it is therefore layered on top of Panda's thread\nimplementation. \"\"\"\n\nimport sys as _sys\nimport atexit as _atexit\n\nfrom direct.stdpy import thread as _thread\nfrom direct.stdpy.thread import stack_size, _newname, _local as local\nfrom panda3d import core\n_sleep = core.Thread.sleep\n\nfrom time import time as _time\nfrom traceback import format_exc as _format_exc\n\n__all__ = ['get_ident', 'active_count', 'Condition', 'current_thread',\n           'enumerate', 'main_thread', 'TIMEOUT_MAX',\n           'Event', 'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Thread',\n           'Timer', 'ThreadError',\n           'setprofile', 'settrace', 'local', 'stack_size']\n\n# Rename some stuff so \"from threading import *\" is safe\n_start_new_thread = _thread.start_new_thread\n_allocate_lock = _thread.allocate_lock\nget_ident = _thread.get_ident\nThreadError = _thread.error\nTIMEOUT_MAX = _thread.TIMEOUT_MAX\ndel _thread\n\n\n# Debug support (adapted from ihooks.py).\n# All the major classes here derive from _Verbose.  We force that to\n# be a new-style class so that all the major classes here are new-style.\n# This helps debugging (type(instance) is more revealing for instances\n# of new-style classes).\n\n_VERBOSE = False\n\nif __debug__:\n\n    class _Verbose(object):\n\n        def __init__(self, verbose=None):\n            if verbose is None:\n                verbose = _VERBOSE\n            self.__verbose = verbose\n\n        def _note(self, format, *args):\n            if self.__verbose:\n                format = format % args\n                format = \"%s: %s\\n\" % (\n                    currentThread().getName(), format)\n                _sys.stderr.write(format)\n\nelse:\n    # Disable this when using \"python -O\"\n    class _Verbose(object):  # type: ignore[no-redef]\n        def __init__(self, verbose=None):\n            pass\n        def _note(self, *args):\n            pass\n\n# Support for profile and trace hooks\n\n_profile_hook = None\n_trace_hook = None\n\ndef setprofile(func):\n    global _profile_hook\n    _profile_hook = func\n\ndef settrace(func):\n    global _trace_hook\n    _trace_hook = func\n\n# Synchronization classes\n\nLock = _allocate_lock\n\ndef RLock(*args, **kwargs):\n    return _RLock(*args, **kwargs)\n\nclass _RLock(_Verbose):\n\n    def __init__(self, verbose=None):\n        _Verbose.__init__(self, verbose)\n        self.__block = _allocate_lock()\n        self.__owner = None\n        self.__count = 0\n\n    def __repr__(self):\n        return \"<%s(%s, %d)>\" % (\n                self.__class__.__name__,\n                self.__owner and self.__owner.getName(),\n                self.__count)\n\n    def acquire(self, blocking=1):\n        me = currentThread()\n        if self.__owner is me:\n            self.__count = self.__count + 1\n            if __debug__:\n                self._note(\"%s.acquire(%s): recursive success\", self, blocking)\n            return 1\n        rc = self.__block.acquire(blocking)\n        if rc:\n            self.__owner = me\n            self.__count = 1\n            if __debug__:\n                self._note(\"%s.acquire(%s): initial success\", self, blocking)\n        else:\n            if __debug__:\n                self._note(\"%s.acquire(%s): failure\", self, blocking)\n        return rc\n\n    __enter__ = acquire\n\n    def release(self):\n        me = currentThread()\n        assert self.__owner is me, \"release() of un-acquire()d lock\"\n        self.__count = count = self.__count - 1\n        if not count:\n            self.__owner = None\n            self.__block.release()\n            if __debug__:\n                self._note(\"%s.release(): final release\", self)\n        else:\n            if __debug__:\n                self._note(\"%s.release(): non-final release\", self)\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n    # Internal methods used by condition variables\n\n    def _acquire_restore(self, state):\n        self.__block.acquire()\n        self.__count, self.__owner = state\n        if __debug__:\n            self._note(\"%s._acquire_restore()\", self)\n\n    def _release_save(self):\n        if __debug__:\n            self._note(\"%s._release_save()\", self)\n        count = self.__count\n        self.__count = 0\n        owner = self.__owner\n        self.__owner = None\n        self.__block.release()\n        return (count, owner)\n\n    def _is_owned(self):\n        return self.__owner is currentThread()\n\n\ndef Condition(*args, **kwargs):\n    return _Condition(*args, **kwargs)\n\nclass _Condition(_Verbose):\n\n    def __init__(self, lock=None, verbose=None):\n        _Verbose.__init__(self, verbose)\n        if lock is None:\n            lock = RLock()\n        self.__lock = lock\n        # Export the lock's acquire() and release() methods\n        self.acquire = lock.acquire\n        self.release = lock.release\n        # If the lock defines _release_save() and/or _acquire_restore(),\n        # these override the default implementations (which just call\n        # release() and acquire() on the lock).  Ditto for _is_owned().\n        try:\n            self._release_save = lock._release_save\n        except AttributeError:\n            pass\n        try:\n            self._acquire_restore = lock._acquire_restore\n        except AttributeError:\n            pass\n        try:\n            self._is_owned = lock._is_owned\n        except AttributeError:\n            pass\n        self.__waiters = []\n\n    def __enter__(self):\n        return self.__lock.__enter__()\n\n    def __exit__(self, *args):\n        return self.__lock.__exit__(*args)\n\n    def __repr__(self):\n        return \"<Condition(%s, %d)>\" % (self.__lock, len(self.__waiters))\n\n    def _release_save(self): # pylint: disable=method-hidden\n        self.__lock.release()           # No state to save\n\n    def _acquire_restore(self, x): # pylint: disable=method-hidden\n        self.__lock.acquire()           # Ignore saved state\n\n    def _is_owned(self): # pylint: disable=method-hidden\n        # Return True if lock is owned by currentThread.\n        # This method is called only if __lock doesn't have _is_owned().\n        if self.__lock.acquire(0):\n            self.__lock.release()\n            return False\n        else:\n            return True\n\n    def wait(self, timeout=None):\n        assert self._is_owned(), \"wait() of un-acquire()d lock\"\n        waiter = _allocate_lock()\n        waiter.acquire()\n        self.__waiters.append(waiter)\n        saved_state = self._release_save()\n        try:    # restore state no matter what (e.g., KeyboardInterrupt)\n            if timeout is None:\n                waiter.acquire()\n                if __debug__:\n                    self._note(\"%s.wait(): got it\", self)\n            else:\n                # Balancing act:  We can't afford a pure busy loop, so we\n                # have to sleep; but if we sleep the whole timeout time,\n                # we'll be unresponsive.  The scheme here sleeps very\n                # little at first, longer as time goes on, but never longer\n                # than 20 times per second (or the timeout time remaining).\n                endtime = _time() + timeout\n                delay = 0.0005 # 500 us -> initial delay of 1 ms\n                while True:\n                    gotit = waiter.acquire(0)\n                    if gotit:\n                        break\n                    remaining = endtime - _time()\n                    if remaining <= 0:\n                        break\n                    delay = min(delay * 2, remaining, .05)\n                    _sleep(delay)\n                if not gotit:\n                    if __debug__:\n                        self._note(\"%s.wait(%s): timed out\", self, timeout)\n                    try:\n                        self.__waiters.remove(waiter)\n                    except ValueError:\n                        pass\n                else:\n                    if __debug__:\n                        self._note(\"%s.wait(%s): got it\", self, timeout)\n        finally:\n            self._acquire_restore(saved_state)\n\n    def notify(self, n=1):\n        assert self._is_owned(), \"notify() of un-acquire()d lock\"\n        __waiters = self.__waiters\n        waiters = __waiters[:n]\n        if not waiters:\n            if __debug__:\n                self._note(\"%s.notify(): no waiters\", self)\n            return\n        self._note(\"%s.notify(): notifying %d waiter%s\", self, n,\n                   n!=1 and \"s\" or \"\")\n        for waiter in waiters:\n            waiter.release()\n            try:\n                __waiters.remove(waiter)\n            except ValueError:\n                pass\n\n    def notifyAll(self):\n        self.notify(len(self.__waiters))\n\n\ndef Semaphore(*args, **kwargs):\n    return _Semaphore(*args, **kwargs)\n\nclass _Semaphore(_Verbose):\n\n    # After Tim Peters' semaphore class, but not quite the same (no maximum)\n\n    def __init__(self, value=1, verbose=None):\n        assert value >= 0, \"Semaphore initial value must be >= 0\"\n        _Verbose.__init__(self, verbose)\n        self.__cond = Condition(Lock())\n        self.__value = value\n\n    def acquire(self, blocking=1):\n        rc = False\n        self.__cond.acquire()\n        while self.__value == 0:\n            if not blocking:\n                break\n            if __debug__:\n                self._note(\"%s.acquire(%s): blocked waiting, value=%s\",\n                           self, blocking, self.__value)\n            self.__cond.wait()\n        else:\n            self.__value = self.__value - 1\n            if __debug__:\n                self._note(\"%s.acquire: success, value=%s\",\n                           self, self.__value)\n            rc = True\n        self.__cond.release()\n        return rc\n\n    __enter__ = acquire\n\n    def release(self):\n        self.__cond.acquire()\n        self.__value = self.__value + 1\n        if __debug__:\n            self._note(\"%s.release: success, value=%s\",\n                       self, self.__value)\n        self.__cond.notify()\n        self.__cond.release()\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n\ndef BoundedSemaphore(*args, **kwargs):\n    return _BoundedSemaphore(*args, **kwargs)\n\nclass _BoundedSemaphore(_Semaphore):\n    \"\"\"Semaphore that checks that # releases is <= # acquires\"\"\"\n    def __init__(self, value=1, verbose=None):\n        _Semaphore.__init__(self, value, verbose)\n        self._initial_value = value\n\n    def release(self):\n        if self._Semaphore__value >= self._initial_value:\n            raise ValueError(\"Semaphore released too many times\")\n        return _Semaphore.release(self)\n\n\ndef Event(*args, **kwargs):\n    return _Event(*args, **kwargs)\n\nclass _Event(_Verbose):\n\n    # After Tim Peters' event class (without is_posted())\n\n    def __init__(self, verbose=None):\n        _Verbose.__init__(self, verbose)\n        self.__cond = Condition(Lock())\n        self.__flag = False\n\n    def isSet(self):\n        return self.__flag\n\n    def set(self):\n        self.__cond.acquire()\n        try:\n            self.__flag = True\n            self.__cond.notifyAll()\n        finally:\n            self.__cond.release()\n\n    def clear(self):\n        self.__cond.acquire()\n        try:\n            self.__flag = False\n        finally:\n            self.__cond.release()\n\n    def wait(self, timeout=None):\n        self.__cond.acquire()\n        try:\n            if not self.__flag:\n                self.__cond.wait(timeout)\n        finally:\n            self.__cond.release()\n\n# Active thread administration\n_active_limbo_lock = _allocate_lock()\n_active = {}    # maps thread id to Thread object\n_limbo = {}\n\n\n# Main class for threads\n\nclass Thread(_Verbose):\n\n    __initialized = False\n    # Need to store a reference to sys.exc_info for printing\n    # out exceptions when a thread tries to use a global var. during interp.\n    # shutdown and thus raises an exception about trying to perform some\n    # operation on/with a NoneType\n    __exc_info = _sys.exc_info\n\n    # Set to True when the _shutdown handler is registered as atexit function.\n    # Protected by _active_limbo_lock.\n    __registered_atexit = False\n\n    def __init__(self, group=None, target=None, name=None,\n                 args=(), kwargs=None, verbose=None, daemon=None):\n        assert group is None, \"group argument must be None for now\"\n        _Verbose.__init__(self, verbose)\n        if kwargs is None:\n            kwargs = {}\n        self.__target = target\n        self.__name = str(name or _newname())\n        self.__args = args\n        self.__kwargs = kwargs\n        if daemon is not None:\n            self.__daemonic = daemon\n        else:\n            self.__daemonic = self._set_daemon()\n        self.__started = False\n        self.__stopped = False\n        self.__block = Condition(Lock())\n        self.__initialized = True\n        # sys.stderr is not stored in the class like\n        # sys.exc_info since it can be changed between instances\n        self.__stderr = _sys.stderr\n\n    def _set_daemon(self):\n        # Overridden in _MainThread and _DummyThread\n        return currentThread().isDaemon()\n\n    def __repr__(self):\n        assert self.__initialized, \"Thread.__init__() was not called\"\n        status = \"initial\"\n        if self.__started:\n            status = \"started\"\n        if self.__stopped:\n            status = \"stopped\"\n        if self.__daemonic:\n            status = status + \" daemon\"\n        return \"<%s(%s, %s)>\" % (self.__class__.__name__, self.__name, status)\n\n    def start(self):\n        assert self.__initialized, \"Thread.__init__() not called\"\n        assert not self.__started, \"thread already started\"\n        if __debug__:\n            self._note(\"%s.start(): starting thread\", self)\n        _active_limbo_lock.acquire()\n        _limbo[self] = self\n\n        # If we are starting a non-daemon thread, we need to call join() on it\n        # when the interpreter exits.  Python will call _shutdown() on the\n        # built-in threading module automatically, but not on our module.\n        if not self.__daemonic and not Thread.__registered_atexit:\n            _atexit.register(_shutdown)\n            Thread.__registered_atexit = True\n\n        _active_limbo_lock.release()\n        _start_new_thread(self.__bootstrap, ())\n        self.__started = True\n        _sleep(0.000001)    # 1 usec, to let the thread run (Solaris hack)\n\n    def run(self):\n        if self.__target:\n            self.__target(*self.__args, **self.__kwargs)\n\n    def __bootstrap(self):\n        try:\n            self.__started = True\n            _active_limbo_lock.acquire()\n            _active[get_ident()] = self\n            del _limbo[self]\n            _active_limbo_lock.release()\n            if __debug__:\n                self._note(\"%s.__bootstrap(): thread started\", self)\n\n            if _trace_hook:\n                self._note(\"%s.__bootstrap(): registering trace hook\", self)\n                _sys.settrace(_trace_hook)\n            if _profile_hook:\n                self._note(\"%s.__bootstrap(): registering profile hook\", self)\n                _sys.setprofile(_profile_hook)\n\n            try:\n                self.run()\n            except SystemExit:\n                if __debug__:\n                    self._note(\"%s.__bootstrap(): raised SystemExit\", self)\n            except:\n                if __debug__:\n                    self._note(\"%s.__bootstrap(): unhandled exception\", self)\n                # If sys.stderr is no more (most likely from interpreter\n                # shutdown) use self.__stderr.  Otherwise still use sys (as in\n                # _sys) in case sys.stderr was redefined since the creation of\n                # self.\n                if _sys:\n                    _sys.stderr.write(\"Exception in thread %s:\\n%s\\n\" %\n                                      (self.getName(), _format_exc()))\n                else:\n                    # Do the best job possible w/o a huge amt. of code to\n                    # approximate a traceback (code ideas from\n                    # Lib/traceback.py)\n                    exc_type, exc_value, exc_tb = self.__exc_info()\n                    try:\n                        self.__stderr.write(\"Exception in thread \" + self.getName() +\n                            \" (most likely raised during interpreter shutdown):\\n\")\n                        self.__stderr.write(\"Traceback (most recent call last):\\n\")\n                        while exc_tb:\n                            self.__stderr.write('  File \"%s\", line %s, in %s\\n' %\n                                (exc_tb.tb_frame.f_code.co_filename,\n                                    exc_tb.tb_lineno,\n                                    exc_tb.tb_frame.f_code.co_name))\n                            exc_tb = exc_tb.tb_next\n                        self.__stderr.write(\"%s: %s\\n\" % (exc_type, exc_value))\n                    # Make sure that exc_tb gets deleted since it is a memory\n                    # hog; deleting everything else is just for thoroughness\n                    finally:\n                        del exc_type, exc_value, exc_tb\n            else:\n                if __debug__:\n                    self._note(\"%s.__bootstrap(): normal return\", self)\n        finally:\n            self.__stop()\n            try:\n                self.__delete()\n            except:\n                pass\n\n    def __stop(self):\n        self.__block.acquire()\n        self.__stopped = True\n        self.__block.notifyAll()\n        self.__block.release()\n\n    def __delete(self):\n        \"Remove current thread from the dict of currently running threads.\"\n\n        # Notes about running with dummy_thread:\n        #\n        # Must take care to not raise an exception if dummy_thread is being\n        # used (and thus this module is being used as an instance of\n        # dummy_threading).  dummy_thread.get_ident() always returns -1 since\n        # there is only one thread if dummy_thread is being used.  Thus\n        # len(_active) is always <= 1 here, and any Thread instance created\n        # overwrites the (if any) thread currently registered in _active.\n        #\n        # An instance of _MainThread is always created by 'threading'.  This\n        # gets overwritten the instant an instance of Thread is created; both\n        # threads return -1 from dummy_thread.get_ident() and thus have the\n        # same key in the dict.  So when the _MainThread instance created by\n        # 'threading' tries to clean itself up when atexit calls this method\n        # it gets a KeyError if another Thread instance was created.\n        #\n        # This all means that KeyError from trying to delete something from\n        # _active if dummy_threading is being used is a red herring.  But\n        # since it isn't if dummy_threading is *not* being used then don't\n        # hide the exception.\n\n        _active_limbo_lock.acquire()\n        try:\n            try:\n                del _active[get_ident()]\n            except KeyError:\n                if 'dummy_threading' not in _sys.modules:\n                    raise\n        finally:\n            _active_limbo_lock.release()\n\n    def join(self, timeout=None):\n        assert self.__initialized, \"Thread.__init__() not called\"\n        assert self.__started, \"cannot join thread before it is started\"\n        assert self is not currentThread(), \"cannot join current thread\"\n        if __debug__:\n            if not self.__stopped:\n                self._note(\"%s.join(): waiting until thread stops\", self)\n        self.__block.acquire()\n        try:\n            if timeout is None:\n                while not self.__stopped:\n                    self.__block.wait()\n                if __debug__:\n                    self._note(\"%s.join(): thread stopped\", self)\n            else:\n                deadline = _time() + timeout\n                while not self.__stopped:\n                    delay = deadline - _time()\n                    if delay <= 0:\n                        if __debug__:\n                            self._note(\"%s.join(): timed out\", self)\n                        break\n                    self.__block.wait(delay)\n                else:\n                    if __debug__:\n                        self._note(\"%s.join(): thread stopped\", self)\n        finally:\n            self.__block.release()\n\n    def getName(self):\n        assert self.__initialized, \"Thread.__init__() not called\"\n        return self.__name\n\n    def setName(self, name):\n        assert self.__initialized, \"Thread.__init__() not called\"\n        self.__name = str(name)\n\n    def is_alive(self):\n        assert self.__initialized, \"Thread.__init__() not called\"\n        return self.__started and not self.__stopped\n\n    isAlive = is_alive\n\n    def isDaemon(self):\n        assert self.__initialized, \"Thread.__init__() not called\"\n        return self.__daemonic\n\n    def setDaemon(self, daemonic):\n        assert self.__initialized, \"Thread.__init__() not called\"\n        assert not self.__started, \"cannot set daemon status of active thread\"\n        self.__daemonic = daemonic\n\n    name = property(getName, setName)\n    daemon = property(isDaemon, setDaemon)\n\n# The timer class was contributed by Itamar Shtull-Trauring\n\ndef Timer(*args, **kwargs):\n    return _Timer(*args, **kwargs)\n\nclass _Timer(Thread):\n    \"\"\"Call a function after a specified number of seconds:\n\n    t = Timer(30.0, f, args=[], kwargs={})\n    t.start()\n    t.cancel() # stop the timer's action if it's still waiting\n    \"\"\"\n\n    def __init__(self, interval, function, args=[], kwargs={}):\n        Thread.__init__(self)\n        self.interval = interval\n        self.function = function\n        self.args = args\n        self.kwargs = kwargs\n        self.finished = Event()\n\n    def cancel(self):\n        \"\"\"Stop the timer if it hasn't finished yet\"\"\"\n        self.finished.set()\n\n    def run(self):\n        self.finished.wait(self.interval)\n        if not self.finished.isSet():\n            self.function(*self.args, **self.kwargs)\n        self.finished.set()\n\n# Special thread class to represent the main thread\n# This is garbage collected through an exit handler\n\nclass _MainThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=\"MainThread\")\n        self._Thread__started = True\n        _active_limbo_lock.acquire()\n        _active[get_ident()] = self\n        _active_limbo_lock.release()\n\n    def _set_daemon(self):\n        return False\n\n    def _exitfunc(self):\n        self._Thread__stop()\n        t = _pickSomeNonDaemonThread()\n        if t:\n            if __debug__:\n                self._note(\"%s: waiting for other threads\", self)\n        while t:\n            t.join()\n            t = _pickSomeNonDaemonThread()\n        if __debug__:\n            self._note(\"%s: exiting\", self)\n        self._Thread__delete()\n\n\n# Dummy thread class to represent threads not started here.\n# These aren't garbage collected when they die, nor can they be waited for.\n# If they invoke anything in threading.py that calls currentThread(), they\n# leave an entry in the _active dict forever after.\n# Their purpose is to return *something* from currentThread().\n# They are marked as daemon threads so we won't wait for them\n# when we exit (conform previous semantics).\n\nclass _DummyThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=_newname(\"Dummy-%d\"), daemon=True)\n\n        # Thread.__block consumes an OS-level locking primitive, which\n        # can never be used by a _DummyThread.  Since a _DummyThread\n        # instance is immortal, that's bad, so release this resource.\n        del self._Thread__block\n\n        self._Thread__started = True\n        _active_limbo_lock.acquire()\n        _active[get_ident()] = self\n        _active_limbo_lock.release()\n\n    def _set_daemon(self):\n        return True\n\n    def join(self, timeout=None):\n        assert False, \"cannot join a dummy thread\"\n\n\n# Global API functions\n\ndef current_thread():\n    try:\n        return _active[get_ident()]\n    except KeyError:\n        ##print \"current_thread(): no current thread for\", get_ident()\n        return _DummyThread()\n\ncurrentThread = current_thread\n\ndef active_count():\n    _active_limbo_lock.acquire()\n    count = len(_active) + len(_limbo)\n    _active_limbo_lock.release()\n    return count\n\nactiveCount = active_count\n\ndef enumerate():\n    _active_limbo_lock.acquire()\n    active = list(_active.values()) + list(_limbo.values())\n    _active_limbo_lock.release()\n    return active\n\n#from thread import stack_size\n\n# Create the main thread object,\n# and make it available for the interpreter\n# (Py_Main) as threading._shutdown.\n\n_main_thread = _MainThread()\n_shutdown = _main_thread._exitfunc\n\ndef _pickSomeNonDaemonThread():\n    for t in enumerate():\n        if not t.isDaemon() and t.isAlive():\n            return t\n    return None\n\ndef main_thread():\n    \"\"\"Return the main thread object.\n    In normal conditions, the main thread is the thread from which the\n    Python interpreter was started.\n    \"\"\"\n    return _main_thread\n\n# get thread-local implementation, either from the thread\n# module, or from the python fallback\n\n## try:\n##     from thread import _local as local\n## except ImportError:\n##     from _threading_local import local\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/stdpy/threading2.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/7cee4064_threading2.json",
    "doc_id": "doc_206"
  }
}