{
  "content": "from direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.showbase.PythonUtil import itype, fastRepr\nfrom direct.showbase.Job import Job\nfrom direct.showbase.JobManagerGlobal import jobMgr\nfrom direct.showbase.MessengerGlobal import messenger\nimport gc\nimport builtins\n\n\nclass MessengerLeakObject(DirectObject):\n    def __init__(self):\n        self.accept('leakEvent', self._handleEvent)\n\n    def _handleEvent(self):\n        pass\n\n\ndef _leakMessengerObject():\n    leakObject = MessengerLeakObject()\n\n\nclass MessengerLeakDetector(Job):\n    # check for objects that are only referenced by the messenger\n    # and would otherwise be garbage collected\n    notify = directNotify.newCategory(\"MessengerLeakDetector\")\n\n    def __init__(self, name):\n        Job.__init__(self, name)\n        self.setPriority(Job.Priorities.Normal*2)\n        jobMgr.add(self)\n\n    def run(self):\n        # set of ids of objects that we know are always attached to builtin;\n        # if an object is attached to one of these, it's attached to builtin\n        # this cuts down on the amount of searching that needs to be done\n        builtinIds = set()\n        builtinIds.add(id(builtins.__dict__))\n        try:\n            builtinIds.add(id(base))\n            builtinIds.add(id(base.cr))\n            builtinIds.add(id(base.cr.doId2do))\n        except Exception:\n            pass\n        try:\n            builtinIds.add(id(simbase))\n            builtinIds.add(id(simbase.air))\n            builtinIds.add(id(simbase.air.doId2do))\n        except Exception:\n            pass\n        try:\n            builtinIds.add(id(uber))\n            builtinIds.add(id(uber.air))\n            builtinIds.add(id(uber.air.doId2do))\n        except Exception:\n            pass\n\n        while True:\n            yield None\n            objects = list(messenger._Messenger__objectEvents.keys())\n            assert self.notify.debug('%s objects in the messenger' % len(objects))\n            for object in objects:\n                yield None\n                assert self.notify.debug('---> new object: %s' % itype(object))\n                # try to find a path to builtin that doesn't involve the messenger\n                # lists of objects for breadth-first search\n                # iterate through one list while populating other list\n                objList1 = []\n                objList2 = []\n                curObjList = objList1\n                nextObjList = objList2\n                visitedObjIds = set()\n\n                # add the id of the object, and the messenger containers so that\n                # the search for builtin will stop at the messenger; we're looking\n                # for any path to builtin that don't involve the messenger\n                visitedObjIds.add(id(object))\n                visitedObjIds.add(id(messenger._Messenger__objectEvents))\n                visitedObjIds.add(id(messenger._Messenger__callbacks))\n\n                nextObjList.append(object)\n                foundBuiltin = False\n\n                # breadth-first search, go until you run out of new objects or you find __builtin__\n                while len(nextObjList) > 0:\n                    if foundBuiltin:\n                        break\n                    # swap the lists, prepare for the next pass\n                    curObjList = nextObjList\n                    nextObjList = []\n                    assert self.notify.debug('next search iteration, num objects: %s' % len(curObjList))\n                    for curObj in curObjList:\n                        if foundBuiltin:\n                            break\n                        yield None\n                        referrers = gc.get_referrers(curObj)\n                        assert self.notify.debug('curObj: %s @ %s, %s referrers, repr=%s' % (\n                            itype(curObj), hex(id(curObj)), len(referrers), fastRepr(curObj, maxLen=2)))\n                        for referrer in referrers:\n                            #assert self.notify.debug('referrer: %s' % itype(curObj))\n                            yield None\n                            refId = id(referrer)\n                            # don't go in a loop\n                            if refId in visitedObjIds:\n                                #assert self.notify.debug('already visited')\n                                continue\n                            # don't self-reference\n                            if referrer is curObjList or referrer is nextObjList:\n                                continue\n                            if refId in builtinIds:\n                                # not a leak, there is a path to builtin that does not involve the messenger\n                                #assert self.notify.debug('object has another path to __builtin__, it\\'s not a messenger leak')\n                                foundBuiltin = True\n                                break\n                            else:\n                                visitedObjIds.add(refId)\n                                nextObjList.append(referrer)\n\n                if not foundBuiltin:\n                    self.notify.warning(\n                        '%s is referenced only by the messenger' % (itype(object)))\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/MessengerLeakDetector.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/f7240720_MessengerLeakDetector.json",
    "doc_id": "doc_264"
  }
}