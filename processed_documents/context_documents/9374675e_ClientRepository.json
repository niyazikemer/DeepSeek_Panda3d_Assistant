{
  "content": "\"\"\"ClientRepository module: contains the ClientRepository class\"\"\"\n\nfrom .ClientRepositoryBase import ClientRepositoryBase\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.showbase.MessengerGlobal import messenger\nfrom .MsgTypesCMU import (\n    CLIENT_DISCONNECT_CMU,\n    CLIENT_HEARTBEAT_CMU,\n    CLIENT_OBJECT_UPDATE_FIELD_TARGETED_CMU,\n    CLIENT_SET_INTEREST_CMU,\n    OBJECT_DELETE_CMU,\n    OBJECT_DISABLE_CMU,\n    OBJECT_GENERATE_CMU,\n    OBJECT_SET_ZONE_CMU,\n    OBJECT_UPDATE_FIELD_CMU,\n    REQUEST_GENERATES_CMU,\n    SET_DOID_RANGE_CMU,\n)\nfrom .PyDatagram import PyDatagram\nfrom .PyDatagramIterator import PyDatagramIterator\nfrom panda3d.core import UniqueIdAllocator, Notify, ClockObject\n\n\nclass ClientRepository(ClientRepositoryBase):\n    \"\"\"\n    This is the open-source ClientRepository as provided by CMU.  It\n    communicates with the ServerRepository in this same directory.\n\n    If you are looking for the VR Studio's implementation of the\n    client repository, look to OTPClientRepository (elsewhere).\n    \"\"\"\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"ClientRepository\")\n\n    # This is required by DoCollectionManager, even though it's not\n    # used by this implementation.\n    GameGlobalsId = 0\n\n    doNotDeallocateChannel = True\n\n    def __init__(self, dcFileNames = None, dcSuffix = '', connectMethod = None,\n                 threadedNet = None):\n        ClientRepositoryBase.__init__(self, dcFileNames = dcFileNames, dcSuffix = dcSuffix, connectMethod = connectMethod, threadedNet = threadedNet)\n        self.setHandleDatagramsInternally(False)\n\n        base.finalExitCallbacks.append(self.shutdown)\n\n        # The doId allocator.  The CMU LAN server may choose to\n        # send us a block of doIds.  If it chooses to do so, then we\n        # may create objects, using those doIds.\n        self.doIdAllocator = None\n        self.doIdBase = 0\n        self.doIdLast = 0\n\n        # The doIdBase of the client message currently being\n        # processed.\n        self.currentSenderId = None\n\n        # Explicitly-requested interest zones.\n        self.interestZones = []\n\n    def handleSetDoIdrange(self, di):\n        self.doIdBase = di.getUint32()\n        self.doIdLast = self.doIdBase + di.getUint32()\n        self.doIdAllocator = UniqueIdAllocator(self.doIdBase, self.doIdLast - 1)\n\n        self.ourChannel = self.doIdBase\n\n        self.createReady()\n\n    def createReady(self):\n        # Now that we've got a doId range, we can safely generate new\n        # distributed objects.\n        messenger.send('createReady', taskChain = 'default')\n        messenger.send(self.uniqueName('createReady'), taskChain = 'default')\n\n    def handleRequestGenerates(self, di):\n        # When new clients join the zone of an object, they need to hear\n        # about it, so we send out all of our information about objects in\n        # that particular zone.\n\n        zone = di.getUint32()\n        for obj in self.doId2do.values():\n            if obj.zoneId == zone:\n                if self.isLocalId(obj.doId):\n                    self.resendGenerate(obj)\n\n    def resendGenerate(self, obj):\n        \"\"\" Sends the generate message again for an already-generated\n        object, presumably to inform any newly-arrived clients of this\n        object's current state. \"\"\"\n\n        # get the list of \"ram\" fields that aren't\n        # required.  These are fields whose values should\n        # persist even if they haven't been received\n        # lately, so we have to re-broadcast these values\n        # in case the new client hasn't heard their latest\n        # values.\n        extraFields = []\n        for i in range(obj.dclass.getNumInheritedFields()):\n            field = obj.dclass.getInheritedField(i)\n            if field.hasKeyword('broadcast') and field.hasKeyword('ram') and not field.hasKeyword('required'):\n                if field.asMolecularField():\n                    # It's a molecular field; this means\n                    # we have to pack the components.\n                    # Fortunately, we'll find those\n                    # separately through the iteration, so\n                    # we can ignore this field itself.\n                    continue\n\n                extraFields.append(field.getName())\n\n        datagram = self.formatGenerate(obj, extraFields)\n        self.send(datagram)\n\n    def handleGenerate(self, di):\n        self.currentSenderId = di.getUint32()\n        zoneId = di.getUint32()\n        classId = di.getUint16()\n        doId = di.getUint32()\n\n        # Look up the dclass\n        dclass = self.dclassesByNumber[classId]\n\n        distObj = self.doId2do.get(doId)\n        if distObj and distObj.dclass == dclass:\n            # We've already got this object.  Probably this is just a\n            # repeat-generate, synthesized for the benefit of someone\n            # else who just entered the zone.  Accept the new updates,\n            # but don't make a formal generate.\n            assert self.notify.debug(\"performing generate-update for %s %s\" % (dclass.getName(), doId))\n            dclass.receiveUpdateBroadcastRequired(distObj, di)\n            dclass.receiveUpdateOther(distObj, di)\n            return\n\n        assert self.notify.debug(\"performing generate for %s %s\" % (dclass.getName(), doId))\n        dclass.startGenerate()\n        # Create a new distributed object, and put it in the dictionary\n        distObj = self.generateWithRequiredOtherFields(dclass, doId, di, 0, zoneId)\n        dclass.stopGenerate()\n\n    def allocateDoId(self):\n        \"\"\" Returns a newly-allocated doId.  Call freeDoId() when the\n        object has been deleted. \"\"\"\n\n        return self.doIdAllocator.allocate()\n\n    def reserveDoId(self, doId):\n        \"\"\" Removes the indicate doId from the available pool, as if\n        it had been explicitly allocated.  You may pass it to\n        freeDoId() later if you wish. \"\"\"\n\n        self.doIdAllocator.initialReserveId(doId)\n        return doId\n\n    def freeDoId(self, doId):\n        \"\"\" Returns a doId back into the free pool for re-use. \"\"\"\n\n        assert self.isLocalId(doId)\n        self.doIdAllocator.free(doId)\n\n    def storeObjectLocation(self, object, parentId, zoneId):\n        # The CMU implementation doesn't use the DoCollectionManager\n        # much.\n        object.parentId = parentId\n        object.zoneId = zoneId\n\n    def createDistributedObject(self, className = None, distObj = None,\n                                zoneId = 0, optionalFields = None,\n                                doId = None, reserveDoId = False):\n\n        \"\"\" To create a DistributedObject, you must pass in either the\n        name of the object's class, or an already-created instance of\n        the class (or both).  If you pass in just a class name (to the\n        className parameter), then a default instance of the object\n        will be created, with whatever parameters the default\n        constructor supplies.  Alternatively, if you wish to create\n        some initial values different from the default, you can create\n        the instance yourself and supply it to the distObj parameter,\n        then that instance will be used instead.  (It should be a\n        newly-created object, not one that has already been manifested\n        on the network or previously passed through\n        createDistributedObject.)  In either case, the new\n        DistributedObject is returned from this method.\n\n        This method will issue the appropriate network commands to\n        make this object appear on all of the other clients.\n\n        You should supply an initial zoneId in which to manifest the\n        object.  The fields marked \"required\" or \"ram\" will be\n        broadcast to all of the other clients; if you wish to\n        broadcast additional field values at this time as well, pass a\n        list of field names in the optionalFields parameters.\n\n        Normally, doId is None, to mean allocate a new doId for the\n        object.  If you wish to use a particular doId, pass it in\n        here.  If you also pass reserveDoId = True, this doId will be\n        reserved from the allocation pool using self.reserveDoId().\n        You are responsible for ensuring this doId falls within the\n        client's allowable doId range and has not already been\n        assigned to another object.  \"\"\"\n\n        if not className:\n            if not distObj:\n                self.notify.error(\"Must specify either a className or a distObj.\")\n            className = distObj.__class__.__name__\n\n        if doId is None:\n            doId = self.allocateDoId()\n        elif reserveDoId:\n            self.reserveDoId(doId)\n\n        dclass = self.dclassesByName.get(className)\n        if not dclass:\n            self.notify.error(\"Unknown distributed class: %s\" % (distObj.__class__))\n        classDef = dclass.getClassDef()\n        if classDef is None:\n            self.notify.error(\"Could not create an undefined %s object.\" % (\n                dclass.getName()))\n\n        if not distObj:\n            distObj = classDef(self)\n        if not isinstance(distObj, classDef):\n            self.notify.error(\"Object %s is not an instance of %s\" % (distObj.__class__.__name__, classDef.__name__))\n\n        distObj.dclass = dclass\n        distObj.doId = doId\n        self.doId2do[doId] = distObj\n        distObj.generateInit()\n        distObj._retrieveCachedData()\n        distObj.generate()\n        distObj.setLocation(0, zoneId)\n        distObj.announceGenerate()\n        datagram = self.formatGenerate(distObj, optionalFields)\n        self.send(datagram)\n        return distObj\n\n    def formatGenerate(self, distObj, extraFields):\n        \"\"\" Returns a datagram formatted for sending the generate message for the indicated object. \"\"\"\n        return distObj.dclass.clientFormatGenerateCMU(distObj, distObj.doId, distObj.zoneId, extraFields)\n\n    def sendDeleteMsg(self, doId):\n        datagram = PyDatagram()\n        datagram.addUint16(OBJECT_DELETE_CMU)\n        datagram.addUint32(doId)\n        self.send(datagram)\n\n    def sendDisconnect(self):\n        if self.isConnected():\n            # Tell the game server that we're going:\n            datagram = PyDatagram()\n            # Add message type\n            datagram.addUint16(CLIENT_DISCONNECT_CMU)\n            # Send the message\n            self.send(datagram)\n            self.notify.info(\"Sent disconnect message to server\")\n            self.disconnect()\n        self.stopHeartbeat()\n\n    def setInterestZones(self, interestZoneIds):\n        \"\"\" Changes the set of zones that this particular client is\n        interested in hearing about. \"\"\"\n\n        datagram = PyDatagram()\n        # Add message type\n        datagram.addUint16(CLIENT_SET_INTEREST_CMU)\n\n        for zoneId in interestZoneIds:\n            datagram.addUint32(zoneId)\n\n        # send the message\n        self.send(datagram)\n        self.interestZones = interestZoneIds[:]\n\n    def setObjectZone(self, distObj, zoneId):\n        \"\"\" Moves the object into the indicated zone. \"\"\"\n        distObj.b_setLocation(0, zoneId)\n        assert distObj.zoneId == zoneId\n\n        # Tell all of the clients monitoring the new zone that we've\n        # arrived.\n        self.resendGenerate(distObj)\n\n    def sendSetLocation(self, doId, parentId, zoneId):\n        datagram = PyDatagram()\n        datagram.addUint16(OBJECT_SET_ZONE_CMU)\n        datagram.addUint32(doId)\n        datagram.addUint32(zoneId)\n        self.send(datagram)\n\n    def sendHeartbeat(self):\n        datagram = PyDatagram()\n        # Add message type\n        datagram.addUint16(CLIENT_HEARTBEAT_CMU)\n        # Send it!\n        self.send(datagram)\n        self.lastHeartbeat = ClockObject.getGlobalClock().getRealTime()\n        # This is important enough to consider flushing immediately\n        # (particularly if we haven't run readerPollTask recently).\n        self.considerFlush()\n\n    def isLocalId(self, doId):\n        \"\"\" Returns true if this doId is one that we're the owner of,\n        false otherwise. \"\"\"\n\n        return doId >= self.doIdBase and doId < self.doIdLast\n\n    def haveCreateAuthority(self):\n        \"\"\" Returns true if this client has been assigned a range of\n        doId's it may use to create objects, false otherwise. \"\"\"\n\n        return self.doIdLast > self.doIdBase\n\n    def getAvatarIdFromSender(self):\n        \"\"\" Returns the doIdBase of the client that originally sent\n        the current update message.  This is only defined when\n        processing an update message or a generate message. \"\"\"\n        return self.currentSenderId\n\n    def handleDatagram(self, di):\n        if self.notify.getDebug():\n            print(\"ClientRepository received datagram:\")\n            di.getDatagram().dumpHex(Notify.out())\n\n        msgType = self.getMsgType()\n        self.currentSenderId = None\n\n        # These are the sort of messages we may expect from the public\n        # Panda server.\n\n        if msgType == SET_DOID_RANGE_CMU:\n            self.handleSetDoIdrange(di)\n        elif msgType == OBJECT_GENERATE_CMU:\n            self.handleGenerate(di)\n        elif msgType == OBJECT_UPDATE_FIELD_CMU:\n            self.handleUpdateField(di)\n        elif msgType == OBJECT_DISABLE_CMU:\n            self.handleDisable(di)\n        elif msgType == OBJECT_DELETE_CMU:\n            self.handleDelete(di)\n        elif msgType == REQUEST_GENERATES_CMU:\n            self.handleRequestGenerates(di)\n        else:\n            self.handleMessageType(msgType, di)\n\n        # If we're processing a lot of datagrams within one frame, we\n        # may forget to send heartbeats.  Keep them coming!\n        self.considerHeartbeat()\n\n    def handleMessageType(self, msgType, di):\n        self.notify.error(\"unrecognized message type %s\" % (msgType))\n\n    def handleUpdateField(self, di):\n        # The CMU update message starts with an additional field, not\n        # present in the Disney update message: the doIdBase of the\n        # original sender.  Extract that and call up to the parent.\n        self.currentSenderId = di.getUint32()\n        ClientRepositoryBase.handleUpdateField(self, di)\n\n    def handleDisable(self, di):\n        # Receives a list of doIds.\n        while di.getRemainingSize() > 0:\n            doId = di.getUint32()\n\n            # We should never get a disable message for our own object.\n            assert not self.isLocalId(doId)\n            self.disableDoId(doId)\n\n    def handleDelete(self, di):\n        # Receives a single doId.\n        doId = di.getUint32()\n        self.deleteObject(doId)\n\n    def deleteObject(self, doId):\n        \"\"\"\n        Removes the object from the client's view of the world.  This\n        should normally not be called directly except in the case of\n        error recovery, since the server will normally be responsible\n        for deleting and disabling objects as they go out of scope.\n\n        After this is called, future updates by server on this object\n        will be ignored (with a warning message).  The object will\n        become valid again the next time the server sends a generate\n        message for this doId.\n\n        This is not a distributed message and does not delete the\n        object on the server or on any other client.\n        \"\"\"\n        if doId in self.doId2do:\n            # If it is in the dictionary, remove it.\n            obj = self.doId2do[doId]\n            # Remove it from the dictionary\n            del self.doId2do[doId]\n            # Disable, announce, and delete the object itself...\n            # unless delayDelete is on...\n            obj.deleteOrDelay()\n            if self.isLocalId(doId):\n                self.freeDoId(doId)\n        elif self.cache.contains(doId):\n            # If it is in the cache, remove it.\n            self.cache.delete(doId)\n            if self.isLocalId(doId):\n                self.freeDoId(doId)\n        else:\n            # Otherwise, ignore it\n            self.notify.warning(\n                \"Asked to delete non-existent DistObj \" + str(doId))\n\n    def stopTrackRequestDeletedDO(self, *args):\n        # No-op.  Not entirely sure what this does on the VR Studio side.\n        pass\n\n    def sendUpdate(self, distObj, fieldName, args):\n        \"\"\" Sends a normal update for a single field. \"\"\"\n        dg = distObj.dclass.clientFormatUpdate(\n            fieldName, distObj.doId, args)\n        self.send(dg)\n\n    def sendUpdateToChannel(self, distObj, channelId, fieldName, args):\n\n        \"\"\" Sends a targeted update of a single field to a particular\n        client.  The top 32 bits of channelId is ignored; the lower 32\n        bits should be the client Id of the recipient (i.e. the\n        client's doIdbase).  The field update will be sent to the\n        indicated client only.  The field must be marked clsend or\n        p2p, and may not be marked broadcast. \"\"\"\n\n        datagram = distObj.dclass.clientFormatUpdate(\n            fieldName, distObj.doId, args)\n        dgi = PyDatagramIterator(datagram)\n\n        # Reformat the packed datagram to change the message type and\n        # add the target id.\n        dgi.getUint16()\n\n        dg = PyDatagram()\n        dg.addUint16(CLIENT_OBJECT_UPDATE_FIELD_TARGETED_CMU)\n        dg.addUint32(channelId & 0xffffffff)\n        dg.appendData(dgi.getRemainingBytes())\n\n        self.send(dg)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/ClientRepository.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/9374675e_ClientRepository.json",
    "doc_id": "doc_333"
  }
}