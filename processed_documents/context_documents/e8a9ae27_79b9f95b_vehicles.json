{
  "content": "Bullet Vehicles\n\nBullet comes with a simple vehicle controller, which can be used for arcade style vehicle simulations. Instead of simulation of each wheel and chassis as separate rigid bodies connected by joints, it simply uses a single rigid body for the chassis. Collision detection for the wheels is approximated by ray casts, and the tire friction is a basic anisotropic friction model. This approach to vehicle modelling is called \"raycast vehicle\", and it is used widely in commercial and non-commercial driving games.\n\nSetup\n\nIn order to create a vehicle we first have to create an ordinary dynamic rigid body. This rigid body will serve as the vehicle chassis. Then we can create a new instance of .BulletVehicle. We have to pass the .BulletWorld and the .BulletRigidBodyNode as arguments to the vehicle constructor.\n\npython\n\nThe following code snippet shows how this could be done.\n\nfrom panda3d.bullet import BulletVehicle\n\n# Chassis body\nshape = BulletBoxShape(Vec3(0.7, 1.5, 0.5))\nts = TransformState.makePos(Point3(0, 0, 0.5))\n\nchassisNP = render.attachNewNode(BulletRigidBodyNode('Vehicle'))\nchassisNP.node().addShape(shape, ts)\nchassisNP.setPos(0, 0, 1)\nchassisNP.node().setMass(800.0)\nchassisNP.node().setDeactivationEnabled(False)\n\nworld.attachRigidBody(chassisNP.node())\n\n# Chassis geometry\nloader.loadModel('path/to/model').reparentTo(chassisNP)\n\n# Vehicle\nvehicle = BulletVehicle(world, chassisNP.node())\nvehicle.setCoordinateSystem(ZUp)\nworld.attachVehicle(vehicle)\n\nWheels\n\nOnce we have created the chassis and the vehicle we can add wheels to the vehicle. We can create a new wheel using the createWheel factory method of the previously created vehicle. Once created we still have to configure the wheel, that is set friction parameters, offset of the wheel hub with respect to the chassis, axle direction and so on.\n\npython\n\nThe following sample shows how to create and configure a wheel. In this case a front wheel is created. Front wheels are steerable.\n\nwheelNP = loader.loadModel('path/to/model')\nwheelNP.reparentTo(render)\n\nwheel = vehicle.createWheel()\n\nwheel.setNode(wheelNP.node())\nwheel.setChassisConnectionPointCs(Point3(0.8, 1.1, 0.3))\nwheel.setFrontWheel(True)\n\nwheel.setWheelDirectionCs(Vec3(0, 0, -1))\nwheel.setWheelAxleCs(Vec3(1, 0, 0))\nwheel.setWheelRadius(0.25)\nwheel.setMaxSuspensionTravelCm(40.0)\n\nwheel.setSuspensionStiffness(40.0)\nwheel.setWheelsDampingRelaxation(2.3)\nwheel.setWheelsDampingCompression(4.4)\nwheel.setFrictionSlip(100.0)\nwheel.setRollInfluence(0.1)\n\nSteering and Engine/Brake\n\nFinally we need to control steering and engine/brakes. This is best done using a task, and keeping the current steering angle around somewhere in a variable.\n\nHere we use a very simple model of controlling the steering angle. If 'turnLeft' or 'turnRight' keys are pressed the steering angle will increase/decrease at a constant rate, until a maximum steering angle is achieved. No relaxation is applied. Therefor we also define constants for the maximum steering angle (here: steeringClamp) and the rate at which the steering angle increases/decreases (here: steeringIncrement).\n\nThe engine force and brake model shown is very simple too. If 'forward' is pressed then the engine force will be the maximum engine force, otherwise engine force will be zero. Likewise for the brakes.\n\nOnce the steering angle and engine/brake forces are determined they will be applied to the wheels. Each wheel - addressed by it's index, i. e. 0 to 3 for a four-wheel car - can be individually assigned values for steering and engine/brake force. This way front/rear drives or four-wheel-drives can be simulated.\n\npython\n\nThe following code snippet shows pseudocode for controlling steering and engine/brakes.\n\n# Steering info\nsteering = 0.0            # degree\nsteeringClamp = 45.0      # degree\nsteeringIncrement = 120.0 # degree per second\n\n# Process input\nengineForce = 0.0\nbrakeForce = 0.0\n\nif inputState.isSet('forward'):\n    engineForce = 1000.0\n    brakeForce = 0.0\n\nif inputState.isSet('reverse'):\n    engineForce = 0.0\n    brakeForce = 100.0\n\nif inputState.isSet('turnLeft'):\n    steering += dt * steeringIncrement\n    steering = min(steering, steeringClamp)\n\nif inputState.isSet('turnRight'):\n    steering -= dt * steeringIncrement\n    steering = max(steering, -steeringClamp)\n\n# Apply steering to front wheels\nvehicle.setSteeringValue(steering, 0)\nvehicle.setSteeringValue(steering, 1)\n\n# Apply engine and brake to rear wheels\nvehicle.applyEngineForce(engineForce, 2)\nvehicle.applyEngineForce(engineForce, 3)\nvehicle.setBrake(brakeForce, 2)\nvehicle.setBrake(brakeForce, 3)\n\nMore realistic control models can be invented, in order to meet the control requirements of individual driving games. For example:\n\nRelaxing the steering angle to zero if the user does no hold down the left or right keys.\n\nReducing the maximum steering angle with increasing vehicle speed.\n\nSetting engine force based on an analogue input, or alternatively based on the duration of the forward key being pressed down.\n\nHowever, it is up to you do invent such controls. What Bullet requires is that you provide the steering angle and the engine and brake force.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/79b9f95b_vehicles.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/e8a9ae27_79b9f95b_vehicles.json",
    "doc_id": "doc_432"
  }
}