{
  "content": "Display Regions\n\nA new window can't render anything until it has at least one .DisplayRegion. A DisplayRegion is necessary to associate a camera with the window.\n\nA .DisplayRegion is a rectangular area of the window that contains the rendered scene, as viewed by one particular camera. Usually, you create just one DisplayRegion that covers the entire window, although you can create as many different smaller regions as you like, each one displaying the output from a different camera.\n\nYou can create a DisplayRegion with the ~.GraphicsOutput.make_display_region() call on a window:\n\npython\n\nregion = win.makeDisplayRegion()\nregion = win.makeDisplayRegion(left, right, bottom, top)\n\ncpp\n\nPT(DisplayRegion) region = win.make_display_region();\nPT(DisplayRegion) region = win.make_display_region(left, right, bottom, top);\n\nThe first example creates a DisplayRegion that fills the entire window, while the second example specifies the size and placement of the DisplayRegion within the window. The ranges of left, right, bottom, top are from 0 to 1, where 0 is the left and bottom of the window, and 1 is the right and top of the window. (Note that this is different from the range of the render2d screen coordinates, which ranges from -1 to 1 instead of 0 to 1.) For instance, the right panel of the second example above was created with the call win.makeDisplayRegion(0.5, 1, 0, 1).\n\nA new DisplayRegion won't render anything until it has been associated with a camera. Each DisplayRegion may have just one camera associated with it (although a particular camera may be associated with more than one DisplayRegion).\n\nA .Camera is a kind of .PandaNode, so you can simply create one and wrap a .NodePath around it:\n\npython\n\ncamNode = Camera('cam')\ncamNP = NodePath(camNode)\nregion.setCamera(camNP)\n\ncpp\n\nPT(Camera) camNode = new Camera(\"cam\");\nNodePath camNP(camNode);\nregion->set_camera(camNP);\n\nOnce you have a Camera, you need to decide where to attach it to the scene graph. If you parent it to base.camera, it will inherit the transform of that node and so it will move with the system trackball controls, if enabled, and will view the scene that base.camera is attached to (usually render). The default Camera that Panda creates is attached to base.camera.\n\npython\n\n# View render, as seen by the default camera\ncamNP.reparentTo(base.camera)\n\ncpp\n\n// View render, as seen by the default camera\ncamNP.reparent_to(windowFramework->get_camera_group());\n\nIf you wish your new Camera to view a completely different scene, you can set up a new scene graph simply by creating a new NodePath to be the root, and then reparent your Camera into that new scene graph. Then, your camera will render whatever models you put into the same scene graph. In this case, since your camera is not a child of base.camera, it will be up to you to position the camera and the models correctly relative to each other.\n\npython\n\n# View some other scene, unrelated to render\nrender2 = NodePath('render2')  # the string parameter is important\ncamNP.reparentTo(render2)\nenv = loader.loadModel('environment.egg')\nenv.reparentTo(render2)\n\ncpp\n\n// View some other scene, unrelated to render\nNodePath render2(\"render2\");  // the string parameter is important\ncamNP.reparent_to(render2);\nNodePath env = windowFramework->load_model(render2, \"environment.egg\");",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/72c18777_display-regions.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/235f12e7_72c18777_display-regions.json",
    "doc_id": "doc_358"
  }
}