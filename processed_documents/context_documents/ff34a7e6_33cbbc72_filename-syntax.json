{
  "content": "Panda Filename Syntax\n\nThe path used in all calls to the Panda3D API must abide by Panda3D's filename conventions. For easier portability, Panda3D uses Unix-style pathnames, even on Microsoft Windows. This means that the directory separator character is always a forward slash, not the Windows backslash character, and there is no leading drive letter prefix. (Instead of a leading drive letter, Panda uses an initial one-letter directory name to represent the drive.)\n\nThere is a fairly straightforward conversion from Windows filenames to panda filenames. Always be sure to use Panda filename syntax when using a Panda3D library function, or one of the panda utility programs:\n\npython\n\n# WRONG:\nloader.loadModel(\"c:\\\\Program Files\\\\My Game\\\\Models\\\\Model1.egg\")\n\n# RIGHT:\nloader.loadModel(\"/c/Program Files/My Game/Models/Model1.egg\")\n\ncpp\n\n# WRONG:\nwindow->load_model(framework.get_models(), \"c:\\\\Program Files\\\\My Game\\\\Models\\\\Model1.egg\");\n\n# RIGHT:\nwindow->load_model(framework.get_models(), \"/c/Program Files/My Game/Models/Model1.egg\");\n\nPanda uses the .Filename class to store Panda-style filenames; many Panda functions expect a Filename object as a parameter. The Filename class also contains several useful methods for path manipulation and file access, as well as for converting between Windows-style filenames and Panda-style filenames; see the .Filename page in the API Reference for a more complete list.\n\nNormally, you can just use forward slashes in your paths and don't need to worry about anything else, since absolute paths should not be used in the program. However, when converting paths from the Python standard library or other libraries, special care is required to ensure that the application will continue to work on Windows correctly.\n\nTo convert a Windows filename to a Panda pathname, use code similar to the following:\n\npython\n\nfrom panda3d.core import Filename\nwinfile = \"c:\\\\MyGame\\\\Model1.egg\"\npandafile = Filename.fromOsSpecific(winfile)\nprint(pandafile)\n\ncpp\n\n#include \"filename.h\"\n\nconst std::string winfile = \"c:\\\\MyGame\\\\Model1.egg\";\nFilename pandafile = Filename::from_os_specific(winfile);\nstd::cout << pandafile.get_fullpath() << \"\\n\";\n\nTo convert a Panda filename into a Windows filename, use code like this:\n\npython\n\nfrom panda3d.core import Filename\npandafile = Filename(\"/c/MyGame/Model1.egg\")\nwinfile = pandafile.toOsSpecific()\nprint(winfile)\n\ncpp\n\n#include \"filename.h\"\n\nFilename pandafile(\"/c/MyGame/Model1.egg\");\nconst std::string winfile = pandafile.to_os_specific();\nstd::cout << winfile << \"\\n\";\n\npython\n\nStarting with Python 3.6, the .Filename class is fully interoperable with the filesystem manipulation functions in the Python standard library. Conversely, pathlib paths will seamlessly work in all Panda3D calls that accept a .Filename object.\n\nLet's say, for instance, that you want to load a model, and the model is in the \"model\" directory that is in the same directory as the program's main file.\n\nHere is how you would load the model:\n\npython\n\nimport sys, os\nimport direct.directbase.DirectStart\nfrom panda3d.core import Filename\n\n# Get the location of the 'py' file I'm running:\nmydir = os.path.dirname(os.path.abspath(__file__))\n\n# Convert that to panda's unix-style notation.\nmydir = Filename.fromOsSpecific(mydir)\n\n# Now load the model:\nmodel = loader.loadModel(mydir / \"models/mymodel.egg\")\n\ncpp\n\n#include \"filename.h\"\n#include \"executionEnvironment.h\"\n\n// Get the location of the executable file I'm running:\nFilename mydir = ExecutionEnvironment::get_binary_name();\nmydir = mydir.get_dirname();\n\n// Now load the model:\nwindow->load_model(framework.get_models(), mydir + \"/models/mymodel.egg\");\n\nYou need to keep in mind that standard library functions provided by the system or the programming language runtime work with OS-specific paths. So do not forget to convert your Panda paths to OS-specific paths when using these built-in functions. In cases where Panda's API offers equivalent functions through the .Filename or .VirtualFileSystem class, however, it is recommended to use those instead, as they will natively understand Panda Filenames.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/33cbbc72_filename-syntax.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/ff34a7e6_33cbbc72_filename-syntax.json",
    "doc_id": "doc_638"
  }
}