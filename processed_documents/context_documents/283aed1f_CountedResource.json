{
  "content": "\nclass CountedResource(object):\n    \"\"\"\n    This class is an attempt to combine the RAIA idiom with reference\n    counting semantics in order to model shared resources. RAIA stands\n    for \"Resource Allocation Is Acquisition\" (see 'Effective C++' for a\n    more in-depth explanation)\n\n    When a resource is needed, create an appropriate CountedResource\n    object.  If the resource is already available (meaning another\n    CountedResource object of the same type already exists), no action\n    is taken.  Otherwise, acquire() is invoked, and the resource is\n    allocated. The resource will remain valid until all matching\n    CountedResource objects have been deleted.  When no objects of\n    a particular CountedResource type exist, the release() function for\n    that type is invoked and the managed resource is cleaned up.\n\n    Usage:\n        Define a subclass of CountedResource that defines the\n        @classmethods acquire() and release().  In these two\n        functions, define your resource allocation and cleanup code.\n\n    IMPORTANT:\n        If you define your own __init__ and __del__ methods, you\n        MUST be sure to call down to the ones defined in\n        CountedResource.\n\n    Notes:\n        Until we figure out a way to wrangle a bit more functionality\n        out of Python, you MUST NOT inherit from any class that has\n        CountedResource as its base class. In debug mode, this will\n        raise a runtime assertion during the invalid class's call to\n        __init__(). If you have more than one resource that you want to\n        manage/access with a single object, you should subclass\n        CountedResource again. See the example code at the bottom of\n        this file to see how to accomplish this (This is useful for\n        dependent resources).\n    \"\"\"\n\n    @classmethod\n    def incrementCounter(cls):\n        try:\n            cls.RESOURCE_COUNTER += 1\n        except AttributeError:\n            cls.RESOURCE_COUNTER = 1\n\n        if cls.RESOURCE_COUNTER == 1:\n            cls.acquire()\n\n    @classmethod\n    def decrementCounter(cls):\n        try:\n            cls.RESOURCE_COUNTER_INIT_FAILED\n            del cls.RESOURCE_COUNTER_INIT_FAILED\n        except AttributeError:\n            cls.RESOURCE_COUNTER -= 1\n            if cls.RESOURCE_COUNTER < 1:\n                cls.release()\n\n    @classmethod\n    def getCount(cls):\n        return cls.RESOURCE_COUNTER\n\n    @classmethod\n    def acquire(cls):\n        pass\n\n    @classmethod\n    def release(cls):\n        pass\n\n    def __init__(self):\n        cls = type(self)\n        cls.RESOURCE_COUNTER_INIT_FAILED = True\n        assert cls.mro()[1] == CountedResource, \\\n               (lambda: \\\n                '%s cannot be subclassed.' \\\n                 % cls.mro()[list(cls.mro()).index(CountedResource) - 1].__name__)()\n        del cls.RESOURCE_COUNTER_INIT_FAILED\n        self.incrementCounter()\n\n    def __del__(self):\n        self.decrementCounter()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/CountedResource.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/283aed1f_CountedResource.json",
    "doc_id": "doc_277"
  }
}