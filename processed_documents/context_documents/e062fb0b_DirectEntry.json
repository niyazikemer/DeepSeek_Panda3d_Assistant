{
  "content": "\"\"\"Contains the DirectEntry class, a type of DirectGUI widget that accepts\ntext entered using the keyboard.\n\nSee the :ref:`directentry` page in the programming manual for a more in-depth\nexplanation and an example of how to use this class.\n\"\"\"\n\n__all__ = ['DirectEntry']\n\nfrom panda3d.core import ConfigVariableBool, PGEntry, Point3, TextNode, Vec3\nfrom direct.showbase import ShowBaseGlobal\nfrom . import DirectGuiGlobals as DGG\nfrom .DirectFrame import DirectFrame\nfrom .OnscreenText import OnscreenText\n# import this to make sure it gets pulled into the publish\nimport encodings.utf_8 # pylint: disable=unused-import\nfrom direct.showbase.DirectObject import DirectObject\n\n# DirectEntry States:\nENTRY_FOCUS_STATE    = PGEntry.SFocus      # 0\nENTRY_NO_FOCUS_STATE = PGEntry.SNoFocus    # 1\nENTRY_INACTIVE_STATE = PGEntry.SInactive   # 2\n\n\nclass DirectEntry(DirectFrame):\n    \"\"\"\n    DirectEntry(parent) - Create a DirectGuiWidget which responds\n    to keyboard buttons\n    \"\"\"\n\n    directWtext = ConfigVariableBool('direct-wtext', True)\n\n    AllowCapNamePrefixes = (\"Al\", \"Ap\", \"Ben\", \"De\", \"Del\", \"Della\", \"Delle\", \"Der\", \"Di\", \"Du\",\n                            \"El\", \"Fitz\", \"La\", \"Las\", \"Le\", \"Les\", \"Lo\", \"Los\",\n                            \"Mac\", \"St\", \"Te\", \"Ten\", \"Van\", \"Von\", )\n    ForceCapNamePrefixes = (\"D'\", \"DeLa\", \"Dell'\", \"L'\", \"M'\", \"Mc\", \"O'\", )\n\n    def __init__(self, parent = None, **kw):\n        # Inherits from DirectFrame\n        # A Direct Frame can have:\n        # - A background texture (pass in path to image, or Texture Card)\n        # - A midground geometry item (pass in geometry)\n        # - A foreground text Node (pass in text string or Onscreen Text)\n        # For a direct entry:\n        # Each button has 3 states (focus, noFocus, disabled)\n        # The same image/geom/text can be used for all three states or each\n        # state can have a different text/geom/image\n        # State transitions happen automatically based upon mouse interaction\n        optiondefs = (\n            # Define type of DirectGuiWidget\n            ('pgFunc',          PGEntry,          None),\n            ('numStates',       3,                None),\n            ('state',           DGG.NORMAL,       None),\n            ('entryFont',       None,             DGG.INITOPT),\n            ('width',           10,               self.updateWidth),\n            ('numLines',        1,                self.updateNumLines),\n            ('focus',           0,                self.setFocus),\n            ('cursorKeys',      1,                self.setCursorKeysActive),\n            ('obscured',        0,                self.setObscureMode),\n            # Setting backgroundFocus allows the entry box to get keyboard\n            # events that are not handled by other things (i.e. events that\n            # fall through to the background):\n            ('backgroundFocus', 0,                self.setBackgroundFocus),\n            # Text used for the PGEntry text node\n            # NOTE: This overrides the DirectFrame text option\n            ('initialText',     '',               DGG.INITOPT),\n            # Enable or disable text overflow scrolling\n            ('overflow',        0,                self.setOverflowMode),\n            # Command to be called on hitting Enter\n            ('command',        None,              None),\n            ('extraArgs',      [],                None),\n            # Command to be called when enter is hit but we fail to submit\n            ('failedCommand',  None,              None),\n            ('failedExtraArgs',[],                None),\n            # commands to be called when focus is gained or lost\n            ('focusInCommand', None,              None),\n            ('focusInExtraArgs', [],              None),\n            ('focusOutCommand', None,             None),\n            ('focusOutExtraArgs', [],             None),\n            # Sounds to be used for button events\n            ('rolloverSound',   DGG.getDefaultRolloverSound(), self.setRolloverSound),\n            ('clickSound',      DGG.getDefaultClickSound(),    self.setClickSound),\n            ('autoCapitalize',  0,                self.autoCapitalizeFunc),\n            ('autoCapitalizeAllowPrefixes', DirectEntry.AllowCapNamePrefixes, None),\n            ('autoCapitalizeForcePrefixes', DirectEntry.ForceCapNamePrefixes, None),\n        )\n        # Merge keyword options with default options\n        self.defineoptions(kw, optiondefs)\n\n        # Initialize superclasses\n        DirectFrame.__init__(self, parent)\n\n        if self['entryFont'] is None:\n            font = DGG.getDefaultFont()\n        else:\n            font = self['entryFont']\n\n        # Create Text Node Component\n        self.onscreenText = self.createcomponent(\n            'text', (), None,\n            OnscreenText,\n            (), parent = ShowBaseGlobal.hidden,\n            # Pass in empty text to avoid extra work, since its really\n            # The PGEntry which will use the TextNode to generate geometry\n            text = '',\n            align = TextNode.ALeft,\n            font = font,\n            scale = 1,\n            # Don't get rid of the text node\n            mayChange = 1)\n\n        # We can get rid of the node path since we're just using the\n        # onscreenText as an easy way to access a text node as a\n        # component\n        self.onscreenText.removeNode()\n\n        # Bind command function\n        self.bind(DGG.ACCEPT, self.commandFunc)\n        self.bind(DGG.ACCEPTFAILED, self.failedCommandFunc)\n\n        self.accept(self.guiItem.getFocusInEvent(), self.focusInCommandFunc)\n        self.accept(self.guiItem.getFocusOutEvent(), self.focusOutCommandFunc)\n\n        # listen for auto-capitalize events on a separate object to prevent\n        # clashing with other parts of the system\n        self._autoCapListener = DirectObject()\n\n        # Call option initialization functions\n        self.initialiseoptions(DirectEntry)\n\n        if not hasattr(self, 'autoCapitalizeAllowPrefixes'):\n            self.autoCapitalizeAllowPrefixes = DirectEntry.AllowCapNamePrefixes\n        if not hasattr(self, 'autoCapitalizeForcePrefixes'):\n            self.autoCapitalizeForcePrefixes = DirectEntry.ForceCapNamePrefixes\n\n        # Update TextNodes for each state\n        for i in range(self['numStates']):\n            self.guiItem.setTextDef(i, self.onscreenText.textNode)\n\n        # Now we should call setup() again to make sure it has the\n        # right font def.\n        self.setup()\n\n        # Update initial text\n        self.unicodeText = 0\n        if self['initialText']:\n            self.enterText(self['initialText'])\n\n    def destroy(self):\n        self.ignoreAll()\n        self._autoCapListener.ignoreAll()\n        DirectFrame.destroy(self)\n\n    def setup(self):\n        self.guiItem.setupMinimal(self['width'], self['numLines'])\n\n    def updateWidth(self):\n        self.guiItem.setMaxWidth(self['width'])\n\n    def updateNumLines(self):\n        self.guiItem.setNumLines(self['numLines'])\n\n    def setFocus(self):\n        PGEntry.setFocus(self.guiItem, self['focus'])\n\n    def setCursorKeysActive(self):\n        PGEntry.setCursorKeysActive(self.guiItem, self['cursorKeys'])\n\n    def setOverflowMode(self):\n        PGEntry.set_overflow_mode(self.guiItem, self['overflow'])\n\n    def setObscureMode(self):\n        PGEntry.setObscureMode(self.guiItem, self['obscured'])\n\n    def setBackgroundFocus(self):\n        PGEntry.setBackgroundFocus(self.guiItem, self['backgroundFocus'])\n\n    def setRolloverSound(self):\n        rolloverSound = self['rolloverSound']\n        if rolloverSound:\n            self.guiItem.setSound(DGG.ENTER + self.guiId, rolloverSound)\n        else:\n            self.guiItem.clearSound(DGG.ENTER + self.guiId)\n\n    def setClickSound(self):\n        clickSound = self['clickSound']\n        if clickSound:\n            self.guiItem.setSound(DGG.ACCEPT + self.guiId, clickSound)\n        else:\n            self.guiItem.clearSound(DGG.ACCEPT + self.guiId)\n\n    def commandFunc(self, event):\n        if self['command']:\n            # Pass any extra args to command\n            self['command'](*[self.get()] + self['extraArgs'])\n\n    def failedCommandFunc(self, event):\n        if self['failedCommand']:\n            # Pass any extra args\n            self['failedCommand'](*[self.get()] + self['failedExtraArgs'])\n\n    def autoCapitalizeFunc(self):\n        if self['autoCapitalize']:\n            self._autoCapListener.accept(self.guiItem.getTypeEvent(), self._handleTyping)\n            self._autoCapListener.accept(self.guiItem.getEraseEvent(), self._handleErasing)\n        else:\n            self._autoCapListener.ignore(self.guiItem.getTypeEvent())\n            self._autoCapListener.ignore(self.guiItem.getEraseEvent())\n\n    def focusInCommandFunc(self):\n        if self['focusInCommand']:\n            self['focusInCommand'](*self['focusInExtraArgs'])\n        if self['autoCapitalize']:\n            self.accept(self.guiItem.getTypeEvent(), self._handleTyping)\n            self.accept(self.guiItem.getEraseEvent(), self._handleErasing)\n\n    def _handleTyping(self, guiEvent):\n        self._autoCapitalize()\n\n    def _handleErasing(self, guiEvent):\n        self._autoCapitalize()\n\n    def _autoCapitalize(self):\n        name = self.guiItem.getWtext()\n        # capitalize each word, allowing for things like McMutton\n        capName = ''\n        # track each individual word to detect prefixes like Mc\n        wordSoFar = ''\n        # track whether the previous character was part of a word or not\n        wasNonWordChar = True\n        for i, character in enumerate(name):\n            # test to see if we are between words\n            # - Count characters that can't be capitalized as a break between words\n            #   This assumes that string.lower and string.upper will return different\n            #   values for all unicode letters.\n            # - Don't count apostrophes as a break between words\n            if character.lower() == character.upper() and character != \"'\":\n                # we are between words\n                wordSoFar = ''\n                wasNonWordChar = True\n            else:\n                capitalize = False\n                if wasNonWordChar:\n                    # first letter of a word, capitalize it unconditionally;\n                    capitalize = True\n                elif character == character.upper() and \\\n                     len(self.autoCapitalizeAllowPrefixes) > 0 and \\\n                     wordSoFar in self.autoCapitalizeAllowPrefixes:\n                    # first letter after one of the prefixes, allow it to be capitalized\n                    capitalize = True\n                elif len(self.autoCapitalizeForcePrefixes) > 0 and \\\n                     wordSoFar in self.autoCapitalizeForcePrefixes:\n                    # first letter after one of the force prefixes, force it to be capitalized\n                    capitalize = True\n                if capitalize:\n                    # allow this letter to remain capitalized\n                    character = character.upper()\n                else:\n                    character = character.lower()\n                wordSoFar += character\n                wasNonWordChar = False\n            capName += character\n        self.guiItem.setWtext(capName)\n        self.guiItem.setCursorPosition(self.guiItem.getNumCharacters())\n\n    def focusOutCommandFunc(self):\n        if self['focusOutCommand']:\n            self['focusOutCommand'](*self['focusOutExtraArgs'])\n        if self['autoCapitalize']:\n            self.ignore(self.guiItem.getTypeEvent())\n            self.ignore(self.guiItem.getEraseEvent())\n\n    def set(self, text):\n        \"\"\" Changes the text currently showing in the typable region;\n        does not change the current cursor position.  Also see\n        enterText(). \"\"\"\n\n        assert not isinstance(text, bytes)\n        self.unicodeText = True\n        self.guiItem.setWtext(text)\n\n    def get(self, plain = False):\n        \"\"\" Returns the text currently showing in the typable region.\n        If plain is True, the returned text will not include any\n        formatting characters like nested color-change codes. \"\"\"\n\n        wantWide = self.unicodeText or self.guiItem.isWtext()\n        if not self.directWtext.getValue():\n            # If the user has configured wide-text off, then always\n            # return an 8-bit string.  This will be encoded if\n            # necessary, according to Panda's default encoding.\n            wantWide = False\n\n        if plain:\n            if wantWide:\n                return self.guiItem.getPlainWtext()\n            else:\n                return self.guiItem.getPlainText()\n        else:\n            if wantWide:\n                return self.guiItem.getWtext()\n            else:\n                return self.guiItem.getText()\n\n    def getCursorPosition(self):\n        return self.guiItem.getCursorPosition()\n\n    def setCursorPosition(self, pos):\n        if pos < 0:\n            self.guiItem.setCursorPosition(self.guiItem.getNumCharacters() + pos)\n        else:\n            self.guiItem.setCursorPosition(pos)\n\n    def getNumCharacters(self):\n        return self.guiItem.getNumCharacters()\n\n    def enterText(self, text):\n        \"\"\" sets the entry's text, and moves the cursor to the end \"\"\"\n        self.set(text)\n        self.setCursorPosition(self.guiItem.getNumCharacters())\n\n    def getFont(self):\n        return self.onscreenText.getFont()\n\n    def getBounds(self, state = 0):\n        # Compute the width and height for the entry itself, ignoring\n        # geometry etc.\n        tn = self.onscreenText.textNode\n        mat = tn.getTransform()\n        align = tn.getAlign()\n        lineHeight = tn.getLineHeight()\n        numLines = self['numLines']\n        width = self['width']\n\n        if align == TextNode.ALeft:\n            left = 0.0\n            right = width\n        elif align == TextNode.ACenter:\n            left = -width / 2.0\n            right = width / 2.0\n        elif align == TextNode.ARight:\n            left = -width\n            right = 0.0\n\n        bottom = -0.3 * lineHeight - (lineHeight * (numLines - 1))\n        top = lineHeight\n\n        self.ll.set(left, 0.0, bottom)\n        self.ur.set(right, 0.0, top)\n        self.ll = mat.xformPoint(Point3.rfu(left, 0.0, bottom))\n        self.ur = mat.xformPoint(Point3.rfu(right, 0.0, top))\n\n        vec_right = Vec3.right()\n        vec_up = Vec3.up()\n        left = (vec_right[0] * self.ll[0]\n              + vec_right[1] * self.ll[1]\n              + vec_right[2] * self.ll[2])\n        right = (vec_right[0] * self.ur[0]\n               + vec_right[1] * self.ur[1]\n               + vec_right[2] * self.ur[2])\n        bottom = (vec_up[0] * self.ll[0]\n                + vec_up[1] * self.ll[1]\n                + vec_up[2] * self.ll[2])\n        top = (vec_up[0] * self.ur[0]\n             + vec_up[1] * self.ur[1]\n             + vec_up[2] * self.ur[2])\n        self.ll = Point3(left, 0.0, bottom)\n        self.ur = Point3(right, 0.0, top)\n\n        # Scale bounds to give a pad around graphics.  We also want to\n        # scale around the border width.\n        pad = self['pad']\n        borderWidth = self['borderWidth']\n        self.bounds = [self.ll[0] - pad[0] - borderWidth[0],\n                       self.ur[0] + pad[0] + borderWidth[0],\n                       self.ll[2] - pad[1] - borderWidth[1],\n                       self.ur[2] + pad[1] + borderWidth[1]]\n        return self.bounds\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/gui/DirectEntry.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/e062fb0b_DirectEntry.json",
    "doc_id": "doc_84"
  }
}