{
  "content": "\"\"\"Contains the FourStateAI class.  See also :mod:`.FourState`.\"\"\"\n\n__all__ = ['FourStateAI']\n\nfrom direct.directnotify import DirectNotifyGlobal\n#import DistributedObjectAI\nfrom . import ClassicFSM\nfrom . import State\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\n\n\nclass FourStateAI:\n    \"\"\"\n    Generic four state ClassicFSM base class.\n\n    This is a mix-in class that expects that your derived class\n    is a DistributedObjectAI.\n\n    Inherit from FourStateFSM and pass in your states.  Two of\n    the states should be oposites of each other and the other\n    two should be the transition states between the first two.\n    E.g::\n\n                    +--------+\n                 -->| closed | --\n                |   +--------+   |\n                |                |\n                |                v\n          +---------+       +---------+\n          | closing |<----->| opening |\n          +---------+       +---------+\n                ^                |\n                |                |\n                |    +------+    |\n                 ----| open |<---\n                     +------+\n\n    There is a fifth off state, but that is an implementation\n    detail (and that's why it's not called a five state ClassicFSM).\n\n    I found that this pattern repeated in several things I was\n    working on, so this base class was created.\n    \"\"\"\n    notify = DirectNotifyGlobal.directNotify.newCategory('FourStateAI')\n\n    def __init__(self, names, durations = [0, 1, None, 1, 1]):\n        \"\"\"\n        Names is a list of state names.  Some examples are::\n\n            ['off', 'opening', 'open', 'closing', 'closed',]\n\n            ['off', 'locking', 'locked', 'unlocking', 'unlocked',]\n\n            ['off', 'deactivating', 'deactive', 'activating', 'activated',]\n\n        durations is a list of durations in seconds or None values.\n        The list of duration values should be the same length\n        as the list of state names and the lists correspond.\n        For each state, after n seconds, the ClassicFSM will move to\n        the next state.  That does not happen for any duration\n        values of None.\n\n        .. rubric:: More Details\n\n        Here is a diagram showing the where the names from the list\n        are used::\n\n            +---------+\n            | 0 (off) |----> (any other state and vice versa).\n            +---------+\n\n                       +--------+\n                    -->| 4 (on) |---\n                   |   +--------+   |\n                   |                |\n                   |                v\n             +---------+       +---------+\n             | 3 (off) |<----->| 1 (off) |\n             +---------+       +---------+\n                   ^                |\n                   |                |\n                   |  +---------+   |\n                    --| 2 (off) |<--\n                      +---------+\n\n        Each states also has an associated on or off value.  The only\n        state that is 'on' is state 4.  So, the transition states\n        between off and on (states 1 and 3) are also considered\n        off (and so is state 2 which is oposite of state 4 and therefore\n        oposite of 'on').\n        \"\"\"\n        self.stateIndex = 0\n        assert self.__debugPrint(\n                \"FourStateAI(names=%s, durations=%s)\"\n                %(names, durations))\n        self.doLaterTask = None\n        assert len(names) == 5\n        assert len(names) == len(durations)\n        self.names = names\n        self.durations = durations\n        self.states = {\n            0: State.State(names[0],\n                           self.enterState0,\n                           self.exitState0,\n                           [names[1],\n                           names[2],\n                           names[3],\n                           names[4]]),\n            1: State.State(names[1],\n                           self.enterState1,\n                           self.exitState1,\n                           [names[2], names[3]]),\n            2: State.State(names[2],\n                           self.enterState2,\n                           self.exitState2,\n                           [names[3]]),\n            3: State.State(names[3],\n                           self.enterState3,\n                           self.exitState3,\n                           [names[4], names[1]]),\n            4: State.State(names[4],\n                           self.enterState4,\n                           self.exitState4,\n                           [names[1]]),\n        }\n        self.fsm = ClassicFSM.ClassicFSM('FourState',\n                           list(self.states.values()),\n                           # Initial State\n                           names[0],\n                           # Final State\n                           names[0],\n                          )\n        self.fsm.enterInitialState()\n\n    def delete(self):\n        assert self.__debugPrint(\"delete()\")\n        if self.doLaterTask is not None:\n            self.doLaterTask.remove()\n            del self.doLaterTask\n        del self.states\n        del self.fsm\n\n    def getState(self):\n        assert self.__debugPrint(\"getState() returning %s\"%(self.stateIndex,))\n        return [self.stateIndex]\n\n    def sendUpdate(self, fieldName, args = [], sendToId = None):\n        raise NotImplementedError\n\n    def sendState(self):\n        assert self.__debugPrint(\"sendState()\")\n        self.sendUpdate('setState', self.getState())\n\n    def setIsOn(self, isOn):\n        assert self.__debugPrint(\"setIsOn(isOn=%s)\"%(isOn,))\n        if isOn:\n            if self.stateIndex != 4:\n                # ...if it's not On; request turning on:\n                self.fsm.request(self.states[3])\n        else:\n            if self.stateIndex != 2:\n                # ...if it's not Off; request turning off:\n                self.fsm.request(self.states[1])\n        #if isOn:\n        #    nextState = (4, 3, 3, 4, None)[self.stateIndex]\n        #else:\n        #    nextState = (2, 2, None, 1, 1)[self.stateIndex]\n        #if nextState is not None:\n        #    self.fsm.request(self.states[nextState])\n\n    def isOn(self):\n        assert self.__debugPrint(\"isOn() returning %s (stateIndex=%s)\"%(self.stateIndex==4, self.stateIndex))\n        return self.stateIndex==4\n\n    def changedOnState(self, isOn):\n        \"\"\"\n        Allow derived classes to overide this.\n        The self.isOn value has toggled.  Call getIsOn() to\n        get the current state.\n        \"\"\"\n        assert self.__debugPrint(\"changedOnState(isOn=%s)\"%(isOn,))\n\n    ##### states #####\n\n    def switchToNextStateTask(self, task):\n        assert self.__debugPrint(\"switchToNextStateTask()\")\n        self.fsm.request(self.states[self.nextStateIndex])\n        return Task.done\n\n    def distributeStateChange(self):\n        \"\"\"\n        This function is intentionaly simple so that derived classes\n        may easily alter the network message.\n        \"\"\"\n        assert self.__debugPrint(\"distributeStateChange()\")\n        self.sendState()\n\n    def enterStateN(self, stateIndex, nextStateIndex):\n        assert self.__debugPrint(\n            \"enterStateN(stateIndex=%s, nextStateIndex=%s)\"%\n            (stateIndex, nextStateIndex))\n        self.stateIndex = stateIndex\n        self.nextStateIndex = nextStateIndex\n        self.distributeStateChange()\n        if self.durations[stateIndex] is not None:\n            assert self.doLaterTask is None\n            self.doLaterTask=taskMgr.doMethodLater(\n                self.durations[stateIndex],\n                self.switchToNextStateTask,\n                \"enterStateN-timer-%s\"%id(self))\n\n    def exitStateN(self):\n        assert self.__debugPrint(\"exitStateN()\")\n        if self.doLaterTask:\n            taskMgr.remove(self.doLaterTask)\n            self.doLaterTask=None\n\n    ##### state 0 #####\n\n    def enterState0(self):\n        assert self.__debugPrint(\"enter0()\")\n        self.enterStateN(0, 0)\n\n    def exitState0(self):\n        assert self.__debugPrint(\"exit0()\")\n\n    ##### state 1 #####\n\n    def enterState1(self):\n        #assert self.__debugPrint(\"enterState1()\")\n        self.enterStateN(1, 2)\n\n    def exitState1(self):\n        assert self.__debugPrint(\"exitState1()\")\n        self.exitStateN()\n\n    ##### state 2 #####\n\n    def enterState2(self):\n        #assert self.__debugPrint(\"enterState2()\")\n        self.enterStateN(2, 3)\n\n    def exitState2(self):\n        assert self.__debugPrint(\"exitState2()\")\n        self.exitStateN()\n\n    ##### state 3 #####\n\n    def enterState3(self):\n        #assert self.__debugPrint(\"enterState3()\")\n        self.enterStateN(3, 4)\n\n    def exitState3(self):\n        assert self.__debugPrint(\"exitState3()\")\n        self.exitStateN()\n\n    ##### state 4 #####\n\n    def enterState4(self):\n        assert self.__debugPrint(\"enterState4()\")\n        self.enterStateN(4, 1)\n        self.changedOnState(1)\n\n    def exitState4(self):\n        assert self.__debugPrint(\"exitState4()\")\n        self.exitStateN()\n        self.changedOnState(0)\n\n    if __debug__:\n        def __debugPrint(self, message):\n            \"\"\"for debugging\"\"\"\n            return self.notify.debug(\"%d (%d) %s\"%(\n                    id(self), self.stateIndex==4, message))\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/fsm/FourStateAI.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/ee9f969a_FourStateAI.json",
    "doc_id": "doc_148"
  }
}