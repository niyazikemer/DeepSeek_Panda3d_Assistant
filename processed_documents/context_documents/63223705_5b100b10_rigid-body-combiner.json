{
  "content": "The Rigid Body Combiner\n\nWhen you are developing a complex game, you will most likely run into the problem that you will have too many meshes <too-many-meshes> in your scene. Panda3D's flattening methods can help you reducing the number of nodes, but often when you have hundreds of moving bodies this is not always an option. Therefore, Panda3D has a feature to help you reduce the number of nodes, even if they are moving: the .RigidBodyCombiner.\n\nThe RigidBodyCombiner is designed to reduce the number of nodes actually sent to the graphics card, just like the flattening functions. But instead of flattening everything into one node immediately, the RigidBodyCombiner keeps your original node structure intact, still allowing you to apply transforms (e.g. moving around, rotating or scaling) sub-nodes. But what's actually sent to the graphics cards is just one node, a combined version of all these sub-nodes. If you want to see the combined version of these nodes (not likely), you can call ~.RigidBodyCombiner.get_internal_scene(), this function will return the NodePath that is actually sent to the graphics card.\n\nThe RigidBodyCombiner class is just another kind of .PandaNode. All of the standard node interfaces apply. Thus, the easiest way to add nodes to a RigidBodyCombiner is to wrap a .NodePath around it, and then use the standard ~.NodePath.reparent_to() interfaces to parent the nodes you want to combine to this NodePath.\n\nWhen you are done with reparenting the nodes, you need to call ~.RigidBodyCombiner.collect() on the original .RigidBodyCombiner instance. This is a fairly expensive call and you should normally only call this once -- but after you called ~.RigidBodyCombiner.collect() you may freely transform all nodes below without having to call this again. If you later add more children to the RBC, though, you will need to call ~.RigidBodyCombiner.collect() again.\n\nThe vertices of the objects you attach to the RigidBodyCombiner must be transformed each frame on the CPU. For this reason, you may find a performance advantage in limiting the number of vertices in the models you use. Also, be sure you do not have normals on your models unless you are actually using lighting.\n\npython\n\nHere is a small example showing a random cloud of boxes:\n\nfrom direct.directbase.DirectStart import *\nfrom panda3d.core import RigidBodyCombiner, NodePath, Vec3\nimport random\n\nrbc = RigidBodyCombiner(\"rbc\")\nrbcnp = NodePath(rbc)\nrbcnp.reparentTo(render)\n\nfor i in range(200):\n    pos = Vec3(random.uniform(-100, 100),\n               random.uniform(-100, 100),\n               random.uniform(-100, 100))\n\n    f = loader.loadModel(\"box.egg\")\n    f.setPos(pos)\n    f.reparentTo(rbcnp)\n\nrbc.collect()\nbase.run()\n\nNote\n\nRenderEffects <render-effects> such as Billboards <billboard-effects> are not supported below this node.\n\nFor more information and a complete list of RigidBodyCombiner methods please see the ~panda3d.core.RigidBodyCombiner page in the API Reference.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/5b100b10_rigid-body-combiner.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/63223705_5b100b10_rigid-body-combiner.json",
    "doc_id": "doc_454"
  }
}