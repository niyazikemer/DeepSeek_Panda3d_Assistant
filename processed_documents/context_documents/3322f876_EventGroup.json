{
  "content": "\"\"\"This module defines the EventGroup class.\"\"\"\n\n__all__ = ['EventGroup']\n\nfrom direct.showbase import DirectObject\nfrom direct.showbase.PythonUtil import SerialNumGen, Functor\nfrom direct.showbase.MessengerGlobal import messenger\n\n\nclass EventGroup(DirectObject.DirectObject):\n    \"\"\"This class allows you to group together multiple events and treat\n    them as a single event. The EventGroup will not send out its event until\n    all of its sub-events have occured.\"\"\"\n\n    _SerialNumGen = SerialNumGen()\n\n    def __init__(self, name, subEvents=None, doneEvent=None):\n        \"\"\"\n        Provide a meaningful name to aid debugging.\n\n        doneEvent is optional. If not provided, a unique done event will be\n        generated and is available as EventGroup.getDoneEvent().\n\n        Examples:\n\n        # waits for gotRed and gotBlue, then sends out 'gotColors'\n        EventGroup('getRedAndBlue', ('gotRed', 'gotBlue'), doneEvent='gotColors')\n\n        # waits for two interests to close, then calls self._handleBothInterestsClosed()\n        # uses EventGroup.getDoneEvent() and EventGroup.newEvent() to generate unique,\n        # disposable event names\n        eGroup = EventGroup('closeInterests')\n        self.acceptOnce(eGroup.getDoneEvent(), self._handleBothInterestsClosed)\n        base.cr.closeInterest(interest1, event=eGroup.newEvent('closeInterest1'))\n        base.cr.closeInterest(interest2, event=eGroup.newEvent('closeInterest2'))\n        \"\"\"\n        self._name = name\n        self._subEvents = set()\n        self._completedEvents = set()\n        if doneEvent is None:\n            # no doneEvent provided, allocate a unique event name\n            doneEvent = 'EventGroup-%s-%s-Done' % (\n                EventGroup._SerialNumGen.next(), self._name)\n        self._doneEvent = doneEvent\n        self._completed = False\n\n        if subEvents is not None:\n            # add the events that were passed in to start with, more may be added\n            # later via newEvent()\n            for event in subEvents:\n                self.addEvent(event)\n\n    def destroy(self):\n        if hasattr(self, '_name'):\n            # keep this around\n            #del self._doneEvent\n            del self._name\n            del self._subEvents\n            del self._completedEvents\n            self.ignoreAll()\n\n    def getName(self):\n        return self._name\n\n    def getDoneEvent(self):\n        return self._doneEvent\n\n    def isCompleted(self):\n        return self._completed\n\n    def addEvent(self, eventName):\n        \"\"\" Adds a new event to the list of sub-events that we're waiting on.\n        Returns the name of the event. \"\"\"\n        if self._completed:\n            self.notify.error('addEvent(\\'%s\\') called on completed EventGroup \\'%s\\'' % (\n                eventName, self.getName()))\n        if eventName in self._subEvents:\n            self.notify.error('addEvent(\\'%s\\'): event already in EventGroup \\'%s\\'' % (\n                eventName, self.getName()))\n        self._subEvents.add(eventName)\n        self.acceptOnce(eventName, Functor(self._subEventComplete, eventName))\n        return eventName\n\n    def newEvent(self, name):\n        \"\"\" Pass in an event name and it will be unique-ified for you and added\n        to this EventGroup. TIP: there's no need to repeat information in this event\n        name that is already in the name of the EventGroup object.\n        Returns the new event name. \"\"\"\n        return self.addEvent('%s-SubEvent-%s-%s' % (\n            self._name, EventGroup._SerialNumGen.next(), name))\n\n    def _subEventComplete(self, subEventName, *args, **kwArgs):\n        if subEventName in self._completedEvents:\n            self.notify.warning('_subEventComplete: \\'%s\\' already received' %\n                                subEventName)\n        else:\n            self._completedEvents.add(subEventName)\n            if self._completedEvents == self._subEvents:\n                self._signalComplete()\n\n    def _signalComplete(self):\n        self._completed = True\n        messenger.send(self._doneEvent)\n        self.destroy()\n\n    def __repr__(self):\n        return '%s(\\'%s\\', %s, doneEvent=\\'%s\\') # completed=%s' % (\n            self.__class__.__name__,\n            self._name,\n            tuple(self._subEvents),\n            self._doneEvent,\n            tuple(self._completedEvents))\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/EventGroup.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/3322f876_EventGroup.json",
    "doc_id": "doc_253"
  }
}