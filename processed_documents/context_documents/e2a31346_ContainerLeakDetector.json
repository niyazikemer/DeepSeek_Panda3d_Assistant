{
  "content": "from __future__ import annotations\n\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nimport direct.showbase.DConfig as config\nfrom direct.showbase.PythonUtil import makeFlywheelGen, flywheel\nfrom direct.showbase.PythonUtil import itype, serialNum, safeRepr, fastRepr\nfrom direct.showbase.PythonUtil import getBase, uniqueName, ScratchPad, nullGen\nfrom direct.showbase.Job import Job\nfrom direct.showbase.JobManagerGlobal import jobMgr\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.task.TaskManagerGlobal import taskMgr\nimport types\nimport weakref\nimport random\nimport builtins\n\n\ndeadEndTypes = frozenset((\n    types.BuiltinFunctionType, types.BuiltinMethodType,\n    types.CodeType, types.FunctionType,\n    types.GeneratorType, types.CoroutineType,\n    types.AsyncGeneratorType,\n    bool, complex, float, int, type,\n    bytes, str, list, tuple,\n    type(None), type(NotImplemented)\n))\n\n\ndef _createContainerLeak():\n    def leakContainer(task=None):\n        base = getBase()\n        if not hasattr(base, 'leakContainer'):\n            base.leakContainer = {}\n        # use tuples as keys since they can't be weakref'd, and use an instance\n        # since it can't be repr/eval'd\n        # that will force the leak detector to hold a normal 'non-weak' reference\n\n        class LeakKey:\n            pass\n        base.leakContainer[(LeakKey(),)] = {}\n        # test the non-weakref object reference handling\n        if random.random() < .01:\n            key = random.choice(list(base.leakContainer.keys()))\n            ContainerLeakDetector.notify.debug(\n                'removing reference to leakContainer key %s so it will be garbage-collected' % safeRepr(key))\n            del base.leakContainer[key]\n        taskMgr.doMethodLater(10, leakContainer, 'leakContainer-%s' % serialNum())\n        if task:\n            return task.done\n    leakContainer()\n\n\ndef _createTaskLeak():\n    leakTaskName = uniqueName('leakedTask')\n    leakDoLaterName = uniqueName('leakedDoLater')\n\n    def nullTask(task=None):\n        return task.cont\n\n    def nullDoLater(task=None):\n        return task.done\n\n    def leakTask(task=None, leakTaskName=leakTaskName):\n        base = getBase()\n        taskMgr.add(nullTask, uniqueName(leakTaskName))\n        taskMgr.doMethodLater(1 << 31, nullDoLater, uniqueName(leakDoLaterName))\n        taskMgr.doMethodLater(10, leakTask, 'doLeakTask-%s' % serialNum())\n        if task:\n            return task.done\n    leakTask()\n\n\nclass NoDictKey:\n    pass\n\n\nclass Indirection:\n    \"\"\"\n    Represents the indirection that brings you from a container to an element of the container.\n    Stored as a string to be used as part of an eval, or as a key to be looked up in a dict.\n    Each dictionary dereference is individually eval'd since the dict key might have been\n    garbage-collected\n    TODO: store string components that are duplicates of strings in the actual system so that\n    Python will keep one copy and reduce memory usage\n    \"\"\"\n\n    def __init__(self, evalStr=None, dictKey=NoDictKey):\n        # if this is a dictionary lookup, pass dictKey instead of evalStr\n        self.evalStr = evalStr\n        self.dictKey = NoDictKey\n        # is the dictKey a weak reference?\n        self._isWeakRef = False\n        self._refCount = 0\n        if dictKey is not NoDictKey:\n            # if we can repr/eval the key, store it as an evalStr\n            keyRepr = safeRepr(dictKey)\n            useEval = False\n            try:\n                keyEval = eval(keyRepr)\n                useEval = True\n            except Exception:\n                pass\n            if useEval:\n                # check to make sure the eval succeeded\n                if hash(keyEval) != hash(dictKey):\n                    useEval = False\n            if useEval:\n                # eval/repr succeeded, store as an evalStr\n                self.evalStr = '[%s]' % keyRepr\n            else:\n                try:\n                    # store a weakref to the key\n                    self.dictKey = weakref.ref(dictKey)\n                    self._isWeakRef = True\n                except TypeError as e:\n                    ContainerLeakDetector.notify.debug('could not weakref dict key %s' % keyRepr)\n                    self.dictKey = dictKey\n                    self._isWeakRef = False\n\n    def destroy(self):\n        # re-entrant\n        self.dictKey = NoDictKey\n\n    def acquire(self):\n        self._refCount += 1\n\n    def release(self):\n        self._refCount -= 1\n        if self._refCount == 0:\n            self.destroy()\n\n    def isDictKey(self):\n        # is this an indirection through a dictionary?\n        return self.dictKey is not NoDictKey\n\n    def _getNonWeakDictKey(self):\n        if not self._isWeakRef:\n            return self.dictKey\n        else:\n            key = self.dictKey()\n            if key is None:\n                return '<garbage-collected dict key>'\n            return key\n\n    def dereferenceDictKey(self, parentDict):\n        # look ourselves up in parentDict\n        key = self._getNonWeakDictKey()\n        # objects in builtins will have parentDict==None\n        if parentDict is None:\n            return key\n        return parentDict[key]\n\n    def getString(self, prevIndirection=None, nextIndirection=None):\n        # return our contribution to the full name of an object\n        instanceDictStr = '.__dict__'\n        if self.evalStr is not None:\n            # if we're an instance dict, skip over this one (obj.__dict__[keyName] == obj.keyName)\n            if nextIndirection is not None and self.evalStr[-len(instanceDictStr):] == instanceDictStr:\n                return self.evalStr[:-len(instanceDictStr)]\n            # if the previous indirection was an instance dict, change our syntax from ['key'] to .key\n            if prevIndirection is not None and prevIndirection.evalStr is not None:\n                if prevIndirection.evalStr[-len(instanceDictStr):] == instanceDictStr:\n                    return '.%s' % self.evalStr[2:-2]\n            return self.evalStr\n\n        # we're stored as a dict key\n        keyRepr = safeRepr(self._getNonWeakDictKey())\n        # if the previous indirection was an instance dict, change our syntax from ['key'] to .key\n        if prevIndirection is not None and prevIndirection.evalStr is not None:\n            if prevIndirection.evalStr[-len(instanceDictStr):] == instanceDictStr:\n                return '.%s' % keyRepr\n        return '[%s]' % keyRepr\n\n    def __repr__(self):\n        return self.getString()\n\n\nclass ObjectRef:\n    \"\"\"\n    stores a reference to a container in a way that does not prevent garbage\n    collection of the container if possible\n    stored as a series of 'indirections' (obj.foo -> '.foo', dict[key] -> '[key]', etc.)\n    \"\"\"\n    notify = directNotify.newCategory(\"ObjectRef\")\n\n    class FailedEval(Exception):\n        pass\n\n    def __init__(self, indirection, objId, other=None):\n        self._indirections = []\n        # are we building off of an existing ref?\n        if other is not None:\n            for ind in other._indirections:\n                self._indirections.append(ind)\n\n        # make sure we're not storing a reference to the actual object,\n        # that could cause a memory leak\n        assert type(objId) is int\n        # prevent cycles (i.e. base.loader.base.loader)\n        assert not self.goesThrough(objId=objId)\n\n        self._indirections.append(indirection)\n\n        # make sure our indirections don't get destroyed while we're using them\n        for ind in self._indirections:\n            ind.acquire()\n        self.notify.debug(repr(self))\n\n    def destroy(self):\n        for indirection in self._indirections:\n            indirection.release()\n        del self._indirections\n\n    def getNumIndirections(self):\n        return len(self._indirections)\n\n    def goesThroughGen(self, obj=None, objId=None):\n        if obj is None:\n            assert type(objId) is int\n        else:\n            objId = id(obj)\n        o = None\n        evalStr = ''\n        curObj = None\n        # make sure the indirections don't go away on us\n        indirections = self._indirections\n        for indirection in indirections:\n            yield None\n            indirection.acquire()\n        for indirection in indirections:\n            yield None\n            if not indirection.isDictKey():\n                # build up a string to be eval'd\n                evalStr += indirection.getString()\n            else:\n                curObj = self._getContainerByEval(evalStr, curObj=curObj)\n                if curObj is None:\n                    raise FailedEval(evalStr)\n                # try to look up this key in the curObj dictionary\n                curObj = indirection.dereferenceDictKey(curObj)\n                evalStr = ''\n            yield None\n            o = self._getContainerByEval(evalStr, curObj=curObj)\n            if id(o) == objId:\n                break\n        for indirection in indirections:\n            yield None\n            indirection.release()\n\n        yield id(o) == objId\n\n    def goesThrough(self, obj=None, objId=None):\n        # since we cache the ids involved in this reference,\n        # this isn't perfect, for example if base.myObject is reassigned\n        # to a different object after this Ref was created this would return\n        # false, allowing a ref to base.myObject.otherObject.myObject\n        for goesThrough in self.goesThroughGen(obj=obj, objId=objId):\n            pass\n        return goesThrough\n\n    def _getContainerByEval(self, evalStr, curObj=None):\n        if curObj is not None:\n            # eval('curObj.foo.bar.someDict')\n            evalStr = 'curObj%s' % evalStr\n        else:\n            # this eval is not based off of curObj, use the globalbuiltins namespace\n            # put builtins at the start if it's not already there\n            bis = 'builtins'\n            if evalStr[:len(bis)] != bis:\n                evalStr = '%s.%s' % (bis, evalStr)\n        try:\n            container = eval(evalStr)\n        except NameError as ne:\n            return None\n        except AttributeError as ae:\n            return None\n        except KeyError as ke:\n            return None\n        return container\n\n    def getContainerGen(self, getInstance=False):\n        # try to get a handle on the container by eval'ing and looking things\n        # up in dictionaries, depending on the type of each indirection\n        # if getInstance is True, will return instance instead of instance dict\n        #import pdb;pdb.set_trace()\n        evalStr = ''\n        curObj = None\n        # make sure the indirections don't go away on us\n        indirections = self._indirections\n        for indirection in indirections:\n            indirection.acquire()\n        for indirection in indirections:\n            yield None\n            if not indirection.isDictKey():\n                # build up a string to be eval'd\n                evalStr += indirection.getString()\n            else:\n                curObj = self._getContainerByEval(evalStr, curObj=curObj)\n                if curObj is None:\n                    raise FailedEval(evalStr)\n                # try to look up this key in the curObj dictionary\n                curObj = indirection.dereferenceDictKey(curObj)\n                evalStr = ''\n        for indirection in indirections:\n            yield None\n            indirection.release()\n\n        if getInstance:\n            lenDict = len('.__dict__')\n            if evalStr[-lenDict:] == '.__dict__':\n                evalStr = evalStr[:-lenDict]\n\n        # TODO: check that this is still the object we originally pointed to\n        yield self._getContainerByEval(evalStr, curObj=curObj)\n\n    def getEvalStrGen(self, getInstance=False):\n        str = ''\n        prevIndirection = None\n        curIndirection = None\n        nextIndirection = None\n        # make sure the indirections don't go away on us\n        indirections = self._indirections\n        for indirection in indirections:\n            indirection.acquire()\n        for i in range(len(indirections)):\n            yield None\n            if i > 0:\n                prevIndirection = indirections[i-1]\n            else:\n                prevIndirection = None\n            curIndirection = indirections[i]\n            if i < len(indirections)-1:\n                nextIndirection = indirections[i+1]\n            else:\n                nextIndirection = None\n            str += curIndirection.getString(prevIndirection=prevIndirection,\n                                            nextIndirection=nextIndirection)\n\n        if getInstance:\n            lenDict = len('.__dict__')\n            if str[-lenDict:] == '.__dict__':\n                str = str[:-lenDict]\n\n        for indirection in indirections:\n            yield None\n            indirection.release()\n        yield str\n\n    def getFinalIndirectionStr(self):\n        prevIndirection = None\n        if len(self._indirections) > 1:\n            prevIndirection = self._indirections[-2]\n        return self._indirections[-1].getString(prevIndirection=prevIndirection)\n\n    def __repr__(self):\n        for result in self.getEvalStrGen():\n            pass\n        return result\n\n\nclass FindContainers(Job):\n    \"\"\"\n    Explore the Python graph, looking for objects that support __len__()\n    \"\"\"\n\n    def __init__(self, name, leakDetector):\n        Job.__init__(self, name)\n        self._leakDetector = leakDetector\n        self._id2ref = self._leakDetector._id2ref\n        # these hold objects that we should start traversals from often and not-as-often,\n        # respectively\n        self._id2baseStartRef = {}\n        self._id2discoveredStartRef = {}\n        # these are working copies so that our iterations aren't disturbed by changes to the\n        # definitive ref sets\n        self._baseStartRefWorkingList = ScratchPad(refGen=nullGen(),\n                                                   source=self._id2baseStartRef)\n        self._discoveredStartRefWorkingList = ScratchPad(refGen=nullGen(),\n                                                         source=self._id2discoveredStartRef)\n        self.notify = self._leakDetector.notify\n        ContainerLeakDetector.addPrivateObj(self.__dict__)\n\n        # set up the base containers, the ones that hold most objects\n        ref = ObjectRef(Indirection(evalStr='builtins.__dict__'), id(builtins.__dict__))\n        self._id2baseStartRef[id(builtins.__dict__)] = ref\n        # container for objects that want to make sure they are found by\n        # the object exploration algorithm, including objects that exist\n        # just to measure things such as C++ memory usage, scene graph size,\n        # framerate, etc. See LeakDetectors.py\n        if not hasattr(builtins, \"leakDetectors\"):\n            builtins.leakDetectors = {}\n        ref = ObjectRef(Indirection(evalStr='leakDetectors'), id(builtins.leakDetectors))\n        self._id2baseStartRef[id(builtins.leakDetectors)] = ref\n        for i in self._addContainerGen(builtins.__dict__, ref):\n            pass\n        try:\n            base\n        except Exception:\n            pass\n        else:\n            ref = ObjectRef(Indirection(evalStr='base.__dict__'), id(base.__dict__))\n            self._id2baseStartRef[id(base.__dict__)] = ref\n            for i in self._addContainerGen(base.__dict__, ref):\n                pass\n        try:\n            simbase\n        except Exception:\n            pass\n        else:\n            ref = ObjectRef(Indirection(evalStr='simbase.__dict__'), id(simbase.__dict__))\n            self._id2baseStartRef[id(simbase.__dict__)] = ref\n            for i in self._addContainerGen(simbase.__dict__, ref):\n                pass\n\n    def destroy(self):\n        ContainerLeakDetector.removePrivateObj(self.__dict__)\n        Job.destroy(self)\n\n    def getPriority(self):\n        return Job.Priorities.Low\n\n    @staticmethod\n    def getStartObjAffinity(startObj):\n        # how good of a starting object is this object for traversing the object graph?\n        try:\n            return len(startObj)\n        except Exception:\n            return 1\n\n    def _isDeadEnd(self, obj, objName=None):\n        if type(obj) in deadEndTypes:\n            return True\n\n        # if it's an internal object, ignore it\n        if id(obj) in ContainerLeakDetector.PrivateIds:\n            return True\n        # prevent crashes in objects that define __cmp__ and don't handle strings\n        if type(objName) == str and objName in ('im_self', 'im_class'):\n            return True\n        try:\n            className = obj.__class__.__name__\n        except Exception:\n            pass\n        else:\n            # prevent infinite recursion in built-in containers related to methods\n            if className == 'method-wrapper':\n                return True\n        return False\n\n    def _hasLength(self, obj):\n        return hasattr(obj, '__len__')\n\n    def _addContainerGen(self, cont, objRef):\n        contId = id(cont)\n        # if this container is new, or the objRef repr is shorter than what we already have,\n        # put it in the table\n        if contId in self._id2ref:\n            for existingRepr in self._id2ref[contId].getEvalStrGen():\n                yield None\n            for newRepr in objRef.getEvalStrGen():\n                yield None\n        if contId not in self._id2ref or len(newRepr) < len(existingRepr):\n            if contId in self._id2ref:\n                self._leakDetector.removeContainerById(contId)\n            self._id2ref[contId] = objRef\n\n    def _addDiscoveredStartRef(self, obj, ref):\n        # we've discovered an object that can be used to start an object graph traversal\n        objId = id(obj)\n        if objId in self._id2discoveredStartRef:\n            existingRef = self._id2discoveredStartRef[objId]\n            if type(existingRef) is not int:\n                if existingRef.getNumIndirections() >= ref.getNumIndirections():\n                    # the ref that we already have is more concise than the new ref\n                    return\n        if objId in self._id2ref:\n            if self._id2ref[objId].getNumIndirections() >= ref.getNumIndirections():\n                # the ref that we already have is more concise than the new ref\n                return\n        storedItem = ref\n        # if we already are storing a reference to this object, don't store a second reference\n        if objId in self._id2ref:\n            storedItem = objId\n        self._id2discoveredStartRef[objId] = storedItem\n\n    def run(self):\n        try:\n            # this yields a different set of start refs every time we start a new traversal\n            # force creation of a new workingListSelector inside the while loop right off the bat\n            workingListSelector = nullGen()\n            # this holds the current step of the current traversal\n            curObjRef = None\n            while True:\n                # yield up here instead of at the end, since we skip back to the\n                # top of the while loop from various points\n                yield None\n                #import pdb;pdb.set_trace()\n                if curObjRef is None:\n                    # choose an object to start a traversal from\n                    try:\n                        startRefWorkingList = next(workingListSelector)\n                    except StopIteration:\n                        # do relative # of traversals on each set based on how many refs it contains\n                        baseLen = len(self._baseStartRefWorkingList.source)\n                        discLen = len(self._discoveredStartRefWorkingList.source)\n                        minLen = float(max(1, min(baseLen, discLen)))\n                        # this will cut down the traversals of the larger set by 2/3\n                        minLen *= 3.\n                        workingListSelector = flywheel([self._baseStartRefWorkingList, self._discoveredStartRefWorkingList],\n                                                       [baseLen/minLen, discLen/minLen])\n                        yield None\n                        continue\n\n                    # grab the next start ref from this sequence and see if it's still valid\n                    while True:\n                        yield None\n                        try:\n                            curObjRef = next(startRefWorkingList.refGen)\n                            break\n                        except StopIteration:\n                            # we've run out of refs, grab a new set\n                            if len(startRefWorkingList.source) == 0:\n                                # ref set is empty, choose another\n                                break\n                            # make a generator that yields containers a # of times that is\n                            # proportional to their length\n                            for fw in makeFlywheelGen(\n                                    list(startRefWorkingList.source.values()),\n                                    countFunc=lambda x: self.getStartObjAffinity(x),\n                                    scale=.05):\n                                yield None\n                            startRefWorkingList.refGen = fw\n                    if curObjRef is None:\n                        # this ref set is empty, choose another\n                        # the base set should never be empty (builtins etc.)\n                        continue\n                    # do we need to go look up the object in _id2ref? sometimes we do that\n                    # to avoid storing multiple redundant refs to a single item\n                    if type(curObjRef) is int:\n                        startId = curObjRef\n                        curObjRef = None\n                        try:\n                            for containerRef in self._leakDetector.getContainerByIdGen(startId):\n                                yield None\n                        except Exception:\n                            # ref is invalid\n                            self.notify.debug('invalid startRef, stored as id %s' % startId)\n                            self._leakDetector.removeContainerById(startId)\n                            continue\n                        curObjRef = containerRef\n\n                try:\n                    for curObj in curObjRef.getContainerGen():\n                        yield None\n                except Exception:\n                    self.notify.debug('lost current container, ref.getContainerGen() failed')\n                    # that container is gone, try again\n                    curObjRef = None\n                    continue\n\n                self.notify.debug('--> %s' % curObjRef)\n                #import pdb;pdb.set_trace()\n\n                # store a copy of the current objRef\n                parentObjRef = curObjRef\n                # if we hit a dead end, start over from another container\n                curObjRef = None\n\n                # types.CellType was added in Python 3.8\n                if type(curObj) is types.CellType:\n                    child = curObj.cell_contents\n                    hasLength = self._hasLength(child)\n                    notDeadEnd = not self._isDeadEnd(child)\n                    if hasLength or notDeadEnd:\n                        objRef = ObjectRef(Indirection(evalStr='.cell_contents'),\n                                           id(child), parentObjRef)\n                        yield None\n                        if hasLength:\n                            for i in self._addContainerGen(child, objRef):\n                                yield None\n                        if notDeadEnd:\n                            self._addDiscoveredStartRef(child, objRef)\n                            curObjRef = objRef\n                    continue\n\n                if hasattr(curObj, '__dict__'):\n                    child = curObj.__dict__\n                    hasLength = self._hasLength(child)\n                    notDeadEnd = not self._isDeadEnd(child)\n                    if hasLength or notDeadEnd:\n                        # prevent cycles in the references (i.e. base.loader.base)\n                        for goesThrough in parentObjRef.goesThroughGen(child):\n                            # don't yield, container might lose this element\n                            pass\n                        if not goesThrough:\n                            objRef = ObjectRef(Indirection(evalStr='.__dict__'),\n                                               id(child), parentObjRef)\n                            yield None\n                            if hasLength:\n                                for i in self._addContainerGen(child, objRef):\n                                    yield None\n                            if notDeadEnd:\n                                self._addDiscoveredStartRef(child, objRef)\n                                curObjRef = objRef\n                    continue\n\n                if type(curObj) is dict:\n                    key = None\n                    attr = None\n                    keys = list(curObj.keys())\n                    # we will continue traversing the object graph via one key of the dict,\n                    # choose it at random without taking a big chunk of CPU time\n                    numKeysLeft = len(keys) + 1\n                    for key in keys:\n                        yield None\n                        numKeysLeft -= 1\n                        try:\n                            attr = curObj[key]\n                        except KeyError as e:\n                            # this is OK because we are yielding during the iteration\n                            self.notify.debug('could not index into %s with key %s' % (\n                                parentObjRef, safeRepr(key)))\n                            continue\n                        hasLength = self._hasLength(attr)\n                        notDeadEnd = False\n                        # if we haven't picked the next ref, check if this one is a candidate\n                        if curObjRef is None:\n                            notDeadEnd = not self._isDeadEnd(attr, key)\n                        if hasLength or notDeadEnd:\n                            # prevent cycles in the references (i.e. base.loader.base)\n                            for goesThrough in parentObjRef.goesThroughGen(curObj[key]):\n                                # don't yield, container might lose this element\n                                pass\n                            if not goesThrough:\n                                if curObj is builtins.__dict__:\n                                    objRef = ObjectRef(Indirection(evalStr='%s' % key),\n                                                       id(curObj[key]))\n                                else:\n                                    objRef = ObjectRef(Indirection(dictKey=key),\n                                                       id(curObj[key]), parentObjRef)\n                                yield None\n                                if hasLength:\n                                    for i in self._addContainerGen(attr, objRef):\n                                        yield None\n                                if notDeadEnd:\n                                    self._addDiscoveredStartRef(attr, objRef)\n                                    if curObjRef is None and random.randrange(numKeysLeft) == 0:\n                                        curObjRef = objRef\n                    del key\n                    del attr\n\n        except Exception as e:\n            print('FindContainers job caught exception: %s' % e)\n            if __dev__:\n                raise\n        yield Job.Done\n\n\nclass CheckContainers(Job):\n    \"\"\"\n    Job to check container sizes and find potential leaks; sub-job of ContainerLeakDetector\n    \"\"\"\n    ReprItems = 5\n\n    def __init__(self, name, leakDetector, index):\n        Job.__init__(self, name)\n        self._leakDetector = leakDetector\n        self.notify = self._leakDetector.notify\n        self._index = index\n        ContainerLeakDetector.addPrivateObj(self.__dict__)\n\n    def destroy(self):\n        ContainerLeakDetector.removePrivateObj(self.__dict__)\n        Job.destroy(self)\n\n    def getPriority(self):\n        return Job.Priorities.Normal\n\n    def run(self):\n        try:\n            self._leakDetector._index2containerId2len[self._index] = {}\n            ids = self._leakDetector.getContainerIds()\n            # record the current len of each container\n            for objId in ids:\n                yield None\n                try:\n                    for result in self._leakDetector.getContainerByIdGen(objId):\n                        yield None\n                    container = result\n                except Exception as e:\n                    # this container no longer exists\n                    if self.notify.getDebug():\n                        for contName in self._leakDetector.getContainerNameByIdGen(objId):\n                            yield None\n                        self.notify.debug(\n                            '%s no longer exists; caught exception in getContainerById (%s)' % (\n                            contName, e))\n                    self._leakDetector.removeContainerById(objId)\n                    continue\n                if container is None:\n                    # this container no longer exists\n                    if self.notify.getDebug():\n                        for contName in self._leakDetector.getContainerNameByIdGen(objId):\n                            yield None\n                        self.notify.debug('%s no longer exists; getContainerById returned None' %\n                                          contName)\n                    self._leakDetector.removeContainerById(objId)\n                    continue\n                try:\n                    cLen = len(container)\n                except Exception as e:\n                    # this container no longer exists\n                    if self.notify.getDebug():\n                        for contName in self._leakDetector.getContainerNameByIdGen(objId):\n                            yield None\n                        self.notify.debug(\n                            '%s is no longer a container, it is now %s (%s)' %\n                            (contName, safeRepr(container), e))\n                    self._leakDetector.removeContainerById(objId)\n                    continue\n                self._leakDetector._index2containerId2len[self._index][objId] = cLen\n            # compare the current len of each container to past lens\n            if self._index > 0:\n                idx2id2len = self._leakDetector._index2containerId2len\n                for objId in idx2id2len[self._index]:\n                    yield None\n                    if objId in idx2id2len[self._index-1]:\n                        diff = idx2id2len[self._index][objId] - idx2id2len[self._index-1][objId]\n                        \"\"\"\n                        # this check is too spammy\n                        if diff > 20:\n                            if diff > idx2id2len[self._index-1][objId]:\n                                minutes = (self._leakDetector._index2delay[self._index] -\n                                           self._leakDetector._index2delay[self._index-1]) / 60.\n                                name = self._leakDetector.getContainerNameById(objId)\n                                if idx2id2len[self._index-1][objId] != 0:\n                                    percent = 100. * (float(diff) / float(idx2id2len[self._index-1][objId]))\n                                    try:\n                                        for container in self._leakDetector.getContainerByIdGen(objId):\n                                            yield None\n                                    except Exception:\n                                        # TODO\n                                        self.notify.debug('caught exception in getContainerByIdGen (1)')\n                                    else:\n                                        self.notify.warning(\n                                            '%s (%s) grew %.2f%% in %.2f minutes (%s items at last measurement, current contents: %s)' % (\n                                            name, itype(container), percent, minutes, idx2id2len[self._index][objId],\n                                            fastRepr(container, maxLen=CheckContainers.ReprItems)))\n                                    yield None\n                                    \"\"\"\n                        if (self._index > 2 and\n                            objId in idx2id2len[self._index-2] and\n                            objId in idx2id2len[self._index-3]):\n                            diff2 = idx2id2len[self._index-1][objId] - idx2id2len[self._index-2][objId]\n                            diff3 = idx2id2len[self._index-2][objId] - idx2id2len[self._index-3][objId]\n                            if self._index <= 4:\n                                if diff > 0 and diff2 > 0 and diff3 > 0:\n                                    name = self._leakDetector.getContainerNameById(objId)\n                                    try:\n                                        for container in self._leakDetector.getContainerByIdGen(objId):\n                                            yield None\n                                    except Exception:\n                                        # TODO\n                                        self.notify.debug('caught exception in getContainerByIdGen (2)')\n                                    else:\n                                        msg = ('%s (%s) consistently increased in size over the last '\n                                               '3 periods (%s items at last measurement, current contents: %s)' %\n                                               (name, itype(container), idx2id2len[self._index][objId],\n                                                fastRepr(container, maxLen=CheckContainers.ReprItems)))\n                                        self.notify.warning(msg)\n                                    yield None\n                            elif (objId in idx2id2len[self._index-4] and\n                                  objId in idx2id2len[self._index-5]):\n                                # if size has consistently increased over the last 5 checks,\n                                # send out a warning\n                                diff4 = idx2id2len[self._index-3][objId] - idx2id2len[self._index-4][objId]\n                                diff5 = idx2id2len[self._index-4][objId] - idx2id2len[self._index-5][objId]\n                                if diff > 0 and diff2 > 0 and diff3 > 0 and diff4 > 0 and diff5 > 0:\n                                    name = self._leakDetector.getContainerNameById(objId)\n                                    try:\n                                        for container in self._leakDetector.getContainerByIdGen(objId):\n                                            yield None\n                                    except Exception:\n                                        # TODO\n                                        self.notify.debug('caught exception in getContainerByIdGen (3)')\n                                    else:\n                                        msg = ('leak detected: %s (%s) consistently increased in size over the last '\n                                               '5 periods (%s items at last measurement, current contents: %s)' %\n                                               (name, itype(container), idx2id2len[self._index][objId],\n                                                fastRepr(container, maxLen=CheckContainers.ReprItems)))\n                                        self.notify.warning(msg)\n                                        yield None\n                                        messenger.send(self._leakDetector.getLeakEvent(), [container, name])\n                                        if config.GetBool('pdb-on-leak-detect', 0):\n                                            import pdb;pdb.set_trace()\n                                            pass\n        except Exception as e:\n            print('CheckContainers job caught exception: %s' % e)\n            if __dev__:\n                raise\n        yield Job.Done\n\n\nclass FPTObjsOfType(Job):\n    def __init__(self, name, leakDetector, otn, doneCallback=None):\n        Job.__init__(self, name)\n        self._leakDetector = leakDetector\n        self.notify = self._leakDetector.notify\n        self._otn = otn\n        self._doneCallback = doneCallback\n        self._ldde = self._leakDetector._getDestroyEvent()\n        self.accept(self._ldde, self._handleLDDestroy)\n        ContainerLeakDetector.addPrivateObj(self.__dict__)\n\n    def destroy(self):\n        self.ignore(self._ldde)\n        self._leakDetector = None\n        self._doneCallback = None\n        ContainerLeakDetector.removePrivateObj(self.__dict__)\n        Job.destroy(self)\n\n    def _handleLDDestroy(self):\n        self.destroy()\n\n    def getPriority(self):\n        return Job.Priorities.High\n\n    def run(self):\n        ids = self._leakDetector.getContainerIds()\n        try:\n            for id in ids:\n                getInstance = (self._otn.lower() not in 'dict')\n                yield None\n                try:\n                    for container in self._leakDetector.getContainerByIdGen(\n                            id, getInstance=getInstance):\n                        yield None\n                except Exception:\n                    pass\n                else:\n                    if hasattr(container, '__class__'):\n                        cName = container.__class__.__name__\n                    else:\n                        cName = container.__name__\n                    if self._otn.lower() in cName.lower():\n                        try:\n                            for ptc in self._leakDetector.getContainerNameByIdGen(\n                                    id, getInstance=getInstance):\n                                yield None\n                        except Exception:\n                            pass\n                        else:\n                            print('GPTC(' + self._otn + '):' + self.getJobName() + ': ' + ptc)\n        except Exception as e:\n            print('FPTObjsOfType job caught exception: %s' % e)\n            if __dev__:\n                raise\n        yield Job.Done\n\n    def finished(self):\n        if self._doneCallback:\n            self._doneCallback(self)\n\n\nclass FPTObjsNamed(Job):\n    def __init__(self, name, leakDetector, on, doneCallback=None):\n        Job.__init__(self, name)\n        self._leakDetector = leakDetector\n        self.notify = self._leakDetector.notify\n        self._on = on\n        self._doneCallback = doneCallback\n        self._ldde = self._leakDetector._getDestroyEvent()\n        self.accept(self._ldde, self._handleLDDestroy)\n        ContainerLeakDetector.addPrivateObj(self.__dict__)\n\n    def destroy(self):\n        self.ignore(self._ldde)\n        self._leakDetector = None\n        self._doneCallback = None\n        ContainerLeakDetector.removePrivateObj(self.__dict__)\n        Job.destroy(self)\n\n    def _handleLDDestroy(self):\n        self.destroy()\n\n    def getPriority(self):\n        return Job.Priorities.High\n\n    def run(self):\n        ids = self._leakDetector.getContainerIds()\n        try:\n            for id in ids:\n                yield None\n                try:\n                    for container in self._leakDetector.getContainerByIdGen(id):\n                        yield None\n                except Exception:\n                    pass\n                else:\n                    name = self._leakDetector._id2ref[id].getFinalIndirectionStr()\n                    if self._on.lower() in name.lower():\n                        try:\n                            for ptc in self._leakDetector.getContainerNameByIdGen(id):\n                                yield None\n                        except Exception:\n                            pass\n                        else:\n                            print('GPTCN(' + self._on + '):' + self.getJobName() + ': ' + ptc)\n        except Exception as e:\n            print('FPTObjsNamed job caught exception: %s' % e)\n            if __dev__:\n                raise\n        yield Job.Done\n\n    def finished(self):\n        if self._doneCallback:\n            self._doneCallback(self)\n\n\nclass PruneObjectRefs(Job):\n    \"\"\"\n    Job to destroy any container refs that are no longer valid.\n    Checks validity by asking for each container\n    \"\"\"\n\n    def __init__(self, name, leakDetector):\n        Job.__init__(self, name)\n        self._leakDetector = leakDetector\n        self.notify = self._leakDetector.notify\n        ContainerLeakDetector.addPrivateObj(self.__dict__)\n\n    def destroy(self):\n        ContainerLeakDetector.removePrivateObj(self.__dict__)\n        Job.destroy(self)\n\n    def getPriority(self):\n        return Job.Priorities.Normal\n\n    def run(self):\n        try:\n            ids = self._leakDetector.getContainerIds()\n            for id in ids:\n                yield None\n                try:\n                    for container in self._leakDetector.getContainerByIdGen(id):\n                        yield None\n                except Exception:\n                    # reference is invalid, remove it\n                    self._leakDetector.removeContainerById(id)\n            _id2baseStartRef = self._leakDetector._findContainersJob._id2baseStartRef\n            ids = list(_id2baseStartRef.keys())\n            for id in ids:\n                yield None\n                try:\n                    for container in _id2baseStartRef[id].getContainerGen():\n                        yield None\n                except Exception:\n                    # reference is invalid, remove it\n                    del _id2baseStartRef[id]\n            _id2discoveredStartRef = self._leakDetector._findContainersJob._id2discoveredStartRef\n            ids = list(_id2discoveredStartRef.keys())\n            for id in ids:\n                yield None\n                try:\n                    for container in _id2discoveredStartRef[id].getContainerGen():\n                        yield None\n                except Exception:\n                    # reference is invalid, remove it\n                    del _id2discoveredStartRef[id]\n        except Exception as e:\n            print('PruneObjectRefs job caught exception: %s' % e)\n            if __dev__:\n                raise\n        yield Job.Done\n\n\nclass ContainerLeakDetector(Job):\n    \"\"\"\n    Low-priority Python object-graph walker that looks for leaking containers.\n    To reduce memory usage, this does a random walk of the Python objects to\n    discover containers rather than keep a set of all visited objects; it may\n    visit the same object many times but eventually it will discover every object.\n    Checks container sizes at ever-increasing intervals.\n    \"\"\"\n    notify = directNotify.newCategory(\"ContainerLeakDetector\")\n    # set of containers that should not be examined\n    PrivateIds: set[int] = set()\n\n    def __init__(self, name, firstCheckDelay = None):\n        Job.__init__(self, name)\n        self._serialNum = serialNum()\n\n        self._findContainersJob = None\n        self._checkContainersJob = None\n        self._pruneContainersJob = None\n\n        if firstCheckDelay is None:\n            firstCheckDelay = 60. * 15.\n        # divide by two, since the first check just takes length measurements and\n        # doesn't check for leaks\n        self._nextCheckDelay = firstCheckDelay/2.\n        self._checkDelayScale = config.GetFloat('leak-detector-check-delay-scale', 1.5)\n        self._pruneTaskPeriod = config.GetFloat('leak-detector-prune-period', 60. * 30.)\n\n        # main dict of id(container)->containerRef\n        self._id2ref = {}\n        # storage for results of check-container job\n        self._index2containerId2len = {}\n        self._index2delay = {}\n\n        if config.GetBool('leak-container', 0):\n            _createContainerLeak()\n        if config.GetBool('leak-tasks', 0):\n            _createTaskLeak()\n\n        # don't check our own tables for leaks\n        ContainerLeakDetector.addPrivateObj(ContainerLeakDetector.PrivateIds)\n        ContainerLeakDetector.addPrivateObj(self.__dict__)\n\n        self.setPriority(Job.Priorities.Min)\n        jobMgr.add(self)\n\n    def destroy(self):\n        messenger.send(self._getDestroyEvent())\n        self.ignoreAll()\n        if self._pruneContainersJob is not None:\n            jobMgr.remove(self._pruneContainersJob)\n            self._pruneContainersJob = None\n        if self._checkContainersJob is not None:\n            jobMgr.remove(self._checkContainersJob)\n            self._checkContainersJob = None\n        jobMgr.remove(self._findContainersJob)\n        self._findContainersJob = None\n        del self._id2ref\n        del self._index2containerId2len\n        del self._index2delay\n\n    def _getDestroyEvent(self):\n        # sent when leak detector is about to be destroyed\n        return 'cldDestroy-%s' % self._serialNum\n\n    def getLeakEvent(self):\n        # sent when a leak is detected\n        # passes description string as argument\n        return 'containerLeakDetected-%s' % self._serialNum\n\n    @classmethod\n    def addPrivateObj(cls, obj):\n        cls.PrivateIds.add(id(obj))\n\n    @classmethod\n    def removePrivateObj(cls, obj):\n        cls.PrivateIds.remove(id(obj))\n\n    def _getCheckTaskName(self):\n        return 'checkForLeakingContainers-%s' % self._serialNum\n\n    def _getPruneTaskName(self):\n        return 'pruneLeakingContainerRefs-%s' % self._serialNum\n\n    def getContainerIds(self):\n        return list(self._id2ref.keys())\n\n    def getContainerByIdGen(self, id, **kwArgs):\n        # return a generator to look up a container\n        return self._id2ref[id].getContainerGen(**kwArgs)\n\n    def getContainerById(self, id):\n        for result in self._id2ref[id].getContainerGen():\n            pass\n        return result\n\n    def getContainerNameByIdGen(self, id, **kwArgs):\n        return self._id2ref[id].getEvalStrGen(**kwArgs)\n\n    def getContainerNameById(self, id):\n        if id in self._id2ref:\n            return repr(self._id2ref[id])\n        return '<unknown container>'\n\n    def removeContainerById(self, id):\n        if id in self._id2ref:\n            self._id2ref[id].destroy()\n            del self._id2ref[id]\n\n    def run(self):\n        # start looking for containers\n        self._findContainersJob = FindContainers(\n            '%s-findContainers' % self.getJobName(), self)\n        jobMgr.add(self._findContainersJob)\n\n        self._scheduleNextLeakCheck()\n        self._scheduleNextPruning()\n\n        while True:\n            yield Job.Sleep\n\n    def getPathsToContainers(self, name, ot, doneCallback=None):\n        j =  FPTObjsOfType(name, self, ot, doneCallback)\n        jobMgr.add(j)\n        return j\n\n    def getPathsToContainersNamed(self, name, on, doneCallback=None):\n        j =  FPTObjsNamed(name, self, on, doneCallback)\n        jobMgr.add(j)\n        return j\n\n    def _scheduleNextLeakCheck(self):\n        taskMgr.doMethodLater(self._nextCheckDelay, self._checkForLeaks,\n                              self._getCheckTaskName())\n        # delay between checks\n        # fib:    1   1   2   3   5   8   13   21   34   55   89\n        # * 2.:   1   2   4   8  16  32   64  128  256  512 1024\n        # * 1.5:  1 1.5 2.3 3.4 5.1 7.6 11.4 17.1 25.6 38.4 57.7\n        #\n        # delay from job start\n        # fib:    1   2    4    7   12   20    33    54    88    143    232\n        # * 2.:   1   3    7   15   31   63   127   255   511   1023   2047\n        # * 1.5:  1 2.5 4.75  8.1 13.2 20.8  32.2  49.3  74.9  113.3    171\n        self._nextCheckDelay = self._nextCheckDelay * self._checkDelayScale\n\n    def _checkForLeaks(self, task=None):\n        self._index2delay[len(self._index2containerId2len)] = self._nextCheckDelay\n        self._checkContainersJob = CheckContainers(\n            '%s-checkForLeaks' % self.getJobName(), self, len(self._index2containerId2len))\n        self.acceptOnce(self._checkContainersJob.getFinishedEvent(),\n                        self._scheduleNextLeakCheck)\n        jobMgr.add(self._checkContainersJob)\n        return task.done\n\n    def _scheduleNextPruning(self):\n        taskMgr.doMethodLater(self._pruneTaskPeriod, self._pruneObjectRefs,\n                              self._getPruneTaskName())\n\n    def _pruneObjectRefs(self, task=None):\n        self._pruneContainersJob = PruneObjectRefs(\n            '%s-pruneObjectRefs' % self.getJobName(), self)\n        self.acceptOnce(self._pruneContainersJob.getFinishedEvent(),\n                        self._scheduleNextPruning)\n        jobMgr.add(self._pruneContainersJob)\n        return task.done\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/ContainerLeakDetector.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/e2a31346_ContainerLeakDetector.json",
    "doc_id": "doc_256"
  }
}