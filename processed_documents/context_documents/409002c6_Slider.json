{
  "content": "\"\"\"\nSlider Class: Velocity style controller for floating point values with\n               a label, entry (validated), and min/max slider\n\"\"\"\n\n__all__ = ['Slider', 'SliderWidget', 'rgbPanel']\n\nfrom .Valuator import Valuator, rgbPanel, VALUATOR_MINI, VALUATOR_FULL\nimport Pmw\nimport tkinter as tk\n\n\nclass Slider(Valuator):\n    \"\"\"\n    Valuator widget which includes an min/max slider and an entry for setting\n    floating point values in a range\n    \"\"\"\n\n    def __init__(self, parent = None, **kw):\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            ('min',        0.0,           self.setMin),\n            ('max',        100.0,         self.setMax),\n            ('style',      VALUATOR_MINI,   INITOPT),\n        )\n        self.defineoptions(kw, optiondefs)\n        Valuator.__init__(self, parent)\n        # Can not enter None for min or max, update propertyDict to reflect\n        self.propertyDict['min']['fNone'] = 0\n        self.propertyDict['min']['help'] = 'Minimum allowable value.'\n        self.propertyDict['max']['fNone'] = 0\n        self.propertyDict['max']['help'] = 'Maximum allowable value.'\n        self.initialiseoptions(Slider)\n\n    def createValuator(self):\n        self._valuator = self.createcomponent(\n            'valuator',\n            (('slider', 'valuator'),),\n            None,\n            SliderWidget,\n            (self.interior(),),\n            style = self['style'],\n            command = self.setEntry,\n            value = self['value'])\n        #self._valuator._widget.bind('<Double-ButtonPress-1>', self.mouseReset)\n\n        # Add popup bindings to slider widget\n        try:\n            self._valuator._arrowBtn.bind(\n                '<ButtonPress-3>', self._popupValuatorMenu)\n        except AttributeError:\n            pass\n        self._valuator._minLabel.bind(\n            '<ButtonPress-3>', self._popupValuatorMenu)\n        self._valuator._maxLabel.bind(\n            '<ButtonPress-3>', self._popupValuatorMenu)\n\n    def packValuator(self):\n        if self['style'] == VALUATOR_FULL:\n            if self._label:\n                self._label.grid(row = 0, column = 0, sticky = tk.EW)\n            self._entry.grid(row = 0, column = 1, sticky = tk.EW)\n            self._valuator.grid(row = 1, columnspan = 2,\n                                padx = 2, pady = 2, sticky = 'ew')\n            self.interior().columnconfigure(0, weight = 1)\n        else:\n            if self._label:\n                self._label.grid(row=0, column=0, sticky = tk.EW)\n            self._entry.grid(row=0, column=1, sticky = tk.EW)\n            self._valuator.grid(row=0, column=2, padx = 2, pady = 2)\n            self.interior().columnconfigure(0, weight = 1)\n\n    def setMin(self):\n        if self['min'] is not None:\n            self._valuator['min'] = self['min']\n\n    def setMax(self):\n        if self['max'] is not None:\n            self._valuator['max'] = self['max']\n\n\n# Based on Pmw ComboBox code.\nclass SliderWidget(Pmw.MegaWidget):\n    def __init__(self, parent = None, **kw):\n\n        # Define the megawidget options.\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            # Appearance\n            ('style',           VALUATOR_MINI,      INITOPT),\n            ('relief',          tk.RAISED,          self.setRelief),\n            ('borderwidth',     2,                  self.setBorderwidth),\n            ('background',      'grey75',           self.setBackground),\n            ('fliparrow',       0,                  INITOPT),\n            # Behavior\n            # Bounds\n            ('min',             0.0,            self.setMin),\n            ('max',             100.0,          self.setMax),\n            # Initial value of slider, use self.set to change value\n            ('value',           0.0,            INITOPT),\n            ('numDigits',       2,              self.setNumDigits),\n            # Command to execute on slider updates\n            ('command',         None,           None),\n            # Extra data to be passed to command function\n            ('commandData',     [],             None),\n            # Callback's to execute during mouse interaction\n            ('preCallback',     None,           None),\n            ('postCallback',    None,           None),\n            # Extra data to be passed to callback function, needs to be a list\n            ('callbackData',    [],             None),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Initialise the base class (after defining the options).\n        Pmw.MegaWidget.__init__(self, parent)\n\n        # Create the components.\n        interior = self.interior()\n\n        # Current value\n        self.value = self['value']\n        self.formatString = '%2f'\n        self.increment = 0.01\n\n        # Interaction flags\n        self._isPosted = 0\n        self._fUnpost = 0\n        self._fUpdate = 0\n        self._firstPress = 1\n        self._fPressInsde = 0\n\n        # Slider dimensions\n        width = 100\n        self.xPad = xPad = 10\n        sliderWidth = width + 2 * xPad\n        height = 20\n        self.left = left = -(width/2.0)\n        self.right = right = (width/2.0)\n        top = -5\n        bottom = top + height\n\n        def createSlider(parent):\n            # Create the slider inside the dropdown window.\n            # Min label\n            self._minLabel = tk.Label(parent, text = self['min'], width = 8,\n                                      anchor = tk.W)\n            self._minLabel.pack(side = tk.LEFT)\n            # Slider widget\n            if self['style'] == VALUATOR_FULL:\n                # Use a scale slider\n                self._widgetVar = tk.DoubleVar()\n                self._widgetVar.set(self['value'])\n                self._widget = self.createcomponent(\n                    'slider', (), None,\n                    tk.Scale, (interior,),\n                    variable = self._widgetVar,\n                    from_ = self['min'], to = self['max'],\n                    resolution = 0.0,\n                    width = 10,\n                    orient = 'horizontal',\n                    showvalue = 0,\n                    length = sliderWidth,\n                    relief = tk.FLAT, bd = 2,\n                    highlightthickness = 0)\n            else:\n                # Use a canvas slider\n                self._widget = self.createcomponent(\n                    'slider', (), None,\n                    tk.Canvas, (parent,),\n                    width = sliderWidth,\n                    height = height,\n                    bd = 2,\n                    highlightthickness = 0,\n                    scrollregion = (left - xPad, top, right + xPad, bottom))\n                # Interaction marker\n                xShift = 1\n                # Shadow arrow\n                self._marker = self._widget.create_polygon(-7 + xShift, 12,\n                                                           7 + xShift, 12,\n                                                           xShift, 0,\n                                                           fill = 'black',\n                                                           tags = ('marker',))\n                # Arrow\n                self._widget.create_polygon(-6.0, 10,\n                                            6.0, 10,\n                                            0, 0,\n                                            fill = 'grey85',\n                                            outline = 'black',\n                                            tags = ('marker',))\n                # The indicator\n                self._widget.create_line(left, 0,\n                                         right, 0,\n                                         width = 2,\n                                         tags = ('line',))\n\n            self._widget.pack(side = tk.LEFT, expand=1, fill=tk.X)\n\n            # Max label\n            self._maxLabel = tk.Label(parent, text = self['max'], width = 8,\n                                      anchor = tk.W)\n            self._maxLabel.pack(side = tk.LEFT)\n\n        # Create slider\n        if self['style'] == VALUATOR_MINI:\n\n            # Create the arrow button to invoke slider\n            self._arrowBtn = self.createcomponent(\n                'arrowbutton',\n                (), None,\n                tk.Canvas, (interior,), borderwidth = 0,\n                relief = tk.FLAT, width = 14, height = 14,\n                scrollregion = (-7, -7, 7, 7))\n            self._arrowBtn.pack(expand = 1, fill = tk.BOTH)\n            self._arrowBtn.create_polygon(-5, -5, 5, -5, 0, 5,\n                                          fill = 'grey50',\n                                          tags = 'arrow')\n            self._arrowBtn.create_line(-5, 5, 5, 5,\n                                       fill = 'grey50',\n                                       tags = 'arrow')\n            # Create the dropdown window.\n            self._popup = self.createcomponent(\n                'popup',\n                (), None,\n                tk.Toplevel, (interior,),\n                relief = tk.RAISED, borderwidth = 2)\n            self._popup.withdraw()\n            self._popup.overrideredirect(1)\n\n            # Create popup slider\n            createSlider(self._popup)\n\n            # Bind events to the arrow button.\n            self._arrowBtn.bind('<1>', self._postSlider)\n            self._arrowBtn.bind('<Enter>', self.highlightWidget)\n            self._arrowBtn.bind('<Leave>', self.restoreWidget)\n            # Need to unpost the popup if the arrow Button is unmapped (eg:\n            # its toplevel window is withdrawn) while the popup slider is\n            # displayed.\n            self._arrowBtn.bind('<Unmap>', self._unpostSlider)\n\n            # Bind events to the dropdown window.\n            self._popup.bind('<Escape>', self._unpostSlider)\n            self._popup.bind('<ButtonRelease-1>', self._widgetBtnRelease)\n            self._popup.bind('<ButtonPress-1>', self._widgetBtnPress)\n            self._popup.bind('<Motion>', self._widgetMove)\n\n            self._widget.bind('<Left>', self._decrementValue)\n            self._widget.bind('<Right>', self._incrementValue)\n            self._widget.bind('<Shift-Left>', self._bigDecrementValue)\n            self._widget.bind('<Shift-Right>', self._bigIncrementValue)\n            self._widget.bind('<Home>', self._goToMin)\n            self._widget.bind('<End>', self._goToMax)\n        else:\n            createSlider(interior)\n            self._widget['command'] = self._firstScaleCommand\n            self._widget.bind('<ButtonRelease-1>', self._scaleBtnRelease)\n            self._widget.bind('<ButtonPress-1>', self._scaleBtnPress)\n\n        # Check keywords and initialise options.\n        self.initialiseoptions(SliderWidget)\n\n        # Adjust relief\n        if 'relief' not in kw:\n            if self['style'] == VALUATOR_FULL:\n                self['relief'] = tk.FLAT\n\n        self.updateIndicator(self['value'])\n\n    def destroy(self):\n        if self['style'] == VALUATOR_MINI and self._isPosted:\n            Pmw.popgrab(self._popup)\n        Pmw.MegaWidget.destroy(self)\n\n    #======================================================================\n\n    # Public methods\n\n    def set(self, value, fCommand = 1):\n        \"\"\"\n        self.set(value, fCommand = 1)\n        Set slider to new value, execute command if fCommand == 1\n        \"\"\"\n        # Send command if any\n        if fCommand and (self['command'] is not None):\n            self['command'](*[value] + self['commandData'])\n        # Record value\n        self.value = value\n\n    def get(self):\n        \"\"\"\n        self.get()\n        Get current slider value\n        \"\"\"\n        return self.value\n\n    def updateIndicator(self, value):\n        if self['style'] == VALUATOR_MINI:\n            # Get current marker position\n            percentX = (value - self['min'])/float(self['max'] - self['min'])\n            newX = percentX * (self.right - self.left) + self.left\n            markerX = self._getMarkerX()\n            dx = newX - markerX\n            self._widget.move('marker', dx, 0)\n        else:\n            # Update scale's variable, which update scale without\n            # Calling scale's command\n            self._widgetVar.set(value)\n\n    #======================================================================\n\n    # Private methods for slider.\n\n    def _postSlider(self, event = None):\n        self._isPosted = 1\n        self._fUpdate = 0\n\n        # Make sure that the arrow is displayed sunken.\n        self.interior()['relief'] = tk.SUNKEN\n        self.update_idletasks()\n        # Position popup so that marker is immediately below center of\n        # Arrow button\n        # Find screen space position of bottom/center of arrow button\n        x = (self._arrowBtn.winfo_rootx() + self._arrowBtn.winfo_width()/2.0 -\n             self.interior()['bd'])\n#             int(self.interior()['bd']))\n        y = self._arrowBtn.winfo_rooty() + self._arrowBtn.winfo_height()\n        # Popup border width\n        bd = self._popup['bd']\n#        bd = int(self._popup['bd'])\n        # Get width of label\n        minW = self._minLabel.winfo_width()\n        # Width of canvas to adjust for\n        cw = (self._getMarkerX() - self.left) + self.xPad\n        popupOffset = bd + minW + cw\n        ch =  self._widget.winfo_height()\n        sh = self.winfo_screenheight()\n\n        # Compensate if too close to edge of screen\n        if y + ch > sh and y > sh / 2:\n            y = self._arrowBtn.winfo_rooty() - ch\n        # Popup window\n        Pmw.setgeometryanddeiconify(self._popup, '+%d+%d' % (x-popupOffset, y))\n\n        # Grab the popup, so that all events are delivered to it, and\n        # set focus to the slider, to make keyboard navigation\n        # easier.\n        Pmw.pushgrab(self._popup, 1, self._unpostSlider)\n        self._widget.focus_set()\n\n        # Ignore the first release of the mouse button after posting the\n        # dropdown slider, unless the mouse enters the dropdown slider.\n        self._fUpdate = 0\n        self._fUnpost = 0\n        self._firstPress = 1\n        self._fPressInsde = 0\n\n    def _updateValue(self, event):\n        mouseX = self._widget.canvasx(\n            event.x_root - self._widget.winfo_rootx())\n        if mouseX < self.left:\n            mouseX = self.left\n        if mouseX > self.right:\n            mouseX = self.right\n        # Update value\n        sf = (mouseX - self.left)/(self.right - self.left)\n        newVal = sf * (self['max'] - self['min']) + self['min']\n        self.set(newVal)\n\n    def _widgetBtnPress(self, event):\n        # Check behavior for this button press\n        widget = self._popup\n        xPos = event.x_root - widget.winfo_rootx()\n        yPos = event.y_root - widget.winfo_rooty()\n        fInside = ((xPos > 0) and (xPos < widget.winfo_width()) and\n                   (yPos > 0) and (yPos < widget.winfo_height()))\n        # Set flags based upon result\n        if fInside:\n            self._fPressInside = 1\n            self._fUpdate = 1\n            if self['preCallback']:\n                self['preCallback'](*self['callbackData'])\n            self._updateValue(event)\n        else:\n            self._fPressInside = 0\n            self._fUpdate = 0\n\n    def _widgetMove(self, event):\n        if self._firstPress and not self._fUpdate:\n            canvasY = self._widget.canvasy(\n                event.y_root - self._widget.winfo_rooty())\n            if canvasY > 0:\n                self._fUpdate = 1\n                if self['preCallback']:\n                    self['preCallback'](*self['callbackData'])\n                self._unpostOnNextRelease()\n        elif self._fUpdate:\n            self._updateValue(event)\n\n    def _scaleBtnPress(self, event):\n        if self['preCallback']:\n            self['preCallback'](*self['callbackData'])\n\n    def _scaleBtnRelease(self, event):\n        # Do post callback if any\n        if self['postCallback']:\n            self['postCallback'](*self['callbackData'])\n\n    def _widgetBtnRelease(self, event):\n        # Do post callback if any\n        if self._fUpdate and self['postCallback']:\n            self['postCallback'](*self['callbackData'])\n        if self._fUnpost or not (self._firstPress or self._fPressInside):\n            self._unpostSlider()\n        # Otherwise, continue\n        self._fUpdate = 0\n        self._firstPress = 0\n        self._fPressInside = 0\n\n    def _unpostOnNextRelease(self, event = None):\n        self._fUnpost = 1\n\n    def _unpostSlider(self, event=None):\n        if not self._isPosted:\n            # It is possible to get events on an unposted popup.  For\n            # example, by repeatedly pressing the space key to post\n            # and unpost the popup.  The <space> event may be\n            # delivered to the popup window even though\n            # Pmw.popgrab() has set the focus away from the\n            # popup window.  (Bug in Tk?)\n            return\n\n        # Restore the focus before withdrawing the window, since\n        # otherwise the window manager may take the focus away so we\n        # can't redirect it.  Also, return the grab to the next active\n        # window in the stack, if any.\n        Pmw.popgrab(self._popup)\n        self._popup.withdraw()\n\n        self._isPosted = 0\n\n        # Raise up arrow button\n        self.interior()['relief'] = tk.RAISED\n\n    def _incrementValue(self, event):\n        self.set(self.value + self.increment)\n\n    def _bigIncrementValue(self, event):\n        self.set(self.value + self.increment * 10.0)\n\n    def _decrementValue(self, event):\n        self.set(self.value - self.increment)\n\n    def _bigDecrementValue(self, event):\n        self.set(self.value - self.increment * 10.0)\n\n    def _goToMin(self, event):\n        self.set(self['min'])\n\n    def _goToMax(self, event):\n        self.set(self['max'])\n\n    def _firstScaleCommand(self, val):\n        \"\"\" Hack to avoid calling command on instantiation of Scale \"\"\"\n        self._widget['command'] = self._scaleCommand\n\n    def _scaleCommand(self, val):\n        self.set(float(val))\n\n    # Methods to modify floater characteristics\n    def setMin(self):\n        self._minLabel['text'] = self.formatString % self['min']\n        if self['style'] == VALUATOR_FULL:\n            self._widget['from_'] = self['min']\n        self.updateIndicator(self.value)\n\n    def setMax(self):\n        self._maxLabel['text'] = self.formatString % self['max']\n        if self['style'] == VALUATOR_FULL:\n            self._widget['to'] = self['max']\n        self.updateIndicator(self.value)\n\n    def setNumDigits(self):\n        self.formatString = '%0.' + ('%d' % self['numDigits']) + 'f'\n        self._minLabel['text'] = self.formatString % self['min']\n        self._maxLabel['text'] = self.formatString % self['max']\n        self.updateIndicator(self.value)\n        self.increment = pow(10, -self['numDigits'])\n\n    def _getMarkerX(self):\n        # Get marker triangle coordinates\n        c = self._widget.coords(self._marker)\n        # Marker postion defined as X position of third vertex\n        return c[4]\n\n    def setRelief(self):\n        self.interior()['relief'] = self['relief']\n\n    def setBorderwidth(self):\n        self.interior()['borderwidth'] = self['borderwidth']\n\n    def setBackground(self):\n        self._widget['background'] = self['background']\n\n    def highlightWidget(self, event):\n        self._arrowBtn.itemconfigure('arrow', fill = 'black')\n\n    def restoreWidget(self, event):\n        self._arrowBtn.itemconfigure('arrow', fill = 'grey50')\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/tkwidgets/Slider.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/409002c6_Slider.json",
    "doc_id": "doc_189"
  }
}