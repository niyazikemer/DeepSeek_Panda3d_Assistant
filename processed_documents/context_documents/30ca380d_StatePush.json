{
  "content": "# classes for event-driven programming\n# http://en.wikipedia.org/wiki/Event-driven_programming\n\nfrom __future__ import annotations\n\n__all__ = ['StateVar', 'FunctionCall', 'EnterExit', 'Pulse', 'EventPulse',\n           'EventArgument', ]\n\nfrom direct.showbase.DirectObject import DirectObject\n\n\nclass PushesStateChanges:\n    # base class for objects that broadcast state changes to a set of subscriber objects\n    def __init__(self, value):\n        self._value = value\n        # push state changes to these objects\n        self._subscribers = set()\n\n    def destroy(self):\n        if len(self._subscribers) != 0:\n            raise Exception('%s object still has subscribers in destroy(): %s' % (\n                self.__class__.__name__, self._subscribers))\n        del self._subscribers\n        del self._value\n\n    def getState(self):\n        return self._value\n\n    def pushCurrentState(self):\n        self._handleStateChange()\n        return self\n\n    def _addSubscription(self, subscriber):\n        self._subscribers.add(subscriber)\n        subscriber._recvStatePush(self)\n\n    def _removeSubscription(self, subscriber):\n        self._subscribers.remove(subscriber)\n\n    def _handlePotentialStateChange(self, value):\n        oldValue = self._value\n        self._value = value\n        if oldValue != value:\n            self._handleStateChange()\n\n    def _handleStateChange(self):\n        # push this object's state to the subscribing objects\n        for subscriber in self._subscribers:\n            subscriber._recvStatePush(self)\n\n\nclass ReceivesStateChanges:\n    # base class for objects that subscribe to state changes from PushesStateChanges objects\n    def __init__(self, source):\n        self._source = None\n        self._initSource = source\n\n    def _finishInit(self):\n        # initialization is split across two functions to allow objects that derive from this\n        # class to set everything up so that they can respond appropriately to the initial\n        # state push from the state source\n        self._subscribeTo(self._initSource)\n        del self._initSource\n\n    def destroy(self):\n        self._unsubscribe()\n        del self._source\n\n    def _subscribeTo(self, source):\n        self._unsubscribe()\n        self._source = source\n        if self._source:\n            self._source._addSubscription(self)\n\n    def _unsubscribe(self):\n        if self._source:\n            self._source._removeSubscription(self)\n            self._source = None\n\n    def _recvStatePush(self, source):\n        pass\n\n\nclass StateVar(PushesStateChanges):\n    # coder-friendly object that allows values to be set on it and pushes those values\n    # as state changes\n    def set(self, value):\n        PushesStateChanges._handlePotentialStateChange(self, value)\n\n    def get(self):\n        return PushesStateChanges.getState(self)\n\n\nclass StateChangeNode(PushesStateChanges, ReceivesStateChanges):\n    # base class that can be used to create a state-change notification chain\n    def __init__(self, source):\n        ReceivesStateChanges.__init__(self, source)\n        PushesStateChanges.__init__(self, source.getState())\n        ReceivesStateChanges._finishInit(self)\n\n    def destroy(self):\n        PushesStateChanges.destroy(self)\n        ReceivesStateChanges.destroy(self)\n\n    def _recvStatePush(self, source):\n        # got a state push, apply new state to self\n        self._handlePotentialStateChange(source._value)\n\n\nclass ReceivesMultipleStateChanges:\n    # base class for objects that subscribe to state changes from multiple PushesStateChanges\n    # objects\n    def __init__(self):\n        self._key2source = {}\n        self._source2key = {}\n\n    def destroy(self):\n        keys = list(self._key2source.keys())\n        for key in keys:\n            self._unsubscribe(key)\n        del self._key2source\n        del self._source2key\n\n    def _subscribeTo(self, source, key):\n        self._unsubscribe(key)\n        self._key2source[key] = source\n        self._source2key[source] = key\n        source._addSubscription(self)\n\n    def _unsubscribe(self, key):\n        if key in self._key2source:\n            source = self._key2source[key]\n            source._removeSubscription(self)\n            del self._key2source[key]\n            del self._source2key[source]\n\n    def _recvStatePush(self, source):\n        self._recvMultiStatePush(self._source2key[source], source)\n\n    def _recvMultiStatePush(self, key, source):\n        pass\n\n\nclass FunctionCall(ReceivesMultipleStateChanges, PushesStateChanges):\n    # calls func with provided args whenever arguments' state changes\n    def __init__(self, func, *args, **kArgs):\n        self._initialized = False\n        ReceivesMultipleStateChanges.__init__(self)\n        PushesStateChanges.__init__(self, None)\n        self._func = func\n        self._args = args\n        self._kArgs = kArgs\n        # keep a copy of the arguments ready to go, already filled in with\n        # the value of arguments that push state\n        self._bakedArgs = []\n        self._bakedKargs = {}\n        for i, arg in enumerate(self._args):\n            key = i\n            if isinstance(arg, PushesStateChanges):\n                self._bakedArgs.append(arg.getState())\n                self._subscribeTo(arg, key)\n            else:\n                self._bakedArgs.append(self._args[i])\n        for key, arg in self._kArgs.items():\n            if isinstance(arg, PushesStateChanges):\n                self._bakedKargs[key] = arg.getState()\n                self._subscribeTo(arg, key)\n            else:\n                self._bakedKargs[key] = arg\n        self._initialized = True\n        # call pushCurrentState() instead\n        ## push the current state to any listeners\n        ##self._handleStateChange()\n\n    def destroy(self):\n        ReceivesMultipleStateChanges.destroy(self)\n        PushesStateChanges.destroy(self)\n        del self._func\n        del self._args\n        del self._kArgs\n        del self._bakedArgs\n        del self._bakedKargs\n\n    def getState(self):\n        # for any state recievers that are hooked up to us, they get a tuple\n        # of (tuple(positional argument values), dict(keyword argument name->value))\n        return (tuple(self._bakedArgs), dict(self._bakedKargs))\n\n    def _recvMultiStatePush(self, key, source):\n        # one of the arguments changed\n        # pick up the new value\n        if isinstance(key, str):\n            self._bakedKargs[key] = source.getState()\n        else:\n            self._bakedArgs[key] = source.getState()\n        # and send it out\n        self._handlePotentialStateChange(self.getState())\n\n    def _handleStateChange(self):\n        if self._initialized:\n            self._func(*self._bakedArgs, **self._bakedKargs)\n            PushesStateChanges._handleStateChange(self)\n\n\nclass EnterExit(StateChangeNode):\n    # call enterFunc when our state becomes true, exitFunc when it becomes false\n    def __init__(self, source, enterFunc, exitFunc):\n        self._enterFunc = enterFunc\n        self._exitFunc = exitFunc\n        StateChangeNode.__init__(self, source)\n\n    def destroy(self):\n        StateChangeNode.destroy(self)\n        del self._exitFunc\n        del self._enterFunc\n\n    def _handlePotentialStateChange(self, value):\n        # convert the incoming state as a bool\n        StateChangeNode._handlePotentialStateChange(self, bool(value))\n\n    def _handleStateChange(self):\n        if self._value:\n            self._enterFunc()\n        else:\n            self._exitFunc()\n        StateChangeNode._handleStateChange(self)\n\n\nclass Pulse(PushesStateChanges):\n    # changes state to True then immediately to False whenever sendPulse is called\n    def __init__(self):\n        PushesStateChanges.__init__(self, False)\n\n    def sendPulse(self):\n        self._handlePotentialStateChange(True)\n        self._handlePotentialStateChange(False)\n\n\nclass EventPulse(Pulse, DirectObject):\n    # sends a True-False \"pulse\" whenever a specific messenger message is sent\n    def __init__(self, event):\n        Pulse.__init__(self)\n        self.accept(event, self.sendPulse)\n\n    def destroy(self):\n        self.ignoreAll()\n        Pulse.destroy(self)\n\n\nclass EventArgument(PushesStateChanges, DirectObject):\n    # tracks a particular argument to a particular messenger event\n    def __init__(self, event, index=0):\n        PushesStateChanges.__init__(self, None)\n        self._index = index\n        self.accept(event, self._handleEvent)\n\n    def destroy(self):\n        self.ignoreAll()\n        del self._index\n        PushesStateChanges.destroy(self)\n\n    def _handleEvent(self, *args):\n        self._handlePotentialStateChange(args[self._index])\n\n\nclass AttrSetter(StateChangeNode):\n    def __init__(self, source, object, attrName):\n        self._object = object\n        self._attrName = attrName\n        StateChangeNode.__init__(self, source)\n        self._handleStateChange()\n\n    def _handleStateChange(self):\n        setattr(self._object, self._attrName, self._value)\n        StateChangeNode._handleStateChange(self)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/fsm/StatePush.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/30ca380d_StatePush.json",
    "doc_id": "doc_146"
  }
}