{
  "content": "\"\"\"Defines the IntervalManager class as well as the global instance of\nthis class, ivalMgr.\"\"\"\n\n__all__ = ['IntervalManager', 'ivalMgr']\n\nfrom panda3d.core import EventQueue\nfrom panda3d.direct import CIntervalManager, Dtool_BorrowThisReference\nfrom direct.showbase import EventManager\nimport fnmatch\n\nclass IntervalManager(CIntervalManager):\n\n    # This is a Python-C++ hybrid class.  IntervalManager is a Python\n    # extension of the C++ class CIntervalManager; the main purpose of\n    # the Python extensions is to add support for Python-based\n    # intervals (like MetaIntervals).\n\n    def __init__(self, globalPtr = 0):\n        # Pass globalPtr == 1 to the constructor to trick it into\n        # \"constructing\" a Python wrapper around the global\n        # CIntervalManager object.\n        if globalPtr:\n            self.cObj = CIntervalManager.getGlobalPtr()\n            Dtool_BorrowThisReference(self, self.cObj)\n            self.dd = self\n        else:\n            CIntervalManager.__init__(self)\n        self.eventQueue = EventQueue()\n        self.MyEventmanager = EventManager.EventManager(self.eventQueue)\n        self.setEventQueue(self.eventQueue)\n        self.ivals = []\n        self.removedIvals = {}\n\n    def addInterval(self, interval):\n        index = self.addCInterval(interval, 1)\n        self.__storeInterval(interval, index)\n\n    def removeInterval(self, interval):\n        index = self.findCInterval(interval.getName())\n        if index >= 0:\n            self.removeCInterval(index)\n            if index < len(self.ivals):\n                self.ivals[index] = None\n            return 1\n        return 0\n\n    def getInterval(self, name):\n        index = self.findCInterval(name)\n        if index >= 0:\n            if index < len(self.ivals) and self.ivals[index]:\n                return self.ivals[index]\n            # It must be a C-only interval.\n            return self.getCInterval(index)\n        return None\n\n    def getIntervalsMatching(self, pattern):\n        ivals = []\n\n        count = 0\n        maxIndex = self.getMaxIndex()\n        for index in range(maxIndex):\n            ival = self.getCInterval(index)\n            if ival and \\\n               fnmatch.fnmatchcase(ival.getName(), pattern):\n                # Finish and remove this interval.  Finishing it\n                # automatically removes it.\n                count += 1\n                if index < len(self.ivals) and self.ivals[index]:\n                    # Get the python version if we have it\n                    ivals.append(self.ivals[index])\n                else:\n                    # Otherwise, it's a C-only interval.\n                    ivals.append(ival)\n\n        return ivals\n\n    def finishIntervalsMatching(self, pattern):\n        ivals = self.getIntervalsMatching(pattern)\n        for ival in ivals:\n            ival.finish()\n        return len(ivals)\n\n    def pauseIntervalsMatching(self, pattern):\n        ivals = self.getIntervalsMatching(pattern)\n        for ival in ivals:\n            ival.pause()\n        return len(ivals)\n\n    def step(self):\n        # This method should be called once per frame to perform all\n        # of the per-frame processing on the active intervals.\n        # Call C++ step, then do the Python stuff.\n        CIntervalManager.step(self)\n        self.__doPythonCallbacks()\n\n    def interrupt(self):\n        # This method should be called during an emergency cleanup\n        # operation, to automatically pause or finish all active\n        # intervals tagged with autoPause or autoFinish set true.\n        # Call C++ interrupt, then do the Python stuff.\n        CIntervalManager.interrupt(self)\n        self.__doPythonCallbacks()\n\n    def __doPythonCallbacks(self):\n        # This method does all of the required Python post-processing\n        # after performing some C++-level action.\n        # It is important to call all of the python callbacks on the\n        # just-removed intervals before we call any of the callbacks\n        # on the still-running intervals.\n        index = self.getNextRemoval()\n        while index >= 0:\n            # We have to clear the interval first before we call\n            # privPostEvent() on it, because the interval might itself\n            # try to add a new interval.\n            ival = self.ivals[index]\n            self.ivals[index] = None\n            ival.privPostEvent()\n            index = self.getNextRemoval()\n\n        index = self.getNextEvent()\n        while index >= 0:\n            self.ivals[index].privPostEvent()\n            index = self.getNextEvent()\n\n        # Finally, throw all the events on the custom event queue.\n        # These are the done events that may have been generated in\n        # C++.  We use a custom event queue so we can service all of\n        # these immediately, rather than waiting for the global event\n        # queue to be serviced (which might not be till next frame).\n        self.MyEventmanager.doEvents()\n\n\n    def __storeInterval(self, interval, index):\n        while index >= len(self.ivals):\n            self.ivals.append(None)\n        assert self.ivals[index] is None or self.ivals[index] == interval\n        self.ivals[index] = interval\n\n#: The global IntervalManager object.\nivalMgr = IntervalManager(1)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/interval/IntervalManager.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/493662c0_IntervalManager.json",
    "doc_id": "doc_160"
  }
}