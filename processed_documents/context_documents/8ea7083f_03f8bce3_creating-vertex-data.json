{
  "content": "Creating and filling a GeomVertexData\n\nOnce you have a geomvertexformat, registered and ready to use, you can use it to create a geomvertexdata.\n\npython\n\nvdata = GeomVertexData('name', format, Geom.UHStatic)\n\ncpp\n\nUsing a custom vertex format <defining-your-own-geomvertexformat>.\n\nPT(GeomVertexData) vdata;\nvdata = new GeomVertexData(\"name\", format, Geom::UH_static);\n\nOr using a Pre-defined vertex format <pre-defined-vertex-formats>.\n\nPT(GeomVertexData) vdata;\nvdata = new GeomVertexData(\"name\", GeomVertexFormat::get_????(), Geom::UH_static);\n\nThe first parameter to the GeomVertexData constructor is the name of the data, which is any arbitrary name you like. This name is mainly for documentation purposes; it may help you identify this vertex data later. You can leave it empty if you like.\n\nThe second parameter is the geomvertexformat to use for this GeomVertexData. The format specifies the number of arrays that will be created for the data, the names and formats of the columns in each array, and the number of bytes that need to be allocated for each row.\n\nThe third parameter is a usage hint, which tells Panda how often (if ever) you expect to be modifying these vertices, once you have filled them in the first time. If you will be filling in the vertices once (or only once in a while) and using them to render many frames without changing them, you should use Geom.UHStatic. The vast majority of vertex datas are of this form. Even GeomVertexDatas that include vertex animation tables should usually be declared Geom.UHStatic, since the vertex data itself will not be changing (even though the vertices might be animating).\n\nHowever, occasionally you might create a GeomVertexData whose vertices you intend to adjust in-place every frame, or every few frames; in this case, you can specify Geom.UHDynamic, to tell Panda not to make too much effort to cache the vertex data. This is just a performance hint; you're not required to adhere to the usage you specify, though you may get better render performance if you do.\n\nIf you are unsure about this third parameter, you should probably use Geom.UHStatic.\n\nNext, it is highly recommended that you set the number of rows you're going to write. This is an optional step; Panda will resize the underlying table appropriately as you are adding new data, but this will cause every add_dataXX() call to be much slower than if you had specified a number of rows.\n\npython\n\nvdata.setNumRows(4)\n\ncpp\n\nvdata->set_num_rows(4);\n\nNow that you have created a GeomVertexData, you should create a number of GeomVertexWriters <more-about-geomvertexreader-geomvertexwriter-and-geomvertexrewriter>, one for each column, to fill in the data.\n\npython\n\nvertex = GeomVertexWriter(vdata, 'vertex')\nnormal = GeomVertexWriter(vdata, 'normal')\ncolor = GeomVertexWriter(vdata, 'color')\ntexcoord = GeomVertexWriter(vdata, 'texcoord')\n\ncpp\n\nGeomVertexWriter vertex(vdata, \"vertex\");\nGeomVertexWriter normal(vdata, \"normal\");\nGeomVertexWriter color(vdata, \"color\");\nGeomVertexWriter texcoord(vdata, \"texcoord\");\n\nIt is your responsibility to know which columns exist in the GeomVertexFormat you have used. It is legal to create a GeomVertexWriter for a column that doesn't exist, but it will be an error if you later attempt to use it to add data.\n\nTo add data, you can now iterate through your vertices and call one of the addData methods on each GeomVertexWriter.\n\npython\n\nvertex.addData3(1, 0, 0)\nnormal.addData3(0, 0, 1)\ncolor.addData4(0, 0, 1, 1)\ntexcoord.addData2(1, 0)\n\nvertex.addData3(1, 1, 0)\nnormal.addData3(0, 0, 1)\ncolor.addData4(0, 0, 1, 1)\ntexcoord.addData2(1, 1)\n\nvertex.addData3(0, 1, 0)\nnormal.addData3(0, 0, 1)\ncolor.addData4(0, 0, 1, 1)\ntexcoord.addData2(0, 1)\n\nvertex.addData3(0, 0, 0)\nnormal.addData3(0, 0, 1)\ncolor.addData4(0, 0, 1, 1)\ntexcoord.addData2(0, 0)\n\ncpp\n\nvertex.add_data3(1, 0, 0);\nnormal.add_data3(0, 0, 1);\ncolor.add_data4(0, 0, 1, 1);\ntexcoord.add_data2(1, 0);\n\nvertex.add_data3(1, 1, 0);\nnormal.add_data3(0, 0, 1);\ncolor.add_data4(0, 0, 1, 1);\ntexcoord.add_data2(1, 1);\n\nvertex.add_data3(0, 1, 0);\nnormal.add_data3(0, 0, 1);\ncolor.add_data4(0, 0, 1, 1);\ntexcoord.add_data2(0, 1);\n\nvertex.add_data3(0, 0, 0);\nnormal.add_data3(0, 0, 1);\ncolor.add_data4(0, 0, 1, 1);\ntexcoord.add_data2(0, 0);\n\nEach call to addData() adds a new row (vertex) to the vertex data, if there is not already one there. The above sample code creates the following data table:\n\nvertex normal color texcoord 0 (1, 0, 0) (0, 0, 1) (0, 0, 1, 1) (1, 0) 1 (1, 1, 0) (0, 0, 1) (0, 0, 1, 1) (1, 1) 2 (0, 1, 0) (0, 0, 1) (0, 0, 1, 1) (0, 1) 3 (0, 0, 0) (0, 0, 1) (0, 0, 1, 1) (0, 0)\n\nNote that there is no relationship between the different GeomVertexWriters, other than the fact that they are operating on the same table. Each GeomVertexWriter maintains its own counter of its current row. This means you must fill in the data for every row of each column, even if you don't care about writing the data for some particular column on certain rows. For instance, even if you want to allow the default color for vertex 1 and 2, you must still call color.addData4() four times, in order to fill in the color value for vertex 3.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/03f8bce3_creating-vertex-data.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/8ea7083f_03f8bce3_creating-vertex-data.json",
    "doc_id": "doc_457"
  }
}