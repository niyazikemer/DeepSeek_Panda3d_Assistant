{
  "content": "from panda3d.core import (\n    ClockObject,\n    ConfigVariableBool,\n    ConfigVariableDouble,\n    Datagram,\n    DatagramIterator,\n)\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.distributed.CRDataCache import CRDataCache\nfrom direct.distributed.ConnectionRepository import ConnectionRepository\nfrom direct.showbase.PythonUtil import safeRepr, itype, makeList\nfrom direct.showbase.MessengerGlobal import messenger\nfrom .MsgTypes import CLIENT_ENTER_OBJECT_REQUIRED_OTHER, MsgId2Names\nfrom . import CRCache\nfrom . import ParentMgr\nfrom . import RelatedObjectMgr\nimport time\n\n\nclass ClientRepositoryBase(ConnectionRepository):\n    \"\"\"\n    This maintains a client-side connection with a Panda server.\n\n    This base class exists to collect the common code between\n    ClientRepository, which is the CMU-provided, open-source version\n    of the client repository code, and OTPClientRepository, which is\n    the VR Studio's implementation of the same.\n    \"\"\"\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"ClientRepositoryBase\")\n\n    def __init__(self, dcFileNames = None, dcSuffix = '',\n                 connectMethod = None, threadedNet = None):\n        if connectMethod is None:\n            connectMethod = self.CM_HTTP\n        ConnectionRepository.__init__(self, connectMethod, base.config, hasOwnerView = True, threadedNet = threadedNet)\n        self.dcSuffix = dcSuffix\n        if hasattr(self, 'setVerbose'):\n            if ConfigVariableBool('verbose-clientrepository', False):\n                self.setVerbose(1)\n\n        self.context=100000\n        self.setClientDatagram(1)\n\n        self.deferredGenerates = []\n        self.deferredDoIds = {}\n        self.lastGenerate = 0\n        self.setDeferInterval(ConfigVariableDouble('deferred-generate-interval', 0.2).value)\n        self.noDefer = False  # Set this True to temporarily disable deferring.\n\n        self.recorder = base.recorder\n\n        self.readDCFile(dcFileNames)\n        self.cache=CRCache.CRCache()\n        self.doDataCache = CRDataCache()\n        self.cacheOwner=CRCache.CRCache()\n        self.serverDelta = 0\n\n        self.bootedIndex = None\n        self.bootedText = None\n\n        # create a parentMgr to handle distributed reparents\n        # this used to be 'token2nodePath'\n        self.parentMgr = ParentMgr.ParentMgr()\n\n        # The RelatedObjectMgr helps distributed objects find each\n        # other.\n        self.relatedObjectMgr = RelatedObjectMgr.RelatedObjectMgr(self)\n\n        # This will be filled in when a TimeManager is created.\n        self.timeManager = None\n\n        # Keep track of how recently we last sent a heartbeat message.\n        # We want to keep these coming at heartbeatInterval seconds.\n        self.heartbeatInterval = ConfigVariableDouble('heartbeat-interval', 10).value\n        self.heartbeatStarted = 0\n        self.lastHeartbeat = 0\n\n        self._delayDeletedDOs = {}\n\n        self.specialNameNumber = 0\n\n    def setDeferInterval(self, deferInterval):\n        \"\"\"Specifies the minimum amount of time, in seconds, that must\n        elapse before generating any two DistributedObjects whose\n        class type is marked \"deferrable\".  Set this to 0 to indicate\n        no deferring will occur.\"\"\"\n\n        self.deferInterval = deferInterval\n        self.setHandleCUpdates(self.deferInterval == 0)\n\n        if self.deferredGenerates:\n            taskMgr.remove('deferredGenerate')\n            taskMgr.doMethodLater(self.deferInterval, self.doDeferredGenerate, 'deferredGenerate')\n\n    ## def queryObjectAll(self, doID, context=0):\n        ## \"\"\"\n        ## Get a one-time snapshot look at the object.\n        ## \"\"\"\n        ## assert self.notify.debugStateCall(self)\n        ## # Create a message\n        ## datagram = PyDatagram()\n        ## datagram.addServerHeader(\n            ## doID, localAvatar.getDoId(), 2020)\n        ## # A context that can be used to index the response if needed\n        ## datagram.addUint32(context)\n        ## self.send(datagram)\n        ## # Make sure the message gets there.\n        ## self.flush()\n\n    def specialName(self, label):\n        name = f\"SpecialName {self.specialNameNumber} {label}\"\n        self.specialNameNumber += 1\n        return name\n\n    def getTables(self, ownerView):\n        if ownerView:\n            return self.doId2ownerView, self.cacheOwner\n        else:\n            return self.doId2do, self.cache\n\n    def _getMsgName(self, msgId):\n        # we might get a list of message names, use the first one\n        return makeList(MsgId2Names.get(msgId, f'UNKNOWN MESSAGE: {msgId}'))[0]\n\n    def allocateContext(self):\n        self.context+=1\n        return self.context\n\n    def setServerDelta(self, delta):\n        \"\"\"\n        Indicates the approximate difference in seconds between the\n        client's clock and the server's clock, in universal time (not\n        including timezone shifts).  This is mainly useful for\n        reporting synchronization information to the logs; don't\n        depend on it for any precise timing requirements.\n\n        Also see Notify.setServerDelta(), which also accounts for a\n        timezone shift.\n        \"\"\"\n        self.serverDelta = delta\n\n    def getServerDelta(self):\n        return self.serverDelta\n\n    def getServerTimeOfDay(self):\n        \"\"\"\n        Returns the current time of day (seconds elapsed since the\n        1972 epoch) according to the server's clock.  This is in GMT,\n        and hence is irrespective of timezones.\n\n        The value is computed based on the client's clock and the\n        known delta from the server's clock, which is not terribly\n        precisely measured and may drift slightly after startup, but\n        it should be accurate plus or minus a couple of seconds.\n        \"\"\"\n        return time.time() + self.serverDelta\n\n    def doGenerate(self, parentId, zoneId, classId, doId, di):\n        # Look up the dclass\n        assert parentId == self.GameGlobalsId or parentId in self.doId2do\n        dclass = self.dclassesByNumber[classId]\n        assert self.notify.debug(f\"performing generate for {dclass.getName()} {doId}\")\n        dclass.startGenerate()\n        # Create a new distributed object, and put it in the dictionary\n        distObj = self.generateWithRequiredOtherFields(dclass, doId, di, parentId, zoneId)\n        dclass.stopGenerate()\n\n    def flushGenerates(self):\n        \"\"\" Forces all pending generates to be performed immediately. \"\"\"\n        while self.deferredGenerates:\n            msgType, extra = self.deferredGenerates[0]\n            del self.deferredGenerates[0]\n            self.replayDeferredGenerate(msgType, extra)\n\n        taskMgr.remove('deferredGenerate')\n\n    def replayDeferredGenerate(self, msgType, extra):\n        \"\"\" Override this to do something appropriate with deferred\n        \"generate\" messages when they are replayed().\n        \"\"\"\n\n        if msgType == CLIENT_ENTER_OBJECT_REQUIRED_OTHER:\n            # It's a generate message.\n            doId = extra\n            if doId in self.deferredDoIds:\n                args, deferrable, dg, updates = self.deferredDoIds[doId]\n                del self.deferredDoIds[doId]\n                self.doGenerate(*args)\n\n                if deferrable:\n                    self.lastGenerate = ClockObject.getGlobalClock().getFrameTime()\n\n                for dg, di in updates:\n                    # non-DC updates that need to be played back in-order are\n                    # stored as (msgType, (dg, di))\n                    if isinstance(di, tuple):\n                        msgType = dg\n                        dg, di = di\n                        self.replayDeferredGenerate(msgType, (dg, di))\n                    else:\n                        # ovUpdated is set to True since its OV\n                        # is assumbed to have occured when the\n                        # deferred update was originally received\n                        self.__doUpdate(doId, di, True)\n        else:\n            self.notify.warning(\"Ignoring deferred message %s\" % (msgType))\n\n    def doDeferredGenerate(self, task):\n        \"\"\" This is the task that generates an object on the deferred\n        queue. \"\"\"\n\n        now = ClockObject.getGlobalClock().getFrameTime()\n        while self.deferredGenerates:\n            if now - self.lastGenerate < self.deferInterval:\n                # Come back later.\n                return Task.again\n\n            # Generate the next deferred object.\n            msgType, extra = self.deferredGenerates[0]\n            del self.deferredGenerates[0]\n            self.replayDeferredGenerate(msgType, extra)\n\n        # All objects are generaetd.\n        return Task.done\n\n    def generateWithRequiredFields(self, dclass, doId, di, parentId, zoneId):\n        if doId in self.doId2do:\n            # ...it is in our dictionary.\n            # Just update it.\n            distObj = self.doId2do[doId]\n            assert distObj.dclass == dclass\n            distObj.generate()\n            distObj.setLocation(parentId, zoneId)\n            distObj.updateRequiredFields(dclass, di)\n            # updateRequiredFields calls announceGenerate\n        elif self.cache.contains(doId):\n            # ...it is in the cache.\n            # Pull it out of the cache:\n            distObj = self.cache.retrieve(doId)\n            assert distObj.dclass == dclass\n            # put it in the dictionary:\n            self.doId2do[doId] = distObj\n            # and update it.\n            distObj.generate()\n            # make sure we don't have a stale location\n            distObj.parentId = None\n            distObj.zoneId = None\n            distObj.setLocation(parentId, zoneId)\n            distObj.updateRequiredFields(dclass, di)\n            # updateRequiredFields calls announceGenerate\n        else:\n            # ...it is not in the dictionary or the cache.\n            # Construct a new one\n            classDef = dclass.getClassDef()\n            if classDef is None:\n                self.notify.error(\"Could not create an undefined %s object.\" % (dclass.getName()))\n            distObj = classDef(self)\n            distObj.dclass = dclass\n            # Assign it an Id\n            distObj.doId = doId\n            # Put the new do in the dictionary\n            self.doId2do[doId] = distObj\n            # Update the required fields\n            distObj.generateInit()  # Only called when constructed\n            distObj._retrieveCachedData()\n            distObj.generate()\n            distObj.setLocation(parentId, zoneId)\n            distObj.updateRequiredFields(dclass, di)\n            # updateRequiredFields calls announceGenerate\n            self.notify.debug(\"New DO:%s, dclass:%s\" % (doId, dclass.getName()))\n        return distObj\n\n    def generateWithRequiredOtherFields(self, dclass, doId, di,\n                                        parentId = None, zoneId = None):\n        if doId in self.doId2do:\n            # ...it is in our dictionary.\n            # Just update it.\n            distObj = self.doId2do[doId]\n            assert distObj.dclass == dclass\n            distObj.generate()\n            distObj.setLocation(parentId, zoneId)\n            distObj.updateRequiredOtherFields(dclass, di)\n            # updateRequiredOtherFields calls announceGenerate\n        elif self.cache.contains(doId):\n            # ...it is in the cache.\n            # Pull it out of the cache:\n            distObj = self.cache.retrieve(doId)\n            assert distObj.dclass == dclass\n            # put it in the dictionary:\n            self.doId2do[doId] = distObj\n            # and update it.\n            distObj.generate()\n            # make sure we don't have a stale location\n            distObj.parentId = None\n            distObj.zoneId = None\n            distObj.setLocation(parentId, zoneId)\n            distObj.updateRequiredOtherFields(dclass, di)\n            # updateRequiredOtherFields calls announceGenerate\n        else:\n            # ...it is not in the dictionary or the cache.\n            # Construct a new one\n            classDef = dclass.getClassDef()\n            if classDef is None:\n                self.notify.error(\"Could not create an undefined %s object.\" % (dclass.getName()))\n            distObj = classDef(self)\n            distObj.dclass = dclass\n            # Assign it an Id\n            distObj.doId = doId\n            # Put the new do in the dictionary\n            self.doId2do[doId] = distObj\n            # Update the required fields\n            distObj.generateInit()  # Only called when constructed\n            distObj._retrieveCachedData()\n            distObj.generate()\n            distObj.setLocation(parentId, zoneId)\n            distObj.updateRequiredOtherFields(dclass, di)\n            # updateRequiredOtherFields calls announceGenerate\n        return distObj\n\n    def generateWithRequiredOtherFieldsOwner(self, dclass, doId, di):\n        if doId in self.doId2ownerView:\n            # ...it is in our dictionary.\n            # Just update it.\n            self.notify.error('duplicate owner generate for %s (%s)' % (\n                doId, dclass.getName()))\n            distObj = self.doId2ownerView[doId]\n            assert distObj.dclass == dclass\n            distObj.generate()\n            distObj.updateRequiredOtherFields(dclass, di)\n            # updateRequiredOtherFields calls announceGenerate\n        elif self.cacheOwner.contains(doId):\n            # ...it is in the cache.\n            # Pull it out of the cache:\n            distObj = self.cacheOwner.retrieve(doId)\n            assert distObj.dclass == dclass\n            # put it in the dictionary:\n            self.doId2ownerView[doId] = distObj\n            # and update it.\n            distObj.generate()\n            distObj.updateRequiredOtherFields(dclass, di)\n            # updateRequiredOtherFields calls announceGenerate\n        else:\n            # ...it is not in the dictionary or the cache.\n            # Construct a new one\n            classDef = dclass.getOwnerClassDef()\n            if classDef is None:\n                self.notify.error(\"Could not create an undefined %s object. Have you created an owner view?\" % (dclass.getName()))\n            distObj = classDef(self)\n            distObj.dclass = dclass\n            # Assign it an Id\n            distObj.doId = doId\n            # Put the new do in the dictionary\n            self.doId2ownerView[doId] = distObj\n            # Update the required fields\n            distObj.generateInit()  # Only called when constructed\n            distObj.generate()\n            distObj.updateRequiredOtherFields(dclass, di)\n            # updateRequiredOtherFields calls announceGenerate\n        return distObj\n\n    def disableDoId(self, doId, ownerView=False):\n        table, cache = self.getTables(ownerView)\n        # Make sure the object exists\n        if doId in table:\n            # Look up the object\n            distObj = table[doId]\n            # remove the object from the dictionary\n            del table[doId]\n\n            # Only cache the object if it is a \"cacheable\" type\n            # object; this way we don't clutter up the caches with\n            # trivial objects that don't benefit from caching.\n            # also don't try to cache an object that is delayDeleted\n            cached = False\n            if distObj.getCacheable() and distObj.getDelayDeleteCount() <= 0:\n                cached = cache.cache(distObj)\n            if not cached:\n                distObj.deleteOrDelay()\n                if distObj.getDelayDeleteCount() <= 0:\n                    # make sure we're not leaking\n                    distObj.detectLeaks()\n\n        elif doId in self.deferredDoIds:\n            # The object had been deferred.  Great; we don't even have\n            # to generate it now.\n            del self.deferredDoIds[doId]\n            i = self.deferredGenerates.index((CLIENT_ENTER_OBJECT_REQUIRED_OTHER, doId))\n            del self.deferredGenerates[i]\n            if len(self.deferredGenerates) == 0:\n                taskMgr.remove('deferredGenerate')\n\n        else:\n            self._logFailedDisable(doId, ownerView)\n\n    def _logFailedDisable(self, doId, ownerView):\n        self.notify.warning(\n            \"Disable failed. DistObj \"\n            + str(doId) +\n            \" is not in dictionary, ownerView=%s\" % ownerView)\n\n    def handleDelete(self, di):\n        # overridden by ClientRepository\n        assert 0\n\n    def handleUpdateField(self, di):\n        \"\"\"\n        This method is called when a CLIENT_OBJECT_UPDATE_FIELD\n        message is received; it decodes the update, unpacks the\n        arguments, and calls the corresponding method on the indicated\n        DistributedObject.\n\n        In fact, this method is exactly duplicated by the C++ method\n        cConnectionRepository::handle_update_field(), which was\n        written to optimize the message loop by handling all of the\n        CLIENT_OBJECT_UPDATE_FIELD messages in C++.  That means that\n        nowadays, this Python method will probably never be called,\n        since UPDATE_FIELD messages will not even be passed to the\n        Python message handlers.  But this method remains for\n        documentation purposes, and also as a \"just in case\" handler\n        in case we ever do come across a situation in the future in\n        which python might handle the UPDATE_FIELD message.\n        \"\"\"\n        # Get the DO Id\n        doId = di.getUint32()\n\n        ovUpdated = self.__doUpdateOwner(doId, di)\n\n        if doId in self.deferredDoIds:\n            # This object hasn't really been generated yet.  Sit on\n            # the update.\n            args, deferrable, dg0, updates = self.deferredDoIds[doId]\n\n            # Keep a copy of the datagram, and move the di to the copy\n            dg = Datagram(di.getDatagram())\n            di = DatagramIterator(dg, di.getCurrentIndex())\n\n            updates.append((dg, di))\n        else:\n            # This object has been fully generated.  It's OK to update.\n            self.__doUpdate(doId, di, ovUpdated)\n\n    def __doUpdate(self, doId, di, ovUpdated):\n        # Find the DO\n        do = self.doId2do.get(doId)\n        if do is not None:\n            # Let the dclass finish the job\n            do.dclass.receiveUpdate(do, di)\n        elif not ovUpdated:\n            # this next bit is looking for avatar handles so that if you get an update\n            # for an avatar that isn't in your doId2do table but there is a\n            # avatar handle for that object then it's messages will be forwarded to that\n            # object. We are currently using that for whisper echoing\n            # if you need a more general perpose system consider registering proxy objects on\n            # a dict and adding the avatar handles to that dict when they are created\n            # then change/remove the old method. I didn't do that because I couldn't think\n            # of a use for it. -JML\n            try:\n                handle = self.identifyAvatar(doId)\n                if handle:\n                    dclass = self.dclassesByName[handle.dclassName]\n                    dclass.receiveUpdate(handle, di)\n                else:\n                    self.notify.warning(\n                        f\"Asked to update non-existent DistObj {doId}\")\n            except Exception:\n                self.notify.warning(\n                    f\"Asked to update non-existent DistObj {doId} and failed to find it\")\n\n    def __doUpdateOwner(self, doId, di):\n        if not self.hasOwnerView():\n            return False\n\n        ovObj = self.doId2ownerView.get(doId)\n        if ovObj:\n            odg = Datagram(di.getDatagram())\n            odi = DatagramIterator(odg, di.getCurrentIndex())\n            ovObj.dclass.receiveUpdate(ovObj, odi)\n            return True\n        return False\n\n    def handleGoGetLost(self, di):\n        # The server told us it's about to drop the connection on us.\n        # Get ready!\n        if di.getRemainingSize() > 0:\n            self.bootedIndex = di.getUint16()\n            self.bootedText = di.getString()\n\n            self.notify.warning(\n                f\"Server is booting us out ({self.bootedIndex}): {self.bootedText}\")\n        else:\n            self.bootedIndex = None\n            self.bootedText = None\n            self.notify.warning(\n                \"Server is booting us out with no explanation.\")\n\n        # disconnect now, don't wait for send/recv to fail\n        self.stopReaderPollTask()\n        self.lostConnection()\n\n    def handleServerHeartbeat(self, di):\n        # Got a heartbeat message from the server.\n        if ConfigVariableBool('server-heartbeat-info', True):\n            self.notify.info(\"Server heartbeat.\")\n\n    def handleSystemMessage(self, di):\n        # Got a system message from the server.\n        message = di.getString()\n        self.notify.info('Message from server: %s' % (message))\n        return message\n\n    def handleSystemMessageAknowledge(self, di):\n        # Got a system message from the server.\n        message = di.getString()\n        self.notify.info('Message with aknowledge from server: %s' % (message))\n        messenger.send(\"system message aknowledge\", [message])\n        return message\n\n    def getObjectsOfClass(self, objClass):\n        \"\"\" returns dict of doId:object, containing all objects\n        that inherit from 'class'. returned dict is safely mutable. \"\"\"\n        doDict = {}\n        for doId, do in self.doId2do.items():\n            if isinstance(do, objClass):\n                doDict[doId] = do\n        return doDict\n\n    def getObjectsOfExactClass(self, objClass):\n        \"\"\" returns dict of doId:object, containing all objects that\n        are exactly of type 'class' (neglecting inheritance). returned\n        dict is safely mutable. \"\"\"\n        doDict = {}\n        for doId, do in self.doId2do.items():\n            if do.__class__ == objClass:\n                doDict[doId] = do\n        return doDict\n\n    def considerHeartbeat(self):\n        \"\"\"Send a heartbeat message if we haven't sent one recently.\"\"\"\n        if not self.heartbeatStarted:\n            self.notify.debug(\"Heartbeats not started; not sending.\")\n            return\n\n        elapsed = ClockObject.getGlobalClock().getRealTime() - self.lastHeartbeat\n        if elapsed < 0 or elapsed > self.heartbeatInterval:\n            # It's time to send the heartbeat again (or maybe someone\n            # reset the clock back).\n            self.notify.info(\"Sending heartbeat mid-frame.\")\n            self.startHeartbeat()\n\n    def stopHeartbeat(self):\n        taskMgr.remove(\"heartBeat\")\n        self.heartbeatStarted = 0\n\n    def startHeartbeat(self):\n        self.stopHeartbeat()\n        self.heartbeatStarted = 1\n        self.sendHeartbeat()\n        self.waitForNextHeartBeat()\n\n    def sendHeartbeatTask(self, task):\n        self.sendHeartbeat()\n        return Task.again\n\n    def waitForNextHeartBeat(self):\n        taskMgr.doMethodLater(self.heartbeatInterval, self.sendHeartbeatTask,\n                              \"heartBeat\", taskChain='net')\n\n    def replaceMethod(self, oldMethod, newFunction):\n        return 0\n\n    def getWorld(self, doId):\n        # Get the world node for this object\n        obj = self.doId2do[doId]\n\n        worldNP = obj.getParent()\n        while 1:\n            nextNP = worldNP.getParent()\n            if nextNP == render:\n                break\n            elif worldNP.isEmpty():\n                return None\n        return worldNP\n\n    def isLive(self):\n        if ConfigVariableBool('force-live', False):\n            return True\n        return not (__dev__ or launcher.isTestServer())\n\n    def isLocalId(self, id):\n        # By default, no ID's are local.  See also\n        # ClientRepository.isLocalId().\n        return 0\n\n    # methods for tracking delaydeletes\n    def _addDelayDeletedDO(self, do):\n        # use the id of the object, it's possible to have multiple DelayDeleted instances\n        # with identical doIds if an object gets deleted then re-generated\n        key = id(do)\n        assert key not in self._delayDeletedDOs\n        self._delayDeletedDOs[key] = do\n\n    def _removeDelayDeletedDO(self, do):\n        key = id(do)\n        del self._delayDeletedDOs[key]\n\n    def printDelayDeletes(self):\n        print('DelayDeletes:')\n        print('=============')\n        for obj in self._delayDeletedDOs.values():\n            print('%s\\t%s (%s)\\tdelayDeletes=%s' % (\n                obj.doId, safeRepr(obj), itype(obj), obj.getDelayDeleteNames()))\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/ClientRepositoryBase.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/b80b02a3_ClientRepositoryBase.json",
    "doc_id": "doc_327"
  }
}