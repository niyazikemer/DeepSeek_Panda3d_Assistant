{
  "content": "Task Chains\n\nWhen you add tasks to the TaskManager, you are actually adding them to the default Task Chain. The TaskManager maintains one or more task chains; each chain is a list of tasks that are available to be executed.\n\nYou are free to create additional task chains as you see the need. Normally, though, there is no reason to have more than the default task chain, unless you wish to take advantage of threaded tasks: each task chain has the option of being serviced by one or more sub-threads, which allows the tasks on that chain to run in parallel with (or at a lower priority than) the main tasks.\n\nNote that threading is an advanced topic, and the use of threading inherently comes with risks. In particular, it is easy to introduce race conditions or deadlocks in code that involves multiple threads. You are responsible for protecting critical sections of your code from mutual access with proper use of synchronization primitives, such as provided by Panda's Mutex and ConditionVar classes, and for Python users, the direct.stdpy.threading module. For the purposes of this discussion, we will assume that you are already familiar with the proper use of synchronization primitives in threading.\n\nNote also that Panda may be compiled with a special threading mode (called \"simple threads\") that is designed to be low overhead, but which is fundamentally incompatible with true threads as provided by the system library. Thus, in any Panda application, you must always use Panda's synchronization primitives, and not the system-provided ones; and you must use Panda's thread primitives and not call into the system thread library directly, or you will risk a terrible crash. That is, you should use Panda's Thread and Mutex classes (or for Python users, the direct.stdpy.threading module), and not any system thread or mutex implementation. See threading for more.\n\nDefining task chains\n\nTo set up a new task chain, you simply call:\n\ncpp\n\nAsyncTaskManager *task_mgr = AsyncTaskManager::get_global_ptr();\nAsyncTaskChain *chain = task_mgr->make_task_chain(\"chain_name\");\n\nEach task chain must have a unique name. If you pass a name to make_task_chain() that has already been used, it will return the same pointer that was returned previously.\n\nOnce you have a task chain pointer, you may then set parameters on that instance to configure the chain according to your needs.\n\npython\n\ntaskMgr.setupTaskChain('chain_name', numThreads = None, tickClock = None,\n                       threadPriority = None, frameBudget = None,\n                       frameSync = None, timeslicePriority = None)\n\nTask chains are identified by their unique name. Repeated calls to setupTaskChain() with the same task chain name will reconfigure the same task chain.\n\nThe task chain parameters are:\n\npython\n\ncpp\n\nUsing task chains\n\npython\n\nYou may add any tasks to the task chain of your choosing with the optional taskChain parameter to taskMgr.add() or taskMgr.doMethodLater(). This parameter should receive the name of the task chain to add the task to; this is the 'chain_name' you specified in the above call to taskMgr.setupTaskChain(). For example:\n\ntaskMgr.add(self.myTaskFunc, 'myTaskName', taskChain = 'myChain')\n\ncpp\n\nYou may add any tasks to the task chain of your choosing by using AsyncTask::set_task_chain(). This method should receive the string name of the task chain to add the task to; this is the \"chain_name\" you specified in the above call to task_mgr->make_task_chain() <AsyncTaskManager::make_task_chain>. For example:\n\nPT(AsyncTask) task = new GenericAsyncTask(\"myTaskName\");\ntask->set_function(my_task_func);\ntask->set_task_chain(\"myChain\");\ntask_mgr->add(task);",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/6df8f2d1_task-chains.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/85c9384f_6df8f2d1_task-chains.json",
    "doc_id": "doc_602"
  }
}