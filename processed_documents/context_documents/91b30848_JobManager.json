{
  "content": "from panda3d.core import ConfigVariableBool, ConfigVariableDouble, ClockObject\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.showbase.Job import Job\nfrom direct.showbase.PythonUtil import flywheel\nfrom direct.showbase.MessengerGlobal import messenger\n\n\nclass JobManager:\n    \"\"\"\n    Similar to the taskMgr but designed for tasks that are CPU-intensive and/or\n    not time-critical. Jobs run in a fixed timeslice that the JobManager is\n    allotted each frame.\n    \"\"\"\n    notify = directNotify.newCategory(\"JobManager\")\n\n    # there's one task for the JobManager, all jobs run in this task\n    TaskName = 'jobManager'\n\n    def __init__(self, timeslice=None):\n        # how long do we run per frame\n        self._timeslice = timeslice\n        # store the jobs in these structures to allow fast lookup by various keys\n        # priority -> jobId -> job\n        self._pri2jobId2job = {}\n        # priority -> chronological list of jobIds\n        self._pri2jobIds = {}\n        # jobId -> priority\n        self._jobId2pri = {}\n        # how many timeslices to give each job; this is used to efficiently implement\n        # the relative job priorities\n        self._jobId2timeslices = {}\n        # how much time did the job use beyond the allotted timeslice, used to balance\n        # out CPU usage\n        self._jobId2overflowTime = {}\n        self._useOverflowTime = None\n        # this is a generator that we use to give high-priority jobs more timeslices,\n        # it yields jobIds in a sequence that includes high-priority jobIds more often\n        # than low-priority\n        self._jobIdGenerator = None\n        self._highestPriority = Job.Priorities.Normal\n\n    def destroy(self):\n        taskMgr.remove(JobManager.TaskName)\n        del self._pri2jobId2job\n\n    def add(self, job):\n        pri = job.getPriority()\n        jobId = job._getJobId()\n        # store the job in the main table\n        self._pri2jobId2job.setdefault(pri, {})\n        self._pri2jobId2job[pri][jobId] = job\n        # and also store a direct mapping from the job's ID to its priority\n        self._jobId2pri[jobId] = pri\n        # add the jobId onto the end of the list of jobIds for this priority\n        self._pri2jobIds.setdefault(pri, [])\n        self._pri2jobIds[pri].append(jobId)\n        # record the job's relative timeslice count\n        self._jobId2timeslices[jobId] = pri\n        # init the overflow time tracking\n        self._jobId2overflowTime[jobId] = 0.\n        # reset the jobId round-robin\n        self._jobIdGenerator = None\n        if len(self._jobId2pri) == 1:\n            taskMgr.add(self._process, JobManager.TaskName)\n            self._highestPriority = pri\n        elif pri > self._highestPriority:\n            self._highestPriority = pri\n        self.notify.debug('added job: %s' % job.getJobName())\n\n    def remove(self, job):\n        jobId = job._getJobId()\n        # look up the job's priority\n        pri = self._jobId2pri.pop(jobId)\n        # TODO: this removal is a linear search\n        self._pri2jobIds[pri].remove(jobId)\n        # remove the job from the main table\n        del self._pri2jobId2job[pri][jobId]\n        # clean up the job's generator, if any\n        job._cleanupGenerator()\n        # remove the job's timeslice count\n        self._jobId2timeslices.pop(jobId)\n        # remove the overflow time\n        self._jobId2overflowTime.pop(jobId)\n        if len(self._pri2jobId2job[pri]) == 0:\n            del self._pri2jobId2job[pri]\n            if pri == self._highestPriority:\n                if len(self._jobId2pri) > 0:\n                    # calculate a new highest priority\n                    # TODO: this is not very fast\n                    priorities = self._getSortedPriorities()\n                    self._highestPriority = priorities[-1]\n                else:\n                    taskMgr.remove(JobManager.TaskName)\n                    self._highestPriority = 0\n        self.notify.debug('removed job: %s' % job.getJobName())\n\n    def finish(self, job):\n        # run this job, right now, until it finishes\n        assert self.notify.debugCall()\n        jobId = job._getJobId()\n        # look up the job's priority\n        pri = self._jobId2pri[jobId]\n        # grab the job\n        job = self._pri2jobId2job[pri][jobId]\n        gen = job._getGenerator()\n        if __debug__:\n            job._pstats.start()\n        job.resume()\n        while True:\n            try:\n                result = next(gen)\n            except StopIteration:\n                # Job didn't yield Job.Done, it ran off the end and returned\n                # treat it as if it returned Job.Done\n                self.notify.warning('job %s never yielded Job.Done' % job)\n                result = Job.Done\n            if result is Job.Done:\n                job.suspend()\n                self.remove(job)\n                job._setFinished()\n                messenger.send(job.getFinishedEvent())\n                # job is done.\n                break\n        if __debug__:\n            job._pstats.stop()\n\n    # how long should we run per frame?\n    @staticmethod\n    def getDefaultTimeslice():\n        # run for 1/2 millisecond per frame by default\n        # config is in milliseconds, this func returns value in seconds\n        return ConfigVariableDouble('job-manager-timeslice-ms', .5).value / 1000.\n\n    def getTimeslice(self):\n        if self._timeslice:\n            return self._timeslice\n        return self.getDefaultTimeslice()\n    def setTimeslice(self, timeslice):\n        self._timeslice = timeslice\n\n    def _getSortedPriorities(self):\n        # returns all job priorities in ascending order\n        return sorted(self._pri2jobId2job)\n\n    def _process(self, task=None):\n        if self._useOverflowTime is None:\n            self._useOverflowTime = ConfigVariableBool('job-use-overflow-time', 1).value\n\n        if len(self._pri2jobId2job) > 0:\n            clock = ClockObject.getGlobalClock()\n            #assert self.notify.debugCall()\n            # figure out how long we can run\n            endT = clock.getRealTime() + (self.getTimeslice() * .9)\n            while True:\n                if self._jobIdGenerator is None:\n                    # round-robin the jobs, giving high-priority jobs more timeslices\n                    self._jobIdGenerator = flywheel(\n                        list(self._jobId2timeslices.keys()),\n                        countFunc = lambda jobId: self._jobId2timeslices[jobId])\n                try:\n                    # grab the next jobId in the sequence\n                    jobId = next(self._jobIdGenerator)\n                except StopIteration:\n                    self._jobIdGenerator = None\n                    continue\n                # OK, we've selected a job to run\n                pri = self._jobId2pri.get(jobId)\n                if pri is None:\n                    # this job is no longer present\n                    continue\n                # check if there's overflow time that we need to make up for\n                if self._useOverflowTime:\n                    overflowTime = self._jobId2overflowTime[jobId]\n                    timeLeft = endT - clock.getRealTime()\n                    if overflowTime >= timeLeft:\n                        self._jobId2overflowTime[jobId] = max(0., overflowTime-timeLeft)\n                        # don't run any more jobs this frame, this makes up\n                        # for the extra overflow time that was used before\n                        break\n                job = self._pri2jobId2job[pri][jobId]\n                gen = job._getGenerator()\n                if __debug__:\n                    job._pstats.start()\n                job.resume()\n                while clock.getRealTime() < endT:\n                    try:\n                        result = next(gen)\n                    except StopIteration:\n                        # Job didn't yield Job.Done, it ran off the end and returned\n                        # treat it as if it returned Job.Done\n                        self.notify.warning('job %s never yielded Job.Done' % job)\n                        result = Job.Done\n\n                    if result is Job.Sleep:\n                        job.suspend()\n                        if __debug__:\n                            job._pstats.stop()\n                        # grab the next job if there's time left\n                        break\n                    elif result is Job.Done:\n                        job.suspend()\n                        self.remove(job)\n                        job._setFinished()\n                        if __debug__:\n                            job._pstats.stop()\n                        messenger.send(job.getFinishedEvent())\n                        # grab the next job if there's time left\n                        break\n                else:\n                    # we've run out of time\n                    #assert self.notify.debug('timeslice end: %s, %s' % (endT, clock.getRealTime()))\n                    job.suspend()\n                    overflowTime = clock.getRealTime() - endT\n                    if overflowTime > self.getTimeslice():\n                        self._jobId2overflowTime[jobId] += overflowTime\n                    if __debug__:\n                        job._pstats.stop()\n                    break\n\n                if len(self._pri2jobId2job) == 0:\n                    # there's nothing left to do, all the jobs are done!\n                    break\n        return task.cont\n\n    def __repr__(self):\n        s  =   '======================================================='\n        s += '\\nJobManager: active jobs in descending order of priority'\n        s += '\\n======================================================='\n        pris = self._getSortedPriorities()\n        if len(pris) == 0:\n            s += '\\n    no jobs running'\n        else:\n            pris.reverse()\n            for pri in pris:\n                jobId2job = self._pri2jobId2job[pri]\n                # run through the jobs at this priority in the order that they will run\n                for jobId in self._pri2jobIds[pri]:\n                    job = jobId2job[jobId]\n                    s += '\\n%5d: %s (jobId %s)' % (pri, job.getJobName(), jobId)\n        s += '\\n'\n        return s\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/JobManager.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/91b30848_JobManager.json",
    "doc_id": "doc_238"
  }
}