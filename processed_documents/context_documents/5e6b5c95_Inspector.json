{
  "content": "\"\"\"Inspectors allow you to visually browse through the members of\nvarious Python objects.  To open an inspector, import this module, and\nexecute ``inspector.inspect(anObject)``.\n\nI start IDLE with this command line::\n\n   idle.py -c \"from inspector import inspect\"\n\nso that I can just type: ``inspect(anObject)`` any time.\n\nSee :ref:`inspection-utilities` for more information.\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = ['inspect', 'inspectorFor', 'Inspector', 'ModuleInspector', 'ClassInspector', 'InstanceInspector', 'FunctionInspector', 'InstanceMethodInspector', 'CodeInspector', 'ComplexInspector', 'DictionaryInspector', 'SequenceInspector', 'SliceInspector', 'InspectorWindow']\n\nimport Pmw\nimport tkinter as tk\n\n### public API\n\n\ndef inspect(anObject):\n    \"\"\"Opens up a window for visually inspecting the details of a given Python\n    object.  See :ref:`inspection-utilities`.\n    \"\"\"\n    inspector = inspectorFor(anObject)\n    inspectorWindow = InspectorWindow(inspector)\n    inspectorWindow.open()\n    return inspectorWindow\n\n### private\n\n_InspectorMap: dict[str, str]\n\n\ndef inspectorFor(anObject):\n    typeName = type(anObject).__name__.capitalize() + 'Type'\n    if typeName in _InspectorMap:\n        inspectorName = _InspectorMap[typeName]\n    else:\n        print((\"Can't find an inspector for \" + typeName))\n        inspectorName = 'Inspector'\n    inspector = globals()[inspectorName](anObject)\n    return inspector\n\n\n### initializing\n\ndef initializeInspectorMap():\n    global _InspectorMap\n    notFinishedTypes = ['BufferType',  'EllipsisType',  'FrameType', 'TracebackType', 'XRangeType']\n\n    _InspectorMap = {\n        'Builtin_function_or_methodType': 'FunctionInspector',\n        'BuiltinFunctionType': 'FunctionInspector',\n        'BuiltinMethodType': 'FunctionInspector',\n        'ClassType': 'ClassInspector',\n        'CodeType': 'CodeInspector',\n        'ComplexType': 'Inspector',\n        'DictionaryType': 'DictionaryInspector',\n        'DictType': 'DictionaryInspector',\n        'FileType': 'Inspector',\n        'FloatType': 'Inspector',\n        'FunctionType': 'FunctionInspector',\n        'Instance methodType': 'InstanceMethodInspector',\n        'InstanceType': 'InstanceInspector',\n        'IntType': 'Inspector',\n        'LambdaType': 'Inspector',\n        'ListType': 'SequenceInspector',\n        'LongType': 'Inspector',\n        'MethodType': 'FunctionInspector',\n        'ModuleType': 'ModuleInspector',\n        'NoneType': 'Inspector',\n        'SliceType': 'SliceInspector',\n        'StringType': 'SequenceInspector',\n        'TupleType': 'SequenceInspector',\n        'TypeType': 'Inspector',\n        'UnboundMethodType': 'FunctionInspector',\n    }\n\n    for each in notFinishedTypes:\n        _InspectorMap[each] = 'Inspector'\n\n\n### Classes\n\nclass Inspector:\n    def __init__(self, anObject):\n        self.object = anObject\n        self.lastPartNumber = 0\n        self.initializePartsList()\n        self.initializePartNames()\n\n    def __str__(self):\n        return __name__ + '(' + str(self.object) + ')'\n\n    def initializePartsList(self):\n        self._partsList = []\n        for each in sorted(self.namedParts()):\n            self._partsList.append(each)\n            #if not callable(getattr(self.object, each)):\n            #    self._partsList.append(each)\n\n    def initializePartNames(self):\n        self._partNames = ['up'] + [str(each) for each in self._partsList]\n\n    def title(self):\n        \"Subclasses may override.\"\n        return self.objectType().__name__.capitalize()\n\n    def getLastPartNumber(self):\n        return self.lastPartNumber\n\n    def selectedPart(self):\n        return self.partNumber(self.getLastPartNumber())\n\n    def namedParts(self):\n        return dir(self.object)\n\n    def stringForPartNumber(self, partNumber):\n        object = self.partNumber(partNumber)\n        doc = None\n        if callable(object):\n            doc = getattr(object, '__doc__', None)\n        if doc:\n            return str(object) + '\\n' + str(doc)\n        else:\n            return str(object)\n\n    def partNumber(self, partNumber):\n        self.lastPartNumber = partNumber\n        if partNumber == 0:\n            return self.object\n        else:\n            part = self.privatePartNumber(partNumber)\n            return getattr(self.object, part)\n\n    def inspectorFor(self, part):\n        return inspectorFor(part)\n\n    def privatePartNumber(self, partNumber):\n        return self._partsList[partNumber - 1]\n\n    def partNames(self):\n        return self._partNames\n\n    def objectType(self):\n        return type(self.object)\n\n###\n\n\nclass ModuleInspector(Inspector):\n    def namedParts(self):\n        return ['__dict__']\n\n\nclass ClassInspector(Inspector):\n    def namedParts(self):\n        return ['__bases__'] + list(self.object.__dict__.keys())\n\n    def title(self):\n        return self.object.__name__ + ' Class'\n\n\nclass InstanceInspector(Inspector):\n    def title(self):\n        return self.object.__class__.__name__\n\n    def namedParts(self):\n        return ['__class__'] + dir(self.object)\n\n###\n\n\nclass FunctionInspector(Inspector):\n    def title(self):\n        return self.object.__name__ + \"()\"\n\n\nclass InstanceMethodInspector(Inspector):\n    def title(self):\n        return str(self.object.__self__.__class__) + \".\" + self.object.__name__ + \"()\"\n\n\nclass CodeInspector(Inspector):\n    def title(self):\n        return str(self.object)\n\n###\n\n\nclass ComplexInspector(Inspector):\n    def namedParts(self):\n        return ['real', 'imag']\n\n###\n\n\nclass DictionaryInspector(Inspector):\n\n    def initializePartsList(self):\n        Inspector.initializePartsList(self)\n        for each in sorted(self.object):\n            self._partsList.append(each)\n\n    def partNumber(self, partNumber):\n        self.lastPartNumber = partNumber\n        if partNumber == 0:\n            return self.object\n        key = self.privatePartNumber(partNumber)\n        if key in self.object:\n            return self.object[key]\n        else:\n            return getattr(self.object, key)\n\n\nclass SequenceInspector(Inspector):\n    def initializePartsList(self):\n        Inspector.initializePartsList(self)\n        for each in range(len(self.object)):\n            self._partsList.append(each)\n\n    def partNumber(self, partNumber):\n        self.lastPartNumber = partNumber\n        if partNumber == 0:\n            return self.object\n        index = self.privatePartNumber(partNumber)\n        if isinstance(index, int):\n            return self.object[index]\n        else:\n            return getattr(self.object, index)\n\n\nclass SliceInspector(Inspector):\n    def namedParts(self):\n        return ['start', 'stop', 'step']\n\n\n### Initialization\ninitializeInspectorMap()\n\n\nclass InspectorWindow:\n    def __init__(self, inspector):\n        self.inspectors = [inspector]\n\n    def topInspector(self):\n        return self.inspectors[len(self.inspectors) - 1]\n\n    def selectedPart(self):\n        return self.topInspector().selectedPart()\n\n    def inspectedObject(self):\n        return self.topInspector().object\n\n    def open(self):\n        self.top= tk.Toplevel()\n        self.top.geometry('650x315')\n        self.createViews()\n        self.update()\n\n    #Private - view construction\n    def createViews(self):\n        self.createMenus()\n        # Paned widget for dividing two halves\n        self.framePane = Pmw.PanedWidget(self.top, orient = tk.HORIZONTAL)\n        self.createListWidget()\n        self.createTextWidgets()\n        self.framePane.pack(expand = 1, fill = tk.BOTH)\n\n    def setTitle(self):\n        self.top.title('Inspecting: ' + self.topInspector().title())\n\n    def createListWidget(self):\n        listFrame = self.framePane.add('list')\n        listWidget = self.listWidget = Pmw.ScrolledListBox(\n            listFrame, vscrollmode = 'static')\n        listWidget.pack(side=tk.LEFT, fill=tk.BOTH, expand=1)\n        # If you click in the list box, take focus so you can navigate\n        # with the cursor keys\n        listbox = listWidget.component('listbox')\n        listbox.bind('<ButtonPress-1>',\n                        lambda e, l = listbox: l.focus_set())\n        listbox.bind('<ButtonRelease-1>',  self.listSelectionChanged)\n        listbox.bind('<Double-Button-1>', self.popOrDive)\n        listbox.bind('<ButtonPress-3>', self.popupMenu)\n        listbox.bind('<KeyRelease-Up>',  self.listSelectionChanged)\n        listbox.bind('<KeyRelease-Down>',  self.listSelectionChanged)\n        listbox.bind('<KeyRelease-Left>', lambda e, s = self: s.pop())\n        listbox.bind('<KeyRelease-Right>', lambda e, s = self: s.dive())\n        listbox.bind('<Return>',  self.popOrDive)\n\n    def createTextWidgets(self):\n        textWidgetsFrame = self.framePane.add('textWidgets')\n        self.textPane = Pmw.PanedWidget(textWidgetsFrame, orient = tk.VERTICAL)\n        textFrame = self.textPane.add('text', size = 200)\n        self.textWidget = Pmw.ScrolledText(\n            textFrame, vscrollmode = 'static', text_state = 'disabled')\n        self.textWidget.pack(fill=tk.BOTH, expand=1)\n        commandFrame = self.textPane.add('command')\n        self.commandWidget = Pmw.ScrolledText(\n            commandFrame, vscrollmode = 'static')\n        self.commandWidget.insert(1.0, '>>> ')\n        self.commandWidget.pack(fill = tk.BOTH, expand = 1)\n        self.commandWidget.component('text').bind(\n            '<KeyRelease-Return>', self.evalCommand)\n        self.textPane.pack(expand = 1, fill = tk.BOTH)\n\n    def createMenus(self):\n        self.menuBar = tk.Menu(self.top)\n        self.top.config(menu=self.menuBar)\n        inspectMenu = tk.Menu(self.menuBar)\n        self.menuBar.add_cascade(label='Inspect', menu=inspectMenu)\n        inspectMenu.add_command(label='Pop', command=self.pop)\n        inspectMenu.add_command(label='Dive', command=self.dive)\n        inspectMenu.add_command(label='Inspect', command=self.inspect)\n        helpMenu = tk.Menu(self.menuBar)\n        self.menuBar.add_cascade(label='Help', menu=helpMenu)\n        helpMenu.add_command(label='Instructions', command=self.showHelp)\n\n    def fillList(self):\n        self.listWidget.delete(0, tk.END)\n        for each in self.topInspector().partNames():\n            self.listWidget.insert(tk.END, each)\n        self.listWidget.select_clear(0)\n\n    # Event Handling\n    def listSelectionChanged(self, event):\n        partNumber = self.selectedIndex()\n        if partNumber is None:\n            partNumber = 0\n        string = self.topInspector().stringForPartNumber(partNumber)\n        self.textWidget.component('text').configure(state = 'normal')\n        self.textWidget.delete('1.0', tk.END)\n        self.textWidget.insert(tk.END, string)\n        self.textWidget.component('text').configure(state = 'disabled')\n\n    def popOrDive(self, event):\n        \"\"\"The list has been double-clicked. If the selection is 'self' then pop,\n        otherwise dive into the selected part\"\"\"\n        if self.selectedIndex() == 0:\n            self.pop()\n        else:\n            self.dive()\n\n    def evalCommand(self, event):\n        \"\"\"Eval text in commandWidget\"\"\"\n        insertPt = self.commandWidget.index(tk.INSERT)\n        commandLineStart = self.commandWidget.search(\n            '>>> ', tk.INSERT, backwards = 1)\n        if commandLineStart:\n            commandStart = self.commandWidget.index(\n                commandLineStart + ' + 4 chars')\n            command = self.commandWidget.get(commandStart,\n                                             commandStart + ' lineend')\n            if command:\n                partDict = {'this': self.selectedPart(),\n                            'object': self.topInspector().object}\n                result = eval(command, partDict)\n                self.commandWidget.insert(tk.INSERT, repr(result) + '\\n>>> ')\n                self.commandWidget.see(tk.INSERT)\n\n    # Menu Events\n    def inspect(self):\n        inspector = self.inspectorForSelectedPart()\n        if inspector is None:\n            return\n        InspectorWindow(inspector).open()\n\n    def pop(self):\n        if len(self.inspectors) > 1:\n            self.inspectors = self.inspectors[:-1]\n            self.update()\n\n    def dive(self):\n        inspector = self.inspectorForSelectedPart()\n        if inspector is None:\n            return\n        self.inspectors.append(inspector)\n        self.update()\n\n    def update(self):\n        self.setTitle()\n        self.fillList()\n        # What is active part in this inspector\n        partNumber = self.topInspector().getLastPartNumber()\n        self.listWidget.select_clear(0)\n        self.listWidget.activate(partNumber)\n        self.listWidget.select_set(partNumber)\n        self.listSelectionChanged(None)\n        # Make sure selected item is visible\n        self.listWidget.see(partNumber)\n        # Make sure left side of listbox visible\n        self.listWidget.xview_moveto(0.0)\n        # Grab focus in listbox\n        self.listWidget.component('listbox').focus_set()\n\n    def showHelp(self):\n        from direct.showbase import ShowBaseGlobal\n        help = tk.Toplevel(ShowBaseGlobal.base.tkRoot)\n        help.title(\"Inspector Help\")\n        frame = tk.Frame(help)\n        frame.pack()\n        text = tk.Label(\n            frame, justify = tk.LEFT,\n            text = \"ListBox shows selected object's attributes\\nDouble click or use right arrow on an instance variable to dive down.\\nDouble click self or use left arrow to pop back up.\\nUse up and down arrow keys to move from item to item in the current level.\\n\\nValue box (upper right) shows current value of selected item\\n\\nCommand box (lower right) is used to evaluate python commands\\nLocal variables 'object' and 'this' are defined as the current object being inspected\\nand the current attribute selected.\"\n        )\n        text.pack()\n\n    #Private\n    def selectedIndex(self):\n        indices = list(map(int, self.listWidget.curselection()))\n        if len(indices) == 0:\n            return None\n        partNumber = indices[0]\n        return partNumber\n\n    def inspectorForSelectedPart(self):\n        partNumber = self.selectedIndex()\n        if partNumber is None:\n            return None\n        part = self.topInspector().partNumber(partNumber)\n        return self.topInspector().inspectorFor(part)\n\n    def popupMenu(self, event):\n        print(event)\n        partNumber = self.selectedIndex()\n        print(partNumber)\n        if partNumber is None:\n            return\n        part = self.topInspector().partNumber(partNumber)\n        print(part)\n        from panda3d.core import NodePath\n        from direct.fsm import ClassicFSM\n        popupMenu = None\n        if isinstance(part, NodePath):\n            popupMenu = self.createPopupMenu(\n                part,\n                [('Explore', NodePath.explore),\n                 ('Place', NodePath.place),\n                 ('Set Color', NodePath.rgbPanel)])\n        elif isinstance(part, ClassicFSM.ClassicFSM):\n            from . import FSMInspector\n            popupMenu = self.createPopupMenu(\n                part,\n                [('Inspect ClassicFSM', FSMInspector.FSMInspector)])\n        print(popupMenu)\n        if popupMenu:\n            popupMenu.post(event.widget.winfo_pointerx(),\n                           event.widget.winfo_pointery())\n\n    def createPopupMenu(self, part, menuList):\n        popupMenu = tk.Menu(self.top, tearoff = 0)\n        for item, func in menuList:\n            popupMenu.add_command(\n                label = item,\n                command = lambda p = part, f = func: f(p))\n        return popupMenu\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/tkpanels/Inspector.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/5e6b5c95_Inspector.json",
    "doc_id": "doc_62"
  }
}