{
  "content": "\"\"\"Defines the `FSMInspector` class, which opens a Tkinter window for\ninspecting :ref:`finite-state-machines`.\n\nUsing the Finite State Inspector\n--------------------------------\n\n1) In your Config.prc add::\n\n    want-tk #t\n\n2) Start up the show and create a Finite State Machine::\n\n    from direct.showbase.ShowBaseGlobal import *\n\n    from direct.fsm import ClassicFSM\n    from direct.fsm import State\n\n    def enterState():\n        print('enterState')\n\n    def exitState():\n        print 'exitState'\n\n    fsm = ClassicFSM.ClassicFSM('stopLight',\n              [State.State('red', enterState, exitState, ['green']),\n                State.State('yellow', enterState, exitState, ['red']),\n                State.State('green', enterState, exitState, ['yellow'])],\n              'red',\n              'red')\n\n    import FSMInspector\n\n    inspector = FSMInspector.FSMInspector(fsm, title = fsm.getName())\n\n    # Note, the inspectorPos argument is optional, the inspector will\n    # automagically position states on startup\n    fsm = ClassicFSM.ClassicFSM('stopLight', [\n        State.State('yellow',\n                    enterState,\n                    exitState,\n                    ['red'],\n                    inspectorPos = [95.9, 48.0]),\n        State.State('red',\n                    enterState,\n                    exitState,\n                    ['green'],\n                    inspectorPos = [0.0, 0.0]),\n        State.State('green',\n                    enterState,\n                    exitState,\n                    ['yellow'],\n                    inspectorPos = [0.0, 95.9])],\n            'red',\n            'red')\n\n3) Pop open a viewer::\n\n    import FSMInspector\n    insp = FSMInspector.FSMInspector(fsm)\n\nor if you wish to be fancy::\n\n    insp = FSMInspector.FSMInspector(fsm, title = fsm.getName())\n\nFeatures:\n\n  - Right mouse button over a state pops up a menu allowing you to\n    request a transition to that state\n  - Middle mouse button will grab the canvas and slide things around if\n    your state machine is bigger than the viewing area\n  - There are some self explanatory menu options up at the top, the most\n    useful being: \"print ClassicFSM layout\" which will print out Python\n    code which will create an ClassicFSM augmented with layout\n    information for the viewer so everything shows up in the same place\n    the next time you inspect the state machine\n\nCaveat\n------\n\nThere is an unexplained problem with using Tk and emacs right now which\noccasionally results in everything locking up.  This procedure seems to\navoid the problem for me::\n\n   # Start up the show\n   from direct.showbase.ShowBaseGlobal import *\n\n   # You will see the window and a Tk panel pop open\n\n   # Type a number at the emacs prompt\n   >>> 123\n\n   # At this point everything will lock up and you won't get your prompt back\n\n   # Hit a bunch of Control-C's in rapid succession, in most cases\n   # this will break you out of whatever badness you were in and\n   # from that point on everything will behave normally\n\n\n   # This is how you pop up an inspector\n   import FSMInspector\n   inspector = FSMInspector.FSMInspector(fsm, title = fsm.getName())\n\n\"\"\"\n\n__all__ = ['FSMInspector', 'StateInspector']\n\nfrom direct.tkwidgets.AppShell import AppShell\nfrom tkinter.simpledialog import askstring\nimport Pmw\nimport math\nimport operator\nimport tkinter as tk\n\n\nDELTA = (5.0 / 360.) * 2.0 * math.pi\n\n\nclass FSMInspector(AppShell):\n    # Override class variables\n    appname = 'ClassicFSM Inspector'\n    frameWidth  = 400\n    frameHeight = 450\n    usecommandarea = 0\n    usestatusarea  = 0\n\n    def __init__(self, fsm, **kw):\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            ('title', fsm.getName(), None),\n            ('gridSize', '0.25i', self._setGridSize),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        self.fsm = fsm\n        # Tell the fsm we are inspecting it so it will send events\n        # when it changes state\n        self.fsm.inspecting = 1\n\n        AppShell.__init__(self)\n\n        self.initialiseoptions(FSMInspector)\n\n    def appInit(self):\n        # Initialize instance variables\n        self.states = []\n        self.stateInspectorDict = {}\n        self.name = self.fsm.getName()\n\n    def createInterface(self):\n        # Create the components\n        interior = self.interior()\n        menuBar = self.menuBar\n\n        # ClassicFSM Menu\n        menuBar.addmenu('ClassicFSM', 'ClassicFSM Operations')\n        menuBar.addmenuitem('ClassicFSM', 'command',\n                                  'Input grid spacing',\n                                  label = 'Grid spacing...',\n                                  command = self.popupGridDialog)\n        # Create the checkbutton variable\n        self._fGridSnap = tk.IntVar()\n        self._fGridSnap.set(1)\n        menuBar.addmenuitem('ClassicFSM', 'checkbutton',\n                                  'Enable/disable grid',\n                                  label = 'Snap to grid',\n                                  variable = self._fGridSnap,\n                                  command = self.toggleGridSnap)\n        menuBar.addmenuitem('ClassicFSM', 'command',\n                                  'Print out ClassicFSM layout',\n                                  label = 'Print ClassicFSM layout',\n                                  command = self.printLayout)\n\n        # States Menu\n        menuBar.addmenu('States', 'State Inspector Operations')\n        menuBar.addcascademenu('States', 'Font Size',\n                                     'Set state label size', tearoff = 1)\n        for size in (8, 10, 12, 14, 18, 24):\n            menuBar.addmenuitem('Font Size', 'command',\n                'Set font to: ' + repr(size) + ' Pts', label = repr(size) + ' Pts',\n                command = lambda s = self, sz = size: s.setFontSize(sz))\n        menuBar.addcascademenu('States', 'Marker Size',\n                                     'Set state marker size', tearoff = 1)\n        for size in ('Small', 'Medium', 'Large'):\n            sizeDict = {'Small': '0.25i', 'Medium': '0.375i', 'Large': '0.5i'}\n            menuBar.addmenuitem('Marker Size', 'command',\n                size + ' markers', label = size + ' Markers',\n                command = lambda s = self, sz = size, d = sizeDict:\n                    s.setMarkerSize(d[sz]))\n\n        # The Scrolled Canvas\n        self._scrolledCanvas = self.createcomponent('scrolledCanvas',\n                (), None,\n                Pmw.ScrolledCanvas, (interior,),\n                hull_width = 400, hull_height = 400,\n                usehullsize = 1)\n        self._canvas = self._scrolledCanvas.component('canvas')\n        self._canvas['scrollregion'] = ('-2i', '-2i', '2i', '2i')\n        self._scrolledCanvas.resizescrollregion()\n        self._scrolledCanvas.pack(padx = 5, pady = 5, expand=1, fill = tk.BOTH)\n\n        # Update lines\n        self._canvas.bind('<B1-Motion>', self.drawConnections)\n        self._canvas.bind('<ButtonPress-2>', self.mouse2Down)\n        self._canvas.bind('<B2-Motion>', self.mouse2Motion)\n        self._canvas.bind('<Configure>',\n                          lambda e, sc = self._scrolledCanvas:\n                          sc.resizescrollregion())\n\n        self.createStateInspectors()\n\n        self.initialiseoptions(FSMInspector)\n\n    def scrolledCanvas(self):\n        return self._scrolledCanvas\n\n    def canvas(self):\n        return self._canvas\n\n    def setFontSize(self, size):\n        self._canvas.itemconfigure('labels', font = ('MS Sans Serif', size))\n\n    def setMarkerSize(self, size):\n        for key in self.stateInspectorDict:\n            self.stateInspectorDict[key].setRadius(size)\n        self.drawConnections()\n\n    def drawConnections(self, event = None):\n        # Get rid of existing arrows\n        self._canvas.delete('arrow')\n        for key in self.stateInspectorDict:\n            si = self.stateInspectorDict[key]\n            state = si.state\n            if state.getTransitions():\n                for name in state.getTransitions():\n                    self.connectStates(si, self.getStateInspector(name))\n\n    def connectStates(self, fromState, toState):\n        endpts = self.computeEndpoints(fromState, toState)\n        line = self._canvas.create_line(endpts, tags = ('arrow',),\n                                        arrow = 'last')\n\n    def computeEndpoints(self, fromState, toState):\n        # Compute angle between two points\n        fromCenter = fromState.center()\n        toCenter = toState.center()\n        angle = self.findAngle(fromCenter, toCenter)\n\n        # Compute offset fromState point\n        newFromPt = map(operator.__add__,\n                        fromCenter,\n                        self.computePoint(fromState.radius,\n                                           angle + DELTA))\n\n        # Compute offset toState point\n        newToPt = map(operator.__sub__,\n                      toCenter,\n                      self.computePoint(toState.radius,\n                                         angle - DELTA))\n        return list(newFromPt) + list(newToPt)\n\n    def computePoint(self, radius, angle):\n        x = radius * math.cos(angle)\n        y = radius * math.sin(angle)\n        return (x, y)\n\n    def findAngle(self, fromPoint, toPoint):\n        dx = toPoint[0] - fromPoint[0]\n        dy = toPoint[1] - fromPoint[1]\n        return math.atan2(dy, dx)\n\n    def mouse2Down(self, event):\n        self._width = 1.0 * self._canvas.winfo_width()\n        self._height = 1.0 * self._canvas.winfo_height()\n        xview = self._canvas.xview()\n        yview = self._canvas.yview()\n        self._left = xview[0]\n        self._top = yview[0]\n        self._dxview = xview[1] - xview[0]\n        self._dyview = yview[1] - yview[0]\n        self._2lx = event.x\n        self._2ly = event.y\n\n    def mouse2Motion(self, event):\n        newx = self._left - ((event.x - self._2lx)/self._width) * self._dxview\n        self._canvas.xview_moveto(newx)\n        newy = self._top - ((event.y - self._2ly)/self._height) * self._dyview\n        self._canvas.yview_moveto(newy)\n        self._2lx = event.x\n        self._2ly = event.y\n        self._left = self._canvas.xview()[0]\n        self._top = self._canvas.yview()[0]\n\n    def createStateInspectors(self):\n        fsm = self.fsm\n        self.states = fsm.getStates()\n        # Number of rows/cols needed to fit inspectors in a grid\n        dim = int(math.ceil(math.sqrt(len(self.states))))\n        # Separation between nodes\n        spacing = 2.5 * self._canvas.canvasx('0.375i')\n        count = 0\n        for state in self.states:\n            si = self.addState(state)\n            if state.getInspectorPos():\n                si.setPos(state.getInspectorPos()[0],\n                          state.getInspectorPos()[1])\n            else:\n                row = int(math.floor(count / dim))\n                col = count % dim\n                si.setPos(col * spacing, row * spacing +\n                          0.5 * (0, spacing)[col % 2])\n            # Add hooks\n            self.accept(self.name + '_' + si.getName() + '_entered',\n                        si.enteredState)\n            self.accept(self.name + '_' + si.getName() + '_exited',\n                        si.exitedState)\n            count = count + 1\n        self.drawConnections()\n        if fsm.getCurrentState():\n            self.enteredState(fsm.getCurrentState().getName())\n\n    def getStateInspector(self, name):\n        return self.stateInspectorDict.get(name, None)\n\n    def addState(self, state):\n        si = self.stateInspectorDict[state.getName()] = (\n            StateInspector(self, state))\n        return si\n\n    def enteredState(self, stateName):\n        si = self.stateInspectorDict.get(stateName, None)\n        if si:\n            si.enteredState()\n\n    def exitedState(self, stateName):\n        si = self.stateInspectorDict.get(stateName, None)\n        if si:\n            si.exitedState()\n\n    def _setGridSize(self):\n        self._gridSize = self['gridSize']\n        self.setGridSize(self._gridSize)\n\n    def setGridSize(self, size):\n        for key in self.stateInspectorDict:\n            self.stateInspectorDict[key].setGridSize(size)\n\n    def popupGridDialog(self):\n        spacing = askstring('ClassicFSM Grid Spacing', 'Grid Spacing:')\n        if spacing:\n            self.setGridSize(spacing)\n            self._gridSize = spacing\n\n    def toggleGridSnap(self):\n        if self._fGridSnap.get():\n            self.setGridSize(self._gridSize)\n        else:\n            self.setGridSize(0)\n\n    def printLayout(self):\n        dict = self.stateInspectorDict\n        keys = sorted(dict)\n        print(\"ClassicFSM.ClassicFSM('%s', [\" % self.name)\n        for key in keys[:-1]:\n            si = dict[key]\n            center = si.center()\n            print(\"    State.State('%s',\" % si.state.getName())\n            print(\"                %s,\" % si.state.getEnterFunc().__name__)\n            print(\"                %s,\" % si.state.getExitFunc().__name__)\n            print(\"                %s,\" % si.state.getTransitions())\n            print(\"                inspectorPos = [%.1f, %.1f]),\" % (center[0], center[1]))\n        for key in keys[-1:]:\n            si = dict[key]\n            center = si.center()\n            print(\"    State.State('%s',\" % si.state.getName())\n            print(\"                %s,\" % si.state.getEnterFunc().__name__)\n            print(\"                %s,\" % si.state.getExitFunc().__name__)\n            print(\"                %s,\" % si.state.getTransitions())\n            print(\"                inspectorPos = [%.1f, %.1f])],\" % (center[0], center[1]))\n        print(\"        '%s',\" % self.fsm.getInitialState().getName())\n        print(\"        '%s')\" % self.fsm.getFinalState().getName())\n\n    def toggleBalloon(self):\n        if self.toggleBalloonVar.get():\n            self.balloon.configure(state = 'balloon')\n        else:\n            self.balloon.configure(state = 'none')\n\n    def onDestroy(self, event):\n        \"\"\" Called on ClassicFSM Panel shutdown \"\"\"\n        self.fsm.inspecting = 0\n        for si in self.stateInspectorDict.values():\n            self.ignore(self.name + '_' + si.getName() + '_entered')\n            self.ignore(self.name + '_' + si.getName() + '_exited')\n\n\nclass StateInspector(Pmw.MegaArchetype):\n    def __init__(self, inspector, state, **kw):\n\n        # Record inspector and state\n        self.inspector = inspector\n        self.state = state\n        # Create a unique tag which you can use to move a marker and\n        # and its corresponding text around together\n        self.tag = state.getName()\n        self.fsm = inspector.fsm\n\n        # Pointers to the inspector's components\n        self.scrolledCanvas = inspector.component('scrolledCanvas')\n        self._canvas = self.scrolledCanvas.component('canvas')\n\n        #define the megawidget options\n        optiondefs = (\n            ('radius', '0.375i', self._setRadius),\n            ('gridSize', '0.25i', self._setGridSize),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Initialize the parent class\n        Pmw.MegaArchetype.__init__(self)\n\n        # Draw the oval\n        self.x = 0\n        self.y = 0\n        half = self._canvas.winfo_fpixels(self['radius'])\n        self.marker = self._canvas.create_oval((self.x - half),\n                                               (self.y - half),\n                                               (self.x + half),\n                                               (self.y + half),\n                                              fill = 'CornflowerBlue',\n                                              tags = (self.tag,'markers'))\n        self.text = self._canvas.create_text(0, 0, text = state.getName(),\n                                           justify = tk.CENTER,\n                                           tags = (self.tag,'labels'))\n        # Is this state contain a sub machine?\n        if state.hasChildren():\n            # reduce half by sqrt of 2.0\n            half = half * 0.707106\n            self.rect = self._canvas.create_rectangle((- half), (- half),\n                                                     half, half,\n                                                     tags = (self.tag,))\n\n        # The Popup State Menu\n        self._popupMenu = tk.Menu(self._canvas, tearoff = 0)\n        self._popupMenu.add_command(label = 'Request transition to ' +\n                                    state.getName(),\n                                    command = self.transitionTo)\n        if state.hasChildren():\n            self._popupMenu.add_command(label = 'Inspect ' + state.getName() +\n                                        ' submachine',\n                                        command = self.inspectSubMachine)\n\n        self.scrolledCanvas.resizescrollregion()\n\n        # Add bindings\n        self._canvas.tag_bind(self.tag, '<Enter>', self.mouseEnter)\n        self._canvas.tag_bind(self.tag, '<Leave>', self.mouseLeave)\n        self._canvas.tag_bind(self.tag, '<ButtonPress-1>', self.mouseDown)\n        self._canvas.tag_bind(self.tag, '<B1-Motion>', self.mouseMotion)\n        self._canvas.tag_bind(self.tag, '<ButtonRelease-1>', self.mouseRelease)\n        self._canvas.tag_bind(self.tag, '<ButtonPress-3>', self.popupStateMenu)\n\n        self.initialiseoptions(StateInspector)\n\n    # Utility methods\n    def _setRadius(self):\n        self.setRadius(self['radius'])\n\n    def setRadius(self, size):\n        half = self.radius = self._canvas.winfo_fpixels(size)\n        c = self.center()\n        self._canvas.coords(self.marker,\n                            c[0] - half, c[1] - half, c[0] + half, c[1] + half)\n        if self.state.hasChildren():\n            half = self.radius * 0.707106\n            self._canvas.coords(self.rect,\n                            c[0] - half, c[1] - half, c[0] + half, c[1] + half)\n\n    def _setGridSize(self):\n        self.setGridSize(self['gridSize'])\n\n    def setGridSize(self, size):\n        self.gridSize = self._canvas.winfo_fpixels(size)\n        if self.gridSize == 0:\n            self.fGridSnap = 0\n        else:\n            self.fGridSnap = 1\n\n    def setText(self, text = None):\n        self._canvas.itemconfigure(self.text, text = text)\n\n    def setPos(self, x, y, snapToGrid = 0):\n        if self.fGridSnap:\n            self.x = round(x / self.gridSize) * self.gridSize\n            self.y = round(y / self.gridSize) * self.gridSize\n        else:\n            self.x = x\n            self.y = y\n        # How far do we have to move?\n        cx, cy = self.center()\n        self._canvas.move(self.tag, self.x - cx, self.y - cy)\n\n    def center(self):\n        c = self._canvas.coords(self.marker)\n        return (c[0] + c[2])/2.0, (c[1] + c[3])/2.0\n\n    def getName(self):\n        return self.tag\n\n    # Event Handlers\n    def mouseEnter(self, event):\n        self._canvas.itemconfig(self.marker, width = 2)\n\n    def mouseLeave(self, event):\n        self._canvas.itemconfig(self.marker, width = 1)\n\n    def mouseDown(self, event):\n        self._canvas.lift(self.tag)\n        self.startx, self.starty = self.center()\n        self.lastx = self._canvas.canvasx(event.x)\n        self.lasty = self._canvas.canvasy(event.y)\n\n    def mouseMotion(self, event):\n        dx = self._canvas.canvasx(event.x) - self.lastx\n        dy = self._canvas.canvasy(event.y) - self.lasty\n        newx, newy = map(operator.__add__, (self.startx, self.starty), (dx, dy))\n        self.setPos(newx, newy)\n\n    def mouseRelease(self, event):\n        self.scrolledCanvas.resizescrollregion()\n\n    def popupStateMenu(self, event):\n        self._popupMenu.post(event.widget.winfo_pointerx(),\n                             event.widget.winfo_pointery())\n\n    def transitionTo(self):\n        self.fsm.request(self.getName())\n\n    def inspectSubMachine(self):\n        print('inspect ' + self.tag + ' subMachine')\n        for childFSM in self.state.getChildren():\n            FSMInspector(childFSM)\n\n    def enteredState(self):\n        self._canvas.itemconfigure(self.marker, fill = 'Red')\n\n    def exitedState(self):\n        self._canvas.itemconfigure(self.marker, fill = 'CornflowerBlue')\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/tkpanels/FSMInspector.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/a5e824d6_FSMInspector.json",
    "doc_id": "doc_64"
  }
}