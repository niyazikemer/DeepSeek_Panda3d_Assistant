{
  "content": "\"\"\"Interval module: contains the Interval class\"\"\"\n\n__all__ = ['Interval']\n\nfrom panda3d.core import ClockObject, PStatCollector\nfrom panda3d.direct import CInterval\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.task.Task import Task, TaskManager\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.extensions_native import CInterval_extensions # pylint: disable=unused-import\nfrom direct.extensions_native import NodePath_extensions # pylint: disable=unused-import\nimport math\n\n\nclass Interval(DirectObject):\n    \"\"\"Interval class: Base class for timeline functionality\"\"\"\n\n    # create Interval DirectNotify category\n    notify = directNotify.newCategory(\"Interval\")\n\n    playbackCounter = 0\n\n    # Class methods\n    def __init__(self, name, duration, openEnded=1):\n        self.name = name\n        self.duration = max(duration, 0.0)\n        self.state = CInterval.SInitial\n        self.currT = 0.0\n        self.doneEvent = None\n        self.setTHooks = []\n        self.__startT = 0\n        self.__startTAtStart = 1\n        self.__endT = duration\n        self.__endTAtEnd = 1\n        self.__playRate = 1.0\n        self.__doLoop = 0\n        self.__loopCount = 0\n\n        self.pstats = None\n        if __debug__ and TaskManager.taskTimerVerbose:\n            self.pname = name.split('-', 1)[0]\n            self.pstats = PStatCollector(\"App:Tasks:ivalLoop:%s\" % (self.pname))\n\n        # Set true if the interval should be invoked if it was\n        # completely skipped over during initialize or finalize, false\n        # if it should be ignored in this case.\n        self.openEnded = openEnded\n\n    def getName(self):\n        return self.name\n\n    def getDuration(self):\n        return self.duration\n\n    def getOpenEnded(self):\n        return self.openEnded\n\n    def setLoop(self, loop=1):\n        self.__doLoop = loop\n\n    def getLoop(self):\n        return self.__doLoop\n\n    def getState(self):\n        return self.state\n\n    def isPaused(self):\n        return self.getState() == CInterval.SPaused\n\n    def isStopped(self):\n        # Returns true if the interval has not been started, has already\n        # played to its completion, or has been explicitly stopped via\n        # finish().\n        return self.getState() == CInterval.SInitial or \\\n               self.getState() == CInterval.SFinal\n\n    def setT(self, t):\n        # There doesn't seem to be any reason to clamp this, and it\n        # breaks looping intervals.  The interval code should properly\n        # handle t values outside the proper range.\n        #t = min(max(t, 0.0), self.getDuration())\n\n        state = self.getState()\n        if state == CInterval.SInitial:\n            self.privInitialize(t)\n            if self.isPlaying():\n                self.setupResume()\n            else:\n                self.privInterrupt()\n        elif state == CInterval.SStarted:\n            # Support modifying t while the interval is playing.  We\n            # assume is_playing() will be true in this state.\n            assert self.isPlaying()\n            self.privInterrupt()\n            self.privStep(t)\n            self.setupResume()\n        elif state == CInterval.SPaused:\n            # Support modifying t while the interval is paused.  In\n            # this case, we simply step to the new value of t; but\n            # this will change the state to S_started, so we must then\n            # change it back to S_paused by hand (because we're still\n            # paused).\n            self.privStep(t)\n            self.privInterrupt()\n        elif state == CInterval.SFinal:\n            self.privReverseInitialize(t)\n            if self.isPlaying():\n                self.setupResume()\n            else:\n                self.privInterrupt()\n        else:\n            self.notify.error(\"Invalid state: %s\" % (state))\n        self.privPostEvent()\n\n    def getT(self):\n        return self.currT\n\n    def start(self, startT = 0.0, endT = -1.0, playRate = 1.0):\n        \"\"\" Starts the interval.  Returns an awaitable. \"\"\"\n        self.setupPlay(startT, endT, playRate, 0)\n        return self.__spawnTask()\n\n    def loop(self, startT = 0.0, endT = -1.0, playRate = 1.0):\n        self.setupPlay(startT, endT, playRate, 1)\n        self.__spawnTask()\n\n    def pause(self):\n        if self.getState() == CInterval.SStarted:\n            self.privInterrupt()\n        self.privPostEvent()\n        self.__removeTask()\n        return self.getT()\n\n    def resume(self, startT = None):\n        if startT is not None:\n            self.setT(startT)\n        self.setupResume()\n        if not self.isPlaying():\n            self.__spawnTask()\n\n    def resumeUntil(self, endT):\n        duration = self.getDuration()\n\n        if endT < 0 or endT >= duration:\n            self.__endT = duration\n            self.__endTAtEnd = 1\n        else:\n            self.__endT = endT\n            self.__endTAtEnd = 0\n\n        self.setupResume()\n        if not self.isPlaying():\n            self.__spawnTask()\n\n    def finish(self):\n        state = self.getState()\n        if state == CInterval.SInitial:\n            self.privInstant()\n        elif state != CInterval.SFinal:\n            self.privFinalize()\n        self.privPostEvent()\n        self.__removeTask()\n\n    def clearToInitial(self):\n        # This method resets the interval's internal state to the\n        # initial state, abandoning any parts of the interval that\n        # have not yet been called.  Calling it is like pausing the\n        # interval and creating a new one in its place.\n        self.pause()\n        self.state = CInterval.SInitial\n        self.currT = 0.0\n\n    def isPlaying(self):\n        return taskMgr.hasTaskNamed(self.getName() + '-play')\n\n    def getPlayRate(self):\n        \"\"\" Returns the play rate as set by the last call to start(),\n        loop(), or setPlayRate(). \"\"\"\n        return self.__playRate\n\n    def setPlayRate(self, playRate):\n        \"\"\" Changes the play rate of the interval.  If the interval is\n        already started, this changes its speed on-the-fly.  Note that\n        since playRate is a parameter to start() and loop(), the next\n        call to start() or loop() will reset this parameter. \"\"\"\n\n        if self.isPlaying():\n            self.pause()\n            self.__playRate = playRate\n            self.resume()\n        else:\n            self.__playRate = playRate\n\n    def setDoneEvent(self, event):\n        self.doneEvent = event\n\n    def getDoneEvent(self):\n        return self.doneEvent\n\n    def privDoEvent(self, t, event):\n        if self.pstats:\n            self.pstats.start()\n        if event == CInterval.ETStep:\n            self.privStep(t)\n        elif event == CInterval.ETFinalize:\n            self.privFinalize()\n        elif event == CInterval.ETInterrupt:\n            self.privInterrupt()\n        elif event == CInterval.ETInstant:\n            self.privInstant()\n        elif event == CInterval.ETInitialize:\n            self.privInitialize(t)\n        elif event == CInterval.ETReverseFinalize:\n            self.privReverseFinalize()\n        elif event == CInterval.ETReverseInstant:\n            self.privReverseInstant()\n        elif event == CInterval.ETReverseInitialize:\n            self.privReverseInitialize(t)\n        else:\n            self.notify.error('Invalid event type: %s' % (event))\n        if self.pstats:\n            self.pstats.stop()\n\n\n    def privInitialize(self, t):\n        # Subclasses may redefine this function\n        self.state = CInterval.SStarted\n        self.privStep(t)\n\n    def privInstant(self):\n        # Subclasses may redefine this function\n        self.state = CInterval.SStarted\n        self.privStep(self.getDuration())\n        self.state = CInterval.SFinal\n        self.intervalDone()\n\n    def privStep(self, t):\n        # Subclasses may redefine this function\n        self.state = CInterval.SStarted\n        self.currT = t\n\n    def privFinalize(self):\n        # Subclasses may redefine this function\n        self.privStep(self.getDuration())\n        self.state = CInterval.SFinal\n        self.intervalDone()\n\n    def privReverseInitialize(self, t):\n        # Subclasses may redefine this function\n        self.state = CInterval.SStarted\n        self.privStep(t)\n\n    def privReverseInstant(self):\n        # Subclasses may redefine this function\n        self.state = CInterval.SStarted\n        self.privStep(0)\n        self.state = CInterval.SInitial\n\n    def privReverseFinalize(self):\n        # Subclasses may redefine this function\n        self.privStep(0)\n        self.state = CInterval.SInitial\n\n    def privInterrupt(self):\n        # Subclasses may redefine this function\n        self.state = CInterval.SPaused\n\n    def intervalDone(self):\n        # Subclasses should call this when the interval transitions to\n        # its final state.\n        if self.doneEvent:\n            messenger.send(self.doneEvent)\n\n    def setupPlay(self, startT, endT, playRate, doLoop):\n        duration = self.getDuration()\n\n        if startT <= 0:\n            self.__startT = 0\n            self.__startTAtStart = 1\n        elif startT > duration:\n            self.__startT = duration\n            self.__startTAtStart = 0\n        else:\n            self.__startT = startT\n            self.__startTAtStart = 0\n\n        if endT < 0 or endT >= duration:\n            self.__endT = duration\n            self.__endTAtEnd = 1\n        else:\n            self.__endT = endT\n            self.__endTAtEnd = 0\n\n        self.__clockStart = ClockObject.getGlobalClock().getFrameTime()\n        self.__playRate = playRate\n        self.__doLoop = doLoop\n        self.__loopCount = 0\n\n    def setupResume(self):\n        now = ClockObject.getGlobalClock().getFrameTime()\n        if self.__playRate > 0:\n            self.__clockStart = now - ((self.getT() - self.__startT) / self.__playRate)\n        elif self.__playRate < 0:\n            self.__clockStart = now - ((self.getT() - self.__endT) / self.__playRate)\n        self.__loopCount = 0\n\n    def stepPlay(self):\n        now = ClockObject.getGlobalClock().getFrameTime()\n        if self.__playRate >= 0:\n            t = (now - self.__clockStart) * self.__playRate + self.__startT\n\n            if self.__endTAtEnd:\n                self.__endT = self.getDuration()\n\n            if t < self.__endT:\n                # In the middle of the interval, not a problem.\n                if self.isStopped():\n                    self.privInitialize(t)\n                else:\n                    self.privStep(t)\n\n            else:\n                # Past the ending point; time to finalize.\n                if self.__endTAtEnd:\n                    # Only finalize if the playback cycle includes the\n                    # whole interval.\n                    if self.isStopped():\n                        if self.getOpenEnded() or self.__loopCount != 0:\n                            self.privInstant()\n                    else:\n                        self.privFinalize()\n                else:\n                    if self.isStopped():\n                        self.privInitialize(self.__endT)\n                    else:\n                        self.privStep(self.__endT)\n\n                # Advance the clock for the next loop cycle.\n                if self.__endT == self.__startT:\n                    # If the interval has no length, we loop exactly once.\n                    self.__loopCount += 1\n\n                else:\n                    # Otherwise, figure out how many loops we need to\n                    # skip.\n                    timePerLoop = (self.__endT - self.__startT) / self.__playRate\n                    numLoops = math.floor((now - self.__clockStart) / timePerLoop)\n                    self.__loopCount += numLoops\n                    self.__clockStart += numLoops * timePerLoop\n\n        else:\n            # Playing backwards\n            t = (now - self.__clockStart) * self.__playRate + self.__endT\n\n            if t >= self.__startT:\n                # In the middle of the interval, not a problem.\n                if self.isStopped():\n                    self.privInitialize(t)\n                else:\n                    self.privStep(t)\n            else:\n                # Past the ending point; time to finalize.\n                if self.__startTAtStart:\n                    # Only finalize if the playback cycle includes the\n                    # whole interval.\n                    if self.isStopped():\n                        if self.getOpenEnded() or self.__loopCount != 0:\n                            self.privReverseInstant()\n                    else:\n                        self.privReverseFinalize()\n                else:\n                    if self.isStopped():\n                        self.privReverseInitialize(self.__startT)\n                    else:\n                        self.privStep(self.__startT)\n\n                # Advance the clock for the next loop cycle.\n                if self.__endT == self.__startT:\n                    # If the interval has no length, we loop exactly once.\n                    self.__loopCount += 1\n\n                else:\n                    # Otherwise, figure out how many loops we need to\n                    # skip.\n                    timePerLoop = (self.__endT - self.__startT) / -self.__playRate\n                    numLoops = math.floor((now - self.__clockStart) / timePerLoop)\n                    self.__loopCount += numLoops\n                    self.__clockStart += numLoops * timePerLoop\n\n        shouldContinue = (self.__loopCount == 0 or self.__doLoop)\n\n        if (not shouldContinue and self.getState() == CInterval.SStarted):\n            self.privInterrupt()\n\n        return shouldContinue\n\n    def __repr__(self, indent=0):\n        space = ''\n        for l in range(indent):\n            space = space + ' '\n        return space + self.name + ' dur: %.2f' % self.duration\n\n    open_ended = property(getOpenEnded)\n    stopped = property(isStopped)\n    t = property(getT, setT)\n    play_rate = property(getPlayRate, setPlayRate)\n    done_event = property(getDoneEvent, setDoneEvent)\n\n    # The rest of these methods are duplicates of functions defined\n    # for the CInterval class via the file CInterval-extensions.py.\n\n    def privPostEvent(self):\n        # Call after calling any of the priv* methods to do any required\n        # Python finishing steps.\n        if self.pstats:\n            self.pstats.start()\n        t = self.getT()\n        if hasattr(self, \"setTHooks\"):\n            for func in self.setTHooks:\n                func(t)\n        if self.pstats:\n            self.pstats.stop()\n\n    def __spawnTask(self):\n        # Spawn task\n        self.__removeTask()\n        taskName = self.getName() + '-play'\n        task = Task(self.__playTask)\n        task.interval = self\n        taskMgr.add(task, taskName)\n        return task\n\n    def __removeTask(self):\n        # Kill old task(s), including those from a similarly-named but\n        # different interval.\n        taskName = self.getName() + '-play'\n        oldTasks = taskMgr.getTasksNamed(taskName)\n        for task in oldTasks:\n            if hasattr(task, \"interval\"):\n                task.interval.privInterrupt()\n                taskMgr.remove(task)\n\n    def __playTask(self, task):\n        again = self.stepPlay()\n        self.privPostEvent()\n        if again:\n            return Task.cont\n        else:\n            return Task.done\n\n    def popupControls(self, tl = None):\n        \"\"\"\n        Popup control panel for interval.\n        \"\"\"\n        # Don't use a regular import, to prevent ModuleFinder from picking\n        # it up as a dependency when building a .p3d package.\n        import importlib\n        EntryScale = importlib.import_module('direct.tkwidgets.EntryScale')\n        tkinter = importlib.import_module('tkinter')\n\n        if tl is None:\n            tl = tkinter.Toplevel()\n            tl.title('Interval Controls')\n        outerFrame = tkinter.Frame(tl)\n        def entryScaleCommand(t, s=self):\n            s.setT(t)\n            s.pause()\n        self.es = es = EntryScale.EntryScale(\n            outerFrame, text = self.getName(),\n            min = 0, max = math.floor(self.getDuration() * 100) / 100,\n            command = entryScaleCommand)\n        es.set(self.getT(), fCommand = 0)\n        es.pack(expand = 1, fill = tkinter.X)\n        bf = tkinter.Frame(outerFrame)\n        # Jump to start and end\n        def toStart(s=self, es=es):\n            s.clearToInitial()\n            es.set(0, fCommand = 0)\n        def toEnd(s=self):\n            s.pause()\n            s.setT(s.getDuration())\n            es.set(s.getDuration(), fCommand = 0)\n            s.pause()\n        jumpToStart = tkinter.Button(bf, text = '<<', command = toStart)\n        # Stop/play buttons\n        def doPlay(s=self, es=es):\n            s.resume(es.get())\n\n        stop = tkinter.Button(bf, text = 'Stop',\n                      command = lambda s=self: s.pause())\n        play = tkinter.Button(\n            bf, text = 'Play',\n            command = doPlay)\n        jumpToEnd = tkinter.Button(bf, text = '>>', command = toEnd)\n        jumpToStart.pack(side = tkinter.LEFT, expand = 1, fill = tkinter.X)\n        play.pack(side = tkinter.LEFT, expand = 1, fill = tkinter.X)\n        stop.pack(side = tkinter.LEFT, expand = 1, fill = tkinter.X)\n        jumpToEnd.pack(side = tkinter.LEFT, expand = 1, fill = tkinter.X)\n        bf.pack(expand = 1, fill = tkinter.X)\n        outerFrame.pack(expand = 1, fill = tkinter.X)\n        # Add function to update slider during setT calls\n        def update(t, es=es):\n            es.set(t, fCommand = 0)\n        if not hasattr(self, \"setTHooks\"):\n            self.setTHooks = []\n        self.setTHooks.append(update)\n        # Clear out function on destroy\n        def onDestroy(e, s=self, u=update):\n            if u in s.setTHooks:\n                s.setTHooks.remove(u)\n        tl.bind('<Destroy>', onDestroy)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/interval/Interval.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/2f6531c1_Interval.json",
    "doc_id": "doc_164"
  }
}