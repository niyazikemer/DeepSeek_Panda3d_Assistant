{
  "content": "from panda3d.core import DocumentSpec, Filename, HTTPClient, VirtualFileSystem, getModelPath\nfrom panda3d.direct import CConnectionRepository, DCPacker\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.distributed.DoInterestManager import DoInterestManager\nfrom direct.distributed.DoCollectionManager import DoCollectionManager\nfrom direct.showbase import GarbageReport\nfrom direct.showbase.MessengerGlobal import messenger\nfrom .PyDatagramIterator import PyDatagramIterator\n\nimport gc\n\n__all__ = [\"ConnectionRepository\", \"GCTrigger\"]\n\n\nclass ConnectionRepository(\n        DoInterestManager, DoCollectionManager, CConnectionRepository):\n    \"\"\"\n    This is a base class for things that know how to establish a\n    connection (and exchange datagrams) with a gameserver.  This\n    includes ClientRepository and AIRepository.\n    \"\"\"\n    notify = directNotify.newCategory(\"ConnectionRepository\")\n    taskPriority = -30\n    taskChain = None\n\n    CM_HTTP=0\n    CM_NET=1\n    CM_NATIVE=2\n\n    gcNotify = directNotify.newCategory(\"GarbageCollect\")\n\n    GarbageCollectTaskName = \"allowGarbageCollect\"\n    GarbageThresholdTaskName = \"adjustGarbageCollectThreshold\"\n\n    def __init__(self, connectMethod, config, hasOwnerView = False,\n                 threadedNet = None):\n        assert self.notify.debugCall()\n        if threadedNet is None:\n            # Default value.\n            threadedNet = config.GetBool('threaded-net', False)\n\n        # let the C connection repository know whether we're supporting\n        # 'owner' views of distributed objects (i.e. 'receives ownrecv',\n        # 'I own this object and have a separate view of it regardless of\n        # where it currently is located')\n        CConnectionRepository.__init__(self, hasOwnerView, threadedNet)\n        self.setWantMessageBundling(config.GetBool('want-message-bundling', 1))\n        # DoInterestManager.__init__ relies on CConnectionRepository being\n        # initialized\n        DoInterestManager.__init__(self)\n        DoCollectionManager.__init__(self)\n        self.setPythonRepository(self)\n\n        # Create a unique ID number for each ConnectionRepository in\n        # the world, helpful for sending messages specific to each one.\n        self.uniqueId = hash(self)\n\n        # Accept this hook so that we can respond to lost-connection\n        # events in the main thread, instead of within the network\n        # thread (if there is one).\n        self.accept(self._getLostConnectionEvent(), self.lostConnection)\n\n        self.config = config\n\n        if self.config.GetBool('verbose-repository'):\n            self.setVerbose(1)\n\n        # Set this to 'http' to establish a connection to the server\n        # using the HTTPClient interface, which ultimately uses the\n        # OpenSSL socket library (even though SSL is not involved).\n        # This is not as robust a socket library as NET's, but the\n        # HTTPClient interface does a good job of negotiating the\n        # connection over an HTTP proxy if one is in use.\n        #\n        # Set it to 'net' to use Panda's net interface\n        # (e.g. QueuedConnectionManager, etc.) to establish the\n        # connection.  This is a higher-level layer build on top of\n        # the low-level \"native net\" library.  There is no support for\n        # proxies.  This is a good, general choice.\n        #\n        # Set it to 'native' to use Panda's low-level native net\n        # interface directly.  This is much faster than either http or\n        # net for high-bandwidth (e.g. server) applications, but it\n        # doesn't support the simulated delay via the start_delay()\n        # call.\n        #\n        # Set it to 'default' to use an appropriate interface\n        # according to the type of ConnectionRepository we are\n        # creating.\n        userConnectMethod = self.config.GetString('connect-method', 'default')\n        if userConnectMethod == 'http':\n            connectMethod = self.CM_HTTP\n        elif userConnectMethod == 'net':\n            connectMethod = self.CM_NET\n        elif userConnectMethod == 'native':\n            connectMethod = self.CM_NATIVE\n\n        self.connectMethod = connectMethod\n        if self.connectMethod == self.CM_HTTP:\n            self.notify.info(\"Using connect method 'http'\")\n        elif self.connectMethod == self.CM_NET:\n            self.notify.info(\"Using connect method 'net'\")\n        elif self.connectMethod == self.CM_NATIVE:\n            self.notify.info(\"Using connect method 'native'\")\n\n        self.connectHttp = None\n        self.http = None\n\n        # This DatagramIterator is constructed once, and then re-used\n        # each time we read a datagram.\n        self.private__di = PyDatagramIterator()\n\n        self.recorder = None\n        self.readerPollTaskObj = None\n\n        # This is the string that is appended to symbols read from the\n        # DC file.  The AIRepository will redefine this to 'AI'.\n        self.dcSuffix = ''\n\n        self._serverAddress = ''\n\n        if self.config.GetBool('gc-save-all', 0):\n            # set gc to preserve every object involved in a cycle, even ones that\n            # would normally be freed automatically during garbage collect\n            # allows us to find and fix these cycles, reducing or eliminating the\n            # need to run garbage collects\n            # garbage collection CPU usage is O(n), n = number of Python objects\n            gc.set_debug(gc.DEBUG_SAVEALL)\n\n        if self.config.GetBool('want-garbage-collect-task', 1):\n            # manual garbage-collect task\n            taskMgr.add(self._garbageCollect, self.GarbageCollectTaskName, 200)\n            # periodically increase gc threshold if there is no garbage\n            taskMgr.doMethodLater(self.config.GetFloat('garbage-threshold-adjust-delay', 5 * 60.),\n                                  self._adjustGcThreshold, self.GarbageThresholdTaskName)\n\n        self._gcDefaultThreshold = gc.get_threshold()\n\n    def _getLostConnectionEvent(self):\n        return self.uniqueName('lostConnection')\n\n    def _garbageCollect(self, task=None):\n        # allow a collect\n        # enable automatic garbage collection\n        gc.enable()\n        # creating an object with gc enabled causes garbage collection to trigger if appropriate\n        gct = GCTrigger()\n        # disable the automatic garbage collect during the rest of the frame\n        gc.disable()\n        return Task.cont\n\n    def _adjustGcThreshold(self, task):\n        # do an unconditional collect to make sure gc.garbage has a chance to be\n        # populated before we start increasing the auto-collect threshold\n        # don't distribute the leak check from the client to the AI, they both\n        # do these garbage checks independently over time\n        numGarbage = GarbageReport.checkForGarbageLeaks()\n        if numGarbage == 0:\n            self.gcNotify.debug('no garbage found, doubling gc threshold')\n            a, b, c = gc.get_threshold()\n            gc.set_threshold(min(a * 2, 1 << 30), b, c)\n\n            task.delayTime = task.delayTime * 2\n            retVal = Task.again\n\n        else:\n            self.gcNotify.warning('garbage found, reverting gc threshold')\n            # the process is producing garbage, stick to the default collection threshold\n            gc.set_threshold(*self._gcDefaultThreshold)\n            retVal = Task.done\n\n        return retVal\n\n    def generateGlobalObject(self, doId, dcname, values=None):\n        # Look up the dclass\n        dclass = self.dclassesByName.get(dcname+self.dcSuffix)\n        if dclass is None:\n            #print \"\\n\\n\\nNeed to define\", dcname+self.dcSuffix\n            self.notify.warning(\"Need to define %s\" % (dcname+self.dcSuffix))\n            dclass = self.dclassesByName.get(dcname+'AI')\n        if dclass is None:\n            dclass = self.dclassesByName.get(dcname)\n        # Create a new distributed object, and put it in the dictionary\n        #distObj = self.generateWithRequiredFields(dclass, doId, di)\n\n        # Construct a new one\n        classDef = dclass.getClassDef()\n        if classDef is None:\n            self.notify.error(\"Could not create an undefined %s object.\"%(\n                dclass.getName()))\n        distObj = classDef(self)\n        distObj.dclass = dclass\n        # Assign it an Id\n        distObj.doId = doId\n        # Put the new do in the dictionary\n        self.doId2do[doId] = distObj\n        # Update the required fields\n        distObj.generateInit()  # Only called when constructed\n        distObj.generate()\n        if values is not None:\n            for i in range(dclass.getNumInheritedFields()):\n                field = dclass.getInheritedField(i)\n                if field.asMolecularField() is None:\n                    value = values.get(field.getName(), None)\n                    if value is None and field.isRequired():\n                        # Gee, this could be better.  What would really be\n                        # nicer is to get value from field.getDefaultValue\n                        # or similar, but that returns a binary string, not\n                        # a python tuple, like the following does.  If you\n                        # want to change something better, please go ahead.\n                        packer = DCPacker()\n                        packer.beginPack(field)\n                        packer.packDefaultValue()\n                        packer.endPack()\n\n                        unpacker = DCPacker()\n                        unpacker.setUnpackData(packer.getString())\n                        unpacker.beginUnpack(field)\n                        value = unpacker.unpackObject()\n                        unpacker.endUnpack()\n                    if value is not None:\n                        function = getattr(distObj, field.getName())\n                        if function is not None:\n                            function(*value)\n                        else:\n                            self.notify.error(\n                                \"\\n\\n\\nNot able to find %s.%s\" % (\n                                    distObj.__class__.__name__,\n                                    field.getName()\n                                )\n                            )\n        distObj.announceGenerate()\n        distObj.parentId = 0\n        distObj.zoneId = 0\n        # updateRequiredFields calls announceGenerate\n        return distObj\n\n    def readDCFile(self, dcFileNames = None):\n        \"\"\"\n        Reads in the dc files listed in dcFileNames, or if\n        dcFileNames is None, reads in all of the dc files listed in\n        the Config.prc file.\n        \"\"\"\n\n        dcFile = self.getDcFile()\n        dcFile.clear()\n        self.dclassesByName = {}\n        self.dclassesByNumber = {}\n        self.hashVal = 0\n\n        if isinstance(dcFileNames, str):\n            # If we were given a single string, make it a list.\n            dcFileNames = [dcFileNames]\n\n        dcImports = {}\n        if dcFileNames is None:\n            readResult = dcFile.readAll()\n            if not readResult:\n                self.notify.error(\"Could not read dc file.\")\n        else:\n            searchPath = getModelPath().getValue()\n            for dcFileName in dcFileNames:\n                pathname = Filename(dcFileName)\n                vfs = VirtualFileSystem.getGlobalPtr()\n                vfs.resolveFilename(pathname, searchPath)\n                readResult = dcFile.read(pathname)\n                if not readResult:\n                    self.notify.error(\"Could not read dc file: %s\" % (pathname))\n\n        #if not dcFile.allObjectsValid():\n        #    names = []\n        #    for i in range(dcFile.getNumTypedefs()):\n        #        td = dcFile.getTypedef(i)\n        #        if td.isBogusTypedef():\n        #            names.append(td.getName())\n        #    nameList = ', '.join(names)\n        #    self.notify.error(\"Undefined types in DC file: \" + nameList)\n\n        self.hashVal = dcFile.getHash()\n\n        # Now import all of the modules required by the DC file.\n        for n in range(dcFile.getNumImportModules()):\n            moduleName = dcFile.getImportModule(n)[:]\n\n            # Maybe the module name is represented as \"moduleName/AI\".\n            suffix = moduleName.split('/')\n            moduleName = suffix[0]\n            suffix=suffix[1:]\n            if self.dcSuffix in suffix:\n                moduleName += self.dcSuffix\n            elif self.dcSuffix == 'UD' and 'AI' in suffix: #HACK:\n                moduleName += 'AI'\n\n            importSymbols = []\n            for i in range(dcFile.getNumImportSymbols(n)):\n                symbolName = dcFile.getImportSymbol(n, i)\n\n                # Maybe the symbol name is represented as \"symbolName/AI\".\n                suffix = symbolName.split('/')\n                symbolName = suffix[0]\n                suffix=suffix[1:]\n                if self.dcSuffix in suffix:\n                    symbolName += self.dcSuffix\n                elif self.dcSuffix == 'UD' and 'AI' in suffix: #HACK:\n                    symbolName += 'AI'\n\n                importSymbols.append(symbolName)\n\n            self.importModule(dcImports, moduleName, importSymbols)\n\n        # Now get the class definition for the classes named in the DC\n        # file.\n        import inspect\n\n        for i in range(dcFile.getNumClasses()):\n            dclass = dcFile.getClass(i)\n            number = dclass.getNumber()\n            className = dclass.getName() + self.dcSuffix\n\n            # Does the class have a definition defined in the newly\n            # imported namespace?\n            classDef = dcImports.get(className)\n            if classDef is None and self.dcSuffix == 'UD': #HACK:\n                className = dclass.getName() + 'AI'\n                classDef = dcImports.get(className)\n\n            # Also try it without the dcSuffix.\n            if classDef is None:\n                className = dclass.getName()\n                classDef = dcImports.get(className)\n            if classDef is None:\n                self.notify.debug(\"No class definition for %s.\" % (className))\n            else:\n                if inspect.ismodule(classDef):\n                    if not hasattr(classDef, className):\n                        self.notify.warning(\"Module %s does not define class %s.\" % (className, className))\n                        continue\n                    classDef = getattr(classDef, className)\n\n                if not inspect.isclass(classDef):\n                    self.notify.error(\"Symbol %s is not a class name.\" % (className))\n                else:\n                    dclass.setClassDef(classDef)\n\n            self.dclassesByName[className] = dclass\n            if number >= 0:\n                self.dclassesByNumber[number] = dclass\n\n        # Owner Views\n        if self.hasOwnerView():\n            ownerDcSuffix = self.dcSuffix + 'OV'\n            # dict of class names (without 'OV') that have owner views\n            ownerImportSymbols = {}\n\n            # Now import all of the modules required by the DC file.\n            for n in range(dcFile.getNumImportModules()):\n                moduleName = dcFile.getImportModule(n)\n\n                # Maybe the module name is represented as \"moduleName/AI\".\n                suffix = moduleName.split('/')\n                moduleName = suffix[0]\n                suffix=suffix[1:]\n                if ownerDcSuffix in suffix:\n                    moduleName = moduleName + ownerDcSuffix\n\n                importSymbols = []\n                for i in range(dcFile.getNumImportSymbols(n)):\n                    symbolName = dcFile.getImportSymbol(n, i)\n\n                    # Check for the OV suffix\n                    suffix = symbolName.split('/')\n                    symbolName = suffix[0]\n                    suffix=suffix[1:]\n                    if ownerDcSuffix in suffix:\n                        symbolName += ownerDcSuffix\n                    importSymbols.append(symbolName)\n                    ownerImportSymbols[symbolName] = None\n\n                self.importModule(dcImports, moduleName, importSymbols)\n\n            # Now get the class definition for the owner classes named\n            # in the DC file.\n            for i in range(dcFile.getNumClasses()):\n                dclass = dcFile.getClass(i)\n                if dclass.getName() + ownerDcSuffix in ownerImportSymbols:\n                    number = dclass.getNumber()\n                    className = dclass.getName() + ownerDcSuffix\n\n                    # Does the class have a definition defined in the newly\n                    # imported namespace?\n                    classDef = dcImports.get(className)\n                    if classDef is None:\n                        self.notify.error(\"No class definition for %s.\" % className)\n                    else:\n                        if inspect.ismodule(classDef):\n                            if not hasattr(classDef, className):\n                                self.notify.error(\"Module %s does not define class %s.\" % (className, className))\n                            classDef = getattr(classDef, className)\n                        dclass.setOwnerClassDef(classDef)\n                        self.dclassesByName[className] = dclass\n\n    def importModule(self, dcImports, moduleName, importSymbols):\n        \"\"\"\n        Imports the indicated moduleName and all of its symbols\n        into the current namespace.  This more-or-less reimplements\n        the Python import command.\n        \"\"\"\n        module = __import__(moduleName, globals(), locals(), importSymbols)\n\n        if importSymbols:\n            # \"from moduleName import symbolName, symbolName, ...\"\n            # Copy just the named symbols into the dictionary.\n            if importSymbols == ['*']:\n                # \"from moduleName import *\"\n                if hasattr(module, \"__all__\"):\n                    importSymbols = module.__all__\n                else:\n                    importSymbols = module.__dict__.keys()\n\n            for symbolName in importSymbols:\n                if hasattr(module, symbolName):\n                    dcImports[symbolName] = getattr(module, symbolName)\n                else:\n                    raise Exception('Symbol %s not defined in module %s.' % (symbolName, moduleName))\n        else:\n            # \"import moduleName\"\n\n            # Copy the root module name into the dictionary.\n\n            # Follow the dotted chain down to the actual module.\n            components = moduleName.split('.')\n            dcImports[components[0]] = module\n\n    def getServerAddress(self):\n        return self._serverAddress\n\n    def connect(self, serverList,\n                successCallback = None, successArgs = [],\n                failureCallback = None, failureArgs = []):\n        \"\"\"\n        Attempts to establish a connection to the server.  May return\n        before the connection is established.  The two callbacks\n        represent the two functions to call (and their arguments) on\n        success or failure, respectively.  The failure callback also\n        gets one additional parameter, which will be passed in first:\n        the return status code giving reason for failure, if it is\n        known.\n        \"\"\"\n\n        ## if self.recorder and self.recorder.isPlaying():\n\n        ##     # If we have a recorder and it's already in playback mode,\n        ##     # don't actually attempt to connect to a gameserver since\n        ##     # we don't need to.  Just let it play back the data.\n        ##     self.notify.info(\"Not connecting to gameserver; using playback data instead.\")\n\n        ##     self.connectHttp = 1\n        ##     self.tcpConn = SocketStreamRecorder()\n        ##     self.recorder.addRecorder('gameserver', self.tcpConn)\n\n        ##     self.startReaderPollTask()\n        ##     if successCallback:\n        ##         successCallback(*successArgs)\n        ##     return\n\n        hasProxy = 0\n        if self.checkHttp():\n            proxies = self.http.getProxiesForUrl(serverList[0])\n            hasProxy = proxies != 'DIRECT'\n\n        if hasProxy:\n            self.notify.info(\"Connecting to gameserver via proxy list: %s\" % (proxies))\n        else:\n            self.notify.info(\"Connecting to gameserver directly (no proxy).\")\n\n        #Redefine the connection to http or net in the default case\n\n        self.bootedIndex = None\n        self.bootedText = None\n        if self.connectMethod == self.CM_HTTP:\n            # In the HTTP case, we can't just iterate through the list\n            # of servers, because each server attempt requires\n            # spawning a request and then coming back later to check\n            # the success or failure.  Instead, we start the ball\n            # rolling by calling the connect callback, which will call\n            # itself repeatedly until we establish a connection (or\n            # run out of servers).\n\n            ch = self.http.makeChannel(0)\n            self.httpConnectCallback(\n                    ch, serverList, 0,\n                    successCallback, successArgs,\n                    failureCallback, failureArgs)\n        elif self.connectMethod == self.CM_NET or (not hasattr(self,\"connectNative\")):\n            # Try each of the servers in turn.\n            for url in serverList:\n                self.notify.info(\"Connecting to %s via NET interface.\" % (url))\n                if self.tryConnectNet(url):\n                    self.startReaderPollTask()\n                    if successCallback:\n                        successCallback(*successArgs)\n                    return\n\n            # Failed to connect.\n            if failureCallback:\n                failureCallback(0, '', *failureArgs)\n        elif self.connectMethod == self.CM_NATIVE:\n            for url in serverList:\n                self.notify.info(\"Connecting to %s via Native interface.\" % (url))\n                if self.connectNative(url):\n                    self.startReaderPollTask()\n                    if successCallback:\n                        successCallback(*successArgs)\n                    return\n\n            # Failed to connect.\n            if failureCallback:\n                failureCallback(0, '', *failureArgs)\n        else:\n            print(\"uh oh, we aren't using one of the tri-state CM variables\")\n            failureCallback(0, '', *failureArgs)\n\n    def disconnect(self):\n        \"\"\"\n        Closes the previously-established connection.\n        \"\"\"\n        self.notify.info(\"Closing connection to server.\")\n        self._serverAddress = ''\n        CConnectionRepository.disconnect(self)\n        self.stopReaderPollTask()\n\n    def shutdown(self):\n        self.ignoreAll()\n        CConnectionRepository.shutdown(self)\n\n    def httpConnectCallback(self, ch, serverList, serverIndex,\n                            successCallback, successArgs,\n                            failureCallback, failureArgs):\n        if ch.isConnectionReady():\n            self.setConnectionHttp(ch)\n            self._serverAddress = serverList[serverIndex-1]\n            self.notify.info(\"Successfully connected to %s.\" % (self._serverAddress))\n\n            ## if self.recorder:\n            ##     # If we have a recorder, we wrap the connect inside a\n            ##     # SocketStreamRecorder, which will trap incoming data\n            ##     # when the recorder is set to record mode.  (It will\n            ##     # also play back data when the recorder is in playback\n            ##     # mode, but in that case we never get this far in the\n            ##     # code, since we just create an empty\n            ##     # SocketStreamRecorder without actually connecting to\n            ##     # the gameserver.)\n            ##     stream = SocketStreamRecorder(self.tcpConn, 1)\n            ##     self.recorder.addRecorder('gameserver', stream)\n\n            ##     # In this case, we pass ownership of the original\n            ##     # connection to the SocketStreamRecorder object.\n            ##     self.tcpConn.userManagesMemory = 0\n            ##     self.tcpConn = stream\n\n            self.startReaderPollTask()\n            if successCallback:\n                successCallback(*successArgs)\n        elif serverIndex < len(serverList):\n            # No connection yet, but keep trying.\n\n            url = serverList[serverIndex]\n            self.notify.info(\"Connecting to %s via HTTP interface.\" % (url))\n            ch.preserveStatus()\n\n            ch.beginConnectTo(DocumentSpec(url))\n            ch.spawnTask(name = 'connect-to-server',\n                         callback = self.httpConnectCallback,\n                         extraArgs = [ch, serverList, serverIndex + 1,\n                                      successCallback, successArgs,\n                                      failureCallback, failureArgs])\n        else:\n            # No more servers to try; we have to give up now.\n            if failureCallback:\n                failureCallback(ch.getStatusCode(), ch.getStatusString(),\n                                *failureArgs)\n\n    def checkHttp(self):\n        # Creates an HTTPClient, if possible, if we don't have one\n        # already.  This might fail if the OpenSSL library isn't\n        # available.  Returns the HTTPClient (also self.http), or None\n        # if not set.\n\n        if self.http is None:\n            try:\n                self.http = HTTPClient()\n            except Exception:\n                pass\n\n        return self.http\n\n    def startReaderPollTask(self):\n        # Stop any tasks we are running now\n        self.stopReaderPollTask()\n        self.accept(CConnectionRepository.getOverflowEventName(),\n                    self.handleReaderOverflow)\n        self.readerPollTaskObj = taskMgr.add(\n            self.readerPollUntilEmpty, self.uniqueName(\"readerPollTask\"),\n            priority = self.taskPriority, taskChain = self.taskChain)\n\n    def stopReaderPollTask(self):\n        if self.readerPollTaskObj:\n            taskMgr.remove(self.readerPollTaskObj)\n            self.readerPollTaskObj = None\n        self.ignore(CConnectionRepository.getOverflowEventName())\n\n    def readerPollUntilEmpty(self, task):\n        while self.readerPollOnce():\n            pass\n        return Task.cont\n\n    def readerPollOnce(self):\n        if self.checkDatagram():\n            self.getDatagramIterator(self.private__di)\n            self.handleDatagram(self.private__di)\n            return 1\n\n        # Unable to receive a datagram: did we lose the connection?\n        if not self.isConnected():\n            self.stopReaderPollTask()\n            messenger.send(self.uniqueName('lostConnection'), taskChain = 'default')\n        return 0\n\n    def handleReaderOverflow(self):\n        # this is called if the incoming-datagram queue overflowed and\n        # we lost some data. Override and handle if desired.\n        pass\n\n    def lostConnection(self):\n        # This should be overrided by a derived class to handle an\n        # unexpectedly lost connection to the gameserver.\n        self.notify.warning(\"Lost connection to gameserver.\")\n\n    def handleDatagram(self, di):\n        # This class is meant to be pure virtual, and any classes that\n        # inherit from it need to make their own handleDatagram method\n        pass\n\n    def send(self, datagram):\n        # Zero-length datagrams might freak out the server.  No point\n        # in sending them, anyway.\n        if datagram.getLength() > 0:\n##             if self.notify.getDebug():\n##                 print \"ConnectionRepository sending datagram:\"\n##                 datagram.dumpHex(ostream)\n\n            self.sendDatagram(datagram)\n\n    # debugging funcs for simulating a network-plug-pull\n    def pullNetworkPlug(self):\n        self.notify.warning('*** SIMULATING A NETWORK-PLUG-PULL ***')\n        self.setSimulatedDisconnect(1)\n\n    def networkPlugPulled(self):\n        return self.getSimulatedDisconnect()\n\n    def restoreNetworkPlug(self):\n        if self.networkPlugPulled():\n            self.notify.info('*** RESTORING SIMULATED PULLED-NETWORK-PLUG ***')\n            self.setSimulatedDisconnect(0)\n\n    def uniqueName(self, idString):\n        return \"%s-%s\" % (idString, self.uniqueId)\n\n\nclass GCTrigger:\n    # used to trigger garbage collection\n    pass\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/ConnectionRepository.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/04ce7bd8_ConnectionRepository.json",
    "doc_id": "doc_303"
  }
}