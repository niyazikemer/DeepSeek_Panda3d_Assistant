{
  "content": "import math\nfrom panda3d.core import BitMask32, Mat4, NodePath, Point3, VBase3, Vec3, Vec4, rad2Deg\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.showbase import ShowBaseGlobal\nfrom .DirectUtil import CLAMP, useDirectRenderStyle\nfrom .DirectGeometry import getCrankAngle, getScreenXY\nfrom . import DirectGlobals as DG\nfrom .DirectSelection import SelectionRay\nfrom direct.interval.IntervalGlobal import Sequence, Func\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\n\nCAM_MOVE_DURATION = 1.2\nCOA_MARKER_SF = 0.0075\nY_AXIS = Vec3(0, 1, 0)\n\n\nclass DirectCameraControl(DirectObject):\n\n    notify = DirectNotifyGlobal.directNotify.newCategory('DirectCameraControl')\n\n    def __init__(self):\n        # Create the grid\n        self.startT = 0.0\n        self.startF = 0\n        self.orthoViewRoll = 0.0\n        self.lastView = 0\n        self.coa = Point3(0, 100, 0)\n        self.coaMarker = ShowBaseGlobal.loader.loadModel('models/misc/sphere')\n        self.coaMarker.setName('DirectCameraCOAMarker')\n        self.coaMarker.setTransparency(1)\n        self.coaMarker.setColor(1, 0, 0, 0)\n        self.coaMarker.setPos(0, 100, 0)\n        useDirectRenderStyle(self.coaMarker)\n        self.coaMarkerPos = Point3(0)\n        self.coaMarkerColorIval = None\n        self.fLockCOA = 0\n        self.nullHitPointCount = 0\n        self.cqEntries = []\n        self.coaMarkerRef = ShowBaseGlobal.direct.group.attachNewNode('coaMarkerRef')\n        self.camManipRef = ShowBaseGlobal.direct.group.attachNewNode('camManipRef')\n        self.switchDirBelowZero = True\n        self.manipulateCameraTask = None\n        self.manipulateCameraInterval = None\n\n        t = CAM_MOVE_DURATION\n        self.actionEvents = [\n            ['DIRECT-mouse1', self.mouseRotateStart],\n            ['DIRECT-mouse1Up', self.mouseDollyStop],\n            ['DIRECT-mouse2', self.mouseFlyStart],\n            ['DIRECT-mouse2Up', self.mouseFlyStop],\n            ['DIRECT-mouse3', self.mouseDollyStart],\n            ['DIRECT-mouse3Up', self.mouseDollyStop],\n        ]\n\n        # [gjeon] moved all of the hotkeys to single place for easy remapping\n##         self.keyEvents = [\n##             ['c', self.centerCamIn, 0.5],\n##             ['f', self.fitOnWidget],                  # Note: This function doesn't work as intended\n##             ['h', self.homeCam],\n##             ['shift-v', self.toggleMarkerVis],\n##             ['m', self.moveToFit],                      # Note: This function doesn't work as intended; the object dissappears and screen flashes\n##             ['n', self.pickNextCOA],\n##             ['u', self.orbitUprightCam],\n##             ['shift-u', self.uprightCam],\n##             [repr(1), self.spawnMoveToView, 1],\n##             [repr(2), self.spawnMoveToView, 2],\n##             [repr(3), self.spawnMoveToView, 3],\n##             [repr(4), self.spawnMoveToView, 4],\n##             [repr(5), self.spawnMoveToView, 5],\n##             [repr(6), self.spawnMoveToView, 6],\n##             [repr(7), self.spawnMoveToView, 7],\n##             [repr(8), self.spawnMoveToView, 8],\n##             ['9', self.swingCamAboutWidget, -90.0, t],\n##             ['0', self.swingCamAboutWidget,  90.0, t],\n##             ['`', self.removeManipulateCameraTask],\n##             ['=', self.zoomCam, 0.5, t],\n##             ['+', self.zoomCam, 0.5, t],\n##             ['-', self.zoomCam, -2.0, t],\n##             ['_', self.zoomCam, -2.0, t],\n##             ]\n\n        self.keyEvents = [\n            ['DIRECT-centerCamIn', self.centerCamIn, 0.5],\n            ['DIRECT-fitOnWidget', self.fitOnWidget],                  # Note: This function doesn't work as intended\n            ['DIRECT-homeCam', self.homeCam],\n            ['DIRECT-toggleMarkerVis', self.toggleMarkerVis],\n            ['DIRECT-moveToFit', self.moveToFit],                      # Note: This function doesn't work as intended; the object dissappears and screen flashes\n            ['DIRECT-pickNextCOA', self.pickNextCOA],\n            ['DIRECT-orbitUprightCam', self.orbitUprightCam],\n            ['DIRECT-uprightCam', self.uprightCam],\n            ['DIRECT-spwanMoveToView-1', self.spawnMoveToView, 1],\n            ['DIRECT-spwanMoveToView-2', self.spawnMoveToView, 2],\n            ['DIRECT-spwanMoveToView-3', self.spawnMoveToView, 3],\n            ['DIRECT-spwanMoveToView-4', self.spawnMoveToView, 4],\n            ['DIRECT-spwanMoveToView-5', self.spawnMoveToView, 5],\n            ['DIRECT-spwanMoveToView-6', self.spawnMoveToView, 6],\n            ['DIRECT-spwanMoveToView-7', self.spawnMoveToView, 7],\n            ['DIRECT-spwanMoveToView-8', self.spawnMoveToView, 8],\n            ['DIRECT-swingCamAboutWidget-0', self.swingCamAboutWidget, -90.0, t],\n            ['DIRECT-swingCamAboutWidget-1', self.swingCamAboutWidget,  90.0, t],\n            ['DIRECT-removeManipulateCameraTask', self.removeManipulateCameraTask],\n            ['DIRECT-zoomInCam', self.zoomCam, 0.5, t],\n            ['DIRECT-zoomOutCam', self.zoomCam, -2.0, t],\n        ]\n        # set this to true to prevent the camera from rolling\n        self.lockRoll = False\n        # NIK - flag to determine whether to use maya camera controls\n        self.useMayaCamControls = 0\n        self.altDown = 0\n        self.perspCollPlane = None # [gjeon] used for new LE\n        self.perspCollPlane2 = None # [gjeon] used for new LE\n\n    def toggleMarkerVis(self):\n        if self.coaMarker.isHidden():\n            self.coaMarker.show()\n        else:\n            self.coaMarker.hide()\n\n    def mouseRotateStart(self, modifiers):\n        if self.useMayaCamControls and modifiers == 4:          # alt is pressed - use maya controls\n            # base.direct.pushUndo([base.direct.camera])        # Wasteful use of undo\n            self.spawnMouseRotateTask()\n\n    def mouseDollyStart(self, modifiers):\n        if self.useMayaCamControls and modifiers == 4: # alt is pressed - use maya controls\n            # Hide the marker for this kind of motion\n            self.coaMarker.hide()\n            # Record time of start of mouse interaction\n            base = ShowBaseGlobal.base\n            self.startT = base.clock.getFrameTime()\n            self.startF = base.clock.getFrameCount()\n            # If the cam is orthogonal, spawn differentTask\n            direct = ShowBaseGlobal.direct\n            if hasattr(direct, \"manipulationControl\") and \\\n               direct.manipulationControl.fMultiView and \\\n               direct.camera.getName() != 'persp':\n                self.spawnOrthoZoom()\n            else:\n                # Start manipulation\n                self.spawnHPanYZoom()\n\n    def __stopManipulateCamera(self):\n        if self.manipulateCameraTask:\n            taskMgr.remove(self.manipulateCameraTask)\n            self.manipulateCameraTask = None\n\n        if self.manipulateCameraInterval:\n            self.manipulateCameraInterval.finish()\n            self.manipulateCameraInterval = None\n\n    def __startManipulateCamera(self, func = None, task = None, ival = None):\n        self.__stopManipulateCamera()\n        if func:\n            assert task is None\n            task = Task.Task(func)\n        if task:\n            self.manipulateCameraTask = taskMgr.add(task, 'manipulateCamera')\n        if ival:\n            ival.start()\n            self.manipulateCameraInterval = ival\n\n    def mouseDollyStop(self):\n        self.__stopManipulateCamera()\n\n    def mouseFlyStart(self, modifiers):\n        # Record undo point\n        base = ShowBaseGlobal.base\n        direct = ShowBaseGlobal.direct\n        #direct.pushUndo([direct.camera])            # Wasteful use of undo\n        if self.useMayaCamControls and modifiers == 4:          # alt is down, use maya controls\n            # Hide the marker for this kind of motion\n            self.coaMarker.hide()\n            # Record time of start of mouse interaction\n            self.startT = base.clock.getFrameTime()\n            self.startF = base.clock.getFrameCount()\n            # Start manipulation\n            # If the cam is orthogonal, spawn differentTask\n            if hasattr(direct, \"manipulationControl\") and \\\n               direct.manipulationControl.fMultiView and \\\n               direct.camera.getName() != 'persp':\n                self.spawnOrthoTranslate()\n            else:\n                self.spawnXZTranslate()\n            self.altDown = 1\n        elif not self.useMayaCamControls:\n            # Where are we in the display region?\n            if abs(direct.dr.mouseX) < 0.9 and abs(direct.dr.mouseY) < 0.9:\n                # MOUSE IS IN CENTRAL REGION\n                # Hide the marker for this kind of motion\n                self.coaMarker.hide()\n                # Record time of start of mouse interaction\n                self.startT = base.clock.getFrameTime()\n                self.startF = base.clock.getFrameCount()\n                # Start manipulation\n                self.spawnXZTranslateOrHPanYZoom()\n                # END MOUSE IN CENTRAL REGION\n            elif abs(direct.dr.mouseX) > 0.9 and abs(direct.dr.mouseY) > 0.9:\n                # Mouse is in corners, spawn roll task\n                self.spawnMouseRollTask()\n            else:\n                # Mouse is in outer frame, spawn mouseRotateTask\n                self.spawnMouseRotateTask()\n        if not modifiers == 4:\n            self.altDown = 0\n\n    def mouseFlyStop(self):\n        self.__stopManipulateCamera()\n        base = ShowBaseGlobal.base\n        stopT = base.clock.getFrameTime()\n        deltaT = stopT - self.startT\n        stopF = base.clock.getFrameCount()\n        deltaF = stopF - self.startF\n        ## No reason this shouldn't work with Maya cam on\n        # if not self.useMayaCamControls and (deltaT <= 0.25) or (deltaF <= 1):\n\n        # Do this when not trying to manipulate camera\n        direct = ShowBaseGlobal.direct\n        if not self.altDown and len(direct.selected.getSelectedAsList()) == 0:\n            # Check for a hit point based on\n            # current mouse position\n            # Allow intersection with unpickable objects\n            # And then spawn task to determine mouse mode\n            # Don't intersect with hidden or backfacing objects\n            skipFlags = DG.SKIP_HIDDEN | DG.SKIP_BACKFACE\n            # Skip camera (and its children), unless control key is pressed\n            skipFlags |= DG.SKIP_CAMERA * (1 - base.getControl())\n            self.computeCOA(direct.iRay.pickGeom(skipFlags = skipFlags))\n            # Record reference point\n            self.coaMarkerRef.setPosHprScale(base.cam, 0, 0, 0, 0, 0, 0, 1, 1, 1)\n            # Record entries\n            self.cqEntries = []\n            for i in range(direct.iRay.getNumEntries()):\n                self.cqEntries.append(direct.iRay.getEntry(i))\n        # Show the marker\n        self.coaMarker.show()\n        # Resize it\n        self.updateCoaMarkerSize()\n\n    def mouseFlyStartTopWin(self):\n        print(\"Moving mouse 2 in new window\")\n        #altIsDown = base.getAlt()\n        #if altIsDown:\n        #    print \"Alt is down\"\n\n    def mouseFlyStopTopWin(self):\n        print(\"Stopping mouse 2 in new window\")\n\n    def spawnXZTranslateOrHPanYZoom(self):\n        # Kill any existing tasks\n        self.__stopManipulateCamera()\n        # Spawn the new task\n        t = Task.Task(self.XZTranslateOrHPanYZoomTask)\n        # For HPanYZoom\n        t.zoomSF = Vec3(self.coaMarker.getPos(ShowBaseGlobal.direct.camera)).length()\n        self.__startManipulateCamera(task = t)\n\n    def spawnXZTranslateOrHPPan(self):\n        # Kill any existing tasks\n        self.__stopManipulateCamera()\n        # Spawn new task\n        self.__startManipulateCamera(func = self.XZTranslateOrHPPanTask)\n\n    def spawnXZTranslate(self):\n        # Kill any existing tasks\n        self.__stopManipulateCamera()\n        # Spawn new task\n        self.__startManipulateCamera(func = self.XZTranslateTask)\n\n    def spawnOrthoTranslate(self):\n        # Kill any existing tasks\n        self.__stopManipulateCamera()\n        # Spawn new task\n        self.__startManipulateCamera(func = self.OrthoTranslateTask)\n\n    def spawnHPanYZoom(self):\n        # Kill any existing tasks\n        self.__stopManipulateCamera()\n        # Spawn new task\n        t = Task.Task(self.HPanYZoomTask)\n        t.zoomSF = Vec3(self.coaMarker.getPos(ShowBaseGlobal.direct.camera)).length()\n        self.__startManipulateCamera(task = t)\n\n    def spawnOrthoZoom(self):\n        # Kill any existing tasks\n        self.__stopManipulateCamera()\n        # Spawn new task\n        t = Task.Task(self.OrthoZoomTask)\n        self.__startManipulateCamera(task = t)\n\n    def spawnHPPan(self):\n        # Kill any existing tasks\n        self.__stopManipulateCamera()\n        # Spawn new task\n        self.__startManipulateCamera(func = self.HPPanTask)\n\n    def XZTranslateOrHPanYZoomTask(self, state):\n        if ShowBaseGlobal.direct.fShift:\n            return self.XZTranslateTask(state)\n        else:\n            return self.HPanYZoomTask(state)\n\n    def XZTranslateOrHPPanTask(self, state):\n        if ShowBaseGlobal.direct.fShift:\n            # Panning action\n            return self.HPPanTask(state)\n        else:\n            # Translation action\n            return self.XZTranslateTask(state)\n\n    def XZTranslateTask(self, state):\n        direct = ShowBaseGlobal.direct\n        coaDist = Vec3(self.coaMarker.getPos(direct.camera)).length()\n        xlateSF = coaDist / direct.dr.near\n        direct.camera.setPos(direct.camera,\n                             (-0.5 * direct.dr.mouseDeltaX *\n                              direct.dr.nearWidth *\n                              xlateSF),\n                             0.0,\n                             (-0.5 * direct.dr.mouseDeltaY *\n                              direct.dr.nearHeight *\n                              xlateSF))\n        return Task.cont\n\n    def OrthoTranslateTask(self, state):\n        # create ray from the camera to detect 3d position\n        direct = ShowBaseGlobal.direct\n        iRay = SelectionRay(direct.camera)\n        iRay.collider.setFromLens(direct.camNode, direct.dr.mouseX, direct.dr.mouseY)\n        #iRay.collideWithBitMask(1)\n        iRay.collideWithBitMask(BitMask32.bit(21))\n        iRay.ct.traverse(direct.grid)\n\n        entry = iRay.getEntry(0)\n        hitPt = entry.getSurfacePoint(entry.getFromNodePath())\n        iRay.collisionNodePath.removeNode()\n        del iRay\n        if hasattr(state, 'prevPt'):\n            direct.camera.setPos(direct.camera, (state.prevPt - hitPt))\n        state.prevPt = hitPt\n        return Task.cont\n\n    def HPanYZoomTask(self, state):\n        # If the cam is orthogonal, don't rotate or zoom.\n        direct = ShowBaseGlobal.direct\n        if (hasattr(direct.cam.node(), \"getLens\") and\n            direct.cam.node().getLens().__class__.__name__ == \"OrthographicLens\"):\n            return\n\n        if direct.fControl:\n            moveDir = Vec3(self.coaMarker.getPos(direct.camera))\n            # If marker is behind camera invert vector\n            if moveDir[1] < 0.0:\n                moveDir.assign(moveDir * -1)\n            moveDir.normalize()\n        else:\n            moveDir = Vec3(Y_AXIS)\n\n        if self.useMayaCamControls: # use maya controls\n            moveDir.assign(moveDir * ((direct.dr.mouseDeltaX -1.0 * direct.dr.mouseDeltaY)\n                                    * state.zoomSF))\n            hVal = 0.0\n        else:\n            moveDir.assign(moveDir * (-1.0 * direct.dr.mouseDeltaY *\n                                        state.zoomSF))\n            if direct.dr.mouseDeltaY > 0.0:\n                moveDir.setY(moveDir[1] * 1.0)\n\n            hVal = 0.5 * direct.dr.mouseDeltaX * direct.dr.fovH\n\n        direct.camera.setPosHpr(direct.camera,\n                                moveDir[0],\n                                moveDir[1],\n                                moveDir[2],\n                                hVal,\n                                0.0, 0.0)\n        if self.lockRoll:\n            # flatten roll\n            direct.camera.setR(0)\n\n        return Task.cont\n\n    def OrthoZoomTask(self, state):\n        direct = ShowBaseGlobal.direct\n        filmSize = direct.camNode.getLens().getFilmSize()\n        factor = (direct.dr.mouseDeltaX -1.0 * direct.dr.mouseDeltaY) * 0.1\n        x = direct.dr.getWidth()\n        y = direct.dr.getHeight()\n        direct.dr.orthoFactor -= factor\n        if direct.dr.orthoFactor < 0:\n            direct.dr.orthoFactor = 0.0001\n        direct.dr.updateFilmSize(x, y)\n        return Task.cont\n\n    def HPPanTask(self, state):\n        direct = ShowBaseGlobal.direct\n        direct.camera.setHpr(direct.camera,\n                             (0.5 * direct.dr.mouseDeltaX *\n                              direct.dr.fovH),\n                             (-0.5 * direct.dr.mouseDeltaY *\n                              direct.dr.fovV),\n                             0.0)\n        return Task.cont\n\n    def spawnMouseRotateTask(self):\n        # Kill any existing tasks\n        self.__stopManipulateCamera()\n        direct = ShowBaseGlobal.direct\n        if self.perspCollPlane:\n            iRay = SelectionRay(direct.camera)\n            iRay.collider.setFromLens(direct.camNode, 0.0, 0.0)\n            iRay.collideWithBitMask(1)\n\n            if direct.camera.getPos().getZ() >=0:\n                iRay.ct.traverse(self.perspCollPlane)\n            else:\n                iRay.ct.traverse(self.perspCollPlane2)\n\n            if iRay.getNumEntries() > 0:\n                entry = iRay.getEntry(0)\n                hitPt = entry.getSurfacePoint(entry.getFromNodePath())\n\n                # create a temp nodePath to get the position\n                np = NodePath('temp')\n                np.setPos(direct.camera, hitPt)\n                self.coaMarkerPos = np.getPos()\n                np.removeNode()\n                self.coaMarker.setPos(self.coaMarkerPos)\n\n            iRay.collisionNodePath.removeNode()\n            del iRay\n\n        # Set at markers position in render coordinates\n        self.camManipRef.setPos(self.coaMarkerPos)\n        self.camManipRef.setHpr(direct.camera, DG.ZERO_POINT)\n        t = Task.Task(self.mouseRotateTask)\n        if abs(direct.dr.mouseX) > 0.9:\n            t.constrainedDir = 'y'\n        else:\n            t.constrainedDir = 'x'\n        self.__startManipulateCamera(task = t)\n\n    def mouseRotateTask(self, state):\n        # If the cam is orthogonal, don't rotate.\n        direct = ShowBaseGlobal.direct\n        if (hasattr(direct.cam.node(), \"getLens\") and\n            direct.cam.node().getLens().__class__.__name__ == \"OrthographicLens\"):\n            return\n        # If moving outside of center, ignore motion perpendicular to edge\n        if ((state.constrainedDir == 'y') and (abs(direct.dr.mouseX) > 0.9)):\n            deltaX = 0\n            deltaY = direct.dr.mouseDeltaY\n        elif ((state.constrainedDir == 'x') and (abs(direct.dr.mouseY) > 0.9)):\n            deltaX = direct.dr.mouseDeltaX\n            deltaY = 0\n        else:\n            deltaX = direct.dr.mouseDeltaX\n            deltaY = direct.dr.mouseDeltaY\n        if direct.fShift:\n            direct.camera.setHpr(direct.camera,\n                                 (deltaX * direct.dr.fovH),\n                                 (-deltaY * direct.dr.fovV),\n                                 0.0)\n            if self.lockRoll:\n                # flatten roll\n                direct.camera.setR(0)\n            self.camManipRef.setPos(self.coaMarkerPos)\n            self.camManipRef.setHpr(direct.camera, DG.ZERO_POINT)\n        else:\n            if direct.camera.getPos().getZ() >=0 or not self.switchDirBelowZero:\n                dirX = -1\n            else:\n                dirX = 1\n\n            wrt = direct.camera.getTransform(self.camManipRef)\n            self.camManipRef.setHpr(self.camManipRef,\n                                    (dirX * deltaX * 180.0),\n                                    (deltaY * 180.0),\n                                    0.0)\n\n            if self.lockRoll:\n                # flatten roll\n                self.camManipRef.setR(0)\n            direct.camera.setTransform(self.camManipRef, wrt)\n        return Task.cont\n\n    def spawnMouseRollTask(self):\n        # Kill any existing tasks\n        self.__stopManipulateCamera()\n        # Set at markers position in render coordinates\n        direct = ShowBaseGlobal.direct\n        self.camManipRef.setPos(self.coaMarkerPos)\n        self.camManipRef.setHpr(direct.camera, DG.ZERO_POINT)\n        t = Task.Task(self.mouseRollTask)\n        t.coaCenter = getScreenXY(self.coaMarker)\n        t.lastAngle = getCrankAngle(t.coaCenter)\n        # Store the camera/manipRef offset transform\n        t.wrt = direct.camera.getTransform(self.camManipRef)\n        self.__startManipulateCamera(task = t)\n\n    def mouseRollTask(self, state):\n        wrt = state.wrt\n        angle = getCrankAngle(state.coaCenter)\n        deltaAngle = angle - state.lastAngle\n        state.lastAngle = angle\n        self.camManipRef.setHpr(self.camManipRef, 0, 0, deltaAngle)\n        if self.lockRoll:\n            # flatten roll\n            self.camManipRef.setR(0)\n        ShowBaseGlobal.direct.camera.setTransform(self.camManipRef, wrt)\n        return Task.cont\n\n    def lockCOA(self):\n        self.fLockCOA = 1\n        ShowBaseGlobal.direct.message('COA Lock On')\n\n    def unlockCOA(self):\n        self.fLockCOA = 0\n        ShowBaseGlobal.direct.message('COA Lock Off')\n\n    def toggleCOALock(self):\n        self.fLockCOA = 1 - self.fLockCOA\n        if self.fLockCOA:\n            ShowBaseGlobal.direct.message('COA Lock On')\n        else:\n            ShowBaseGlobal.direct.message('COA Lock Off')\n\n    def pickNextCOA(self):\n        \"\"\" Cycle through collision handler entries \"\"\"\n        if self.cqEntries:\n            # Get next entry and rotate entries\n            entry = self.cqEntries[0]\n            self.cqEntries = self.cqEntries[1:] + self.cqEntries[:1]\n            # Filter out object's under camera\n            nodePath = entry.getIntoNodePath()\n            if ShowBaseGlobal.direct.camera not in nodePath.getAncestors():\n                # Compute new hit point\n                hitPt = entry.getSurfacePoint(entry.getFromNodePath())\n                # Move coa marker to new point\n                self.updateCoa(hitPt, ref = self.coaMarkerRef)\n            else:\n                # Remove offending entry\n                self.cqEntries = self.cqEntries[:-1]\n                self.pickNextCOA()\n\n    def computeCOA(self, entry):\n        coa = Point3(0)\n        dr = ShowBaseGlobal.direct.drList.getCurrentDr()\n        if self.fLockCOA:\n            # COA is locked, use existing point\n            # Use existing point\n            coa.assign(self.coaMarker.getPos(ShowBaseGlobal.direct.camera))\n            # Reset hit point count\n            self.nullHitPointCount = 0\n        elif entry:\n            # Got a hit point (hit point is in camera coordinates)\n            # Set center of action\n            hitPt = entry.getSurfacePoint(entry.getFromNodePath())\n            hitPtDist = Vec3(hitPt).length()\n            coa.assign(hitPt)\n            # Handle case of bad coa point (too close or too far)\n            if ((hitPtDist < (1.1 * dr.near)) or\n                (hitPtDist > dr.far)):\n                # Just use existing point\n                coa.assign(self.coaMarker.getPos(ShowBaseGlobal.direct.camera))\n            # Reset hit point count\n            self.nullHitPointCount = 0\n        else:\n            # Increment null hit point count\n            self.nullHitPointCount = (self.nullHitPointCount + 1) % 7\n            # No COA lock and no intersection point\n            # Use a point out in front of camera\n            # Distance to point increases on multiple null hit points\n            # MRM: Would be nice to be able to control this\n            # At least display it\n            dist = pow(10.0, self.nullHitPointCount)\n            ShowBaseGlobal.direct.message('COA Distance: ' + repr(dist))\n            coa.set(0, dist, 0)\n        # Compute COA Dist\n        coaDist = Vec3(coa - DG.ZERO_POINT).length()\n        if coaDist < (1.1 * dr.near):\n            coa.set(0, 100, 0)\n            coaDist = 100\n        # Update coa and marker\n        self.updateCoa(coa, coaDist = coaDist)\n\n    def updateCoa(self, ref2point, coaDist = None, ref = None):\n        self.coa.set(ref2point[0], ref2point[1], ref2point[2])\n        if not coaDist:\n            coaDist = Vec3(self.coa - DG.ZERO_POINT).length()\n        # Place the marker in render space\n        if ref is None:\n            # KEH: use the current display region\n            # ref = base.cam\n            ref = ShowBaseGlobal.direct.drList.getCurrentDr().cam\n        self.coaMarker.setPos(ref, self.coa)\n        pos = self.coaMarker.getPos()\n        self.coaMarker.setPosHprScale(pos, Vec3(0), Vec3(1))\n        # Resize it\n        self.updateCoaMarkerSize(coaDist)\n        # Record marker pos in render space\n        self.coaMarkerPos.assign(self.coaMarker.getPos())\n\n    def updateCoaMarkerSizeOnDeath(self):\n        # Needed because tasks pass in state as first arg\n        self.updateCoaMarkerSize()\n\n    def updateCoaMarkerSize(self, coaDist = None):\n        if not coaDist:\n            coaDist = Vec3(self.coaMarker.getPos(ShowBaseGlobal.direct.camera)).length()\n        # Nominal size based on default 30 degree vertical FOV\n        # Need to adjust size based on distance and current FOV\n        sf = COA_MARKER_SF * coaDist * (ShowBaseGlobal.direct.drList.getCurrentDr().fovV/30.0)\n        if sf == 0.0:\n            sf = 0.1\n        self.coaMarker.setScale(sf)\n        # Lerp color to fade out\n        if self.coaMarkerColorIval:\n            self.coaMarkerColorIval.finish()\n        self.coaMarkerColorIval = Sequence(\n            Func(self.coaMarker.unstash),\n            self.coaMarker.colorInterval(1.5, Vec4(1, 0, 0, 0),\n                                         startColor = Vec4(1, 0, 0, 1),\n                                         blendType = 'easeInOut'),\n            Func(self.coaMarker.stash)\n        )\n        self.coaMarkerColorIval.start()\n\n    def homeCam(self):\n        # Record undo point\n        direct = ShowBaseGlobal.direct\n        direct.pushUndo([direct.camera])\n        direct.camera.reparentTo(ShowBaseGlobal.base.render)\n        direct.camera.clearMat()\n        # Resize coa marker\n        self.updateCoaMarkerSize()\n\n    def uprightCam(self):\n        self.__stopManipulateCamera()\n        # Record undo point\n        direct = ShowBaseGlobal.direct\n        direct.pushUndo([direct.camera])\n        # Pitch camera till upright\n        currH = direct.camera.getH()\n        ival = direct.camera.hprInterval(CAM_MOVE_DURATION,\n                                         (currH, 0, 0),\n                                         other=ShowBaseGlobal.base.render,\n                                         blendType='easeInOut',\n                                         name='manipulateCamera')\n        self.__startManipulateCamera(ival=ival)\n\n    def orbitUprightCam(self):\n        self.__stopManipulateCamera()\n        # Record undo point\n        direct = ShowBaseGlobal.direct\n        direct.pushUndo([direct.camera])\n        # Transform camera z axis to render space\n        render = ShowBaseGlobal.base.render\n        mCam2Render = Mat4(Mat4.identMat()) # [gjeon] fixed to give required argument\n        mCam2Render.assign(direct.camera.getMat(render))\n        zAxis = Vec3(mCam2Render.xformVec(DG.Z_AXIS))\n        zAxis.normalize()\n        # Compute rotation angle needed to upright cam\n        orbitAngle = rad2Deg(math.acos(CLAMP(zAxis.dot(DG.Z_AXIS), -1, 1)))\n        # Check angle\n        if orbitAngle < 0.1:\n            # Already upright\n            return\n        # Compute orthogonal axis of rotation\n        rotAxis = Vec3(zAxis.cross(DG.Z_AXIS))\n        rotAxis.normalize()\n        # Find angle between rot Axis and render X_AXIS\n        rotAngle = rad2Deg(math.acos(CLAMP(rotAxis.dot(DG.X_AXIS), -1, 1)))\n        # Determine sign or rotation angle\n        if rotAxis[1] < 0:\n            rotAngle *= -1\n        # Position ref CS at coa marker with xaxis aligned with rot axis\n        self.camManipRef.setPos(self.coaMarker, Vec3(0))\n        self.camManipRef.setHpr(render, rotAngle, 0, 0)\n        # Reparent Cam to ref Coordinate system\n        parent = direct.camera.getParent()\n        direct.camera.wrtReparentTo(self.camManipRef)\n        # Rotate ref CS to final orientation\n        ival = self.camManipRef.hprInterval(CAM_MOVE_DURATION,\n                                            (rotAngle, orbitAngle, 0),\n                                            other = render,\n                                            blendType = 'easeInOut')\n        ival = Sequence(ival, Func(self.reparentCam, parent),\n                        name = 'manipulateCamera')\n        self.__startManipulateCamera(ival = ival)\n\n    def centerCam(self):\n        self.centerCamIn(1.0)\n\n    def centerCamNow(self):\n        self.centerCamIn(0.)\n\n    def centerCamIn(self, t):\n        self.__stopManipulateCamera()\n        # Record undo point\n        direct = ShowBaseGlobal.direct\n        direct.pushUndo([direct.camera])\n        # Determine marker location\n        markerToCam = self.coaMarker.getPos(direct.camera)\n        dist = Vec3(markerToCam - DG.ZERO_POINT).length()\n        scaledCenterVec = Y_AXIS * dist\n        delta = markerToCam - scaledCenterVec\n        self.camManipRef.setPosHpr(direct.camera, Point3(0), Point3(0))\n        ival = direct.camera.posInterval(CAM_MOVE_DURATION,\n                                         Point3(delta),\n                                         other=self.camManipRef,\n                                         blendType='easeInOut')\n        ival = Sequence(ival, Func(self.updateCoaMarkerSizeOnDeath),\n                        name = 'manipulateCamera')\n        self.__startManipulateCamera(ival = ival)\n\n    def zoomCam(self, zoomFactor, t):\n        self.__stopManipulateCamera()\n        # Record undo point\n        direct = ShowBaseGlobal.direct\n        direct.pushUndo([direct.camera])\n        # Find a point zoom factor times the current separation\n        # of the widget and cam\n        zoomPtToCam = self.coaMarker.getPos(direct.camera) * zoomFactor\n        # Put a target nodePath there\n        self.camManipRef.setPos(direct.camera, zoomPtToCam)\n        # Move to that point\n        ival = direct.camera.posInterval(CAM_MOVE_DURATION,\n                                         DG.ZERO_POINT,\n                                         other=self.camManipRef,\n                                         blendType='easeInOut')\n        ival = Sequence(ival, Func(self.updateCoaMarkerSizeOnDeath),\n                        name = 'manipulateCamera')\n        self.__startManipulateCamera(ival = ival)\n\n    def spawnMoveToView(self, view):\n        # Kill any existing tasks\n        self.__stopManipulateCamera()\n        # Record undo point\n        direct = ShowBaseGlobal.direct\n        direct.pushUndo([direct.camera])\n        # Calc hprOffset\n        hprOffset = VBase3()\n        if view == 8:\n            # Try the next roll angle\n            self.orthoViewRoll = (self.orthoViewRoll + 90.0) % 360.0\n            # but use the last view\n            view = self.lastView\n        else:\n            self.orthoViewRoll = 0.0\n        # Adjust offset based on specified view\n        if view == 1:\n            hprOffset.set(180., 0., 0.)\n        elif view == 2:\n            hprOffset.set(0., 0., 0.)\n        elif view == 3:\n            hprOffset.set(90., 0., 0.)\n        elif view == 4:\n            hprOffset.set(-90., 0., 0.)\n        elif view == 5:\n            hprOffset.set(0., -90., 0.)\n        elif view == 6:\n            hprOffset.set(0., 90., 0.)\n        elif view == 7:\n            hprOffset.set(135., -35.264, 0.)\n        # Position target\n        self.camManipRef.setPosHpr(self.coaMarker, DG.ZERO_VEC,\n                                   hprOffset)\n        # Scale center vec by current distance to target\n        offsetDistance = Vec3(direct.camera.getPos(self.camManipRef) -\n                              DG.ZERO_POINT).length()\n        scaledCenterVec = Y_AXIS * (-1.0 * offsetDistance)\n        # Now put the camManipRef at that point\n        self.camManipRef.setPosHpr(self.camManipRef,\n                                   scaledCenterVec,\n                                   DG.ZERO_VEC)\n        # Record view for next time around\n        self.lastView = view\n        ival = direct.camera.posHprInterval(CAM_MOVE_DURATION,\n                                            pos=DG.ZERO_POINT,\n                                            hpr=VBase3(0, 0, self.orthoViewRoll),\n                                            other=self.camManipRef,\n                                            blendType='easeInOut')\n        ival = Sequence(ival, Func(self.updateCoaMarkerSizeOnDeath),\n                        name = 'manipulateCamera')\n        self.__startManipulateCamera(ival = ival)\n\n    def swingCamAboutWidget(self, degrees, t):\n        # Remove existing camera manipulation task\n        self.__stopManipulateCamera()\n\n        # Record undo point\n        direct = ShowBaseGlobal.direct\n        direct.pushUndo([direct.camera])\n\n        # Coincident with widget\n        self.camManipRef.setPos(self.coaMarker, DG.ZERO_POINT)\n        # But aligned with render space\n        self.camManipRef.setHpr(DG.ZERO_POINT)\n\n        parent = direct.camera.getParent()\n        direct.camera.wrtReparentTo(self.camManipRef)\n\n        ival = self.camManipRef.hprInterval(CAM_MOVE_DURATION,\n                                            VBase3(degrees, 0, 0),\n                                            blendType = 'easeInOut')\n        ival = Sequence(ival, Func(self.reparentCam, parent),\n                        name = 'manipulateCamera')\n        self.__startManipulateCamera(ival = ival)\n\n    def reparentCam(self, parent):\n        ShowBaseGlobal.direct.camera.wrtReparentTo(parent)\n        self.updateCoaMarkerSize()\n\n    def fitOnWidget(self, nodePath = 'None Given'):\n        # Fit the node on the screen\n        # stop any ongoing tasks\n        self.__stopManipulateCamera()\n        # How big is the node?\n        direct = ShowBaseGlobal.direct\n        nodeScale = direct.widget.scalingNode.getScale(ShowBaseGlobal.base.render)\n        maxScale = max(nodeScale[0], nodeScale[1], nodeScale[2])\n        maxDim = min(direct.dr.nearWidth, direct.dr.nearHeight)\n\n        # At what distance does the object fill 30% of the screen?\n        # Assuming radius of 1 on widget\n        camY = direct.dr.near * (2.0 * maxScale) / (0.3 * maxDim)\n\n        # What is the vector through the center of the screen?\n        centerVec = Y_AXIS * camY\n\n        # Where is the node relative to the viewpoint\n        vWidget2Camera = direct.widget.getPos(direct.camera)\n\n        # How far do you move the camera to be this distance from the node?\n        deltaMove = vWidget2Camera - centerVec\n\n        # Move a target there\n        try:\n            self.camManipRef.setPos(direct.camera, deltaMove)\n        except Exception:\n            #self.notify.debug\n            pass\n\n        parent = direct.camera.getParent()\n        direct.camera.wrtReparentTo(self.camManipRef)\n        ival = direct.camera.posInterval(CAM_MOVE_DURATION,\n                                         Point3(0, 0, 0),\n                                         blendType='easeInOut')\n        ival = Sequence(ival, Func(self.reparentCam, parent),\n                        name='manipulateCamera')\n        self.__startManipulateCamera(ival=ival)\n\n    def moveToFit(self):\n        # How big is the active widget?\n        direct = ShowBaseGlobal.direct\n        widgetScale = direct.widget.scalingNode.getScale(ShowBaseGlobal.base.render)\n        maxScale = max(widgetScale[0], widgetScale[1], widgetScale[2])\n        # At what distance does the widget fill 50% of the screen?\n        camY = ((2 * direct.dr.near * (1.5 * maxScale)) /\n                min(direct.dr.nearWidth, direct.dr.nearHeight))\n        # Find a point this distance along the Y axis\n        # MRM: This needs to be generalized to support non uniform frusta\n        centerVec = Y_AXIS * camY\n        # Before moving, record the relationship between the selected nodes\n        # and the widget, so that this can be maintained\n        direct.selected.getWrtAll()\n        # Push state onto undo stack\n        direct.pushUndo(direct.selected)\n        # Remove the task to keep the widget attached to the object\n        taskMgr.remove('followSelectedNodePath')\n        # Spawn a task to keep the selected objects with the widget\n        taskMgr.add(self.stickToWidgetTask, 'stickToWidget')\n        # Spawn a task to move the widget\n        ival = direct.widget.posInterval(CAM_MOVE_DURATION,\n                                         Point3(centerVec),\n                                         other=direct.camera,\n                                         blendType='easeInOut')\n        ival = Sequence(ival, Func(lambda: taskMgr.remove('stickToWidget')),\n                        name = 'moveToFit')\n        ival.start()\n\n    def stickToWidgetTask(self, state):\n        # Move the objects with the widget\n        ShowBaseGlobal.direct.selected.moveWrtWidgetAll()\n        # Continue\n        return Task.cont\n\n    def enableMouseFly(self, fKeyEvents = 1):\n        # disable C++ fly interface\n        base = ShowBaseGlobal.base\n        base.disableMouse()\n        # Enable events\n        for event in self.actionEvents:\n            self.accept(event[0], event[1], extraArgs = event[2:])\n        if fKeyEvents:\n            for event in self.keyEvents:\n                self.accept(event[0], event[1], extraArgs = event[2:])\n        # Show marker\n        self.coaMarker.reparentTo(ShowBaseGlobal.direct.group)\n\n    def disableMouseFly(self):\n        # Hide the marker\n        self.coaMarker.reparentTo(ShowBaseGlobal.hidden)\n        # Ignore events\n        for event in self.actionEvents:\n            self.ignore(event[0])\n        for event in self.keyEvents:\n            self.ignore(event[0])\n        # Kill tasks\n        self.removeManipulateCameraTask()\n        taskMgr.remove('stickToWidget')\n        ShowBaseGlobal.base.enableMouse()\n\n    def removeManipulateCameraTask(self):\n        self.__stopManipulateCamera()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/directtools/DirectCameraControl.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/b7d65bc2_DirectCameraControl.json",
    "doc_id": "doc_181"
  }
}