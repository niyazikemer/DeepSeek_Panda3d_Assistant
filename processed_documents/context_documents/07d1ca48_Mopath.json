{
  "content": "from direct.showbase.DirectObject import DirectObject\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.directtools.DirectUtil import CLAMP\nfrom direct.task.TaskManagerGlobal import taskMgr\n\nfrom panda3d.core import (\n    PCTHPR,\n    PCTNONE,\n    PCTT,\n    PCTXYZ,\n    ClockObject,\n    LineSegs,\n    NodePath,\n    ParametricCurve,\n    Point3,\n    Vec3,\n)\n\n\nclass Mopath(DirectObject):\n\n    nameIndex = 1\n\n    def __init__(self, name = None, fluid = 1, objectToLoad = None, upVectorNodePath = None, reverseUpVector = False):\n        if name is None:\n            name = f'mopath{self.nameIndex}'\n            self.nameIndex = self.nameIndex + 1\n        self.name = name\n        self.fluid = fluid\n        self.tPoint = Point3(0)\n        self.posPoint = Point3(0)\n        self.hprPoint = Point3(0)\n        self.tangentVec = Vec3(0)\n        self.fFaceForward = 0\n        self.faceForwardDelta = None\n        self.faceForwardNode = None\n        self.timeScale = 1\n        self.upVectorNodePath = upVectorNodePath\n        self.reverseUpVector = reverseUpVector\n        self.reset()\n        if isinstance(objectToLoad, NodePath):\n            self.loadNodePath(objectToLoad)\n        elif isinstance(objectToLoad, str):\n            self.loadFile(objectToLoad)\n        elif objectToLoad is not None:\n            print(f\"Mopath: Unable to load object '{objectToLoad}', objectToLoad must be a file name string or a NodePath\")\n\n    def getMaxT(self):\n        return self.maxT * self.timeScale\n\n    def loadFile(self, filename, fReset = 1):\n        nodePath = base.loader.loadModel(filename)\n        if nodePath:\n            self.loadNodePath(nodePath)\n            nodePath.removeNode()\n        else:\n            print('Mopath: no data in file: %s' % filename)\n\n    def loadNodePath(self, nodePath, fReset = 1):\n        if fReset:\n            self.reset()\n\n        self.__extractCurves(nodePath)\n        if self.tNurbsCurve:\n            self.maxT = self.tNurbsCurve[-1].getMaxT()\n        elif self.xyzNurbsCurve is not None:\n            self.maxT = self.xyzNurbsCurve.getMaxT()\n        elif self.hprNurbsCurve is not None:\n            self.maxT = self.hprNurbsCurve.getMaxT()\n        else:\n            print('Mopath: no valid curves in nodePath: %s' % nodePath)\n\n    def reset(self):\n        self.maxT = 0.0\n        self.loop = 0\n        self.xyzNurbsCurve = None\n        self.hprNurbsCurve = None\n        self.tNurbsCurve = []\n        self.node = None\n\n    def __extractCurves(self, nodePath):\n        node = nodePath.node()\n        if isinstance(node, ParametricCurve):\n            if node.getCurveType() == PCTXYZ:\n                self.xyzNurbsCurve = node\n            elif node.getCurveType() == PCTHPR:\n                self.hprNurbsCurve = node\n            elif node.getCurveType() == PCTNONE:\n                if self.xyzNurbsCurve is None:\n                    self.xyzNurbsCurve = node\n                else:\n                    print('Mopath: got a PCT_NONE curve and an XYZ Curve in nodePath: %s' % nodePath)\n            elif node.getCurveType() == PCTT:\n                self.tNurbsCurve.append(node)\n        else:\n            # Iterate over children if any\n            for child in nodePath.getChildren():\n                self.__extractCurves(child)\n\n    def calcTime(self, tIn):\n        return self.__calcTime(tIn, self.tNurbsCurve)\n\n    def __calcTime(self, tIn, tCurveList):\n        if tCurveList:\n            tCurveList[-1].getPoint(tIn, self.tPoint)\n            return self.__calcTime(self.tPoint[0], tCurveList[:-1])\n        else:\n            return tIn\n\n    def getFinalState(self):\n        pos = Point3(0)\n        if self.xyzNurbsCurve is not None:\n            self.xyzNurbsCurve.getPoint(self.maxT, pos)\n        hpr = Point3(0)\n        if self.hprNurbsCurve is not None:\n            self.hprNurbsCurve.getPoint(self.maxT, hpr)\n        return (pos, hpr)\n\n    def goTo(self, node, time):\n        if self.xyzNurbsCurve is None and self.hprNurbsCurve is None:\n            print('Mopath: Mopath has no curves')\n            return\n        time /= self.timeScale\n        self.playbackTime = self.calcTime(CLAMP(time, 0.0, self.maxT))\n        if self.xyzNurbsCurve is not None:\n            self.xyzNurbsCurve.getPoint(self.playbackTime, self.posPoint)\n            if self.fluid:\n                node.setFluidPos(self.posPoint)\n            else:\n                node.setPos(self.posPoint)\n        if self.hprNurbsCurve is not None:\n            self.hprNurbsCurve.getPoint(self.playbackTime, self.hprPoint)\n            node.setHpr(self.hprPoint)\n        elif self.fFaceForward and self.xyzNurbsCurve is not None:\n            if self.faceForwardDelta:\n                # Look at a point a bit ahead in parametric time.\n                t = min(self.playbackTime + self.faceForwardDelta, self.xyzNurbsCurve.getMaxT())\n                lookPoint = Point3()\n                self.xyzNurbsCurve.getPoint(t, lookPoint)\n                if self.faceForwardNode:\n                    self.faceForwardNode.setPos(lookPoint)\n            else:\n                self.xyzNurbsCurve.getTangent(self.playbackTime, self.tangentVec)\n                lookPoint = self.posPoint + self.tangentVec\n\n            # use the self.upVectorNodePath position if it exists to\n            # create an up vector for lookAt\n            if self.upVectorNodePath is None:\n                node.lookAt(lookPoint)\n            else:\n                if not self.reverseUpVector:\n                    node.lookAt(lookPoint,\n                                self.upVectorNodePath.getPos() - self.posPoint)\n                else:\n                    node.lookAt(lookPoint,\n                                self.posPoint - self.upVectorNodePath.getPos())\n\n    def play(self, node, time = 0.0, loop = 0):\n        if self.xyzNurbsCurve is None and self.hprNurbsCurve is None:\n            print('Mopath: Mopath has no curves')\n            return\n        self.node = node\n        self.loop = loop\n        self.stop()\n        t = taskMgr.add(self.__playTask, self.name + '-play')\n        t.currentTime = time\n        t.lastTime = ClockObject.getGlobalClock().getFrameTime()\n\n    def stop(self):\n        taskMgr.remove(self.name + '-play')\n\n    def __playTask(self, task):\n        time = ClockObject.getGlobalClock().getFrameTime()\n        dTime = time - task.lastTime\n        task.lastTime = time\n        if self.loop:\n            cTime = (task.currentTime + dTime) % self.getMaxT()\n        else:\n            cTime = task.currentTime + dTime\n        if self.loop == 0 and cTime > self.getMaxT():\n            self.stop()\n            messenger.send(self.name + '-done')\n            self.node = None\n            return task.done\n        self.goTo(self.node, cTime)\n        task.currentTime = cTime\n        return task.cont\n\n    def draw(self, subdiv = 1000):\n        \"\"\" Draws a quick and cheesy visualization of the Mopath using\n        LineSegs.  Returns the NodePath representing the drawing. \"\"\"\n\n        ls = LineSegs('mopath')\n        p = Point3()\n        for ti in range(subdiv):\n            t = float(ti) / float(subdiv) * self.maxT\n            tp = self.calcTime(t)\n            self.xyzNurbsCurve.getPoint(tp, p)\n            ls.drawTo(p)\n\n        return NodePath(ls.create())\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/directutil/Mopath.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/07d1ca48_Mopath.json",
    "doc_id": "doc_121"
  }
}