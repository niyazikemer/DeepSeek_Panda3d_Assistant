{
  "content": "from direct.directnotify.DirectNotifyGlobal import directNotify\n\n\nclass PhasedObject:\n    \"\"\"\n    This class is governs the loading and unloading of successive\n    phases in an ordered and automatic manner.\n\n    An object can only have one phase at any given moment. At the\n    completion of setPhase() the current and all previous phases are\n    guaranteed to be loaded, while all later phases are guaranteed\n    to be unloaded.\n\n    In order to define a phase, simply define the functions:\n    loadPhase<#> and unloadPhase<#> where # corresponds to the number\n    of the phase to be defined and # >= 0.\n\n    You also have the ability to define alias for phases so that\n    your function definitions are more descriptive.  The way to do\n    this is to provide an aliasMap to __init__().  The aliasMap is\n    of the form {'alias':#, ...}. You can then call setPhase() with\n    this alias as well.\n\n    So for example, if you wanted to alias phase 0 to 'Far' you\n    would define loadPhaseFar() and unloadPhaseFar(). Upon calling\n    setPhase(0), setPhase('Far'), setPhase(<any phase greater than 0>),\n    or setPhase(<any alias greater than 'Far'>), loadPhaseFar() will\n    be invoked.\n\n    For a skeleton example class, see the AnfaPhasedObject class\n    definition lower in this file.\n    \"\"\"\n    notify = directNotify.newCategory(\"PhasedObject\")\n\n    def __init__(self, aliasMap = {}):\n        self.phase = -1\n        self.phaseAliasMap = {}\n        self.aliasPhaseMap = {}\n        self.__phasing = False\n\n        for alias,phase in list(aliasMap.items()):\n            self.setAlias(phase, alias)\n\n    def __repr__(self):\n        return 'PhasedObject(%s)' % str(self.aliasPhaseMap)\n\n    def __str__(self):\n        outStr = PhasedObject.__repr__(self)\n        outStr += ' in phase \\'%s\\'' % self.getPhase()\n        return outStr\n\n    def setAlias(self, phase, alias):\n        \"\"\"\n        Map an alias to a phase number.\n\n        phase must be >= 0 and alias must be a string\n        of characters suitable for python variable names.\n\n        The mapping must be one-to-one.\n        \"\"\"\n        assert isinstance(phase,int) and phase >= 0\n        assert isinstance(alias,str)\n\n        self.phaseAliasMap[phase] = alias\n        self.aliasPhaseMap[alias] = phase\n\n    def getPhaseAlias(self, phase):\n        \"\"\"\n        Returns the alias of a phase number, if it exists.\n        Otherwise, returns the phase number.\n        \"\"\"\n        return self.phaseAliasMap.get(phase, phase)\n\n    def getAliasPhase(self, alias):\n        \"\"\"\n        Returns the phase number of an alias, if it exists.\n        Otherwise, returns the alias.\n        \"\"\"\n        return self.aliasPhaseMap.get(alias, alias)\n\n    def getPhase(self):\n        \"\"\"\n        Returns the current phase (or alias, if defined)\n        this object is currently in.\n        \"\"\"\n        return self.getPhaseAlias(self.phase)\n\n    def setPhase(self, aPhase):\n        \"\"\"\n        aPhase can be either a phase number or a predefined alias.\n\n        Will invoke a sequence of loadPhase*() or unloadPhase*()\n        functions corresponding to the difference between the current\n        phase and aPhase, starting at the current phase.\n        \"\"\"\n        assert not self.__phasing, 'Already phasing. Cannot setPhase() while phasing in progress.'\n        self.__phasing = True\n\n        phase = self.aliasPhaseMap.get(aPhase,aPhase)\n        assert isinstance(phase,int), 'Phase alias \\'%s\\' not found' % aPhase\n        assert phase >= -1, 'Invalid phase number \\'%s\\'' % phase\n\n        if phase > self.phase:\n            for x in range(self.phase + 1, phase + 1):\n                self.__loadPhase(x)\n        elif phase < self.phase:\n            for x in range(self.phase, phase, -1):\n                self.__unloadPhase(x)\n\n        self.__phasing = False\n\n    def cleanup(self):\n        \"\"\"\n        Will force the unloading, in correct order, of all currently\n        loaded phases.\n        \"\"\"\n        if self.phase >= 0:\n            self.setPhase(-1)\n\n    def __loadPhase(self, phase):\n        aPhase = self.phaseAliasMap.get(phase, phase)\n        getattr(self, f'loadPhase{aPhase}',\n                lambda: self.__phaseNotFound('load', aPhase))()\n        self.phase = phase\n\n    def __unloadPhase(self, phase):\n        aPhase = self.phaseAliasMap.get(phase, phase)\n        getattr(self, f'unloadPhase{aPhase}',\n                lambda: self.__phaseNotFound('unload', aPhase))()\n        self.phase = phase - 1\n\n    def __phaseNotFound(self, mode, aPhase):\n        assert self.notify.debug(f'{mode}{aPhase}() not found!\\n')\n\nif __debug__:\n    class AnfaPhasedObject(PhasedObject):\n        \"\"\"\n        This is an example class to demonstrate the concept of\n        alias mapping for PhasedObjects.\n\n        As the distance between an observer and this object closes,\n        we would set the phase level succesively higher, with an initial\n        phase of 'Away' being set in __init__:\n\n        setPhase('Far') -> invokes loadPhaseFar()\n        setPhase('Near') -> invokes loadPhaseNear()\n\n        Now let's say the objects start moving away from each other:\n\n        setPhase('Far') -> invokes unloadPhaseNear()\n        setPhase('Away') -> invokes unloadPhaseFar()\n\n        Now one object teleports to the other:\n\n        setPhase('At') -> invokes loadPhase('Far'),\n                          then    loadPhase('Near'),\n                          then    loadPhase('At')\n\n        Now the phased object is destroyed, we must clean it up\n        before removal:\n\n        cleanup() -> invokes unloadPhase('At')\n                     then    unloadPhase('Near')\n                     then    unloadPhase('Far')\n                     then    unloadPhase('Away')\n        \"\"\"\n        def __init__(self):\n            PhasedObject.__init__(self, {'At':3, 'Near':2, 'Far':1, 'Away':0})\n            self.setPhase('Away')\n\n        def loadPhaseAway(self):\n            print('loading Away')\n\n        def unloadPhaseAway(self):\n            print('unloading Away')\n\n        def loadPhaseFar(self):\n            print('loading Far')\n\n        def unloadPhaseFar(self):\n            print('unloading Far')\n\n        def loadPhaseNear(self):\n            print('loading Near')\n\n        def unloadPhaseNear(self):\n            print('unloading Near')\n\n        def loadPhaseAt(self):\n            print('loading At')\n\n        def unloadPhaseAt(self):\n            print('unloading At')\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/PhasedObject.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/0cacf4fe_PhasedObject.json",
    "doc_id": "doc_278"
  }
}