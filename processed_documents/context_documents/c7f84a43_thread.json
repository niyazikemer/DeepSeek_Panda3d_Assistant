{
  "content": "\"\"\" This module reimplements Python's native thread module using Panda\nthreading constructs.  It's designed as a drop-in replacement for the\nthread module for code that works with Panda; it is necessary because\nin some compilation models, Panda's threading constructs are\nincompatible with the OS-provided threads used by Python's thread\nmodule. \"\"\"\n\n__all__ = [\n    'error', 'LockType',\n    'start_new_thread',\n    'interrupt_main',\n    'exit', 'allocate_lock', 'get_ident',\n    'stack_size',\n    'force_yield', 'consider_yield',\n    'forceYield', 'considerYield',\n    'TIMEOUT_MAX'\n]\n\nfrom panda3d import core\nimport sys\n\nif sys.platform == \"win32\":\n    TIMEOUT_MAX = float(0xffffffff // 1000)\nelse:\n    TIMEOUT_MAX = float(0x7fffffffffffffff // 1000000000)\n\n# These methods are defined in Panda, and are particularly useful if\n# you may be running in Panda's SIMPLE_THREADS compilation mode.\nforce_yield = core.Thread.force_yield\nconsider_yield = core.Thread.consider_yield\n\nforceYield = force_yield\nconsiderYield = consider_yield\nerror = RuntimeError\n\n\nclass LockType:\n    \"\"\" Implements a mutex lock.  Instead of directly subclassing\n    PandaModules.Mutex, we reimplement the lock here, to allow us to\n    provide the described Python lock semantics.  In particular, this\n    allows a different thread to release the lock than the one that\n    acquired it. \"\"\"\n\n    def __init__(self):\n        self.__lock = core.Mutex('PythonLock')\n        self.__cvar = core.ConditionVar(self.__lock)\n        self.__locked = False\n\n    def acquire(self, waitflag = 1, timeout = -1):\n        self.__lock.acquire()\n        try:\n            if self.__locked and not waitflag:\n                return False\n\n            if timeout >= 0:\n                while self.__locked:\n                    self.__cvar.wait(timeout)\n            else:\n                while self.__locked:\n                    self.__cvar.wait()\n\n            self.__locked = True\n            return True\n\n        finally:\n            self.__lock.release()\n\n    def release(self):\n        self.__lock.acquire()\n        try:\n            if not self.__locked:\n                raise error('Releasing unheld lock.')\n\n            self.__locked = False\n            self.__cvar.notify()\n\n        finally:\n            self.__lock.release()\n\n    def locked(self):\n        return self.__locked\n\n    __enter__ = acquire\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n\n# Helper to generate new thread names\n_counter = 0\n\n\ndef _newname(template=\"Thread-%d\"):\n    global _counter\n    _counter = _counter + 1\n    return template % _counter\n\n\n_threads = {}\n_nextThreadId = 0\n_threadsLock = core.Mutex('thread._threadsLock')\n\n\ndef start_new_thread(function, args, kwargs = {}, name = None):\n    def threadFunc(threadId, function = function, args = args, kwargs = kwargs):\n        try:\n            try:\n                function(*args, **kwargs)\n            except SystemExit:\n                pass\n\n        finally:\n            _remove_thread_id(threadId)\n\n    global _nextThreadId\n    _threadsLock.acquire()\n    try:\n        threadId = _nextThreadId\n        _nextThreadId += 1\n\n        if name is None:\n            name = 'PythonThread-%s' % (threadId)\n\n        thread = core.PythonThread(threadFunc, [threadId], name, name)\n        thread.setPythonIndex(threadId)\n        _threads[threadId] = (thread, {}, None)\n\n        thread.start(core.TPNormal, False)\n        return threadId\n\n    finally:\n        _threadsLock.release()\n\n\ndef _add_thread(thread, wrapper):\n    \"\"\" Adds the indicated core.Thread object, with the indicated Python\n    wrapper, to the thread list.  Returns the new thread ID. \"\"\"\n\n    global _nextThreadId\n    _threadsLock.acquire()\n    try:\n        threadId = _nextThreadId\n        _nextThreadId += 1\n\n        thread.setPythonIndex(threadId)\n        _threads[threadId] = (thread, {}, wrapper)\n        return threadId\n\n    finally:\n        _threadsLock.release()\n\n\ndef _get_thread_wrapper(thread, wrapperClass):\n    \"\"\" Returns the thread wrapper for the indicated thread.  If there\n    is not one, creates an instance of the indicated wrapperClass\n    instead. \"\"\"\n\n    threadId = thread.getPythonIndex()\n    if threadId == -1:\n        # The thread has never been assigned a threadId.  Go assign one.\n\n        global _nextThreadId\n        _threadsLock.acquire()\n        try:\n            threadId = _nextThreadId\n            _nextThreadId += 1\n\n            thread.setPythonIndex(threadId)\n            wrapper = wrapperClass(thread, threadId)\n            _threads[threadId] = (thread, {}, wrapper)\n            return wrapper\n\n        finally:\n            _threadsLock.release()\n\n    else:\n        # The thread has been assigned a threadId.  Look for the wrapper.\n        _threadsLock.acquire()\n        try:\n            t, locals, wrapper = _threads[threadId]\n            assert t == thread\n            if wrapper is None:\n                wrapper = wrapperClass(thread, threadId)\n                _threads[threadId] = (thread, locals, wrapper)\n            return wrapper\n\n        finally:\n            _threadsLock.release()\n\n\ndef _get_thread_locals(thread, i):\n    \"\"\" Returns the locals dictionary for the indicated thread.  If\n    there is not one, creates an empty dictionary. \"\"\"\n\n    threadId = thread.getPythonIndex()\n    if threadId == -1:\n        # The thread has never been assigned a threadId.  Go assign one.\n\n        global _nextThreadId\n        _threadsLock.acquire()\n        try:\n            threadId = _nextThreadId\n            _nextThreadId += 1\n\n            thread.setPythonIndex(threadId)\n            locals = {}\n            _threads[threadId] = (thread, locals, None)\n            return locals.setdefault(i, {})\n\n        finally:\n            _threadsLock.release()\n\n    else:\n        # The thread has been assigned a threadId.  Get the locals.\n        _threadsLock.acquire()\n        try:\n            t, locals, wrapper = _threads[threadId]\n            assert t == thread\n            return locals.setdefault(i, {})\n\n        finally:\n            _threadsLock.release()\n\n\ndef _remove_thread_id(threadId):\n    \"\"\" Removes the thread with the indicated ID from the thread list. \"\"\"\n\n    # On interpreter shutdown, Python may set module globals to None.\n    if _threadsLock is None or _threads is None:\n        return\n\n    _threadsLock.acquire()\n    try:\n        if threadId in _threads:\n            thread, locals, wrapper = _threads[threadId]\n            assert thread.getPythonIndex() == threadId\n            del _threads[threadId]\n            thread.setPythonIndex(-1)\n\n    finally:\n        _threadsLock.release()\n\n\ndef interrupt_main():\n    # TODO.\n    pass\n\n\ndef exit():\n    raise SystemExit\n\n\ndef allocate_lock():\n    return LockType()\n\n\ndef get_ident():\n    return core.Thread.getCurrentThread().this\n\n\ndef stack_size(size = 0):\n    raise error\n\n\nclass _local(object):\n    \"\"\" This class provides local thread storage using Panda's\n    threading system. \"\"\"\n\n    def __del__(self):\n        i = id(self)\n\n        # Delete this key from all threads.\n        _threadsLock.acquire()\n        try:\n            for thread, locals, wrapper in list(_threads.values()):\n                try:\n                    del locals[i]\n                except KeyError:\n                    pass\n\n        finally:\n            _threadsLock.release()\n\n    def __setattr__(self, key, value):\n        d = _get_thread_locals(core.Thread.getCurrentThread(), id(self))\n        d[key] = value\n\n    def __getattribute__(self, key):\n        d = _get_thread_locals(core.Thread.getCurrentThread(), id(self))\n        if key == '__dict__':\n            return d\n        try:\n            return d[key]\n        except KeyError:\n            return object.__getattribute__(self, key)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/stdpy/thread.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/c7f84a43_thread.json",
    "doc_id": "doc_205"
  }
}