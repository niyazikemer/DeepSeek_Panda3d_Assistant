{
  "content": "import distutils.log\nimport os\nimport subprocess\nimport sys\nimport tarfile\nimport zipfile\nimport struct\n\nimport panda3d.core as p3d\n\ndef create_zip(command, basename, build_dir):\n    base_dir = command.get_archive_basedir()\n\n    with zipfile.ZipFile(basename+'.zip', 'w', compression=zipfile.ZIP_DEFLATED) as zf:\n        zf.write(build_dir, base_dir)\n\n        for dirpath, dirnames, filenames in os.walk(build_dir):\n            dirnames.sort()\n            for name in dirnames:\n                path = os.path.normpath(os.path.join(dirpath, name))\n                zf.write(path, path.replace(build_dir, base_dir, 1))\n            for name in filenames:\n                path = os.path.normpath(os.path.join(dirpath, name))\n                if os.path.isfile(path):\n                    zf.write(path, path.replace(build_dir, base_dir, 1))\n\n\ndef create_tarball(command, basename, build_dir, tar_compression):\n    base_dir = command.get_archive_basedir()\n    build_cmd = command.get_finalized_command('build_apps')\n    binary_names = list(build_cmd.console_apps.keys()) + list(build_cmd.gui_apps.keys())\n\n    source_date = os.environ.get('SOURCE_DATE_EPOCH', '').strip()\n    if source_date:\n        max_mtime = int(source_date)\n    else:\n        max_mtime = None\n\n    def tarfilter(tarinfo):\n        if tarinfo.isdir() or os.path.basename(tarinfo.name) in binary_names:\n            tarinfo.mode = 0o755\n        else:\n            tarinfo.mode = 0o644\n\n        # This isn't interesting information to retain for distribution.\n        tarinfo.uid = 0\n        tarinfo.gid = 0\n        tarinfo.uname = \"\"\n        tarinfo.gname = \"\"\n\n        if max_mtime is not None and tarinfo.mtime >= max_mtime:\n            tarinfo.mtime = max_mtime\n\n        return tarinfo\n\n    filename = '{}.tar.{}'.format(basename, tar_compression)\n    with tarfile.open(filename, 'w|{}'.format(tar_compression)) as tf:\n        tf.add(build_dir, base_dir, filter=tarfilter)\n\n    if tar_compression == 'gz' and max_mtime is not None:\n        # Python provides no elegant way to overwrite the gzip timestamp.\n        with open(filename, 'r+b') as fp:\n            fp.seek(4)\n            fp.write(struct.pack(\"<L\", max_mtime))\n\n\ndef create_gztar(command, basename, build_dir):\n    return create_tarball(command, basename, build_dir, 'gz')\n\n\ndef create_bztar(command, basename, build_dir):\n    return create_tarball(command, basename, build_dir, 'bz2')\n\n\ndef create_xztar(command, basename, build_dir):\n    return create_tarball(command, basename, build_dir, 'xz')\n\n\ndef create_nsis(command, basename, build_dir):\n    platform = command.get_current_platform()\n    if not platform.startswith('win'):\n        command.announce(\n            '\\tNSIS installer not supported for platform: {}'.format(platform),\n            distutils.log.ERROR\n        )\n        return\n    try:\n        subprocess.call(['makensis', '--version'])\n    except OSError:\n        command.announce(\n            '\\tCould not find makensis tool that is required to build NSIS installers',\n            distutils.log.ERROR\n        )\n        return\n\n    is_64bit = platform == 'win_amd64'\n    # Get a list of build applications\n    build_cmd = command.get_finalized_command('build_apps')\n    apps = build_cmd.gui_apps.copy()\n    apps.update(build_cmd.console_apps)\n    apps = [\n        '{}.exe'.format(i)\n        for i in apps\n    ]\n\n    shortname = command.distribution.get_name()\n\n    # Create the .nsi installer script\n    nsifile = p3d.Filename(build_cmd.build_base, shortname + \".nsi\")\n    nsifile.unlink()\n    nsi = open(nsifile.to_os_specific(), \"w\")\n\n    # Some global info\n    nsi.write('Name \"%s\"\\n' % shortname)\n    nsi.write('OutFile \"%s\"\\n' % os.path.join(command.dist_dir, basename+'.exe'))\n    if is_64bit:\n        nsi.write('InstallDir \"$PROGRAMFILES64\\\\%s\"\\n' % shortname)\n    else:\n        nsi.write('InstallDir \"$PROGRAMFILES\\\\%s\"\\n' % shortname)\n    nsi.write('SetCompress auto\\n')\n    nsi.write('SetCompressor lzma\\n')\n    nsi.write('ShowInstDetails nevershow\\n')\n    nsi.write('ShowUninstDetails nevershow\\n')\n    nsi.write('InstType \"Typical\"\\n')\n\n    # Tell Vista that we require admin rights\n    nsi.write('RequestExecutionLevel admin\\n')\n    nsi.write('\\n')\n\n    # TODO offer run and desktop shortcut after we figure out how to deal\n    # with multiple apps\n\n    nsi.write('!include \"MUI2.nsh\"\\n')\n    nsi.write('!define MUI_ABORTWARNING\\n')\n    nsi.write('\\n')\n    nsi.write('Var StartMenuFolder\\n')\n    nsi.write('!insertmacro MUI_PAGE_WELCOME\\n')\n    # TODO license file\n    nsi.write('!insertmacro MUI_PAGE_DIRECTORY\\n')\n    nsi.write('!insertmacro MUI_PAGE_STARTMENU Application $StartMenuFolder\\n')\n    nsi.write('!insertmacro MUI_PAGE_INSTFILES\\n')\n    nsi.write('!insertmacro MUI_PAGE_FINISH\\n')\n    nsi.write('!insertmacro MUI_UNPAGE_WELCOME\\n')\n    nsi.write('!insertmacro MUI_UNPAGE_CONFIRM\\n')\n    nsi.write('!insertmacro MUI_UNPAGE_INSTFILES\\n')\n    nsi.write('!insertmacro MUI_UNPAGE_FINISH\\n')\n    nsi.write('!insertmacro MUI_LANGUAGE \"English\"\\n')\n\n    # This section defines the installer.\n    nsi.write('Section \"\" SecCore\\n')\n    nsi.write('  SetOutPath \"$INSTDIR\"\\n')\n    curdir = \"\"\n    nsi_dir = p3d.Filename.fromOsSpecific(build_cmd.build_base)\n    build_root_dir = p3d.Filename.fromOsSpecific(build_dir)\n    for root, dirs, files in os.walk(build_dir):\n        dirs.sort()\n        for name in files:\n            basefile = p3d.Filename.fromOsSpecific(os.path.join(root, name))\n            file = p3d.Filename(basefile)\n            file.makeAbsolute()\n            file.makeRelativeTo(nsi_dir)\n            outdir = p3d.Filename(basefile)\n            outdir.makeAbsolute()\n            outdir.makeRelativeTo(build_root_dir)\n            outdir = outdir.getDirname().replace('/', '\\\\')\n            if curdir != outdir:\n                nsi.write('  SetOutPath \"$INSTDIR\\\\%s\"\\n' % outdir)\n                curdir = outdir\n            nsi.write('  File \"%s\"\\n' % (file.toOsSpecific()))\n    nsi.write('  SetOutPath \"$INSTDIR\"\\n')\n    nsi.write('  WriteUninstaller \"$INSTDIR\\\\Uninstall.exe\"\\n')\n    nsi.write('  ; Start menu items\\n')\n    nsi.write('  !insertmacro MUI_STARTMENU_WRITE_BEGIN Application\\n')\n    nsi.write('    CreateDirectory \"$SMPROGRAMS\\\\$StartMenuFolder\"\\n')\n    for app in apps:\n        nsi.write('    CreateShortCut \"$SMPROGRAMS\\\\$StartMenuFolder\\\\%s.lnk\" \"$INSTDIR\\\\%s\"\\n' % (shortname, app))\n    nsi.write('    CreateShortCut \"$SMPROGRAMS\\\\$StartMenuFolder\\\\Uninstall.lnk\" \"$INSTDIR\\\\Uninstall.exe\"\\n')\n    nsi.write('  !insertmacro MUI_STARTMENU_WRITE_END\\n')\n    nsi.write('SectionEnd\\n')\n\n    # This section defines the uninstaller.\n    nsi.write('Section Uninstall\\n')\n    nsi.write('  RMDir /r \"$INSTDIR\"\\n')\n    nsi.write('  ; Desktop icon\\n')\n    nsi.write('  Delete \"$DESKTOP\\\\%s.lnk\"\\n' % shortname)\n    nsi.write('  ; Start menu items\\n')\n    nsi.write('  !insertmacro MUI_STARTMENU_GETFOLDER Application $StartMenuFolder\\n')\n    nsi.write('  RMDir /r \"$SMPROGRAMS\\\\$StartMenuFolder\"\\n')\n    nsi.write('SectionEnd\\n')\n    nsi.close()\n\n    cmd = ['makensis']\n    for flag in [\"V2\"]:\n        cmd.append(\n            '{}{}'.format('/' if sys.platform.startswith('win') else '-', flag)\n        )\n    cmd.append(nsifile.to_os_specific())\n    subprocess.check_call(cmd)\n\n\ndef create_aab(command, basename, build_dir):\n    \"\"\"Create an Android App Bundle.  This is a newer format that replaces\n    Android's .apk format for uploads to the Play Store.  Unlike .apk files, it\n    does not rely on a proprietary signing scheme or an undocumented binary XML\n    format (protobuf is used instead), so it is easier to create without\n    requiring external tools.  If desired, it is possible to install bundletool\n    and use it to convert an .aab into an .apk.\n    \"\"\"\n\n    from ._android import AndroidManifest, AbiAlias, BundleConfig, NativeLibraries, ResourceTable\n\n    bundle_fn = p3d.Filename.from_os_specific(command.dist_dir) / (basename + '.aab')\n    build_dir_fn = p3d.Filename.from_os_specific(build_dir)\n\n    # Convert the AndroidManifest.xml file to a protobuf-encoded version of it.\n    axml = AndroidManifest()\n    with open(os.path.join(build_dir, 'AndroidManifest.xml'), 'rb') as fh:\n        axml.parse_xml(fh.read())\n\n    # We use our own zip implementation, which can create the correct\n    # alignment and signature needed by Android automatically.\n    bundle_fn.unlink()\n\n    bundle = p3d.ZipArchive()\n    if not bundle.open_read_write(bundle_fn):\n        command.announce(\n            f'\\tUnable to open {bundle_fn} for writing', distutils.log.ERROR)\n        return\n\n    config = BundleConfig()\n    config.bundletool.version = '1.1.0'\n    config.optimizations.splits_config.Clear()\n    config.optimizations.uncompress_native_libraries.enabled = False\n    bundle.add_subfile('BundleConfig.pb', p3d.StringStream(config.SerializeToString()), 9)\n\n    resources = ResourceTable()\n    package = resources.package.add()\n    package.package_id.id = 0x7f\n    for attrib in axml.root.element.attribute:\n        if attrib.name == 'package':\n            package.package_name = attrib.value\n\n    # Were there any icons referenced in the AndroidManifest.xml?\n    for type_i, type_name in enumerate(axml.resource_types):\n        res_type = package.type.add()\n        res_type.name = type_name\n        res_type.type_id.id = type_i + 1\n\n        for entry_id, res_name in enumerate(axml.resources[type_name]):\n            entry = res_type.entry.add()\n            entry.entry_id.id = entry_id\n            entry.name = res_name\n\n            for density, tag in (160, 'mdpi'), (240, 'hdpi'), (320, 'xhdpi'), (480, 'xxhdpi'), (640, 'xxxhdpi'):\n                path = f'res/mipmap-{tag}-v4/{res_name}.png'\n                if (build_dir_fn / path).exists():\n                    bundle.add_subfile('base/' + path, build_dir_fn / path, 0)\n                    config_value = entry.config_value.add()\n                    config_value.config.density = density\n                    config_value.value.item.file.path = path\n\n    bundle.add_subfile('base/resources.pb', p3d.StringStream(resources.SerializeToString()), 9)\n\n    native = NativeLibraries()\n    for abi in os.listdir(os.path.join(build_dir, 'lib')):\n        native_dir = native.directory.add()\n        native_dir.path = 'lib/' + abi\n        native_dir.targeting.abi.alias = getattr(AbiAlias, abi.upper().replace('-', '_'))\n    bundle.add_subfile('base/native.pb', p3d.StringStream(native.SerializeToString()), 9)\n\n    bundle.add_subfile('base/manifest/AndroidManifest.xml', p3d.StringStream(axml.dumps()), 9)\n\n    # Add the classes.dex.\n    bundle.add_subfile('base/dex/classes.dex', build_dir_fn / 'classes.dex', 9)\n\n    # Add libraries, compressed.\n    for abi in os.listdir(os.path.join(build_dir, 'lib')):\n        abi_dir = os.path.join(build_dir, 'lib', abi)\n\n        for lib in os.listdir(abi_dir):\n            if lib.startswith('lib') and lib.endswith('.so'):\n                bundle.add_subfile(f'base/lib/{abi}/{lib}', build_dir_fn / 'lib' / abi / lib, 9)\n\n    # Add assets, compressed.\n    assets_dir = os.path.join(build_dir, 'assets')\n    for dirpath, dirnames, filenames in os.walk(assets_dir):\n        rel_dirpath = os.path.relpath(dirpath, build_dir).replace('\\\\', '/')\n        dirnames.sort()\n        filenames.sort()\n\n        for name in filenames:\n            fn = p3d.Filename.from_os_specific(dirpath) / name\n            if fn.is_regular_file():\n                bundle.add_subfile(f'base/{rel_dirpath}/{name}', fn, 9)\n\n    # Finally, generate the manifest file / signature, if a signing certificate\n    # has been specified.\n    if command.signing_certificate:\n        password = command.signing_passphrase or ''\n\n        if not password and 'ENCRYPTED' in open(command.signing_private_key).read():\n            # It appears to be encrypted, and we don't have a passphrase, so we\n            # must request it on the command-line.\n            from getpass import getpass\n            password = getpass('Enter pass phrase for private key: ')\n\n        if not bundle.add_jar_signature(\n                p3d.Filename.from_os_specific(command.signing_certificate),\n                p3d.Filename.from_os_specific(command.signing_private_key),\n                password):\n            command.announce(\n                f'\\tFailed to sign {bundle_fn}.', distutils.log.ERROR)\n\n    bundle.close()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/dist/installers.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/ab4cb8db_installers.json",
    "doc_id": "doc_131"
  }
}