{
  "content": "\"\"\"ActorInterval module: contains the ActorInterval class.\n\nSee the :ref:`actor-intervals` page in the programming manual for explanation\nof this class.\n\"\"\"\n\n__all__ = ['ActorInterval', 'LerpAnimInterval']\n\nfrom panda3d.direct import CInterval, CLerpAnimEffectInterval\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom . import Interval\nimport math\n\nclass ActorInterval(Interval.Interval):\n\n    # create ActorInterval DirectNotify category\n    notify = directNotify.newCategory('ActorInterval')\n\n    # Name counter\n    animNum = 1\n    # Class methods\n\n    # Plays an animation on an Actor.  The subrange of the animation\n    # to be played may be specified via frames (startFrame up to and\n    # including endFrame) or seconds (startTime up to and including\n    # endTime).  If neither is specified, the default is the entire\n    # range of the animation.\n\n    # The duration may be implicit or explicit.  If it is omitted, it\n    # is taken to be endTime - startTime.  There's not much point in\n    # specifying otherwise unless you also specify loop=1, which will\n    # loop the animation over its frame range during the duration of\n    # the interval.\n\n    # Note: if loop == 0 and duration > anim duration then the\n    # animation will play once and then hold its final pose for the\n    # remainder of the interval.\n\n    # loop = 1 implies a loop within the entire range of animation,\n    # while constrainedLoop = 1 implies a loop within startFrame and\n    # endFrame only.\n\n    def __init__(self, actor, animName, loop=0, constrainedLoop=0,\n                 duration=None, startTime=None, endTime=None,\n                 startFrame=None, endFrame=None,\n                 playRate=1.0, name=None, forceUpdate=0,\n                 partName=None, lodName=None):\n        # Generate unique id\n        id = 'Actor-%s-%d' % (animName, ActorInterval.animNum)\n        ActorInterval.animNum += 1\n        # Record class specific variables\n        self.actor = actor\n        self.animName = animName\n        self.controls = self.actor.getAnimControls(\n            self.animName, partName = partName, lodName = lodName)\n        self.loopAnim = loop\n        self.constrainedLoop = constrainedLoop\n        self.forceUpdate = forceUpdate\n        self.playRate = playRate\n\n        # If no name specified, use id as name\n        if name is None:\n            name = id\n\n        if len(self.controls) == 0:\n            self.notify.warning(\"Unknown animation for actor: %s\" % (self.animName))\n            self.frameRate = 1.0\n            self.startFrame = 0\n            self.endFrame = 0\n        else:\n\n            self.frameRate = self.controls[0].getFrameRate() * abs(playRate)\n            # Compute start and end frames.\n            if startFrame is not None:\n                self.startFrame = startFrame\n            elif startTime is not None:\n                self.startFrame = startTime * self.frameRate\n            else:\n                self.startFrame = 0\n\n            if endFrame is not None:\n                self.endFrame = endFrame\n            elif endTime is not None:\n                self.endFrame = endTime * self.frameRate\n            elif duration is not None:\n                if startTime is None:\n                    startTime = float(self.startFrame) / float(self.frameRate)\n                endTime = startTime + duration\n                self.endFrame = endTime * self.frameRate\n            else:\n                # No end frame specified.  Choose the maximum of all\n                # of the controls' numbers of frames.\n                maxFrames = self.controls[0].getNumFrames()\n                warned = 0\n                for i in range(1, len(self.controls)):\n                    numFrames = self.controls[i].getNumFrames()\n                    if numFrames != maxFrames and numFrames != 1 and not warned:\n                        self.notify.warning(\"Animations '%s' on %s have an inconsistent number of frames.\" % (animName, actor.getName()))\n                        warned = 1\n                    maxFrames = max(maxFrames, numFrames)\n                self.endFrame = maxFrames - 1\n\n        # Must we play the animation backwards?  We play backwards if\n        # either (or both) of the following is true: the playRate is\n        # negative, or endFrame is before startFrame.\n        self.reverse = (playRate < 0)\n        if self.endFrame < self.startFrame:\n            self.reverse = 1\n            t = self.endFrame\n            self.endFrame = self.startFrame\n            self.startFrame = t\n\n        self.numFrames = self.endFrame - self.startFrame + 1\n\n        # Compute duration if no duration specified\n        self.implicitDuration = 0\n        if duration is None:\n            self.implicitDuration = 1\n            duration = float(self.numFrames) / self.frameRate\n\n        # Initialize superclass\n        Interval.Interval.__init__(self, name, duration)\n\n    def getCurrentFrame(self):\n        \"\"\"Calculate the current frame playing in this interval.\n\n        returns a float value between startFrame and endFrame, inclusive\n        returns None if there are any problems\n        \"\"\"\n        retval = None\n        if not self.isStopped():\n            framesPlayed = self.numFrames * self.currT\n            retval = self.startFrame + framesPlayed\n        return retval\n\n    def privStep(self, t):\n        frameCount = t * self.frameRate\n        if self.constrainedLoop:\n            frameCount = frameCount % self.numFrames\n\n        if self.reverse:\n            absFrame = self.endFrame - frameCount\n        else:\n            absFrame = self.startFrame + frameCount\n\n        # Calc integer frame number\n        intFrame = int(math.floor(absFrame + 0.0001))\n\n        # Pose anim\n\n        # We use our pre-computed list of animControls for\n        # efficiency's sake, rather than going through the relatively\n        # expensive Actor interface every frame.\n        for control in self.controls:\n            # Each animControl might have a different number of frames.\n            numFrames = control.getNumFrames()\n            if self.loopAnim:\n                frame = (intFrame % numFrames) + (absFrame - intFrame)\n            else:\n                frame = max(min(absFrame, numFrames - 1), 0)\n\n            control.pose(frame)\n\n        if self.forceUpdate:\n            self.actor.update()\n        self.state = CInterval.SStarted\n        self.currT = t\n\n    def privFinalize(self):\n        if self.implicitDuration and not self.loopAnim:\n            # As a special case, we ensure we end up posed to the last\n            # frame of the animation if the original duration was\n            # implicit.  This is necessary only to guard against\n            # possible roundoff error in computing the final frame\n            # from the duration.  We don't do this in the case of a\n            # looping animation, however, because this would introduce\n            # a hitch in the animation when it plays back-to-back with\n            # the next cycle.\n            if self.reverse:\n                for control in self.controls:\n                    control.pose(self.startFrame)\n            else:\n                for control in self.controls:\n                    control.pose(self.endFrame)\n            if self.forceUpdate:\n                self.actor.update()\n\n        else:\n            # Otherwise, the user-specified duration determines which\n            # is our final frame.\n            self.privStep(self.getDuration())\n\n        self.state = CInterval.SFinal\n        self.intervalDone()\n\n    # If we want to change what part this interval is playing on after\n    # the interval has been created, call resetControls and pass in a partName\n    # and optional lod param\n    def resetControls(self, partName, lodName=None):\n        self.controls = self.actor.getAnimControls(\n            self.animName, partName = partName, lodName = lodName)\n\nclass LerpAnimInterval(CLerpAnimEffectInterval):\n    # Blends between two anims.  Start both anims first (or use\n    # parallel ActorIntervals), then invoke LerpAnimInterval to\n    # smoothly blend the control effect from the first to the second.\n    lerpAnimNum = 1\n\n    def __init__(self, actor, duration, startAnim, endAnim,\n                 startWeight = 0.0, endWeight = 1.0,\n                 blendType = 'noBlend', name = None,\n                 partName=None, lodName=None):\n        # Generate unique name if necessary\n        if name is None:\n            name = 'LerpAnimInterval-%d' % LerpAnimInterval.lerpAnimNum\n            LerpAnimInterval.lerpAnimNum += 1\n\n        blendType = self.stringBlendType(blendType)\n        assert blendType != self.BTInvalid\n\n        # Initialize superclass\n        CLerpAnimEffectInterval.__init__(self, name, duration, blendType)\n\n        if startAnim is not None:\n            controls = actor.getAnimControls(\n                startAnim, partName = partName, lodName = lodName)\n            #controls = actor.getAnimControls(startAnim)\n            for control in controls:\n                self.addControl(control, startAnim,\n                                1.0 - startWeight, 1.0 - endWeight)\n\n        if endAnim is not None:\n            controls = actor.getAnimControls(\n                endAnim, partName = partName, lodName = lodName)\n            #controls = actor.getAnimControls(endAnim)\n            for control in controls:\n                self.addControl(control, endAnim,\n                                startWeight, endWeight)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/interval/ActorInterval.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/9713deac_ActorInterval.json",
    "doc_id": "doc_161"
  }
}