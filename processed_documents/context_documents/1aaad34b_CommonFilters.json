{
  "content": "\"\"\"\nClass CommonFilters implements certain common image\npostprocessing filters.  See the :ref:`common-image-filters` page for\nmore information about how to use these filters.\n\nThese filters are written in the Cg shading language.\n\"\"\"\n\n# It is not ideal that these filters are all included in a single\n# monolithic module.  Unfortunately, when you want to apply two filters\n# at the same time, you have to compose them into a single shader, and\n# the composition process isn't simply a question of concatenating them:\n# you have to somehow make them work together.  I suspect that there\n# exists some fairly simple framework that would make this automatable.\n# However, until I write some more filters myself, I won't know what\n# that framework is.  Until then, I'll settle for this\n# clunky approach.  - Josh\n\nfrom panda3d.core import LVecBase4, LPoint2\nfrom panda3d.core import AuxBitplaneAttrib, AntialiasAttrib\nfrom panda3d.core import Texture, Shader, ATSNone\nfrom panda3d.core import FrameBufferProperties\nfrom panda3d.core import getDefaultCoordinateSystem, CS_zup_right, CS_zup_left\n\nfrom direct.task.TaskManagerGlobal import taskMgr\n\nfrom .FilterManager import FilterManager\nfrom .filterBloomI import BLOOM_I\nfrom .filterBloomX import BLOOM_X\nfrom .filterBloomY import BLOOM_Y\nfrom .filterBlurX import BLUR_X\nfrom .filterBlurY import BLUR_Y\nfrom .filterCopy import COPY\nfrom .filterDown4 import DOWN_4\n\nCARTOON_BODY = \"\"\"\nfloat4 cartoondelta = k_cartoonseparation * texpix_txaux.xwyw;\nfloat4 cartoon_c0 = tex2D(k_txaux, %(texcoord)s + cartoondelta.xy);\nfloat4 cartoon_c1 = tex2D(k_txaux, %(texcoord)s - cartoondelta.xy);\nfloat4 cartoon_c2 = tex2D(k_txaux, %(texcoord)s + cartoondelta.wz);\nfloat4 cartoon_c3 = tex2D(k_txaux, %(texcoord)s - cartoondelta.wz);\nfloat4 cartoon_mx = max(cartoon_c0, max(cartoon_c1, max(cartoon_c2, cartoon_c3)));\nfloat4 cartoon_mn = min(cartoon_c0, min(cartoon_c1, min(cartoon_c2, cartoon_c3)));\nfloat cartoon_thresh = saturate(dot(cartoon_mx - cartoon_mn, float4(3,3,0,0)) - 0.5);\no_color = lerp(o_color, k_cartooncolor, cartoon_thresh);\n\"\"\"\n\n# Some GPUs do not support variable-length loops.\n#\n# We fill in the actual value of numsamples in the loop limit\n# when the shader is configured.\n#\nSSAO_BODY = \"\"\"//Cg\n\nvoid vshader(float4 vtx_position : POSITION,\n             float2 vtx_texcoord : TEXCOORD0,\n             out float4 l_position : POSITION,\n             out float2 l_texcoord : TEXCOORD0,\n             out float2 l_texcoordD : TEXCOORD1,\n             out float2 l_texcoordN : TEXCOORD2,\n             uniform float4 texpad_depth,\n             uniform float4 texpad_normal,\n             uniform float4x4 mat_modelproj)\n{\n  l_position = mul(mat_modelproj, vtx_position);\n  l_texcoord = vtx_texcoord;\n  l_texcoordD = vtx_texcoord * texpad_depth.xy * 2;\n  l_texcoordN = vtx_texcoord * texpad_normal.xy * 2;\n}\n\nfloat3 sphere[16] = float3[](float3(0.53812504, 0.18565957, -0.43192),float3(0.13790712, 0.24864247, 0.44301823),float3(0.33715037, 0.56794053, -0.005789503),float3(-0.6999805, -0.04511441, -0.0019965635),float3(0.06896307, -0.15983082, -0.85477847),float3(0.056099437, 0.006954967, -0.1843352),float3(-0.014653638, 0.14027752, 0.0762037),float3(0.010019933, -0.1924225, -0.034443386),float3(-0.35775623, -0.5301969, -0.43581226),float3(-0.3169221, 0.106360726, 0.015860917),float3(0.010350345, -0.58698344, 0.0046293875),float3(-0.08972908, -0.49408212, 0.3287904),float3(0.7119986, -0.0154690035, -0.09183723),float3(-0.053382345, 0.059675813, -0.5411899),float3(0.035267662, -0.063188605, 0.54602677),float3(-0.47761092, 0.2847911, -0.0271716));\n\nvoid fshader(out float4 o_color : COLOR,\n             uniform float4 k_params1,\n             uniform float4 k_params2,\n             float2 l_texcoord : TEXCOORD0,\n             float2 l_texcoordD : TEXCOORD1,\n             float2 l_texcoordN : TEXCOORD2,\n             uniform sampler2D k_random : TEXUNIT0,\n             uniform sampler2D k_depth : TEXUNIT1,\n             uniform sampler2D k_normal : TEXUNIT2)\n{\n  float pixel_depth = tex2D(k_depth, l_texcoordD).a;\n  float3 pixel_normal = (tex2D(k_normal, l_texcoordN).xyz * 2.0 - 1.0);\n  float3 random_vector = normalize((tex2D(k_random, l_texcoord * 18.0 + pixel_depth + pixel_normal.xy).xyz * 2.0) - float3(1.0)).xyz;\n  float occlusion = 0.0;\n  float radius = k_params1.z / pixel_depth;\n  float depth_difference;\n  float3 sample_normal;\n  float3 ray;\n  for(int i = 0; i < %d; ++i) {\n   ray = radius * reflect(sphere[i], random_vector);\n   sample_normal = (tex2D(k_normal, l_texcoordN + ray.xy).xyz * 2.0 - 1.0);\n   depth_difference =  (pixel_depth - tex2D(k_depth,l_texcoordD + ray.xy).r);\n   occlusion += step(k_params2.y, depth_difference) * (1.0 - dot(sample_normal.xyz, pixel_normal)) * (1.0 - smoothstep(k_params2.y, k_params2.x, depth_difference));\n  }\n  o_color.rgb = 1.0 + (occlusion * k_params1.y);\n  o_color.a = 1.0;\n}\n\"\"\"\n\n\nclass ToneMap:\n    ACES = object()\n    PBR_NEUTRAL = object()\n\n\nclass FilterConfig:\n    pass\n\n\nclass CommonFilters:\n    \"\"\" Class CommonFilters implements certain common image postprocessing\n    filters.  The constructor requires a filter builder as a parameter. \"\"\"\n\n    def __init__(self, win, cam):\n        self.manager = FilterManager(win, cam)\n        self.configuration = {}\n        self.task = None\n        self.cleanup()\n\n    def cleanup(self):\n        self.manager.cleanup()\n        self.textures = {}\n        self.finalQuad = None\n        self.bloom = []\n        self.blur = []\n        self.ssao = []\n        if self.task is not None:\n            taskMgr.remove(self.task)\n            self.task = None\n\n    def reconfigure(self, fullrebuild, changed):\n        \"\"\" Reconfigure is called whenever any configuration change is made. \"\"\"\n\n        configuration = self.configuration\n\n        if fullrebuild:\n            self.cleanup()\n\n            if len(configuration) == 0:\n                return\n\n            if not self.manager.win.gsg.getSupportsBasicShaders():\n                return False\n\n            auxbits = 0\n            needtex = set([\"color\"])\n            needtexcoord = set([\"color\"])\n\n            if \"CartoonInk\" in configuration:\n                needtex.add(\"aux\")\n                auxbits |= AuxBitplaneAttrib.ABOAuxNormal\n                needtexcoord.add(\"aux\")\n\n            if \"AmbientOcclusion\" in configuration:\n                needtex.add(\"depth\")\n                needtex.add(\"ssao0\")\n                needtex.add(\"ssao1\")\n                needtex.add(\"ssao2\")\n                needtex.add(\"aux\")\n                auxbits |= AuxBitplaneAttrib.ABOAuxNormal\n                needtexcoord.add(\"ssao2\")\n\n            if \"BlurSharpen\" in configuration:\n                needtex.add(\"blur0\")\n                needtex.add(\"blur1\")\n                needtexcoord.add(\"blur1\")\n\n            if \"Bloom\" in configuration:\n                needtex.add(\"bloom0\")\n                needtex.add(\"bloom1\")\n                needtex.add(\"bloom2\")\n                needtex.add(\"bloom3\")\n                auxbits |= AuxBitplaneAttrib.ABOGlow\n                needtexcoord.add(\"bloom3\")\n\n            if \"ViewGlow\" in configuration:\n                auxbits |= AuxBitplaneAttrib.ABOGlow\n\n            if \"VolumetricLighting\" in configuration:\n                needtex.add(configuration[\"VolumetricLighting\"].source)\n\n            for tex in needtex:\n                self.textures[tex] = Texture(\"scene-\" + tex)\n                self.textures[tex].setWrapU(Texture.WMClamp)\n                self.textures[tex].setWrapV(Texture.WMClamp)\n\n            fbprops = None\n            clamping = None\n            if \"HighDynamicRange\" in configuration:\n                fbprops = FrameBufferProperties()\n                fbprops.setFloatColor(True)\n                fbprops.setSrgbColor(False)\n                clamping = False\n\n            if \"MSAA\" in configuration:\n                if fbprops is None:\n                    fbprops = FrameBufferProperties()\n                fbprops.setMultisamples(configuration[\"MSAA\"].samples)\n\n            self.finalQuad = self.manager.renderSceneInto(textures = self.textures, auxbits=auxbits, fbprops=fbprops, clamping=clamping)\n            if self.finalQuad is None:\n                self.cleanup()\n                return False\n\n            if \"MSAA\" in configuration:\n                camNode = self.manager.camera.node()\n                state = camNode.getInitialState()\n                state.setAttrib(AntialiasAttrib.make(AntialiasAttrib.M_multisample))\n                camNode.setInitialState(state)\n\n            if \"BlurSharpen\" in configuration:\n                blur0 = self.textures[\"blur0\"]\n                blur1 = self.textures[\"blur1\"]\n                self.blur.append(self.manager.renderQuadInto(\"filter-blur0\", colortex=blur0, div=2))\n                self.blur.append(self.manager.renderQuadInto(\"filter-blur1\", colortex=blur1))\n                self.blur[0].setShaderInput(\"src\", self.textures[\"color\"])\n                self.blur[0].setShader(Shader.make(BLUR_X, Shader.SL_Cg))\n                self.blur[1].setShaderInput(\"src\", blur0)\n                self.blur[1].setShader(Shader.make(BLUR_Y, Shader.SL_Cg))\n\n            if \"AmbientOcclusion\" in configuration:\n                ssao0 = self.textures[\"ssao0\"]\n                ssao1 = self.textures[\"ssao1\"]\n                ssao2 = self.textures[\"ssao2\"]\n                self.ssao.append(self.manager.renderQuadInto(\"filter-ssao0\", colortex=ssao0))\n                self.ssao.append(self.manager.renderQuadInto(\"filter-ssao1\", colortex=ssao1, div=2))\n                self.ssao.append(self.manager.renderQuadInto(\"filter-ssao2\", colortex=ssao2))\n                self.ssao[0].setShaderInput(\"depth\", self.textures[\"depth\"])\n                self.ssao[0].setShaderInput(\"normal\", self.textures[\"aux\"])\n                self.ssao[0].setShaderInput(\"random\", base.loader.loadTexture(\"maps/random.rgb\"))\n                self.ssao[0].setShader(Shader.make(SSAO_BODY % configuration[\"AmbientOcclusion\"].numsamples, Shader.SL_Cg))\n                self.ssao[1].setShaderInput(\"src\", ssao0)\n                self.ssao[1].setShader(Shader.make(BLUR_X, Shader.SL_Cg))\n                self.ssao[2].setShaderInput(\"src\", ssao1)\n                self.ssao[2].setShader(Shader.make(BLUR_Y, Shader.SL_Cg))\n\n            if \"Bloom\" in configuration:\n                bloomconf = configuration[\"Bloom\"]\n                bloom0 = self.textures[\"bloom0\"]\n                bloom1 = self.textures[\"bloom1\"]\n                bloom2 = self.textures[\"bloom2\"]\n                bloom3 = self.textures[\"bloom3\"]\n                if bloomconf.size == \"large\":\n                    scale=8\n                    downsamplerName=\"filter-down4\"\n                    downsampler=DOWN_4\n                elif bloomconf.size == \"medium\":\n                    scale=4\n                    downsamplerName=\"filter-copy\"\n                    downsampler=COPY\n                else:\n                    scale=2\n                    downsamplerName=\"filter-copy\"\n                    downsampler=COPY\n                self.bloom.append(self.manager.renderQuadInto(\"filter-bloomi\", colortex=bloom0, div=2,     align=scale))\n                self.bloom.append(self.manager.renderQuadInto(downsamplerName, colortex=bloom1, div=scale, align=scale))\n                self.bloom.append(self.manager.renderQuadInto(\"filter-bloomx\", colortex=bloom2, div=scale, align=scale))\n                self.bloom.append(self.manager.renderQuadInto(\"filter-bloomy\", colortex=bloom3, div=scale, align=scale))\n                self.bloom[0].setShaderInput(\"src\", self.textures[\"color\"])\n                self.bloom[0].setShader(Shader.make(BLOOM_I, Shader.SL_Cg))\n                self.bloom[1].setShaderInput(\"src\", bloom0)\n                self.bloom[1].setShader(Shader.make(downsampler, Shader.SL_Cg))\n                self.bloom[2].setShaderInput(\"src\", bloom1)\n                self.bloom[2].setShader(Shader.make(BLOOM_X, Shader.SL_Cg))\n                self.bloom[3].setShaderInput(\"src\", bloom2)\n                self.bloom[3].setShader(Shader.make(BLOOM_Y, Shader.SL_Cg))\n\n            texcoords = {}\n            texcoordPadding = {}\n\n            for tex in needtexcoord:\n                if self.textures[tex].getAutoTextureScale() != ATSNone or \\\n                                           \"HalfPixelShift\" in configuration:\n                    texcoords[tex] = \"l_texcoord_\" + tex\n                    texcoordPadding[\"l_texcoord_\" + tex] = tex\n                else:\n                    # Share unpadded texture coordinates.\n                    texcoords[tex] = \"l_texcoord\"\n                    texcoordPadding[\"l_texcoord\"] = None\n\n            texcoordSets = list(enumerate(texcoordPadding.keys()))\n\n            text = \"//Cg\\n\"\n            if \"HighDynamicRange\" in configuration:\n                tonemap = configuration[\"HighDynamicRange\"]\n                if tonemap is ToneMap.ACES:\n                    text += \"static const float3x3 aces_input_mat = {\\n\"\n                    text += \"  {0.59719, 0.35458, 0.04823},\\n\"\n                    text += \"  {0.07600, 0.90834, 0.01566},\\n\"\n                    text += \"  {0.02840, 0.13383, 0.83777},\\n\"\n                    text += \"};\\n\"\n                    text += \"static const float3x3 aces_output_mat = {\\n\"\n                    text += \"  { 1.60475, -0.53108, -0.07367},\\n\"\n                    text += \"  {-0.10208,  1.10813, -0.00605},\\n\"\n                    text += \"  {-0.00327, -0.07276,  1.07602},\\n\"\n                    text += \"};\\n\"\n\n            text += \"void vshader(float4 vtx_position : POSITION,\\n\"\n            text += \"  out float4 l_position : POSITION,\\n\"\n\n            for texcoord, padTex in texcoordPadding.items():\n                if padTex is not None:\n                    text += \"  uniform float4 texpad_tx%s,\\n\" % (padTex)\n                    if \"HalfPixelShift\" in configuration:\n                        text += \"  uniform float4 texpix_tx%s,\\n\" % (padTex)\n\n            for i, name in texcoordSets:\n                text += \"  out float2 %s : TEXCOORD%d,\\n\" % (name, i)\n\n            text += \"  uniform float4x4 mat_modelproj)\\n\"\n            text += \"{\\n\"\n            text += \"  l_position = mul(mat_modelproj, vtx_position);\\n\"\n\n            # The card is oriented differently depending on our chosen\n            # coordinate system.  We could just use vtx_texcoord, but this\n            # saves on an additional variable.\n            if getDefaultCoordinateSystem() in (CS_zup_right, CS_zup_left):\n                pos = \"vtx_position.xz\"\n            else:\n                pos = \"vtx_position.xy\"\n\n            for texcoord, padTex in texcoordPadding.items():\n                if padTex is None:\n                    text += \"  %s = %s * float2(0.5, 0.5) + float2(0.5, 0.5);\\n\" % (texcoord, pos)\n                else:\n                    text += \"  %s = (%s * texpad_tx%s.xy) + texpad_tx%s.xy;\\n\" % (texcoord, pos, padTex, padTex)\n\n                    if \"HalfPixelShift\" in configuration:\n                        text += \"  %s += texpix_tx%s.xy * 0.5;\\n\" % (texcoord, padTex)\n\n            text += \"}\\n\"\n\n            text += \"void fshader(\\n\"\n\n            for i, name in texcoordSets:\n                text += \"  float2 %s : TEXCOORD%d,\\n\" % (name, i)\n\n            for key in self.textures:\n                text += \"  uniform sampler2D k_tx\" + key + \",\\n\"\n\n            if \"CartoonInk\" in configuration:\n                text += \"  uniform float4 k_cartoonseparation,\\n\"\n                text += \"  uniform float4 k_cartooncolor,\\n\"\n                text += \"  uniform float4 texpix_txaux,\\n\"\n\n            if \"BlurSharpen\" in configuration:\n                text += \"  uniform float4 k_blurval,\\n\"\n\n            if \"VolumetricLighting\" in configuration:\n                text += \"  uniform float4 k_casterpos,\\n\"\n                text += \"  uniform float4 k_vlparams,\\n\"\n\n            if \"ExposureAdjust\" in configuration:\n                text += \"  uniform float k_exposure,\\n\"\n\n            text += \"  out float4 o_color : COLOR)\\n\"\n            text += \"{\\n\"\n            text += \"  o_color = tex2D(k_txcolor, %s);\\n\" % (texcoords[\"color\"])\n            if \"CartoonInk\" in configuration:\n                text += CARTOON_BODY % {\"texcoord\": texcoords[\"aux\"]}\n            if \"AmbientOcclusion\" in configuration:\n                text += \"  o_color *= tex2D(k_txssao2, %s).r;\\n\" % (texcoords[\"ssao2\"])\n            if \"BlurSharpen\" in configuration:\n                text += \"  o_color = lerp(tex2D(k_txblur1, %s), o_color, k_blurval.x);\\n\" % (texcoords[\"blur1\"])\n            if \"Bloom\" in configuration:\n                text += \"  o_color = saturate(o_color);\\n\"\n                text += \"  float4 bloom = 0.5 * tex2D(k_txbloom3, %s);\\n\" % (texcoords[\"bloom3\"])\n                text += \"  o_color = 1-((1-bloom)*(1-o_color));\\n\"\n            if \"ViewGlow\" in configuration:\n                text += \"  o_color.r = o_color.a;\\n\"\n            if \"VolumetricLighting\" in configuration:\n                text += \"  float decay = 1.0f;\\n\"\n                text += \"  float2 curcoord = %s;\\n\" % (texcoords[\"color\"])\n                text += \"  float2 lightdir = curcoord - k_casterpos.xy;\\n\"\n                text += \"  lightdir *= k_vlparams.x;\\n\"\n                text += \"  half4 sample = tex2D(k_txcolor, curcoord);\\n\"\n                text += \"  float3 vlcolor = sample.rgb * sample.a;\\n\"\n                text += \"  for (int i = 0; i < %s; i++) {\\n\" % (int(configuration[\"VolumetricLighting\"].numsamples))\n                text += \"    curcoord -= lightdir;\\n\"\n                text += \"    sample = tex2D(k_tx%s, curcoord);\\n\" % (configuration[\"VolumetricLighting\"].source)\n                text += \"    sample *= sample.a * decay;//*weight\\n\"\n                text += \"    vlcolor += sample.rgb;\\n\"\n                text += \"    decay *= k_vlparams.y;\\n\"\n                text += \"  }\\n\"\n                text += \"  o_color += float4(vlcolor * k_vlparams.z, 1);\\n\"\n\n            if \"ExposureAdjust\" in configuration:\n                text += \"  o_color.rgb *= k_exposure;\\n\"\n\n            if \"HighDynamicRange\" in configuration:\n                tonemap = configuration[\"HighDynamicRange\"]\n                if tonemap is ToneMap.ACES:\n                    # With thanks to Stephen Hill!\n                    text += \"  float3 aces_color = mul(aces_input_mat, o_color.rgb);\\n\"\n                    text += \"  o_color.rgb = saturate(mul(aces_output_mat, (aces_color * (aces_color + 0.0245786f) - 0.000090537f) / (aces_color * (0.983729f * aces_color + 0.4329510f) + 0.238081f)));\\n\"\n                elif tonemap is ToneMap.PBR_NEUTRAL:\n                    text += \"  const float start_compression = 0.8 - 0.04;\\n\"\n                    text += \"  const float desaturation = 0.15;\\n\"\n\n                    text += \"  float x = min(o_color.r, min(o_color.g, o_color.b));\\n\"\n                    text += \"  float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\\n\"\n                    text += \"  o_color.rgb -= offset;\\n\"\n\n                    text += \"  float peak = max(o_color.r, max(o_color.g, o_color.b));\\n\"\n\n                    text += \"  if (peak >= start_compression) {\\n\"\n                    text += \"    const float d = 1.0 - start_compression;\\n\"\n                    text += \"    float new_peak = 1.0 - d * d / (peak + d - start_compression);\\n\"\n                    text += \"    o_color.rgb *= new_peak / peak;\\n\"\n                    text += \"    float g = 1.0 - 1.0 / (desaturation * (peak - new_peak) + 1.0);\\n\"\n\n                    text += \"    o_color.rgb = lerp(o_color.rgb, new_peak * float3(1, 1, 1), g);\\n\"\n                    text += \"}\\n\"\n\n            if \"GammaAdjust\" in configuration:\n                gamma = configuration[\"GammaAdjust\"]\n                if gamma == 0.5:\n                    text += \"  o_color.rgb = sqrt(o_color.rgb);\\n\"\n                elif gamma == 2.0:\n                    text += \"  o_color.rgb *= o_color.rgb;\\n\"\n                elif gamma != 1.0:\n                    text += \"  o_color.rgb = pow(o_color.rgb, %ff);\\n\" % (gamma)\n\n            if \"SrgbEncode\" in configuration:\n                text += \"  o_color.r = (o_color.r < 0.0031308) ? (o_color.r * 12.92) : (1.055 * pow(o_color.r, 0.41666) - 0.055);\\n\"\n                text += \"  o_color.g = (o_color.g < 0.0031308) ? (o_color.g * 12.92) : (1.055 * pow(o_color.g, 0.41666) - 0.055);\\n\"\n                text += \"  o_color.b = (o_color.b < 0.0031308) ? (o_color.b * 12.92) : (1.055 * pow(o_color.b, 0.41666) - 0.055);\\n\"\n\n            if \"Inverted\" in configuration:\n                text += \"  o_color = float4(1, 1, 1, 1) - o_color;\\n\"\n            text += \"}\\n\"\n\n            shader = Shader.make(text, Shader.SL_Cg)\n            if not shader:\n                return False\n            self.finalQuad.setShader(shader)\n            for tex in self.textures:\n                self.finalQuad.setShaderInput(\"tx\"+tex, self.textures[tex])\n\n            self.task = taskMgr.add(self.update, \"common-filters-update\")\n\n        if changed == \"CartoonInk\" or fullrebuild:\n            if \"CartoonInk\" in configuration:\n                c = configuration[\"CartoonInk\"]\n                self.finalQuad.setShaderInput(\"cartoonseparation\", LVecBase4(c.separation, 0, c.separation, 0))\n                self.finalQuad.setShaderInput(\"cartooncolor\", c.color)\n\n        if changed == \"BlurSharpen\" or fullrebuild:\n            if \"BlurSharpen\" in configuration:\n                blurval = configuration[\"BlurSharpen\"]\n                self.finalQuad.setShaderInput(\"blurval\", LVecBase4(blurval, blurval, blurval, blurval))\n\n        if changed == \"Bloom\" or fullrebuild:\n            if \"Bloom\" in configuration:\n                bloomconf = configuration[\"Bloom\"]\n                intensity = bloomconf.intensity * 3.0\n                self.bloom[0].setShaderInput(\"blend\", bloomconf.blendx, bloomconf.blendy, bloomconf.blendz, bloomconf.blendw * 2.0)\n                self.bloom[0].setShaderInput(\"trigger\", bloomconf.mintrigger, 1.0/(bloomconf.maxtrigger-bloomconf.mintrigger), 0.0, 0.0)\n                self.bloom[0].setShaderInput(\"desat\", bloomconf.desat)\n                self.bloom[3].setShaderInput(\"intensity\", intensity, intensity, intensity, intensity)\n\n        if changed == \"VolumetricLighting\" or fullrebuild:\n            if \"VolumetricLighting\" in configuration:\n                config = configuration[\"VolumetricLighting\"]\n                tcparam = config.density / float(config.numsamples)\n                self.finalQuad.setShaderInput(\"vlparams\", tcparam, config.decay, config.exposure, 0.0)\n\n        if changed == \"AmbientOcclusion\" or fullrebuild:\n            if \"AmbientOcclusion\" in configuration:\n                config = configuration[\"AmbientOcclusion\"]\n                self.ssao[0].setShaderInput(\"params1\", config.numsamples, -float(config.amount) / config.numsamples, config.radius, 0)\n                self.ssao[0].setShaderInput(\"params2\", config.strength, config.falloff, 0, 0)\n\n        if changed == \"ExposureAdjust\" or fullrebuild:\n            if \"ExposureAdjust\" in configuration:\n                stops = configuration[\"ExposureAdjust\"]\n                self.finalQuad.setShaderInput(\"exposure\", 2 ** stops)\n\n        self.update()\n        return True\n\n    def update(self, task = None):\n        \"\"\"Updates the shader inputs that need to be updated every frame.\n        Normally, you shouldn't call this, it's being called in a task.\"\"\"\n\n        if \"VolumetricLighting\" in self.configuration:\n            caster = self.configuration[\"VolumetricLighting\"].caster\n            casterpos = LPoint2()\n            self.manager.camera.node().getLens().project(caster.getPos(self.manager.camera), casterpos)\n            self.finalQuad.setShaderInput(\"casterpos\", LVecBase4(casterpos.getX() * 0.5 + 0.5, (casterpos.getY() * 0.5 + 0.5), 0, 0))\n        if task is not None:\n            return task.cont\n\n    def setMSAA(self, samples):\n        \"\"\"Enables multisample anti-aliasing on the render-to-texture buffer.\n        If you enable this, it is recommended to leave any multisample request\n        on the main framebuffer OFF (ie. don't set framebuffer-multisample true\n        in Config.prc), since it would be a waste of resources otherwise.\n\n        .. versionadded:: 1.10.13\n        \"\"\"\n        fullrebuild = \"MSAA\" not in self.configuration or self.configuration[\"MSAA\"].samples != samples\n        newconfig = FilterConfig()\n        newconfig.samples = samples\n        self.configuration[\"MSAA\"] = newconfig\n        return self.reconfigure(fullrebuild, \"MSAA\")\n\n    def delMSAA(self):\n        if \"MSAA\" in self.configuration:\n            del self.configuration[\"MSAA\"]\n            return self.reconfigure(True, \"MSAA\")\n        return True\n\n    def setCartoonInk(self, separation=1, color=(0, 0, 0, 1)):\n        fullrebuild = (\"CartoonInk\" not in self.configuration)\n        newconfig = FilterConfig()\n        newconfig.separation = separation\n        newconfig.color = color\n        self.configuration[\"CartoonInk\"] = newconfig\n        return self.reconfigure(fullrebuild, \"CartoonInk\")\n\n    def delCartoonInk(self):\n        if \"CartoonInk\" in self.configuration:\n            del self.configuration[\"CartoonInk\"]\n            return self.reconfigure(True, \"CartoonInk\")\n        return True\n\n    def setBloom(self, blend=(0.3,0.4,0.3,0.0), mintrigger=0.6, maxtrigger=1.0, desat=0.6, intensity=1.0, size=\"medium\"):\n        \"\"\"\n        Applies the Bloom filter to the output.\n        size can either be \"off\", \"small\", \"medium\", or \"large\".\n        Setting size to \"off\" will remove the Bloom filter.\n        \"\"\"\n        if size == 0 or size == \"off\":\n            self.delBloom()\n            return\n        elif size == 1:\n            size = \"small\"\n        elif size == 2:\n            size = \"medium\"\n        elif size == 3:\n            size = \"large\"\n\n        if maxtrigger is None:\n            maxtrigger = mintrigger + 0.8\n\n        oldconfig = self.configuration.get(\"Bloom\", None)\n        fullrebuild = True\n        if oldconfig and oldconfig.size == size:\n            fullrebuild = False\n\n        newconfig = FilterConfig()\n        (newconfig.blendx, newconfig.blendy, newconfig.blendz, newconfig.blendw) = blend\n        newconfig.maxtrigger = maxtrigger\n        newconfig.mintrigger = mintrigger\n        newconfig.desat = desat\n        newconfig.intensity = intensity\n        newconfig.size = size\n        self.configuration[\"Bloom\"] = newconfig\n        return self.reconfigure(fullrebuild, \"Bloom\")\n\n    def delBloom(self):\n        if \"Bloom\" in self.configuration:\n            del self.configuration[\"Bloom\"]\n            return self.reconfigure(True, \"Bloom\")\n        return True\n\n    def setHalfPixelShift(self):\n        fullrebuild = (\"HalfPixelShift\" not in self.configuration)\n        self.configuration[\"HalfPixelShift\"] = 1\n        return self.reconfigure(fullrebuild, \"HalfPixelShift\")\n\n    def delHalfPixelShift(self):\n        if \"HalfPixelShift\" in self.configuration:\n            del self.configuration[\"HalfPixelShift\"]\n            return self.reconfigure(True, \"HalfPixelShift\")\n        return True\n\n    def setViewGlow(self):\n        fullrebuild = (\"ViewGlow\" not in self.configuration)\n        self.configuration[\"ViewGlow\"] = 1\n        return self.reconfigure(fullrebuild, \"ViewGlow\")\n\n    def delViewGlow(self):\n        if \"ViewGlow\" in self.configuration:\n            del self.configuration[\"ViewGlow\"]\n            return self.reconfigure(True, \"ViewGlow\")\n        return True\n\n    def setInverted(self):\n        fullrebuild = (\"Inverted\" not in self.configuration)\n        self.configuration[\"Inverted\"] = 1\n        return self.reconfigure(fullrebuild, \"Inverted\")\n\n    def delInverted(self):\n        if \"Inverted\" in self.configuration:\n            del self.configuration[\"Inverted\"]\n            return self.reconfigure(True, \"Inverted\")\n        return True\n\n    def setVolumetricLighting(self, caster, numsamples = 32, density = 5.0, decay = 0.1, exposure = 0.1, source = \"color\"):\n        oldconfig = self.configuration.get(\"VolumetricLighting\", None)\n        fullrebuild = True\n        if oldconfig and oldconfig.source == source and oldconfig.numsamples == int(numsamples):\n            fullrebuild = False\n        newconfig = FilterConfig()\n        newconfig.caster = caster\n        newconfig.numsamples = int(numsamples)\n        newconfig.density = density\n        newconfig.decay = decay\n        newconfig.exposure = exposure\n        newconfig.source = source\n        self.configuration[\"VolumetricLighting\"] = newconfig\n        return self.reconfigure(fullrebuild, \"VolumetricLighting\")\n\n    def delVolumetricLighting(self):\n        if \"VolumetricLighting\" in self.configuration:\n            del self.configuration[\"VolumetricLighting\"]\n            return self.reconfigure(True, \"VolumetricLighting\")\n        return True\n\n    def setBlurSharpen(self, amount=0.0):\n        \"\"\"Enables the blur/sharpen filter. If the 'amount' parameter is 1.0, it will not have any effect.\n        A value of 0.0 means fully blurred, and a value higher than 1.0 sharpens the image.\"\"\"\n        fullrebuild = (\"BlurSharpen\" not in self.configuration)\n        self.configuration[\"BlurSharpen\"] = amount\n        return self.reconfigure(fullrebuild, \"BlurSharpen\")\n\n    def delBlurSharpen(self):\n        if \"BlurSharpen\" in self.configuration:\n            del self.configuration[\"BlurSharpen\"]\n            return self.reconfigure(True, \"BlurSharpen\")\n        return True\n\n    def setAmbientOcclusion(self, numsamples = 16, radius = 0.05, amount = 2.0, strength = 0.01, falloff = 0.000002):\n        fullrebuild = (\"AmbientOcclusion\" not in self.configuration)\n\n        if not fullrebuild:\n            fullrebuild = (numsamples != self.configuration[\"AmbientOcclusion\"].numsamples)\n\n        newconfig = FilterConfig()\n        newconfig.numsamples = numsamples\n        newconfig.radius = radius\n        newconfig.amount = amount\n        newconfig.strength = strength\n        newconfig.falloff = falloff\n        self.configuration[\"AmbientOcclusion\"] = newconfig\n        return self.reconfigure(fullrebuild, \"AmbientOcclusion\")\n\n    def delAmbientOcclusion(self):\n        if \"AmbientOcclusion\" in self.configuration:\n            del self.configuration[\"AmbientOcclusion\"]\n            return self.reconfigure(True, \"AmbientOcclusion\")\n        return True\n\n    def setGammaAdjust(self, gamma):\n        \"\"\" Applies additional gamma correction to the image.  1.0 = no correction. \"\"\"\n        old_gamma = self.configuration.get(\"GammaAdjust\", 1.0)\n        if old_gamma != gamma:\n            self.configuration[\"GammaAdjust\"] = gamma\n            return self.reconfigure(True, \"GammaAdjust\")\n        return True\n\n    def delGammaAdjust(self):\n        if \"GammaAdjust\" in self.configuration:\n            old_gamma = self.configuration[\"GammaAdjust\"]\n            del self.configuration[\"GammaAdjust\"]\n            return self.reconfigure((old_gamma != 1.0), \"GammaAdjust\")\n        return True\n\n    def setSrgbEncode(self, force=False):\n        \"\"\" Applies the inverse sRGB EOTF to the output, unless the window\n        already has an sRGB framebuffer, in which case this filter refuses to\n        apply, to prevent accidental double-application.\n\n        Set the force argument to True to force it to be applied in all cases.\n\n        .. versionadded:: 1.10.7\n        \"\"\"\n        new_enable = force or not self.manager.win.getFbProperties().getSrgbColor()\n        old_enable = self.configuration.get(\"SrgbEncode\", False)\n        if new_enable and not old_enable:\n            self.configuration[\"SrgbEncode\"] = True\n            return self.reconfigure(True, \"SrgbEncode\")\n        elif not new_enable and old_enable:\n            del self.configuration[\"SrgbEncode\"]\n        return new_enable\n\n    def delSrgbEncode(self):\n        \"\"\" Reverses the effects of setSrgbEncode. \"\"\"\n        if \"SrgbEncode\" in self.configuration:\n            old_enable = self.configuration[\"SrgbEncode\"]\n            del self.configuration[\"SrgbEncode\"]\n            return self.reconfigure(old_enable, \"SrgbEncode\")\n        return True\n\n    def setHighDynamicRange(self, tonemap=ToneMap.ACES):\n        \"\"\" Enables HDR rendering by using a floating-point framebuffer,\n        disabling color clamping on the main scene, and applying a tone map\n        operator (ACES or Khronos PBR Neutral).\n\n        It may also be necessary to use setExposureAdjust to perform exposure\n        compensation on the scene, depending on the lighting intensity.\n\n        .. versionadded:: 1.10.7\n        \"\"\"\n\n        fullrebuild = \"HighDynamicRange\" not in self.configuration or \\\n                      self.configuration[\"HighDynamicRange\"] is not tonemap\n        if tonemap is not ToneMap.ACES and tonemap is not ToneMap.PBR_NEUTRAL:\n            raise ValueError(\"Invalid value for tonemap\")\n        self.configuration[\"HighDynamicRange\"] = tonemap\n        return self.reconfigure(fullrebuild, \"HighDynamicRange\")\n\n    def delHighDynamicRange(self):\n        if \"HighDynamicRange\" in self.configuration:\n            del self.configuration[\"HighDynamicRange\"]\n            return self.reconfigure(True, \"HighDynamicRange\")\n        return True\n\n    def setExposureAdjust(self, stops):\n        \"\"\" Sets a relative exposure adjustment to multiply with the result of\n        rendering the scene, in stops.  A value of 0 means no adjustment, a\n        positive value will result in a brighter image.  Useful in conjunction\n        with HDR, see setHighDynamicRange.\n\n        .. versionadded:: 1.10.7\n        \"\"\"\n        old_stops = self.configuration.get(\"ExposureAdjust\")\n        if old_stops != stops:\n            self.configuration[\"ExposureAdjust\"] = stops\n            return self.reconfigure(old_stops is None, \"ExposureAdjust\")\n        return True\n\n    def delExposureAdjust(self):\n        if \"ExposureAdjust\" in self.configuration:\n            del self.configuration[\"ExposureAdjust\"]\n            return self.reconfigure(True, \"ExposureAdjust\")\n        return True\n\n    #snake_case alias:\n    set_msaa = setMSAA\n    del_msaa = delMSAA\n    del_cartoon_ink = delCartoonInk\n    set_half_pixel_shift = setHalfPixelShift\n    del_half_pixel_shift = delHalfPixelShift\n    set_inverted = setInverted\n    del_inverted = delInverted\n    del_view_glow = delViewGlow\n    set_volumetric_lighting = setVolumetricLighting\n    set_bloom = setBloom\n    set_view_glow = setViewGlow\n    set_ambient_occlusion = setAmbientOcclusion\n    set_cartoon_ink = setCartoonInk\n    del_bloom = delBloom\n    del_ambient_occlusion = delAmbientOcclusion\n    set_blur_sharpen = setBlurSharpen\n    del_blur_sharpen = delBlurSharpen\n    del_volumetric_lighting = delVolumetricLighting\n    set_gamma_adjust = setGammaAdjust\n    del_gamma_adjust = delGammaAdjust\n    set_srgb_encode = setSrgbEncode\n    del_srgb_encode = delSrgbEncode\n    set_exposure_adjust = setExposureAdjust\n    del_exposure_adjust = delExposureAdjust\n    set_high_dynamic_range = setHighDynamicRange\n    del_high_dynamic_range = delHighDynamicRange\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/filter/CommonFilters.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/1aaad34b_CommonFilters.json",
    "doc_id": "doc_218"
  }
}