{
  "content": "\"\"\"Implements a pop-up menu containing multiple clickable options.\n\nSee the :ref:`directoptionmenu` page in the programming manual for a more\nin-depth explanation and an example of how to use this class.\n\"\"\"\n\n__all__ = ['DirectOptionMenu']\n\nfrom panda3d.core import OmniBoundingVolume, TextNode, VBase3\nfrom direct.showbase import ShowBaseGlobal\nfrom . import DirectGuiGlobals as DGG\nfrom .DirectButton import DirectButton\nfrom .DirectFrame import DirectFrame\n\n\nclass DirectOptionMenu(DirectButton):\n    \"\"\"\n    DirectOptionMenu(parent) - Create a DirectButton which pops up a\n    menu which can be used to select from a list of items.\n    Execute button command (passing the selected item through) if defined\n    To cancel the popup menu click anywhere on the screen outside of the\n    popup menu.  No command is executed in this case.\n    \"\"\"\n\n    def __init__(self, parent = None, **kw):\n        # Inherits from DirectButton\n        optiondefs = (\n            # List of items to display on the popup menu\n            ('items',       [],             self.setItems),\n            # Initial item to display on menu button\n            # Can be an integer index or the same string as the button\n            ('initialitem', None,           DGG.INITOPT),\n            # Amount of padding to place around popup button indicator\n            ('popupMarkerBorder', (.1, .1), None),\n            # The initial position of the popup marker\n            ('popupMarker_pos', None, None),\n            # Background color to use to highlight popup menu items\n            ('highlightColor', (.5, .5, .5, 1), None),\n            # Extra scale to use on highlight popup menu items\n            ('highlightScale', (1, 1), None),\n            # Alignment to use for text on popup menu button\n            # Changing this breaks button layout\n            ('text_align',  TextNode.ALeft, None),\n            # Remove press effect because it looks a bit funny\n            ('pressEffect',     0,          DGG.INITOPT),\n        )\n        # Merge keyword options with default options\n        self.defineoptions(kw, optiondefs)\n        # Initialize superclasses\n        DirectButton.__init__(self, parent)\n        # Record any user specified frame size\n        self.initFrameSize = self['frameSize']\n        # Create a small rectangular marker to distinguish this button\n        # as a popup menu button\n        self.popupMarker = self.createcomponent(\n            'popupMarker', (), None,\n            DirectFrame, (self,),\n            frameSize = (-0.5, 0.5, -0.2, 0.2),\n            scale = 0.4,\n            relief = DGG.RAISED)\n        # Record any user specified popup marker position\n        self.initPopupMarkerPos = self['popupMarker_pos']\n        # This needs to popup the menu too\n        self.popupMarker.bind(DGG.B1PRESS, self.showPopupMenu)\n        # Check if item is highlighted on release and select it if it is\n        self.popupMarker.bind(DGG.B1RELEASE, self.selectHighlightedIndex)\n        # Make popup marker have the same click sound\n        if self['clickSound']:\n            self.popupMarker.guiItem.setSound(\n                DGG.B1PRESS + self.popupMarker.guiId, self['clickSound'])\n        else:\n            self.popupMarker.guiItem.clearSound(DGG.B1PRESS + self.popupMarker.guiId)\n        # This is created when you set the menu's items\n        self.popupMenu = None\n        self.selectedIndex = None\n        self.highlightedIndex = None\n        if 'item_text_scale' in kw:\n            self._prevItemTextScale = kw['item_text_scale']\n        else:\n            self._prevItemTextScale = (1,1)\n        # A big screen encompassing frame to catch the cancel clicks\n        self.cancelFrame = self.createcomponent(\n            'cancelframe', (), None,\n            DirectFrame, (self,),\n            frameSize = (-1, 1, -1, 1),\n            relief = None,\n            state = 'normal')\n        # Make sure this is on top of all the other widgets\n        self.cancelFrame.setBin('gui-popup', 0)\n        self.cancelFrame.node().setBounds(OmniBoundingVolume())\n        self.cancelFrame.bind(DGG.B1PRESS, self.hidePopupMenu)\n        # Default action on press is to show popup menu\n        self.bind(DGG.B1PRESS, self.showPopupMenu)\n        # Check if item is highlighted on release and select it if it is\n        self.bind(DGG.B1RELEASE, self.selectHighlightedIndex)\n        # Call option initialization functions\n        self.initialiseoptions(DirectOptionMenu)\n        # Need to call this since we explicitly set frame size\n        self.resetFrameSize()\n\n    def setItems(self):\n        \"\"\"\n        self['items'] = itemList\n        Create new popup menu to reflect specified set of items\n        \"\"\"\n        # Remove old component if it exits\n        if self.popupMenu is not None:\n            self.destroycomponent('popupMenu')\n        # Create new component\n        self.popupMenu = self.createcomponent('popupMenu', (), None,\n                                              DirectFrame,\n                                              (self,),\n                                              relief = 'raised',\n                                              )\n        # Make sure it is on top of all the other gui widgets\n        self.popupMenu.setBin('gui-popup', 0)\n        self.highlightedIndex = None\n        if not self['items']:\n            return\n        # Create a new component for each item\n        # Find the maximum extents of all items\n        itemIndex = 0\n        self.minX = self.maxX = self.minZ = self.maxZ = None\n        for item in self['items']:\n            c = self.createcomponent(\n                'item%d' % itemIndex, (), 'item',\n                DirectButton, (self.popupMenu,),\n                text = item, text_align = TextNode.ALeft,\n                command = lambda i = itemIndex: self.set(i))\n            bounds = c.getBounds()\n            if self.minX is None:\n                self.minX = bounds[0]\n            elif bounds[0] < self.minX:\n                self.minX = bounds[0]\n            if self.maxX is None:\n                self.maxX = bounds[1]\n            elif bounds[1] > self.maxX:\n                self.maxX = bounds[1]\n            if self.minZ is None:\n                self.minZ = bounds[2]\n            elif bounds[2] < self.minZ:\n                self.minZ = bounds[2]\n            if self.maxZ is None:\n                self.maxZ = bounds[3]\n            elif bounds[3] > self.maxZ:\n                self.maxZ = bounds[3]\n            itemIndex += 1\n        # Calc max width and height\n        self.maxWidth = self.maxX - self.minX\n        self.maxHeight = self.maxZ - self.minZ\n        # Adjust frame size for each item and bind actions to mouse events\n        for i in range(itemIndex):\n            item = self.component('item%d' %i)\n            # So entire extent of item's slot on popup is reactive to mouse\n            item['frameSize'] = (self.minX, self.maxX, self.minZ, self.maxZ)\n            # Move it to its correct position on the popup\n            item.setPos(-self.minX, 0, -self.maxZ - i * self.maxHeight)\n            item.bind(DGG.B1RELEASE, self.hidePopupMenu)\n            # Highlight background when mouse is in item\n            item.bind(DGG.WITHIN,\n                      lambda x, i=i, item=item:self._highlightItem(item, i))\n            # Restore specified color upon exiting\n            fc = item['frameColor']\n            item.bind(DGG.WITHOUT,\n                      lambda x, item=item, fc=fc: self._unhighlightItem(item, fc))\n        # Set popup menu frame size to encompass all items\n        f = self.component('popupMenu')\n        f['frameSize'] = (0, self.maxWidth, -self.maxHeight * itemIndex, 0)\n\n        # Determine what initial item to display and set text accordingly\n        if self['initialitem']:\n            self.set(self['initialitem'], fCommand = 0)\n        else:\n            # No initial item specified, just use first item\n            self.set(0, fCommand = 0)\n\n        # Position popup Marker to the right of the button\n        pm = self.popupMarker\n        pmw = (pm.getWidth() * pm.getScale()[0] +\n               2 * self['popupMarkerBorder'][0])\n        if self.initFrameSize:\n            # Use specified frame size\n            bounds = list(self.initFrameSize)\n        else:\n            # Or base it upon largest item\n            bounds = [self.minX, self.maxX, self.minZ, self.maxZ]\n        if self.initPopupMarkerPos:\n            # Use specified position\n            pmPos = list(self.initPopupMarkerPos)\n        else:\n            # Or base the position on the frame size.\n            pmPos = [bounds[1] + pmw/2.0, 0, bounds[2] + (bounds[3] - bounds[2])/2.0]\n        pm.setPos(pmPos[0], pmPos[1], pmPos[2])\n        # Adjust popup menu button to fit all items (or use user specified\n        # frame size\n        bounds[1] += pmw\n        self['frameSize'] = (bounds[0], bounds[1], bounds[2], bounds[3])\n        # Set initial state\n        self.hidePopupMenu()\n\n    def showPopupMenu(self, event = None):\n        \"\"\"\n        Make popup visible and try to position it just to right of\n        mouse click with currently selected item aligned with button.\n        Adjust popup position if default position puts it outside of\n        visible screen region\n        \"\"\"\n\n        # Needed attributes (such as minZ) won't be set unless the user has specified\n        # items to display. Let's assert that we've given items to work with.\n        items = self['items']\n        assert items and len(items) > 0, 'Cannot show an empty popup menu! You must add items!'\n\n        # Show the menu\n        self.popupMenu.show()\n        # Make sure its at the right scale\n        self.popupMenu.setScale(self, VBase3(1))\n        # Compute bounds\n        b = self.getBounds()\n        fb = self.popupMenu.getBounds()\n        # Position menu at midpoint of button\n        xPos = (b[1] - b[0])/2.0 - fb[0]\n        self.popupMenu.setX(self, xPos)\n        # Try to set height to line up selected item with button\n        self.popupMenu.setZ(\n            self, self.minZ + (self.selectedIndex + 1)*self.maxHeight)\n        # Make sure the whole popup menu is visible\n        pos = self.popupMenu.getPos(ShowBaseGlobal.render2d)\n        scale = self.popupMenu.getScale(ShowBaseGlobal.render2d)\n        # How are we doing relative to the right side of the screen\n        maxX = pos[0] + fb[1] * scale[0]\n        if maxX > 1.0:\n            # Need to move menu to the left\n            self.popupMenu.setX(ShowBaseGlobal.render2d, pos[0] + (1.0 - maxX))\n        # How about up and down?\n        minZ = pos[2] + fb[2] * scale[2]\n        maxZ = pos[2] + fb[3] * scale[2]\n        if minZ < -1.0:\n            # Menu too low, move it up\n            self.popupMenu.setZ(ShowBaseGlobal.render2d, pos[2] + (-1.0 - minZ))\n        elif maxZ > 1.0:\n            # Menu too high, move it down\n            self.popupMenu.setZ(ShowBaseGlobal.render2d, pos[2] + (1.0 - maxZ))\n        # Also display cancel frame to catch clicks outside of the popup\n        self.cancelFrame.show()\n        # Position and scale cancel frame to fill entire window\n        self.cancelFrame.setPos(ShowBaseGlobal.render2d, 0, 0, 0)\n        self.cancelFrame.setScale(ShowBaseGlobal.render2d, 1, 1, 1)\n\n    def hidePopupMenu(self, event = None):\n        \"\"\" Put away popup and cancel frame \"\"\"\n        self.popupMenu.hide()\n        self.cancelFrame.hide()\n\n    def _highlightItem(self, item, index):\n        \"\"\" Set frame color of highlighted item, record index \"\"\"\n        self._prevItemTextScale = item['text_scale']\n        item['frameColor'] = self['highlightColor']\n        item['frameSize'] = (self['highlightScale'][0]*self.minX, self['highlightScale'][0]*self.maxX, self['highlightScale'][1]*self.minZ, self['highlightScale'][1]*self.maxZ)\n        item['text_scale'] = self['highlightScale']\n        self.highlightedIndex = index\n\n    def _unhighlightItem(self, item, frameColor):\n        \"\"\" Clear frame color, clear highlightedIndex \"\"\"\n        item['frameColor'] = frameColor\n        item['frameSize'] = (self.minX, self.maxX, self.minZ, self.maxZ)\n        item['text_scale'] = self._prevItemTextScale\n        self.highlightedIndex = None\n\n    def selectHighlightedIndex(self, event = None):\n        \"\"\"\n        Check to see if item is highlighted (by cursor being within\n        that item).  If so, selected it.  If not, do nothing\n        \"\"\"\n        if self.highlightedIndex is not None:\n            self.set(self.highlightedIndex)\n            self.hidePopupMenu()\n\n    def index(self, index):\n        intIndex = None\n        if isinstance(index, int):\n            intIndex = index\n        elif index in self['items']:\n            i = 0\n            for item in self['items']:\n                if item == index:\n                    intIndex = i\n                    break\n                i += 1\n        return intIndex\n\n    def set(self, index, fCommand = 1):\n        # Item was selected, record item and call command if any\n        newIndex = self.index(index)\n        if newIndex is not None:\n            self.selectedIndex = newIndex\n            item = self['items'][self.selectedIndex]\n            self['text'] = item\n            if fCommand and self['command']:\n                # Pass any extra args to command\n                self['command'](*[item] + self['extraArgs'])\n\n    def get(self):\n        \"\"\" Get currently selected item \"\"\"\n        return self['items'][self.selectedIndex]\n\n    def commandFunc(self, event):\n        \"\"\"\n        Override popup menu button's command func\n        Command is executed in response to selecting menu items\n        \"\"\"\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/gui/DirectOptionMenu.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/57082ee2_DirectOptionMenu.json",
    "doc_id": "doc_73"
  }
}