{
  "content": "Common Image Filters\n\ncpp\n\nNote\n\nSorry, but the CommonFilters and FilterManager classes are implemented in Python and will not be of much use to C++ users.\n\nThe purpose of the ~direct.filter.CommonFilters.CommonFilters class is to make it easy to set up a number of common image postprocessing operations.\n\nImport the class like this:\n\nfrom direct.filter.CommonFilters import CommonFilters\n\nCurrently, the image postprocessing operations supported by CommonFilters are:\n\nBloom Filter - creates a glowing halo around bright objects.\n\nCartoon Inker - draws black lines around 3D objects.\n\nVolumetric Lighting - screen-space method for casting god-rays.\n\nInverted Filter - inverts all colors.\n\nBlur/Sharpen Filter - applies a generic blur or sharpen filter.\n\nAmbient Occlusion - applies a screen-space ambient occlusion filter.\n\nGamma Adjust - applies a gamma adjustment.\n\nsRGB Encode - ensures the image is encoded using the sRGB inverse EOTF.\n\nHigh Dynamic Range Filter - enables HDR rendering and tone mapping.\n\nExposure Adjust - applies exposure compensation before tone mapping.\n\nMSAA - enables multisample antialiasing.\n\nBasic Setup\n\nThe first step is to create an object of class CommonFilters. Pass in a pointer to your window, and your 3D camera:\n\nfilters = CommonFilters(base.win, base.cam)\n\nThis will have no effect until you enable a filter (instructions below.) Once a filter is enabled, class CommonFilters will reconfigure the Panda3D rendering as follows:\n\nIt will render the scene into an offscreen buffer, using the camera you provided.\n\nIt will remove the scene from the specified window, and replace it with a fullscreen quad.\n\nThe quad will be textured with the scene, plus a shader that implements whatever filter you have selected.\n\nIf all goes well, the net effect is that your scene will continue to appear in your window, but it will be filtered as you specify.\n\nWhat if the Video Card can't handle it?\n\nIf the video card is not capable of implementing your filters, then all filters will be removed and the filter-enabling function will return False. Otherwise, filter-enabling functions will return True.\n\nThe Bloom Filter\n\nThe bloom filter causes bright objects to have a glowing halo around them. To enable a bloom filter, use setBloom. To disable, use delBloom:\n\nfilters.setBloom( ... options ...)\nfilters.delBloom()\n\nThe bloom filter works as follows. First, it renders the scene into a texture. It also asks the renderer to render any glow-maps into the alpha channel of the texture. After rendering the scene, it generates a second copy of the scene which has been darkened until only the brightest pixels are visible, and all the others go to black. It then blurs that texture, yielding soft halos where the bright pixels used to be, and black everywhere else. It then adds the soft halos back onto the scene in the window.\n\nNote: If you want to use glow maps to indicate which parts of the image should receive bloom, you should assign a nonzero value to the alpha value of the blend-weight parameter, and you should enable the shader generator <the-shader-generator> for the models that have glow maps applied.\n\nThe bloom filter has many keyword parameters:\n\nblend - The bloom filter needs to measure the brightness of each pixel. It does this by weighting the R,G,B, and A components. Default weights: (0.3,0.4,0.3,0.0). You should assign a nonzero weight to the alpha channel if you want the glow map to have an effect, or a value like (0, 0, 0, 1) if you only want your glow map to indicate which models should glow.\n\nmintrigger - Minimum brightness at which a halo is generated. Default: 0.6\n\nmaxtrigger - Maximum brightness at which the halo reaches peak intensity. Default: 1.0\n\ndesat - Degree to which the halo is desaturated. Setting this to zero means the halo is the same color as the bright pixel. Setting it to one means the halo is white. Default: 0.6\n\nintensity - An adjustment parameter for the brightness of the halos. Default: 1.0\n\nsize - Adjusts the size of the halos. Takes a string value: \"small\", \"medium\", or \"large\". The reason that this is a discrete value and not a continuous one is that the blur operation involves downsampling the original texture by a power of two. Default: \"medium\"\n\nThe Cartoon Inking Filter\n\nThe cartoon inking filter causes objects to have black lines around them. To enable a cartoon inking filter, use setCartoonInk. To disable, use delCartoonInk:\n\nfilters.setCartoonInk( ... options ...)\nfilters.delCartoonInk()\n\nThe cartoon inking filter works by rendering a camera-space normal into an texture. Then, a postprocessing filter does an edge-detect algorithm on the camera-space normal texture.\n\nThe filter has the following keyword parameters:\n\nseparation - Distance in pixels, controls the width of the ink line. Default: 1 pixel.\n\ncolor - Color of the outline. Default: (0, 0, 0, 1)\n\nThe Volumetric Lighting Filter\n\nThe Volumetric Lighting filter makes objects cast visible light rays (also known as crepuscular rays, god rays or sunbeams) that can be occluded by visible geometry. This is an easy way to easily create nice-looking light/sun effects.\n\nfilters.setVolumetricLighting( ... options ...)\nfilters.delVolumetricLighting()\n\nThe filter has the following keyword parameters:\n\ncaster - NodePath that indicates the origin of the rays. Usually, you would pass your light, and create a sun billboard which is reparented to the light's NodePath.\n\nnumsamples - Number of samples. The more samples you use, the slower the effect will be, but you will have smoother light rays. Note that using a fuzzy billboarded dot instead of a hard-edged sphere as light caster can help with smoothing the end result, too. This value does not need to be a power-of-two, it can be any positive number. Default: 32\n\ndensity - This defines the length of the rays. The default value of 5.0 is probably too high for many purposes, usually a value between 0.5 and 1.0 works best. This also depends on the number of samples and exposure you've chosen, though. Default: 5.0\n\ndecay - Decay makes rays gradually decrease in brightness. The default value of 0.1 is not well chosen and makes the rays very short! Usually, this a value close to 1.0, like 0.98. Default: 0.1\n\nexposure - Defines the brightness of the rays. Default: 0.1\n\nThe Inverted Filter\n\nThis filter simply inverts the colors of the image.\n\nfilters.setInverted()\nfilters.delInverted()\n\nThis filter has no parameters.\n\nThe Blur / Sharpen Filter\n\nThis filter can apply a blur or sharpen effect to the image.\n\nfilters.setBlurSharpen( ... options ...)\nfilters.delBlurSharpen()\n\nThe filter has the following keyword parameters:\n\namount - The amount of blurring, this is usually a value between 0.0 and 2.0. You can take values smaller than 0.0 or larger than 2.0, but this usually gives ugly artifacts. A value of 0.0 means maximum blur. A value of 1.0 does nothing, and if you go past 1.0, the image will be sharpened instead of blurred. Default: 0.0\n\nThe Ambient Occlusion Filter\n\nThis filter adds a simple screen-space ambient occlusion effect to the scene.\n\nfilters.setAmbientOcclusion( ... options ...)\nfilters.delAmbientOcclusion()\n\nIt is important that the viewing frustrum's near and far values fit the scene as tightly as possible. Note that you need to do lots of tweaking to the parameters to get this filter to work for your particular situation.\n\nThe filter has the following keyword parameters:\n\nnumsamples - The amount of samples used. Default: 16\n\nradius - The sampling radius of the rotating kernel. Default: 0.05\n\namount - Default: 2.0\n\nstrength - Default: 0.01\n\nfalloff - Default: 0.000002\n\nThe Gamma Adjust Filter\n\nThis filter performs a simple gamma adjustment by raising the color values to the given power.\n\nDo not use this to adjust to the 2.2 gamma of a computer monitor. For that, see the below filter.\n\nfilters.setGammaAdjust(1.5)\nfilters.delGammaAdjust()\n\nThe sRGB Encode Filter\n\nThis filter applies the inverse sRGB Electro-Optical Transfer Function (EOTF) to the final rendering result. This allows the lighting and blending calculations to be performed in linear space, which results in more accurate colors and lighting.\n\nThe effect of this is similar to applying a gamma adjustment of 1.0/2.2, but not quite. The sRGB transfer function has a linear section in the beginning to better preserve the fidelity of dark values.\n\nWhen enabling this, it is important to make sure that all color input textures are properly configured to use the sRGB format, to prevent them from appearing too bright and washed-out.\n\nIf the framebuffer-srgb setting is active, this filter is unnecessary. Panda will detect if this is the case and refuse to apply this filter, in order to prevent double-applying the sRGB transformation.\n\nfilters.setSrgbEncode()\nfilters.delSrgbEncode()\n\nThis filter is available as of Panda3D 1.10.7.\n\nThe High Dynamic Range Filter\n\nThis filter enables High Dynamic Range rendering. This will enable the use of a floating-point framebuffer format and disables clamping of the color values before they are written to the framebuffer. This allows you to use far greater brightness values on your lights, which creates a greater dynamic range in your scene. A tonemapping filter (ACES) is used to bring the values back into the appropriate range for display on a monitor.\n\nDepending on the brightness of your lights, it may be necessary to use the Exposure Adjust filter in order to prevent an oversaturated image.\n\nIt is recommended to set your lights to use an inverse square falloff attenuation (using setAttenuation(0, 0, 1)), enable the sRGB Encode filter, and use realistically bright values for your light colors to achieve the most realistic effect.\n\nfilters.setHighDynamicRange()\nfilters.delHighDynamicRange()\n\nThis filter is available as of Panda3D 1.10.7.\n\nThe Exposure Adjust Filter\n\nThis filter is meant to be used in conjunction with the HDR filter, above, in order to adjust the exposure level. In a game where the player moves between different parts of the scene with different lighting levels, it will be necessary to adjust this on the fly depending on the player's location. This is similar to how our eyes adjust to different light levels as we move between areas of differing brightness.\n\nThe value is in f-stops, meaning that a value of 0 resulting in no adjustment, and each value above 0 doubles the scene luminance, whereas each value below 0 halves it.\n\nfilters.setExposureAdjust(0)\nfilters.delExposureAdjust()\n\nThis filter is available as of Panda3D 1.10.7.\n\nThe MSAA Filter\n\nThis is not really a \"filter\" as such, but just a way to enable multisample antialiasing on the offscreen buffer. Doing this has a couple of advantages compared to enabling multisample filtering on the main window, such as the fact that you can switch this setting based on detected capabilities and user settings, without having to reopen the window.\n\nWhen using this setting, it is recommended to leave multisample filtering off on the main window, otherwise it will be a waste of GPU memory. So, do not put framebuffer-multisample in your Config.prc file.\n\nThis filter is available as of Panda3D 1.10.13.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/14d9d4de_common-image-filters.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/8f076aff_14d9d4de_common-image-filters.json",
    "doc_id": "doc_419"
  }
}