{
  "content": "import math\n\nfrom panda3d.core import (\n    CollisionNode,\n    ConfigVariableBool,\n    ConfigVariableString,\n    CSDefault,\n    GraphicsWindow,\n    NodePath,\n    Point3,\n    TextNode,\n    VBase3,\n    VBase4,\n    Vec3,\n    Vec4,\n    decomposeMatrix,\n    deg2Rad,\n)\nfrom .DirectUtil import useDirectRenderStyle\n\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.showbase.BulletinBoardGlobal import bulletinBoard as bboard\nfrom direct.task import Task\n\nfrom . import DirectGlobals as DG\nfrom .DirectCameraControl import DirectCameraControl\nfrom .DirectManipulation import DirectManipulationControl\nfrom .DirectSelection import SelectionRay, COA_ORIGIN, SelectedNodePaths\nfrom .DirectGrid import DirectGrid\n#from DirectGeometry import *\nfrom .DirectLights import DirectLights\n## from direct.tkpanels import Placer\n## from direct.tkwidgets import Slider\n## from direct.tkwidgets import SceneGraphExplorer\nfrom direct.gui import OnscreenText\nfrom direct.interval.IntervalGlobal import Func, Sequence\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.showbase import ShowBaseGlobal\nfrom direct.showbase.ShowBaseGlobal import ShowBase, hidden\n\nimport builtins\n\nbase: ShowBase\n\nclass DirectSession(DirectObject):\n\n    # post this to the bboard to make sure DIRECT doesn't turn on\n    DIRECTdisablePost = 'disableDIRECT'\n\n    cam: NodePath\n    camera: NodePath\n    oobeCamera: NodePath\n\n    def __init__(self):\n        # Establish a global pointer to the direct object early on\n        # so dependant classes can access it in their code\n        global direct, base\n        base = ShowBaseGlobal.base\n        base.direct = self\n        setattr(builtins, 'direct', self)\n        ShowBaseGlobal.direct = self\n\n        # These come early since they are used later on\n        self.group = base.render.attachNewNode('DIRECT')\n        self.font = TextNode.getDefaultFont()\n        self.fEnabled = 0\n        self.fEnabledLight = 0\n        self.fScaleWidgetByCam = 0 # [gjeon] flag for scaling widget by distance from the camera\n        self.fIgnoreDirectOnlyKeyMap = 0 # [gjeon] to skip old direct controls in new LE\n\n        self.drList = DisplayRegionList()\n        self.iRayList = [x.iRay for x in self.drList]\n        self.dr = self.drList[0]\n        self.win: GraphicsWindow = base.win\n        self.camera = base.camera\n        self.cam = base.cam\n        self.camNode = base.camNode\n        self.trueCamera = self.camera\n        self.iRay = self.dr.iRay\n        self.coaMode = COA_ORIGIN\n\n        self.cameraControl = DirectCameraControl()\n        self.manipulationControl = DirectManipulationControl()\n        self.useObjectHandles()\n        self.grid = DirectGrid()\n        self.grid.disable()\n        self.lights = DirectLights(self.group)\n        # Create some default lights\n        self.lights.createDefaultLights()\n        # But turn them off\n        self.lights.allOff()\n\n        # Initialize the collection of selected nodePaths\n        self.selected = SelectedNodePaths()\n        # Ancestry of currently selected object\n        self.ancestry = []\n        self.ancestryIndex = 0\n        self.activeParent = None\n\n        self.selectedNPReadout = OnscreenText.OnscreenText(\n            pos = (0.1, 0.1), bg=Vec4(0, 0, 0, .2), style=3,\n            fg = (1, 1, 1, 1), scale = 0.05, align = TextNode.ALeft,\n            mayChange = 1, font = self.font)\n        # Make sure readout is never lit or drawn in wireframe\n        useDirectRenderStyle(self.selectedNPReadout)\n        self.selectedNPReadout.reparentTo(hidden)\n\n        self.activeParentReadout = OnscreenText.OnscreenText(\n            pos = (0.1, 0.16), bg=Vec4(0, 0, 0, .2), style = 3,\n            fg = (1, 1, 1, 1), scale = 0.05, align = TextNode.ALeft,\n            mayChange = 1, font = self.font)\n        # Make sure readout is never lit or drawn in wireframe\n        useDirectRenderStyle(self.activeParentReadout)\n        self.activeParentReadout.reparentTo(hidden)\n\n        self.directMessageReadout = OnscreenText.OnscreenText(\n            pos = (0.1, -0.1), bg=Vec4(0, 0, 0, .2), style = 3,\n            fg = (1, 1, 1, 1), scale = 0.05, align = TextNode.ALeft,\n            mayChange = 1, font = self.font)\n        # Make sure readout is never lit or drawn in wireframe\n        useDirectRenderStyle(self.directMessageReadout)\n        self.directMessageReadout.reparentTo(hidden)\n\n        # Create a vrpn client vrpn-server or default\n        self.deviceManager = None\n        self.joybox = None\n        self.radamec = None\n        self.fastrak = []\n        if ConfigVariableBool('want-vrpn', False):\n            from direct.directdevices import DirectDeviceManager\n            self.deviceManager = DirectDeviceManager.DirectDeviceManager()\n            # Automatically create any devices specified in config file\n            joybox = ConfigVariableString('vrpn-joybox-device', '').value\n            radamec = ConfigVariableString('vrpn-radamec-device', '').value\n            fastrak = ConfigVariableString('vrpn-fastrak-device', '').value\n            if joybox:\n                from direct.directdevices import DirectJoybox\n                self.joybox = DirectJoybox.DirectJoybox(joybox)\n            if radamec:\n                from direct.directdevices import DirectRadamec\n                self.radamec = DirectRadamec.DirectRadamec(radamec)\n            if fastrak:\n                from direct.directdevices import DirectFastrak\n                # parse string into format device:N where N is the sensor name\n                fastrak = fastrak.split()\n                for i in range(len(fastrak))[1:]:\n                    self.fastrak.append(DirectFastrak.DirectFastrak(fastrak[0] + ':' + fastrak[i]))\n\n        self.fControl = 0\n        self.fAlt = 0\n        self.fShift = 0\n        self.fMouse1 = 0 # [gjeon] to update alt key information while mouse1 is pressed\n        self.fMouse2 = 0\n        self.fMouse3 = 0\n\n        self.pos = VBase3()\n        self.hpr = VBase3()\n        self.scale = VBase3()\n\n        self.hitPt = Point3(0.0)\n\n        # Lists for managing undo/redo operations\n        self.undoList = []\n        self.redoList = []\n\n        # One run through the context task to init everything\n        self.drList.updateContext()\n        for dr in self.drList:\n            dr.camUpdate()\n\n        self.actionEvents = [\n            ['select', self.select],\n            ['DIRECT-select', self.selectCB],\n            ['deselect', self.deselect],\n            ['deselectAll', self.deselectAll],\n            ['DIRECT-preDeselectAll', self.deselectAllCB],\n            ['highlightAll', self.selected.highlightAll],\n            ['preRemoveNodePath', self.deselect],\n            # Scene graph explorer functions\n            ['SGE_Select', self.select],\n            ['SGE_Deselect', self.deselect],\n            ['SGE_Set Reparent Target', self.setActiveParent],\n            ['SGE_Reparent', self.reparent],\n            ['SGE_WRT Reparent', lambda np, s=self: s.reparent(np, fWrt = 1)],\n            ['SGE_Flash', self.flash],\n            ['SGE_Isolate', self.isolate],\n            ['SGE_Toggle Vis', self.toggleVis],\n            ['SGE_Show All', self.showAllDescendants],\n            ['SGE_Fit', self.fitOnNodePath],\n            ['SGE_Delete', self.removeNodePath],\n            ['SGE_Set Name', self.getAndSetName],\n            ['DIRECT-delete', self.removeAllSelected],\n            ['DIRECT-Undo', self.undo],\n            ['DIRECT-Redo', self.redo],\n            ['DIRECT-OOBE', self.oobe],\n            ['DIRECT-toggleWidgetVis', self.toggleWidgetVis],\n            ['DIRECT-toggleWireframe', base.toggleWireframe],\n            ['DIRECT-toggleVisAll', self.selected.toggleVisAll],\n            ['DIRECT-toggleTexture', base.toggleTexture],\n            ['DIRECT-upAncestry', self.upAncestry],\n            ['DIRECT-downAncestry', self.downAncestry],\n            ['DIRECT-toggleBackface', base.toggleBackface],\n            ['DIRECT-flash', self.flash],\n            ['DIRECT-toggleLigths', self.lights.toggle],\n            ['DIRECT-toggleCOALock', self.cameraControl.toggleCOALock],\n            ['DIRECT-setActiveParent', self.doSetActiveParent],\n            ['DIRECT-doWrtReparent', self.doWrtReparent],\n            ['DIRECT-doReparent', self.doReparent],\n            ['DIRECT-doSelect', self.doSelect],\n        ]\n\n        if base.wantTk:\n            from direct.tkpanels import Placer\n            from direct.tkwidgets import Slider\n            from direct.tkwidgets import SceneGraphExplorer\n            self.actionEvents.extend([\n            ['SGE_Place', Placer.place],\n            ['SGE_Set Color', Slider.rgbPanel],\n            ['SGE_Explore', SceneGraphExplorer.explore],])\n        self.modifierEvents = ['control', 'control-up', 'control-repeat',\n                              'shift', 'shift-up', 'shift-repeat',\n                              'alt', 'alt-up', 'alt-repeat',\n                               ]\n\n        keyList = [chr(i) for i in range(97, 123)]\n        keyList.extend([chr(i) for i in range(48, 58)])\n        keyList.extend([\"`\", \"-\", \"=\", \"[\", \"]\", \";\", \"'\", \",\", \".\", \"/\", \"\\\\\"])\n\n        self.specialKeys = ['escape', 'delete', 'page_up', 'page_down', 'enter']\n\n        def addCtrl(a):\n            return \"control-%s\"%a\n\n        def addShift(a):\n            return \"shift-%s\"%a\n\n        self.keyEvents = keyList[:]\n        self.keyEvents.extend(list(map(addCtrl, keyList)))\n        self.keyEvents.extend(list(map(addShift, keyList)))\n        self.keyEvents.extend(self.specialKeys)\n\n        self.mouseEvents = ['mouse1', 'mouse1-up',\n                            'shift-mouse1', 'shift-mouse1-up',\n                            'control-mouse1', 'control-mouse1-up',\n                            'alt-mouse1', 'alt-mouse1-up',\n                            'mouse2', 'mouse2-up',\n                            'shift-mouse2', 'shift-mouse2-up',\n                            'control-mouse2', 'control-mouse2-up',\n                            'alt-mouse2', 'alt-mouse2-up',\n                            'mouse3', 'mouse3-up',\n                            'shift-mouse3', 'shift-mouse3-up',\n                            'control-mouse3', 'control-mouse3-up',\n                            'alt-mouse3', 'alt-mouse3-up',\n                            ]\n\n        self.directOnlyKeyMap = {\n            'u': ('Orbit Upright Camera', 'DIRECT-orbitUprightCam'),\n            'shift-u': ('Upright Camera', 'DIRECT-uprightCam'),\n            '1': ('Move Camera to View 1', 'DIRECT-spwanMoveToView-1'),\n            '2': ('Move Camera to View 2', 'DIRECT-spwanMoveToView-2'),\n            '3': ('Move Camera to View 3', 'DIRECT-spwanMoveToView-3'),\n            '4': ('Move Camera to View 4', 'DIRECT-spwanMoveToView-4'),\n            '5': ('Move Camera to View 5', 'DIRECT-spwanMoveToView-5'),\n            '6': ('Move Camera to View 6', 'DIRECT-spwanMoveToView-6'),\n            '7': ('Move Camera to View 7', 'DIRECT-spwanMoveToView-7'),\n            '8': ('Move Camera to View 8', 'DIRECT-spwanMoveToView-8'),\n            '9': ('Rotate Camera About widget 90 degrees Counterclockwise', 'DIRECT-swingCamAboutWidget-0'),\n            '0': ('Rotate Camera About widget 90 degrees Clockwise', 'DIRECT-swingCamAboutWidget-1'),\n            '`': ('Remove ManipulateCameraTask', 'DIRECT-removeManipulateCameraTask'),\n            '=': ('Zoom In', 'DIRECT-zoomInCam'),\n            'shift-=': ('Zoom In', 'DIRECT-zoomInCam'),\n            'shift-_': ('Zoom Out', 'DIRECT-zoomOutCam'),\n            '-': ('Zoom Out', 'DIRECT-zoomOutCam'),\n            'o': ('Toggle OOBE', 'DIRECT-OOBE'),\n            '[': ('DIRECT-Undo', 'DIRECT-Undo'),\n            'shift-[': ('DIRECT-Undo', 'DIRECT-Undo'),\n            ']': ('DIRECT-Redo', 'DIRECT-Redo'),\n            'shift-]': ('DIRECT-Redo', 'DIRECT-Redo'),\n        }\n\n        self.hotKeyMap = {\n            'c': ('Center Camera', 'DIRECT-centerCamIn'),\n            'f': ('Fit on Widget', 'DIRECT-fitOnWidget'),\n            'h': ('Move Camera to ', 'DIRECT-homeCam'),\n            'shift-v': ('Toggle Marker', 'DIRECT-toggleMarkerVis'),\n            'm': ('Move to fit', 'DIRECT-moveToFit'),\n            'n': ('Pick Next COA', 'DIRECT-pickNextCOA'),\n            'delete': ('Delete', 'DIRECT-delete'),\n            '.': ('Scale Up Widget', 'DIRECT-widgetScaleUp'),\n            ',': ('Scale Down Widget', 'DIRECT-widgetScaleDown'),\n            'page_up': ('Up Ancestry', 'DIRECT-upAncestry'),\n            'page_down': ('Down Ancestry', 'DIRECT-downAncestry'),\n            'escape': ('Deselect All', 'deselectAll'),\n            'v': ('Toggle Manipulating Widget', 'DIRECT-toggleWidgetVis'),\n            'b': ('Toggle Backface', 'DIRECT-toggleBackface'),\n            'control-f': ('Flash', 'DIRECT-flash'),\n            'l': ('Toggle lights', 'DIRECT-toggleLigths'),\n            'shift-l': ('Toggle COA Lock', 'DIRECT-toggleCOALock'),\n            'p': ('Set Active Parent', 'DIRECT-setActiveParent'),\n            'r': ('Wrt Reparent', 'DIRECT-doWrtReparent'),\n            'shift-r': ('Reparent', 'DIRECT-doReparent'),\n            's': ('Select', 'DIRECT-doSelect'),\n            't': ('Toggle Textures', 'DIRECT-toggleTexture'),\n            'shift-a': ('Toggle Vis all', 'DIRECT-toggleVisAll'),\n            'w': ('Toggle Wireframe', 'DIRECT-toggleWireframe'),\n            'control-z': ('Undo', 'LE-Undo'),\n            'shift-z': ('Redo', 'LE-Redo'),\n            'control-d': ('Duplicate', 'LE-Duplicate'),\n            'control-l': ('Make Live', 'LE-MakeLive'),\n            'control-n': ('New Scene', 'LE-NewScene'),\n            'control-s': ('Save Scene', 'LE-SaveScene'),\n            'control-o': ('Open Scene', 'LE-OpenScene'),\n            'control-q': ('Quit', 'LE-Quit'),\n        }\n\n        self.speicalKeyMap = {\n                              'enter': 'DIRECT-enter',\n                             }\n\n        self.passThroughKeys = ['v','b','l','p', 'r', 'shift-r', 's', 't','shift-a', 'w']\n\n        if base.wantTk:\n            from direct.tkpanels import DirectSessionPanel\n            self.panel = DirectSessionPanel.DirectSessionPanel(parent = base.tkRoot)\n\n        clusterMode: str\n        if hasattr(builtins, 'clusterMode'):\n            # Has the clusterMode been set externally (i.e. via the\n            # bootstrap application?\n            clusterMode = builtins.clusterMode\n        else:\n            # Has the clusterMode been set via a config variable?\n            clusterMode = ConfigVariableString(\"cluster-mode\", '').value\n        self.clusterMode = clusterMode\n\n        if self.clusterMode == 'client':\n            from direct.cluster.ClusterClient import createClusterClient\n            self.cluster = createClusterClient()\n        elif self.clusterMode == 'server':\n            from direct.cluster.ClusterServer import ClusterServer\n            self.cluster = ClusterServer(base.camera, base.cam)\n        else:\n            from direct.cluster.ClusterClient import DummyClusterClient\n            self.cluster = DummyClusterClient()\n        setattr(builtins, 'cluster', self.cluster)\n\n    def addPassThroughKey(self,key):\n\n        self.passThroughKeys.append(key)\n\n    def enable(self):\n        # don't enable DIRECT if someone has posted DIRECTdisablePost\n        if bboard.has(DirectSession.DIRECTdisablePost):\n            return\n        if self.fEnabled:\n            return\n        # Make sure old tasks are shut down\n        self.disable()\n        # Start all display region context tasks\n        self.drList.spawnContextTask()\n        if not self.fEnabledLight:\n            # Turn on mouse Flying\n            self.cameraControl.enableMouseFly()\n        # Turn on object manipulation\n        self.manipulationControl.enableManipulation()\n        # Make sure list of selected items is reset\n        self.selected.reset()\n        # Accept appropriate hooks\n        if not self.fEnabledLight:\n            self.enableKeyEvents()\n        self.enableMouseEvents()\n        self.enableActionEvents()\n        self.enableModifierEvents()\n        # Set flag\n        self.fEnabled = 1\n\n    def enableLight(self):\n        self.fEnabledLight = 1\n        self.enable()\n\n    def disable(self):\n        # Shut down all display region context tasks\n        self.drList.removeContextTask()\n        # Turn off camera fly\n        self.cameraControl.disableMouseFly()\n        # Turn off object manipulation\n        self.deselectAll()\n        self.manipulationControl.disableManipulation()\n        self.disableKeyEvents()\n        self.disableModifierEvents()\n        self.disableMouseEvents()\n        self.disableActionEvents()\n        # Kill tasks\n        taskMgr.remove('flashNodePath')\n        taskMgr.remove('hideDirectMessage')\n        taskMgr.remove('hideDirectMessageLater')\n        # Set flag\n        self.fEnabled = 0\n\n    def toggleDirect(self):\n        if self.fEnabled:\n            self.disable()\n        else:\n            self.enable()\n\n    def minimumConfiguration(self):\n        # Remove context task\n        self.drList.removeContextTask()\n        # Turn off camera fly\n        self.cameraControl.disableMouseFly()\n        # Ignore keyboard and action events\n        self.disableKeyEvents()\n        self.disableActionEvents()\n        # But let mouse events pass through\n        self.enableMouseEvents()\n        self.enableModifierEvents()\n\n    def oobe(self):\n        # If oobeMode was never set, set it to false and create the\n        # structures we need to implement OOBE.\n        if not hasattr(self, 'oobeMode'):\n            self.oobeMode = 0\n\n            self.oobeCamera = hidden.attachNewNode('oobeCamera')\n\n            self.oobeVis = base.loader.loadModel('models/misc/camera')\n            if self.oobeVis:\n                self.oobeVis.node().setFinal(1)\n\n        if self.oobeMode:\n            # Position a target point to lerp the oobe camera to\n            self.cameraControl.camManipRef.setPosHpr(self.trueCamera, 0, 0, 0, 0, 0, 0)\n            ival = self.oobeCamera.posHprInterval(\n                2.0, pos = Point3(0), hpr = Vec3(0),\n                other = self.cameraControl.camManipRef,\n                blendType = 'easeInOut')\n            ival = Sequence(ival, Func(self.endOOBE), name = 'oobeTransition')\n            ival.start()\n        else:\n            # Place camera marker at true camera location\n            self.oobeVis.reparentTo(self.trueCamera)\n            # Remove any transformation on the models arc\n            self.oobeVis.clearMat()\n            # Make oobeCamera be a sibling of wherever camera is now.\n            cameraParent = self.camera.getParent()\n            # Prepare oobe camera\n            self.oobeCamera.reparentTo(cameraParent)\n            self.oobeCamera.setPosHpr(self.trueCamera, 0, 0, 0, 0, 0, 0)\n            # Put camera under new oobe camera\n            self.cam.reparentTo(self.oobeCamera)\n            # Position a target point to lerp the oobe camera to\n            self.cameraControl.camManipRef.setPos(\n                self.trueCamera, Vec3(-2, -20, 5))\n            self.cameraControl.camManipRef.lookAt(self.trueCamera)\n            ival = self.oobeCamera.posHprInterval(\n                2.0, pos = Point3(0), hpr = Vec3(0),\n                other = self.cameraControl.camManipRef,\n                blendType = 'easeInOut')\n            ival = Sequence(ival, Func(self.beginOOBE), name = 'oobeTransition')\n            ival.start()\n\n    def beginOOBE(self):\n        # Make sure we've reached our final destination\n        self.oobeCamera.setPosHpr(self.cameraControl.camManipRef, 0, 0, 0, 0, 0, 0)\n        self.camera = self.oobeCamera\n        self.oobeMode = 1\n\n    def endOOBE(self):\n        # Make sure we've reached our final destination\n        self.oobeCamera.setPosHpr(self.trueCamera, 0, 0, 0, 0, 0, 0)\n        # Disable OOBE mode.\n        self.cam.reparentTo(self.trueCamera)\n        self.camera = self.trueCamera\n        # Get rid of ancillary node paths\n        self.oobeVis.reparentTo(hidden)\n        self.oobeCamera.reparentTo(hidden)\n        self.oobeMode = 0\n\n    def destroy(self):\n        self.disable()\n\n    def reset(self):\n        self.enable()\n\n    # EVENT FUNCTIONS\n    def enableActionEvents(self):\n        for event in self.actionEvents:\n            self.accept(event[0], event[1], extraArgs = event[2:])\n\n    def enableModifierEvents(self):\n        for event in self.modifierEvents:\n            self.accept(event, self.inputHandler, [event])\n\n    def enableKeyEvents(self):\n        for event in self.keyEvents:\n            self.accept(event, self.inputHandler, [event])\n\n    def enableMouseEvents(self):\n        for event in self.mouseEvents:\n            self.accept(event, self.inputHandler, [event])\n\n    def disableActionEvents(self):\n        for event, method in self.actionEvents:\n            self.ignore(event)\n\n    def disableModifierEvents(self):\n        for event in self.modifierEvents:\n            self.ignore(event)\n\n    def disableKeyEvents(self):\n        for event in self.keyEvents:\n            self.ignore(event)\n\n    def disableMouseEvents(self):\n        for event in self.mouseEvents:\n            self.ignore(event)\n\n    def inputHandler(self, input):\n        if not hasattr(self, 'oobeMode') or self.oobeMode == 0:\n            # [gjeon] change current camera dr, iRay, mouseWatcher accordingly to support multiple windows\n            if self.manipulationControl.fMultiView:\n                # handling orphan events\n                if self.fMouse1 and 'mouse1' not in input or\\\n                   self.fMouse2 and 'mouse2' not in input or\\\n                   self.fMouse3 and 'mouse3' not in input:\n                    if input.endswith('-up') or\\\n                       input not in self.modifierEvents:\n                        # to handle orphan events\n                        return\n\n                if (self.fMouse1 == 0 and 'mouse1-up' in input) or\\\n                   (self.fMouse2 == 0 and 'mouse2-up' in input) or\\\n                   (self.fMouse3 == 0 and 'mouse3-up' in input):\n                    # to handle orphan events\n                    return\n\n                if (self.fMouse1 or self.fMouse2 or self.fMouse3) and\\\n                   input[4:7] != self.camera.getName()[:3] and\\\n                   input.endswith('-up'):\n                    # to handle orphan events\n                    return\n\n                winCtrl = None\n                possibleWinCtrls = []\n                for cWinCtrl in base.winControls:\n                    if cWinCtrl.mouseWatcher.node().hasMouse():\n                        possibleWinCtrls.append(cWinCtrl)\n\n                if len(possibleWinCtrls) == 1:\n                    winCtrl = possibleWinCtrls[0]\n                elif len(possibleWinCtrls) > 1:\n                    for cWinCtrl in possibleWinCtrls:\n                        if (input.endswith('-up') and\\\n                            not input in self.modifierEvents and\\\n                            not input in self.mouseEvents) or\\\n                           (input in self.mouseEvents):\n                            if input[4:7] == cWinCtrl.camera.getName()[:3]:\n                                winCtrl = cWinCtrl\n                        else:\n                            if input[4:7] != cWinCtrl.camera.getName()[:3]:\n                                winCtrl = cWinCtrl\n                if winCtrl is None:\n                    return\n                if input not in self.modifierEvents:\n                    self.win = winCtrl.win\n                    self.camera = winCtrl.camera\n                    self.trueCamera = self.camera\n                    self.cam = NodePath(winCtrl.camNode)\n                    self.camNode = winCtrl.camNode\n                    if hasattr(winCtrl, 'grid'):\n                        self.grid = winCtrl.grid\n                    self.dr = self.drList[base.camList.index(NodePath(winCtrl.camNode))]\n                    self.iRay = self.dr.iRay\n                    base.mouseWatcher = winCtrl.mouseWatcher\n                    base.mouseWatcherNode = winCtrl.mouseWatcher.node()\n                    self.dr.mouseUpdate()\n                    DG.LE_showInOneCam(self.selectedNPReadout, self.camera.getName())\n                    self.widget = self.manipulationControl.widgetList[base.camList.index(NodePath(winCtrl.camNode))]\n\n                input = input[8:] # get rid of camera prefix\n                if self.fAlt and 'alt' not in input and not input.endswith('-up'):\n                    input = 'alt-' + input\n                if input.endswith('-repeat'):\n                    input = input[:-7]\n\n        # Deal with keyboard and mouse input\n        if input in self.hotKeyMap:\n            keyDesc = self.hotKeyMap[input]\n            messenger.send(keyDesc[1])\n        elif input in self.speicalKeyMap:\n            messenger.send(self.speicalKeyMap[input])\n        elif input in self.directOnlyKeyMap:\n            if self.fIgnoreDirectOnlyKeyMap:\n                return\n            keyDesc = self.directOnlyKeyMap[input]\n            messenger.send(keyDesc[1])\n        elif input == 'mouse1-up':\n            self.fMouse1 = 0 # [gjeon] to update alt key information while mouse1 is pressed\n            messenger.send('DIRECT-mouse1Up')\n        elif input.find('mouse1') != -1:\n            self.fMouse1 = 1 # [gjeon] to update alt key information while mouse1 is pressed\n            modifiers = self.getModifiers(input, 'mouse1')\n            messenger.send('DIRECT-mouse1', sentArgs = [modifiers])\n        elif input == 'mouse2-up':\n            self.fMouse2 = 0\n            messenger.send('DIRECT-mouse2Up')\n        elif input.find('mouse2') != -1:\n            self.fMouse2 = 1\n            modifiers = self.getModifiers(input, 'mouse2')\n            messenger.send('DIRECT-mouse2', sentArgs = [modifiers])\n        elif input == 'mouse3-up':\n            self.fMouse3 = 0\n            messenger.send('DIRECT-mouse3Up')\n        elif input.find('mouse3') != -1:\n            self.fMouse3 = 1\n            modifiers = self.getModifiers(input, 'mouse3')\n            messenger.send('DIRECT-mouse3', sentArgs = [modifiers])\n        elif input == 'shift':\n            self.fShift = 1\n        elif input == 'shift-up':\n            self.fShift = 0\n        elif input == 'control':\n            self.fControl = 1\n            # [gjeon] to update control key information while mouse1 is pressed\n            if self.fMouse1:\n                modifiers = DG.DIRECT_NO_MOD\n                modifiers |= DG.DIRECT_CONTROL_MOD\n                messenger.send('DIRECT-mouse1', sentArgs = [modifiers])\n        elif input == 'control-up':\n            self.fControl = 0\n        elif input == 'alt':\n            if self.fAlt:\n                return\n            self.fAlt = 1\n            # [gjeon] to update alt key information while mouse1 is pressed\n            if self.fMouse1:\n                modifiers = DG.DIRECT_NO_MOD\n                modifiers |= DG.DIRECT_ALT_MOD\n                messenger.send('DIRECT-mouse1', sentArgs = [modifiers])\n            elif self.fMouse2:\n                modifiers = DG.DIRECT_NO_MOD\n                modifiers |= DG.DIRECT_ALT_MOD\n                messenger.send('DIRECT-mouse2', sentArgs = [modifiers])\n            elif self.fMouse3:\n                modifiers = DG.DIRECT_NO_MOD\n                modifiers |= DG.DIRECT_ALT_MOD\n                messenger.send('DIRECT-mouse3', sentArgs = [modifiers])\n        elif input == 'alt-up':\n            self.fAlt = 0\n\n        #Pass along certain events if this display is a cluster client\n        if self.clusterMode == 'client':\n            if input in self.passThroughKeys:\n                self.cluster('messenger.send(\"%s\")' % input, 0)\n\n    def doSetActiveParent(self):\n        if self.selected.last:\n            self.setActiveParent(self.selected.last)\n\n    def doReparent(self):\n        if self.selected.last:\n            self.reparent(self.selected.last)\n\n    def doWrtReparent(self):\n        if self.selected.last:\n            self.reparent(self.selected.last, fWrt = 1)\n\n    def doSelect(self):\n        if self.selected.last:\n            self.select(self.selected.last)\n\n    def getModifiers(self, input, base):\n        modifiers = DG.DIRECT_NO_MOD\n        modifierString = input[: input.find(base)]\n        if modifierString.find('shift') != -1:\n            modifiers |= DG.DIRECT_SHIFT_MOD\n        if modifierString.find('control') != -1:\n            modifiers |= DG.DIRECT_CONTROL_MOD\n        if modifierString.find('alt') != -1:\n            modifiers |= DG.DIRECT_ALT_MOD\n        return modifiers\n\n    def gotShift(self, modifiers):\n        return modifiers & DG.DIRECT_SHIFT_MOD\n\n    def gotControl(self, modifiers):\n        return modifiers & DG.DIRECT_CONTROL_MOD\n\n    def gotAlt(self, modifiers):\n        return modifiers & DG.DIRECT_ALT_MOD\n\n    def setFScaleWidgetByCam(self, flag):\n        self.fScaleWidgetByCam = flag\n        if flag:\n            taskMgr.add(self.widgetResizeTask, 'DIRECTWidgetResize')\n        else:\n            taskMgr.remove('DIRECTWidgetResize')\n\n    def widgetResizeTask(self, state):\n        if not taskMgr.hasTaskNamed('resizeObjectHandles'):\n            dnp = self.selected.last\n            if dnp:\n                if self.manipulationControl.fMultiView:\n                    for i in range(3):\n                        sf = 30.0 * self.drList[i].orthoFactor\n                        self.manipulationControl.widgetList[i].setDirectScalingFactor(sf)\n\n                    nodeCamDist = Vec3(dnp.getPos(base.camList[3])).length()\n                    sf = 0.075 * nodeCamDist * math.tan(deg2Rad(self.drList[3].fovV))\n                    self.manipulationControl.widgetList[3].setDirectScalingFactor(sf)\n\n                else:\n                    nodeCamDist = Vec3(dnp.getPos(self.camera)).length()\n                    sf = 0.075 * nodeCamDist * math.tan(deg2Rad(self.drList.getCurrentDr().fovV))\n                    self.widget.setDirectScalingFactor(sf)\n        return Task.cont\n\n    def select(self, nodePath, fMultiSelect = 0,\n               fSelectTag = 1, fResetAncestry = 1, fLEPane=0, fUndo=1):\n        messenger.send('DIRECT-select', [nodePath, fMultiSelect, fSelectTag, fResetAncestry, fLEPane, fUndo])\n\n    def selectCB(self, nodePath, fMultiSelect = 0,\n               fSelectTag = 1, fResetAncestry = 1, fLEPane = 0, fUndo=1):\n        dnp = self.selected.select(nodePath, fMultiSelect, fSelectTag)\n        if dnp:\n            messenger.send('DIRECT_preSelectNodePath', [dnp])\n            if fResetAncestry:\n                # Update ancestry\n                self.ancestry = dnp.getAncestors()\n                self.ancestryIndex = 0\n            # Update the selectedNPReadout\n            self.selectedNPReadout.reparentTo(base.a2dBottomLeft)\n            self.selectedNPReadout.setText(\n                'Selected:' + dnp.getName())\n            # Show the manipulation widget\n            if self.manipulationControl.fMultiView:\n                for widget in self.manipulationControl.widgetList:\n                    widget.showWidget()\n            else:\n                self.widget.showWidget()\n            editTypes = self.manipulationControl.getEditTypes([dnp])\n            if (editTypes & DG.EDIT_TYPE_UNEDITABLE) == DG.EDIT_TYPE_UNEDITABLE:\n                self.manipulationControl.disableWidgetMove()\n            else:\n                self.manipulationControl.enableWidgetMove()\n            # Update camera controls coa to this point\n            # Coa2Camera = Coa2Dnp * Dnp2Camera\n            mCoa2Camera = dnp.mCoa2Dnp * dnp.getMat(self.camera)\n            row = mCoa2Camera.getRow(3)\n            coa = Vec3(row[0], row[1], row[2])\n            self.cameraControl.updateCoa(coa)\n            # Adjust widgets size\n            # This uses the additional scaling factor used to grow and\n            # shrink the widget\n            if not self.fScaleWidgetByCam: # [gjeon] for not scaling widget by distance from camera\n                if self.manipulationControl.fMultiView:\n                    for widget in self.manipulationControl.widgetList:\n                        widget.setScalingFactor(dnp.getRadius())\n                else:\n                    self.widget.setScalingFactor(dnp.getRadius())\n\n            # Spawn task to have object handles follow the selected object\n            taskMgr.remove('followSelectedNodePath')\n            t = Task.Task(self.followSelectedNodePathTask)\n            t.dnp = dnp\n            taskMgr.add(t, 'followSelectedNodePath')\n            # Send an message marking the event\n            messenger.send('DIRECT_selectedNodePath', [dnp])\n            messenger.send('DIRECT_selectedNodePath_fMulti_fTag', [dnp, fMultiSelect, fSelectTag])\n            messenger.send('DIRECT_selectedNodePath_fMulti_fTag_fLEPane', [dnp, fMultiSelect, fSelectTag, fLEPane])\n\n    def followSelectedNodePathTask(self, state):\n        mCoa2Render = state.dnp.mCoa2Dnp * state.dnp.getMat(base.render)\n        decomposeMatrix(mCoa2Render,\n                        self.scale, self.hpr, self.pos,\n                        CSDefault)\n        self.widget.setPosHpr(self.pos, self.hpr)\n        return Task.cont\n\n    def deselect(self, nodePath):\n        dnp = self.selected.deselect(nodePath)\n        if dnp:\n            # Hide the manipulation widget\n            if self.manipulationControl.fMultiView:\n                for widget in self.manipulationControl.widgetList:\n                    widget.hideWidget()\n            else:\n                self.widget.hideWidget()\n            self.selectedNPReadout.reparentTo(hidden)\n            self.selectedNPReadout.setText(' ')\n            taskMgr.remove('followSelectedNodePath')\n            self.ancestry = []\n            # Send an message marking the event\n            messenger.send('DIRECT_deselectedNodePath', [dnp])\n\n    def deselectAll(self):\n        messenger.send('DIRECT-preDeselectAll')\n\n    def deselectAllCB(self):\n        self.selected.deselectAll()\n        # Hide the manipulation widget\n        if self.manipulationControl.fMultiView:\n            for widget in self.manipulationControl.widgetList:\n                widget.hideWidget()\n        else:\n            self.widget.hideWidget()\n        self.selectedNPReadout.reparentTo(hidden)\n        self.selectedNPReadout.setText(' ')\n        taskMgr.remove('followSelectedNodePath')\n        messenger.send('DIRECT_deselectAll')\n\n    def setActiveParent(self, nodePath = None):\n        # Record new parent\n        self.activeParent = nodePath\n        # Update the activeParentReadout\n        self.activeParentReadout.reparentTo(base.a2dBottomLeft)\n        self.activeParentReadout.setText(\n            'Active Reparent Target:' + nodePath.getName())\n        # Alert everyone else\n        messenger.send('DIRECT_activeParent', [self.activeParent])\n\n    def reparent(self, nodePath = None, fWrt = 0):\n        if (nodePath and self.activeParent and\n            self.isNotCycle(nodePath, self.activeParent)):\n            oldParent = nodePath.getParent()\n            if fWrt:\n                nodePath.wrtReparentTo(self.activeParent)\n            else:\n                nodePath.reparentTo(self.activeParent)\n            # Alert everyone else\n            messenger.send('DIRECT_reparent',\n                           [nodePath, oldParent, self.activeParent])\n            # [gjeon] for others who needs fWrt information\n            messenger.send('DIRECT_reparent_fWrt',\n                           [nodePath, oldParent, self.activeParent, fWrt])\n\n    def isNotCycle(self, nodePath, parent):\n        if nodePath == parent:\n            print('DIRECT.reparent: Invalid parent')\n            return 0\n        elif parent.hasParent():\n            return self.isNotCycle(nodePath, parent.getParent())\n        else:\n            return 1\n\n    def flash(self, nodePath = 'None Given'):\n        \"\"\" Highlight an object by setting it red for a few seconds \"\"\"\n        # Clean up any existing task\n        taskMgr.remove('flashNodePath')\n        # Spawn new task if appropriate\n        if nodePath == 'None Given':\n            # If nothing specified, try selected node path\n            nodePath = self.selected.last\n        if nodePath:\n            if nodePath.hasColor():\n                doneColor = nodePath.getColor()\n                flashColor = VBase4(1) - doneColor\n                flashColor.setW(1)\n            else:\n                doneColor = None\n                flashColor = VBase4(1, 0, 0, 1)\n            # Temporarily set node path color\n            nodePath.setColor(flashColor)\n            # Clean up color in a few seconds\n            t = taskMgr.doMethodLater(DG.DIRECT_FLASH_DURATION,\n                                      # This is just a dummy task\n                                      self.flashDummy,\n                                      'flashNodePath',)\n            t.nodePath = nodePath\n            t.doneColor = doneColor\n            # This really does all the work\n            t.setUponDeath(self.flashDone)\n\n    def flashDummy(self, state):\n        # Real work is done in upon death function\n        return Task.done\n\n    def flashDone(self, state):\n        # Return node Path to original state\n        if state.nodePath.isEmpty():\n            # Node path doesn't exist anymore, bail\n            return\n        if state.doneColor:\n            state.nodePath.setColor(state.doneColor)\n        else:\n            state.nodePath.clearColor()\n\n    def fitOnNodePath(self, nodePath = 'None Given'):\n        if nodePath == 'None Given':\n            # If nothing specified, try selected node path\n            nodePath = self.selected.last\n        self.select(nodePath)\n\n        def fitTask(state, self = self):\n            self.cameraControl.fitOnWidget()\n            return Task.done\n        taskMgr.doMethodLater(0.1, fitTask, 'manipulateCamera')\n\n    def isolate(self, nodePath = 'None Given'):\n        \"\"\" Show a node path and hide its siblings \"\"\"\n        # First kill the flashing task to avoid complications\n        taskMgr.remove('flashNodePath')\n        # Use currently selected node path if node selected\n        if nodePath == 'None Given':\n            nodePath = self.selected.last\n        # Do we have a node path?\n        if nodePath:\n            # Yes, show everything in level\n            self.showAllDescendants(nodePath.getParent())\n            # Now hide all of this node path's siblings\n            for sib in nodePath.getParent().getChildren():\n                if sib.node() != nodePath.node():\n                    sib.hide()\n\n    def toggleVis(self, nodePath = 'None Given'):\n        \"\"\" Toggle visibility of node path \"\"\"\n        # First kill the flashing task to avoid complications\n        taskMgr.remove('flashNodePath')\n        if nodePath == 'None Given':\n            # If nothing specified, try selected node path\n            nodePath = self.selected.last\n        if nodePath:\n            # Now toggle node path's visibility state\n            if nodePath.isHidden():\n                nodePath.show()\n            else:\n                nodePath.hide()\n\n    def removeNodePath(self, nodePath = 'None Given'):\n        if nodePath == 'None Given':\n            # If nothing specified, try selected node path\n            nodePath = self.selected.last\n        if nodePath:\n            nodePath.removeNode()\n\n    def removeAllSelected(self):\n        self.selected.removeAll()\n\n    def showAllDescendants(self, nodePath = None):\n        \"\"\" Show the level and its descendants \"\"\"\n        if nodePath is None:\n            nodePath = base.render\n\n        if not isinstance(nodePath, CollisionNode):\n            nodePath.show()\n\n        for child in nodePath.getChildren():\n            self.showAllDescendants(child)\n\n    def upAncestry(self):\n        if self.ancestry:\n            l = len(self.ancestry)\n            i = self.ancestryIndex + 1\n            if i < l:\n                np = self.ancestry[i]\n                name = np.getName()\n                if (name != 'render') and (name != 'renderTop'):\n                    self.ancestryIndex = i\n                    self.select(np, 0, 0)\n                    self.flash(np)\n\n    def downAncestry(self):\n        if self.ancestry:\n            l = len(self.ancestry)\n            i = self.ancestryIndex - 1\n            if i >= 0:\n                np = self.ancestry[i]\n                name = np.getName()\n                if (name != 'render') and (name != 'renderTop'):\n                    self.ancestryIndex = i\n                    self.select(np, 0, 0)\n                    self.flash(np)\n\n    def getAndSetName(self, nodePath):\n        \"\"\" Prompt user for new node path name \"\"\"\n        from tkinter.simpledialog import askstring\n        newName = askstring('Node Path: ' + nodePath.getName(),\n                            'Enter new name:')\n        if newName:\n            nodePath.setName(newName)\n            messenger.send('DIRECT_nodePathSetName', [nodePath, newName])\n\n    # UNDO REDO FUNCTIONS\n    def pushUndo(self, nodePathList, fResetRedo = 1):\n        # Assemble group of changes\n        undoGroup = []\n        for nodePath in nodePathList:\n            t = nodePath.getTransform()\n            undoGroup.append([nodePath, t])\n        # Now record group\n        self.undoList.append(undoGroup)\n        # Truncate list\n        self.undoList = self.undoList[-25:]\n        # Alert anyone who cares\n        messenger.send('DIRECT_pushUndo')\n        if fResetRedo and (nodePathList != []):\n            self.redoList = []\n            messenger.send('DIRECT_redoListEmpty')\n\n    def popUndoGroup(self):\n        # Get last item\n        undoGroup = self.undoList[-1]\n        # Strip last item off of undo list\n        self.undoList = self.undoList[:-1]\n        # Update state of undo button\n        if not self.undoList:\n            messenger.send('DIRECT_undoListEmpty')\n        # Return last item\n        return undoGroup\n\n    def pushRedo(self, nodePathList):\n        # Assemble group of changes\n        redoGroup = []\n        for nodePath in nodePathList:\n            t = nodePath.getTransform()\n            redoGroup.append([nodePath, t])\n        # Now record redo group\n        self.redoList.append(redoGroup)\n        # Truncate list\n        self.redoList = self.redoList[-25:]\n        # Alert anyone who cares\n        messenger.send('DIRECT_pushRedo')\n\n    def popRedoGroup(self):\n        # Get last item\n        redoGroup = self.redoList[-1]\n        # Strip last item off of redo list\n        self.redoList = self.redoList[:-1]\n        # Update state of redo button\n        if not self.redoList:\n            messenger.send('DIRECT_redoListEmpty')\n        # Return last item\n        return redoGroup\n\n    def undo(self):\n        if self.undoList:\n            # Get last item off of redo list\n            undoGroup = self.popUndoGroup()\n            # Record redo information\n            nodePathList = [x[0] for x in undoGroup]\n            self.pushRedo(nodePathList)\n            # Now undo xform for group\n            for pose in undoGroup:\n                # Undo xform\n                pose[0].setTransform(pose[1])\n            # Alert anyone who cares\n            messenger.send('DIRECT_undo', [nodePathList])\n\n    def redo(self):\n        if self.redoList:\n            # Get last item off of redo list\n            redoGroup = self.popRedoGroup()\n            # Record undo information\n            nodePathList = [x[0] for x in redoGroup]\n            self.pushUndo(nodePathList, fResetRedo = 0)\n            # Redo xform\n            for pose in redoGroup:\n                pose[0].setTransform(pose[1])\n            # Alert anyone who cares\n            messenger.send('DIRECT_redo', [nodePathList])\n\n    # UTILITY FUNCTIONS\n    def message(self, text):\n        taskMgr.remove('hideDirectMessage')\n        taskMgr.remove('hideDirectMessageLater')\n        self.directMessageReadout.reparentTo(base.a2dTopLeft)\n        self.directMessageReadout.setText(text)\n        self.hideDirectMessageLater()\n\n    def hideDirectMessageLater(self):\n        taskMgr.doMethodLater(3.0, self.hideDirectMessage, 'hideDirectMessage')\n\n    def hideDirectMessage(self, state):\n        self.directMessageReadout.reparentTo(hidden)\n        return Task.done\n\n    def useObjectHandles(self):\n        self.widget = self.manipulationControl.objectHandles\n        self.widget.reparentTo(self.group)\n\n    def hideSelectedNPReadout(self):\n        self.selectedNPReadout.reparentTo(hidden)\n\n    def hideActiveParentReadout(self):\n        self.activeParentReadout.reparentTo(hidden)\n\n    def toggleWidgetVis(self):\n        self.widget.toggleWidget()\n\n    def setCOAMode(self, mode):\n        self.coaMode = mode\n\n    def isEnabled(self):\n        return self.fEnabled\n\n    def addUnpickable(self, item):\n        for iRay in self.iRayList:\n            iRay.addUnpickable(item)\n\n    def removeUnpickable(self, item):\n        for iRay in self.iRayList:\n            iRay.removeUnpickable(item)\n\n\nclass DisplayRegionContext(DirectObject):\n    regionCount = 0\n\n    def __init__(self, cam):\n        self.cam = cam\n        self.camNode = self.cam.node()\n        self.camLens = self.camNode.getLens()\n        # set lens change callback\n        changeEvent = 'dr%d-change-event' % DisplayRegionContext.regionCount\n        DisplayRegionContext.regionCount += 1\n        self.camLens.setChangeEvent(changeEvent)\n        self.accept(changeEvent, self.camUpdate)\n        self.iRay = SelectionRay(self.cam)\n        self.nearVec = Vec3(0)\n        self.mouseX = 0.0\n        self.mouseY = 0.0\n\n        self.orthoFactor = 0.1\n        # A Camera node can have more than one display region\n        # associated with it.  Here I assume that there is only\n        # one display region per camera, since we are defining a\n        # display region on a per-camera basis.  See note in\n        # DisplayRegionList.__init__()\n        self.dr = self.camNode.getDisplayRegion(0)\n        left = self.dr.getLeft()\n        right = self.dr.getRight()\n        bottom = self.dr.getBottom()\n        top = self.dr.getTop()\n        self.originX = left+right-1\n        self.originY = top+bottom-1\n        self.scaleX = 1.0/(right-left)\n        self.scaleY = 1.0/(top-bottom)\n        self.setOrientation()\n        self.camUpdate()\n\n    def __getitem__(self, key):\n        return self.__dict__[key]\n\n    def setOrientation(self):\n        # MRM This assumes orientation is set on transform above cam\n        hpr = self.cam.getHpr()\n        if hpr[2] < 135 and hpr[2]>45 or hpr[2]>225 and hpr[2]<315:\n            self.isSideways = 1\n        elif hpr[2] > -135 and hpr[2] < -45 or hpr[2] < -225 and hpr[2] > -315:\n            self.isSideways = 1\n        else:\n            self.isSideways = 0\n\n    # The following take into consideration sideways displays\n    def getHfov(self):\n        if self.isSideways:\n            return self.camLens.getVfov()\n        else:\n            return self.camLens.getHfov()\n\n    def getVfov(self):\n        if self.isSideways:\n            return self.camLens.getHfov()\n        else:\n            return self.camLens.getVfov()\n\n    def setHfov(self, hfov):\n        if self.isSideways:\n            self.camLens.setFov(self.camLens.getHfov(), hfov)\n        else:\n            self.camLens.setFov(hfov, self.camLens.getVfov())\n\n    def setVfov(self, vfov):\n        if self.isSideways:\n            self.camLens.setFov(vfov, self.camLens.getVfov())\n        else:\n            self.camLens.setFov(self.camLens.getHfov(), vfov)\n\n    def setFov(self, hfov, vfov):\n        if self.isSideways:\n            self.camLens.setFov(vfov, hfov)\n        else:\n            self.camLens.setFov(hfov, vfov)\n\n    def getWidth(self):\n        prop = ShowBaseGlobal.direct.win.getProperties()\n        if prop.hasSize():\n            return prop.getXSize()\n        else:\n            return 640\n\n    def getHeight(self):\n        prop = ShowBaseGlobal.direct.win.getProperties()\n        if prop.hasSize():\n            return prop.getYSize()\n        else:\n            return 480\n\n    def updateFilmSize(self, width, height):\n        if self.camLens.__class__.__name__ == \"OrthographicLens\":\n            width *= self.orthoFactor\n            height *= self.orthoFactor\n\n        self.camLens.setFilmSize(width, height)\n\n    def camUpdate(self, lens = None):\n        # Window Data\n        self.near = self.camLens.getNear()\n        self.far = self.camLens.getFar()\n        self.fovH = self.camLens.getHfov()\n        self.fovV = self.camLens.getVfov()\n        self.nearWidth = math.tan(deg2Rad(self.fovH * 0.5)) * self.near * 2.0\n        self.nearHeight = math.tan(deg2Rad(self.fovV * 0.5)) * self.near * 2.0\n        self.left = -self.nearWidth * 0.5\n        self.right = self.nearWidth * 0.5\n        self.top = self.nearHeight * 0.5\n        self.bottom = -self.nearHeight * 0.5\n\n    def mouseUpdate(self):\n        # Mouse Data\n        # Last frame\n        self.mouseLastX = self.mouseX\n        self.mouseLastY = self.mouseY\n\n        # Values for this frame\n        # This ranges from -1 to 1\n        mouseWatcherNode = base.mouseWatcherNode\n        if mouseWatcherNode and mouseWatcherNode.hasMouse():\n            self.mouseX = mouseWatcherNode.getMouseX()\n            self.mouseY = mouseWatcherNode.getMouseY()\n            self.mouseX = (self.mouseX-self.originX)*self.scaleX\n            self.mouseY = (self.mouseY-self.originY)*self.scaleY\n        # Delta percent of window the mouse moved\n        self.mouseDeltaX = self.mouseX - self.mouseLastX\n        self.mouseDeltaY = self.mouseY - self.mouseLastY\n        self.nearVec.set((self.nearWidth*0.5) * self.mouseX,\n                         self.near,\n                         (self.nearHeight*0.5) * self.mouseY)\n\n\nclass DisplayRegionList(DirectObject):\n    def __init__(self):\n        self.displayRegionList = []\n        i = 0\n        # Things are funky if we are oobe\n        if getattr(base, 'oobeMode', False):\n            # assume we only have one cam at this point\n            drc = DisplayRegionContext(base.cam)\n            self.displayRegionList.append(drc)\n        else:\n            # MRM: Doesn't properly handle multiple camera groups anymore\n            # Assumes everything is under main camera\n\n            # This is following the old way of setting up\n            # display regions.  A display region is set up for\n            # each camera node in the scene graph.  This was done\n            # so that only display regions in the scene graph are\n            # considered.  The right way to do this is to set up\n            # a display region for each real display region, and then\n            # keep track of which are currently active (e.g. use a flag)\n            # processing only them.\n            for camIndex, cam in enumerate(base.camList):\n                if cam.name == '<noname>':\n                    cam.name = f'Camera{camIndex}'\n                drc = DisplayRegionContext(cam)\n                self.displayRegionList.append(drc)\n\n        self.accept(\"DIRECT-mouse1\", self.mouseUpdate)\n        self.accept(\"DIRECT-mouse2\", self.mouseUpdate)\n        self.accept(\"DIRECT-mouse3\", self.mouseUpdate)\n        self.accept(\"DIRECT-mouse1Up\", self.mouseUpdate)\n        self.accept(\"DIRECT-mouse2Up\", self.mouseUpdate)\n        self.accept(\"DIRECT-mouse3Up\", self.mouseUpdate)\n        self.tryToGetCurrentDr = True\n\n    def __getitem__(self, index):\n        return self.displayRegionList[index]\n\n    def __len__(self):\n        return len(self.displayRegionList)\n\n    def __iter__(self):\n        return iter(self.displayRegionList)\n\n    def updateContext(self):\n        self.contextTask(None)\n\n    def setNearFar(self, near, far):\n        for dr in self.displayRegionList:\n            dr.camLens.setNearFar(near, far)\n\n    def setNear(self, near):\n        for dr in self.displayRegionList:\n            dr.camLens.setNear(near)\n\n    def setFar(self, far):\n        for dr in self.displayRegionList:\n            dr.camLens.setFar(far)\n\n    def setFov(self, hfov, vfov):\n        for dr in self.displayRegionList:\n            dr.setFov(hfov, vfov)\n\n    def setHfov(self, fov):\n        for dr in self.displayRegionList:\n            dr.setHfov(fov)\n\n    def setVfov(self, fov):\n        for dr in self.displayRegionList:\n            dr.setVfov(fov)\n\n    def mouseUpdate(self, modifiers = DG.DIRECT_NO_MOD):\n        for dr in self.displayRegionList:\n            dr.mouseUpdate()\n        #base.direct.dr = self.getCurrentDr()\n\n    def getCurrentDr(self):\n        if not self.tryToGetCurrentDr:\n            return ShowBaseGlobal.direct.dr\n        for dr in self.displayRegionList:\n            if (dr.mouseX >= -1.0 and dr.mouseX <= 1.0 and\n                dr.mouseY >= -1.0 and dr.mouseY <= 1.0):\n                return dr\n        return self.displayRegionList[0]\n\n    def start(self):\n        # First shutdown any existing task\n        self.stop()\n        # Start a new context task\n        self.spawnContextTask()\n\n    def stop(self):\n        # Kill the existing context task\n        taskMgr.remove('DIRECTContextTask')\n\n    def spawnContextTask(self):\n        taskMgr.add(self.contextTask, 'DIRECTContextTask')\n\n    def removeContextTask(self):\n        taskMgr.remove('DIRECTContextTask')\n\n    def contextTask(self, state):\n        # Window Data\n        self.mouseUpdate()\n        # hack to test movement\n        return Task.cont\n\n    def addDisplayRegionContext(self, cam):\n        self.displayRegionList.append(DisplayRegionContext(cam))\n\n    def removeDisplayRegionContext(self, cam):\n        for drc in self.displayRegionList:\n            if drc.cam == cam:\n                self.displayRegionList.remove(drc)\n                break\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/directtools/DirectSession.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/4b554dbd_DirectSession.json",
    "doc_id": "doc_185"
  }
}