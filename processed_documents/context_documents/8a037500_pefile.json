{
  "content": "\"\"\" Tools for manipulating Portable Executable files.\n\nThis can be used, for example, to extract a list of dependencies from an .exe\nor .dll file, or to add version information and an icon resource to it. \"\"\"\n\n__all__ = [\"PEFile\"]\n\nfrom struct import Struct, unpack, pack, pack_into\nfrom collections import namedtuple\nfrom array import array\nimport time\nfrom io import BytesIO\n\n\n# Define some internally used structures.\nRVASize = namedtuple('RVASize', ('addr', 'size'))\nimpdirtab = namedtuple('impdirtab', ('lookup', 'timdat', 'forward', 'name', 'impaddr'))\nexpdirtab = namedtuple('expdirtab', ('flags', 'timdat', 'majver', 'minver', 'name', 'ordinal_base', 'nentries', 'nnames', 'entries', 'names', 'ordinals'))\n\n\ndef _unpack_zstring(mem, offs=0):\n    \"Read a zero-terminated string from memory.\"\n    c = mem[offs]\n    str = \"\"\n    while c:\n        str += chr(c)\n        offs += 1\n        c = mem[offs]\n    return str\n\n\ndef _unpack_wstring(mem, offs=0):\n    \"Read a UCS-2 string from memory.\"\n    name_len, = unpack('<H', mem[offs:offs+2])\n    name = \"\"\n    for i in range(name_len):\n        offs += 2\n        name += chr(*unpack('<H', mem[offs:offs+2]))\n    return name\n\n\ndef _padded(n, boundary):\n    align = n % boundary\n    if align:\n        n += boundary - align\n    return n\n\n\nclass Section(object):\n    _header = Struct('<8sIIIIIIHHI')\n\n    modified = True\n\n    def read_header(self, fp):\n        name, vsize, vaddr, size, scnptr, relptr, lnnoptr, nreloc, nlnno, flags = \\\n            self._header.unpack(fp.read(40))\n\n        self.name = name.rstrip(b'\\x00')\n        self.vaddr = vaddr # Base virtual address to map to.\n        self.vsize = vsize\n        self.offset = scnptr # Offset of the section in the file.\n        self.size = size\n        self.flags = flags\n\n        self.modified = False\n\n    def write_header(self, fp):\n        fp.write(self._header.pack(self.name, self.vsize, self.vaddr,\n                                   self.size, self.offset, 0, 0, 0, 0,\n                                   self.flags))\n\n    def __repr__(self):\n        return \"<section '%s' memory %x-%x>\" % (self.name, self.vaddr, self.vaddr + self.vsize)\n\n    def __gt__(self, other):\n        return self.vaddr > other.vaddr\n\n    def __lt__(self, other):\n        return self.vaddr < other.vaddr\n\n\nclass DataResource(object):\n    \"\"\" A resource entry in the resource table. \"\"\"\n\n    # Resource types.\n    cursor = 1\n    bitmap = 2\n    icon = 3\n    menu = 4\n    dialog = 5\n    string = 6\n    font_directory = 7\n    font = 8\n    accelerator = 9\n    rcdata = 10\n    message_table = 11\n    cursor_group = 12\n    icon_group = 14\n    version = 16\n    dlg_include = 17\n    plug_play = 19\n    vxd = 20\n    animated_cursor = 21\n    animated_icon = 22\n    html = 23\n    manifest = 24\n\n    def __init__(self):\n        self._ident = ()\n        self.data = None\n        self.code_page = 0\n\n    @property\n    def encoding(self):\n        if self.code_page == 0:\n            return 'ascii'\n        else:\n            return 'cp%d' % (self.code_page)\n\n    def get_data(self):\n        return self.data\n\n    def get_text(self, errors='strict'):\n        return self.data.decode(self.encoding, errors)\n\n\nclass IconGroupResource(object):\n    code_page = 0\n    type = 14\n    _entry = Struct('<BBBxHHIH')\n    Icon = namedtuple('Icon', ('width', 'height', 'planes', 'bpp', 'size', 'id'))\n\n    def __init__(self):\n        self.icons = []\n\n    def add_icon(self, *args, **kwargs):\n        self.icons.append(self.Icon(*args, **kwargs))\n\n    def get_data(self):\n        data = bytearray(pack('<HHH', 0, 1, len(self.icons)))\n\n        for width, height, planes, bpp, size, id in self.icons:\n            colors = 1 << (planes * bpp)\n            if colors >= 256:\n                colors = 0\n            if width >= 256:\n                width = 0\n            if height >= 256:\n                height = 0\n            data += self._entry.pack(width, height, colors, planes, bpp, size, id)\n        return data\n\n    def unpack_from(self, data, offs=0):\n        type, count = unpack('<HH', data[offs+2:offs+6])\n        offs += 6\n        for i in range(count):\n            width, height, colors, planes, bpp, size, id = \\\n                self._entry.unpack(data[offs:offs+14])\n            if width == 0:\n                width = 256\n            if height == 0:\n                height = 256\n            self.icons.append(self.Icon(width, height, planes, bpp, size, id))\n            offs += 14\n\n\nclass VersionInfoResource(object):\n    code_page = 0\n    type = 16\n\n    def __init__(self):\n        self.string_info = {}\n        self.var_info = {}\n        self.signature = 0xFEEF04BD\n        self.struct_version = 0x10000\n        self.file_version = (0, 0, 0, 0)\n        self.product_version = (0, 0, 0, 0)\n        self.file_flags_mask = 0x3f\n        self.file_flags = 0\n        self.file_os = 0x40004 # Windows NT\n        self.file_type = 1 # Application\n        self.file_subtype = 0\n        self.file_date = (0, 0)\n\n    def get_data(self):\n        # The first part of the header is pretty much fixed - we'll go\n        # back later to write the struct size.\n        data = bytearray(b'\\x00\\x004\\x00\\x00\\x00V\\x00S\\x00_\\x00V\\x00E\\x00R\\x00S\\x00I\\x00O\\x00N\\x00_\\x00I\\x00N\\x00F\\x00O\\x00\\x00\\x00\\x00\\x00')\n        data += pack('<13I', self.signature, self.struct_version,\n                             self.file_version[1] | (self.file_version[0] << 16),\n                             self.file_version[3] | (self.file_version[2] << 16),\n                             self.product_version[1] | (self.product_version[0] << 16),\n                             self.product_version[3] | (self.product_version[2] << 16),\n                             self.file_flags_mask, self.file_flags,\n                             self.file_os, self.file_type, self.file_subtype,\n                             self.file_date[0], self.file_date[1])\n\n        self._pack_info(data, 'StringFileInfo', self.string_info)\n        self._pack_info(data, 'VarFileInfo', self.var_info)\n        data[0:2] = pack('<H', len(data))\n        return data\n\n    def _pack_info(self, data, key, value):\n        offset = len(data)\n\n        if isinstance(value, dict):\n            type = 1\n            value_length = 0\n        elif isinstance(value, bytes) or isinstance(value, str):\n            type = 1\n            value_length = len(value) * 2 + 2\n        else:\n            type = 0\n            value_length = len(value)\n\n        data += pack('<HHH', 0, value_length, type)\n\n        for c in key:\n            data += pack('<H', ord(c))\n        data += b'\\x00\\x00'\n        if len(data) & 2:\n            data += b'\\x00\\x00'\n        assert len(data) & 3 == 0\n\n        if isinstance(value, dict):\n            for key2, value2 in sorted(value.items(), key=lambda x:x[0]):\n                self._pack_info(data, key2, value2)\n        elif isinstance(value, bytes) or isinstance(value, str):\n            for c in value:\n                data += pack('<H', ord(c))\n            data += b'\\x00\\x00'\n        else:\n            data += value\n            if len(data) & 1:\n                data += b'\\x00'\n\n        if len(data) & 2:\n            data += b'\\x00\\x00'\n        assert len(data) & 3 == 0\n\n        data[offset:offset+2] = pack('<H', len(data) - offset)\n\n    def unpack_from(self, data):\n        length, value_length = unpack('<HH', data[0:4])\n        offset = 40 + value_length + (value_length & 1)\n        dwords = array('I')\n        dwords.frombytes(bytes(data[40:offset]))\n\n        if len(dwords) > 0:\n            self.signature = dwords[0]\n        if len(dwords) > 1:\n            self.struct_version = dwords[1]\n        if len(dwords) > 3:\n            self.file_version = \\\n                (int(dwords[2] >> 16), int(dwords[2] & 0xffff),\n                int(dwords[3] >> 16), int(dwords[3] & 0xffff))\n        if len(dwords) > 5:\n            self.product_version = \\\n                (int(dwords[4] >> 16), int(dwords[4] & 0xffff),\n                int(dwords[5] >> 16), int(dwords[5] & 0xffff))\n        if len(dwords) > 7:\n            self.file_flags_mask = dwords[6]\n            self.file_flags = dwords[7]\n        if len(dwords) > 8:\n            self.file_os = dwords[8]\n        if len(dwords) > 9:\n            self.file_type = dwords[9]\n        if len(dwords) > 10:\n            self.file_subtype = dwords[10]\n        if len(dwords) > 12:\n            self.file_date = (dwords[11], dwords[12])\n\n        while offset < length:\n            offset += self._unpack_info(self, data, offset)\n\n    def __getitem__(self, key):\n        if key == 'StringFileInfo':\n            return self.string_info\n        elif key == 'VarFileInfo':\n            return self.var_info\n        else:\n            raise KeyError(\"%s does not exist\" % (key))\n\n    def __contains__(self, key):\n        return key in ('StringFileInfo', 'VarFileInfo')\n\n    def _unpack_info(self, dict, data, offset):\n        length, value_length, type = unpack('<HHH', data[offset:offset+6])\n        assert length > 0\n        end = offset + length\n        offset += 6\n        key = \"\"\n        c, = unpack('<H', data[offset:offset+2])\n        offset += 2\n        while c:\n            key += chr(c)\n            c, = unpack('<H', data[offset:offset+2])\n            offset += 2\n\n        # Padding bytes to align value to 32-bit boundary.\n        offset = _padded(offset, 4)\n\n        if value_length > 0:\n            # It contains a value.\n            if type:\n                # It's a wchar array value.\n                value = \"\"\n                c, = unpack('<H', data[offset:offset+2])\n                offset += 2\n                while c:\n                    value += chr(c)\n                    c, = unpack('<H', data[offset:offset+2])\n                    offset += 2\n            else:\n                # A binary value.\n                value = bytes(data[offset:offset+value_length])\n                offset += value_length\n            dict[key] = value\n        else:\n            # It contains sub-entries.\n            if key not in dict:\n                dict[key] = {}\n            subdict = dict[key]\n            while offset < end:\n                offset += self._unpack_info(subdict, data, offset)\n\n        # Padding bytes to pad value to 32-bit boundary.\n        return _padded(length, 4)\n\n\nclass ResourceTable(object):\n    \"\"\" A table in the resource directory. \"\"\"\n\n    _header = Struct('<IIHHHH')\n\n    def __init__(self, ident=()):\n        self.flags = 0\n        self.timdat = 0\n        self.version = (0, 0)\n        self._name_leaves = []\n        self._id_leaves = []\n        self._ident = ident\n        self._strings_size = 0 # Amount of space occupied by table keys.\n        self._descs_size = 0\n\n    def __getitem__(self, key):\n        if isinstance(key, int):\n            leaves = self._id_leaves\n        else:\n            leaves = self._name_leaves\n\n        i = 0\n        while i < len(leaves):\n            idname, leaf = leaves[i]\n            if idname >= key:\n                if key == idname:\n                    return leaf\n                break\n            i += 1\n        if not isinstance(key, int):\n            self._strings_size += _padded(len(key) * 2 + 2, 4)\n        leaf = ResourceTable(ident=self._ident + (key,))\n        leaves.insert(i, (key, leaf))\n        return leaf\n\n    def __setitem__(self, key, value):\n        \"\"\" Adds the given item to the table.  Maintains sort order. \"\"\"\n        if isinstance(key, int):\n            leaves = self._id_leaves\n        else:\n            leaves = self._name_leaves\n\n        if not isinstance(value, ResourceTable):\n            self._descs_size += 16\n\n        value._ident = self._ident + (key,)\n        i = 0\n        while i < len(leaves):\n            idname, leaf = leaves[i]\n            if idname >= key:\n                if key == idname:\n                    if not isinstance(leaves[i][1], ResourceTable):\n                        self._descs_size -= 16\n                    leaves[i] = (key, value)\n                    return\n                break\n            i += 1\n        if not isinstance(key, int):\n            self._strings_size += _padded(len(key) * 2 + 2, 4)\n        leaves.insert(i, (key, value))\n\n    def __len__(self):\n        return len(self._name_leaves) + len(self._id_leaves)\n\n    def __iter__(self):\n        keys = []\n        for name, leaf in self._name_leaves:\n            keys.append(name)\n        for id, leaf in self._id_leaves:\n            keys.append(id)\n        return iter(keys)\n\n    def items(self):\n        return self._name_leaves + self._id_leaves\n\n    def count_resources(self):\n        \"\"\"Counts all of the resources.\"\"\"\n        count = 0\n        for key, leaf in self._name_leaves + self._id_leaves:\n            if isinstance(leaf, ResourceTable):\n                count += leaf.count_resources()\n            else:\n                count += 1\n        return count\n\n    def get_nested_tables(self):\n        \"\"\"Returns all tables in this table and subtables.\"\"\"\n        # First we yield child tables, then nested tables.  This is the\n        # order in which pack_into assumes the tables will be written.\n        for key, leaf in self._name_leaves + self._id_leaves:\n            if isinstance(leaf, ResourceTable):\n                yield leaf\n\n        for key, leaf in self._name_leaves + self._id_leaves:\n            if isinstance(leaf, ResourceTable):\n                for table in leaf.get_nested_tables():\n                    yield table\n\n    def pack_header(self, data, offs):\n        self._header.pack_into(data, offs, self.flags, self.timdat,\n                               self.version[0], self.version[1],\n                               len(self._name_leaves), len(self._id_leaves))\n\n    def unpack_from(self, mem, addr=0, offs=0):\n        start = addr + offs\n        self.flags, self.timdat, majver, minver, nnames, nids = \\\n            self._header.unpack(mem[start:start+16])\n        self.version = (majver, minver)\n        start += 16\n\n        # Subtables/entries specified by string name.\n        self._name_leaves = []\n        for i in range(nnames):\n            name_p, data = unpack('<II', mem[start:start+8])\n            if name_p & 0x80000000:\n                name = _unpack_wstring(mem, addr + (name_p & 0x7fffffff))\n            else:\n                # Not sure what to do with this; I don't have a file with this.\n                name = str(name_p)\n\n            if data & 0x80000000:\n                entry = ResourceTable(self._ident + (name,))\n                entry.unpack_from(mem, addr, data & 0x7fffffff)\n            else:\n                entry = self._unpack_data_entry(mem, addr + data, ident=self._ident+(name,))\n                self._descs_size += 16\n            self._name_leaves.append((name, entry))\n            self._strings_size += _padded(len(name) * 2 + 2, 4)\n            start += 8\n\n        # Subtables/entries specified by integer ID.\n        self._id_leaves = []\n        for i in range(nids):\n            id, data = unpack('<II', mem[start:start+8])\n            if data & 0x80000000:\n                entry = ResourceTable(self._ident + (id,))\n                entry.unpack_from(mem, addr, data & 0x7fffffff)\n            else:\n                entry = self._unpack_data_entry(mem, addr + data, ident=self._ident+(id,))\n                self._descs_size += 16\n            self._id_leaves.append((id, entry))\n            start += 8\n\n    def _unpack_data_entry(self, mem, addr, ident):\n        rva, size, code_page = unpack('<III', mem[addr:addr+12])\n        type, name, lang = ident\n        #print(\"%s/%s/%s: %s [%s]\" % (type, name, lang, size, code_page))\n\n        data = mem[rva:rva+size]\n\n        if type == VersionInfoResource.type:\n            entry = VersionInfoResource()\n            entry.unpack_from(data)\n        elif type == IconGroupResource.type:\n            entry = IconGroupResource()\n            entry.unpack_from(data)\n        else:\n            entry = DataResource()\n            entry.data = data\n            entry.code_page = code_page\n\n        return entry\n\n\nclass PEFile(object):\n\n    imports = ()\n\n    def open(self, fn, mode='r'):\n        if 'b' not in mode:\n            mode += 'b'\n        self.fp = open(fn, mode)\n        self.read(self.fp)\n\n    def close(self):\n        self.fp.close()\n\n    def read(self, fp):\n        \"\"\" Reads a PE file from the given file object, which must be opened\n        in binary mode. \"\"\"\n\n        # Read position of header.\n        fp.seek(0x3c)\n        offset, = unpack('<I', fp.read(4))\n\n        fp.seek(offset)\n        if fp.read(4) != b'PE\\0\\0':\n            raise ValueError(\"Invalid PE file.\")\n\n        # Read the COFF header.\n        self.machine, nscns, timdat, symptr, nsyms, opthdr, flags = \\\n            unpack('<HHIIIHH', fp.read(20))\n\n        if nscns == 0:\n            raise ValueError(\"No sections found.\")\n\n        if not opthdr:\n            raise ValueError(\"No opthdr found.\")\n\n        # Read part of the opthdr.\n        magic, self.code_size, self.initialized_size, self.uninitialized_size = \\\n            unpack('<HxxIII', fp.read(16))\n\n        # Read alignments.\n        fp.seek(16, 1)\n        self.section_alignment, self.file_alignment = unpack('<II', fp.read(8))\n\n        # Read header/image sizes.\n        fp.seek(16, 1)\n        self.image_size, self.header_size = unpack('<II', fp.read(8))\n\n        if magic == 0x010b: # 32-bit.\n            fp.seek(28, 1)\n        elif magic == 0x20B: # 64-bit.\n            fp.seek(44, 1)\n        else:\n            raise ValueError(\"unknown type 0x%x\" % (magic))\n\n        self.rva_offset = fp.tell()\n        numrvas, = unpack('<I', fp.read(4))\n\n        self.exp_rva = RVASize(0, 0)\n        self.imp_rva = RVASize(0, 0)\n        self.res_rva = RVASize(0, 0)\n\n        # Locate the relevant tables in memory.\n        if numrvas >= 1:\n            self.exp_rva = RVASize(*unpack('<II', fp.read(8)))\n        if numrvas >= 2:\n            self.imp_rva = RVASize(*unpack('<II', fp.read(8)))\n        if numrvas >= 3:\n            self.res_rva = RVASize(*unpack('<II', fp.read(8)))\n\n        # Skip the rest of the tables.\n        if numrvas >= 4:\n            fp.seek((numrvas - 3) * 8, 1)\n\n        # Loop through the sections to find the ones containing our tables.\n        self.sections = []\n        for i in range(nscns):\n            section = Section()\n            section.read_header(fp)\n            self.sections.append(section)\n\n        self.sections.sort()\n\n        # Read the sections into some kind of virtual memory.\n        self.vmem = bytearray(self.sections[-1].vaddr + self.sections[-1].size)\n        memview = memoryview(self.vmem)\n\n        for section in self.sections:\n            fp.seek(section.offset)\n            fp.readinto(memview[section.vaddr:section.vaddr+section.size])\n\n        # Read the import table.\n        start = self.imp_rva.addr\n        dir = impdirtab(*unpack('<IIIII', self.vmem[start:start+20]))\n\n        imports = []\n        while dir.name and dir.lookup:\n            name = _unpack_zstring(self.vmem, dir.name)\n            imports.append(name)\n\n            start += 20\n            dir = impdirtab(*unpack('<IIIII', self.vmem[start:start+20]))\n\n        # Make it a tuple to indicate we don't support modifying it for now.\n        self.imports = tuple(imports)\n\n        # Read the resource tables from the .rsrc section.\n        self.resources = ResourceTable()\n        if self.res_rva.addr and self.res_rva.size:\n            self.resources.unpack_from(self.vmem, self.res_rva.addr)\n\n    def _mark_address_modified(self, rva):\n        for section in self.sections:\n            if rva >= section.vaddr and rva - section.vaddr <= section.size:\n                section.modified = True\n\n    def rename_export(self, old_name, new_name):\n        \"\"\" Renames a symbol in the export table. \"\"\"\n\n        assert len(new_name) <= len(old_name)\n\n        new_name = new_name.ljust(len(old_name) + 1, '\\0').encode('ascii')\n\n        start = self.exp_rva.addr\n        expdir = expdirtab(*unpack('<IIHHIIIIIII', self.vmem[start:start+40]))\n        if expdir.nnames == 0 or expdir.ordinals == 0 or expdir.names == 0:\n            return False\n\n        nptr = expdir.names\n        for i in range(expdir.nnames):\n            name_rva, = unpack('<I', self.vmem[nptr:nptr+4])\n            if name_rva != 0:\n                name = _unpack_zstring(self.vmem, name_rva)\n                if name == old_name:\n                    self.vmem[name_rva:name_rva+len(new_name)] = new_name\n                    self._mark_address_modified(name_rva)\n                    return True\n            nptr += 4\n\n        return False\n\n    def get_export_address(self, symbol_name):\n        \"\"\" Finds the virtual address for a named export symbol. \"\"\"\n\n        if isinstance(symbol_name, bytes):\n            symbol_name = symbol_name.decode('ascii')\n\n        start = self.exp_rva.addr\n        expdir = expdirtab(*unpack('<IIHHIIIIIII', self.vmem[start:start+40]))\n        if expdir.nnames == 0 or expdir.ordinals == 0 or expdir.names == 0:\n            return None\n\n        nptr = expdir.names\n        optr = expdir.ordinals\n        for i in range(expdir.nnames):\n            name_rva, = unpack('<I', self.vmem[nptr:nptr+4])\n            ordinal, = unpack('<H', self.vmem[optr:optr+2])\n            if name_rva != 0:\n                name = _unpack_zstring(self.vmem, name_rva)\n                if name == symbol_name:\n                    assert ordinal >= 0 and ordinal < expdir.nentries\n                    start = expdir.entries + 4 * ordinal\n                    addr, = unpack('<I', self.vmem[start:start+4])\n                    return addr\n            nptr += 4\n            optr += 2\n\n    def get_address_offset(self, addr):\n        \"\"\" Turns an address into a offset relative to the file beginning. \"\"\"\n\n        section = self.get_address_section(addr)\n        if section is not None:\n            return (addr - section.vaddr) + section.offset\n\n    def get_address_section(self, addr):\n        \"\"\" Returns the section that this virtual address belongs to. \"\"\"\n\n        for section in self.sections:\n            if addr >= section.vaddr and addr < section.vaddr + section.size:\n                return section\n\n    def add_icon(self, icon, ordinal=2):\n        \"\"\" Adds an icon resource from the given Icon object.  Requires\n        calling add_resource_section() afterwards. \"\"\"\n\n        group = IconGroupResource()\n        self.resources[group.type][ordinal][1033] = group\n\n        images = sorted(icon.images.items(), key=lambda x:-x[0])\n        id = 1\n\n        # Write 8-bpp image headers for sizes under 256x256.\n        for size, image in images:\n            if size >= 256:\n                continue\n\n            xorsize = size\n            if xorsize % 4 != 0:\n                xorsize += 4 - (xorsize % 4)\n            andsize = (size + 7) >> 3\n            if andsize % 4 != 0:\n                andsize += 4 - (andsize % 4)\n            datasize = 40 + 256 * 4 + (xorsize + andsize) * size\n            group.add_icon(size, size, 1, 8, datasize, id)\n\n            buf = BytesIO()\n            icon._write_bitmap(buf, image, size, 8)\n\n            res = DataResource()\n            res.data = buf.getvalue()\n            self.resources[3][id][1033] = res\n            id += 1\n\n        # And now the 24/32 bpp versions.\n        for size, image in images:\n            if size > 256:\n                continue\n\n            # Calculate the size so we can write the offset within the file.\n            if image.hasAlpha():\n                bpp = 32\n                xorsize = size * 4\n            else:\n                bpp = 24\n                xorsize = size * 3 + (-(size * 3) & 3)\n            andsize = (size + 7) >> 3\n            if andsize % 4 != 0:\n                andsize += 4 - (andsize % 4)\n            datasize = 40 + (xorsize + andsize) * size\n\n            buf = BytesIO()\n            icon._write_bitmap(buf, image, size, bpp)\n\n            res = DataResource()\n            res.data = buf.getvalue()\n            self.resources[3][id][1033] = res\n            group.add_icon(size, size, 1, bpp, datasize, id)\n            id += 1\n\n    def add_section(self, name, flags, data):\n        \"\"\" Adds a new section with the given name, flags and data.  The\n        virtual address space is automatically resized to fit the new data.\n\n        Returns the newly created Section object. \"\"\"\n\n        if isinstance(name, str):\n            name = name.encode('ascii')\n\n        section = Section()\n        section.name = name\n        section.flags = flags\n\n        # Put it at the end of all the other sections.\n        section.offset = 0\n        for s in self.sections:\n            section.offset = max(section.offset, s.offset + s.size)\n\n        # Align the offset.\n        section.offset = _padded(section.offset, self.file_alignment)\n\n        # Find a place to put it in the virtual address space.\n        section.vaddr = len(self.vmem)\n        align = section.vaddr % self.section_alignment\n        if align:\n            pad = self.section_alignment - align\n            self.vmem += bytearray(pad)\n            section.vaddr += pad\n\n        section.vsize = len(data)\n        section.size = _padded(section.vsize, self.file_alignment)\n        self.vmem += data\n        self.sections.append(section)\n\n        # Update the size tallies from the opthdr.\n        self.image_size += _padded(section.vsize, self.section_alignment)\n        if flags & 0x20:\n            self.code_size += section.size\n        if flags & 0x40:\n            self.initialized_size += section.size\n        if flags & 0x80:\n            self.uninitialized_size += section.size\n\n        return section\n\n    def add_version_info(self, file_ver, product_ver, data, lang=1033, codepage=1200):\n        \"\"\" Adds a version info resource to the file. \"\"\"\n\n        if \"FileVersion\" not in data:\n            data[\"FileVersion\"] = '.'.join(file_ver)\n        if \"ProductVersion\" not in data:\n            data[\"ProductVersion\"] = '.'.join(product_ver)\n\n        assert len(file_ver) == 4\n        assert len(product_ver) == 4\n\n        res = VersionInfoResource()\n        res.file_version = file_ver\n        res.product_version = product_ver\n        res.string_info = {\n            \"%04x%04x\" % (lang, codepage): data\n        }\n        res.var_info = {\n            \"Translation\": bytearray(pack(\"<HH\", lang, codepage))\n        }\n\n        self.resources[16][1][lang] = res\n\n    def add_resource_section(self):\n        \"\"\" Adds a resource section to the file containing the resources that\n        were previously added via add_icon et al.  Assumes the file does not\n        contain a resource section yet. \"\"\"\n\n        # Calculate how much space to reserve.\n        tables = [self.resources] + list(self.resources.get_nested_tables())\n        table_size = 0\n        string_size = 0\n        desc_size = 16 * self.resources.count_resources()\n\n        for table in tables:\n            table._offset = table_size\n            table_size += 16 + 8 * len(table)\n            string_size += table._strings_size\n            desc_size += table._descs_size\n\n        # Now write the actual data.\n        tbl_offs = 0\n        str_offs = table_size\n        desc_offs = str_offs + string_size\n        data_offs = desc_offs + desc_size\n        data = bytearray(data_offs)\n        data_addr = _padded(len(self.vmem), self.section_alignment) + data_offs\n\n        for table in tables:\n            table.pack_header(data, tbl_offs)\n\n            tbl_offs += 16\n\n            for name, leaf in table._name_leaves:\n                if isinstance(leaf, ResourceTable):\n                    pack_into('<II', data, tbl_offs, str_offs | 0x80000000, leaf._offset | 0x80000000)\n                else:\n                    pack_into('<II', data, tbl_offs, str_offs | 0x80000000, desc_offs)\n                    resdata = leaf.get_data()\n                    pack_into('<IIII', data, desc_offs, data_addr, len(resdata), leaf.code_page, 0)\n                    data += resdata\n                    desc_offs += 16\n                    data_addr += len(resdata)\n                    align = len(resdata) & 3\n                    if align:\n                        data += bytearray(4 - align)\n                        data_addr += 4 - align\n                tbl_offs += 8\n\n                # Pack the name into the string table.\n                pack_into('<H', data, str_offs, len(name))\n                str_offs += 2\n                for c in name:\n                    pack_into('<H', data, str_offs, ord(c))\n                    str_offs += 2\n                str_offs = _padded(str_offs, 4)\n\n            for id, leaf in table._id_leaves:\n                if isinstance(leaf, ResourceTable):\n                    pack_into('<II', data, tbl_offs, id, leaf._offset | 0x80000000)\n                else:\n                    pack_into('<II', data, tbl_offs, id, desc_offs)\n                    resdata = leaf.get_data()\n                    pack_into('<IIII', data, desc_offs, data_addr, len(resdata), leaf.code_page, 0)\n                    data += resdata\n                    desc_offs += 16\n                    data_addr += len(resdata)\n                    align = len(resdata) & 3\n                    if align:\n                        data += bytearray(4 - align)\n                        data_addr += 4 - align\n                tbl_offs += 8\n\n        flags = 0x40000040 # readable, contains initialized data\n        section = self.add_section('.rsrc', flags, data)\n        self.res_rva = RVASize(section.vaddr, section.vsize)\n\n    def write_changes(self):\n        \"\"\" Assuming the file was opened in read-write mode, writes back the\n        changes made via this class to the .exe file. \"\"\"\n\n        fp = self.fp\n        # Read position of header.\n        fp.seek(0x3c)\n        offset, = unpack('<I', fp.read(4))\n\n        fp.seek(offset)\n        if fp.read(4) != b'PE\\0\\0':\n            raise ValueError(\"Invalid PE file.\")\n\n        # Sync read/write pointer.  Necessary before write.  Bug in Python?\n        fp.seek(fp.tell())\n\n        # Rewrite the first part of the COFF header.\n        timdat = int(time.time())\n        fp.write(pack('<HHI', self.machine, len(self.sections), timdat))\n\n        # Write calculated init and uninitialised sizes to the opthdr.\n        fp.seek(16, 1)\n        fp.write(pack('<III', self.code_size, self.initialized_size, self.uninitialized_size))\n\n        # Same for the image and header size.\n        fp.seek(40, 1)\n        fp.write(pack('<II', self.image_size, self.header_size))\n\n        # Write the modified RVA table.\n        fp.seek(self.rva_offset)\n        numrvas, = unpack('<I', fp.read(4))\n        assert numrvas >= 3\n\n        fp.seek(self.rva_offset + 4)\n        if numrvas >= 1:\n            fp.write(pack('<II', *self.exp_rva))\n        if numrvas >= 2:\n            fp.write(pack('<II', *self.imp_rva))\n        if numrvas >= 3:\n            fp.write(pack('<II', *self.res_rva))\n\n        # Skip the rest of the tables.\n        if numrvas >= 4:\n            fp.seek((numrvas - 3) * 8, 1)\n\n        # Write the modified section headers.\n        for section in self.sections:\n            section.write_header(fp)\n            assert fp.tell() <= self.header_size\n\n        # Write the section data of modified sections.\n        for section in self.sections:\n            if not section.modified:\n                continue\n\n            fp.seek(section.offset)\n            size = min(section.vsize, section.size)\n            fp.write(self.vmem[section.vaddr:section.vaddr+size])\n\n            pad = section.size - size\n            assert pad >= 0\n            if pad > 0:\n                fp.write(bytearray(pad))\n\n            section.modified = False\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/dist/pefile.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/8a037500_pefile.json",
    "doc_id": "doc_130"
  }
}