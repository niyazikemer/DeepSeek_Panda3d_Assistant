{
  "content": "\"\"\"\nContains the ParticleInterval class\n\"\"\"\n\n__all__ = ['ParticleInterval']\n\nfrom panda3d.direct import CInterval\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom .Interval import Interval\n\n\nclass ParticleInterval(Interval):\n    \"\"\"\n    Use this interval when you want to have greater control over a\n    ParticleEffect.  The interval does not register the effect with\n    the global particle and physics managers, but it does call upon\n    them to perform its stepping.  You should NOT call\n    particleEffect.start() with an effect that is being controlled\n    by a ParticleInterval.\n    \"\"\"\n    # Name counter\n    particleNum = 1\n    # create ParticleInterval DirectNotify category\n    notify = directNotify.newCategory('ParticleInterval')\n    # Class methods\n    def __init__(self,\n                 particleEffect,\n                 parent,\n                 worldRelative = 1,\n                 renderParent = None,\n                 duration = 0.0,\n                 softStopT = 0.0,\n                 cleanup = False,\n                 name = None):\n        \"\"\"\n        Args:\n            particleEffect (ParticleEffect): a particle effect\n            parent (NodePath): this is where the effect will be parented in the\n                scene graph\n            worldRelative (bool): this will override 'renderParent' with render\n            renderParent (NodePath): this is where the particles will be\n                rendered in the scenegraph\n            duration (float): for the time\n            softStopT (float): no effect if 0.0, a positive value will count\n                from the start of the interval, a negative value will count\n                from the end of the interval\n            cleanup (boolean): if True the effect will be destroyed and removed\n                from the scenegraph upon interval completion.  Set to False if\n                planning on reusing the interval.\n            name (string): use this for unique intervals so that they can be\n                easily found in the taskMgr.\n        \"\"\"\n\n        # Generate unique name\n        id = 'Particle-%d' % ParticleInterval.particleNum\n        ParticleInterval.particleNum += 1\n        if name is None:\n            name = id\n        # Record instance variables\n        self.particleEffect = particleEffect\n        self.cleanup = cleanup\n\n        if parent is not None:\n            self.particleEffect.reparentTo(parent)\n        if worldRelative:\n            renderParent = render\n        if renderParent:\n            for particles in self.particleEffect.getParticlesList():\n                particles.setRenderParent(renderParent.node())\n\n        self.__softStopped = False\n\n        if softStopT == 0.0:\n            self.softStopT = duration\n        elif softStopT < 0.0:\n            self.softStopT = duration+softStopT\n        else:\n            self.softStopT = softStopT\n\n        # Initialize superclass\n        Interval.__init__(self, name, duration)\n\n    def __step(self,dt):\n        if self.particleEffect:\n            self.particleEffect.accelerate(dt,1,0.05)\n\n    def __softStart(self):\n        if self.particleEffect:\n            self.particleEffect.softStart()\n        self.__softStopped = False\n\n    def __softStop(self):\n        if self.particleEffect:\n            self.particleEffect.softStop()\n        self.__softStopped = True\n\n    def privInitialize(self, t):\n        if self.state != CInterval.SPaused:\n            # Restarting from a hard stop or just interrupting the\n            # current play\n            self.__softStart()\n            if self.particleEffect:\n                self.particleEffect.clearToInitial()\n            self.currT = 0\n\n        if self.particleEffect:\n            for forceGroup in self.particleEffect.getForceGroupList():\n                forceGroup.enable()\n\n        Interval.privInitialize(self,t)\n\n    def privInstant(self):\n        self.privInitialize(self.getDuration())\n        self.privFinalize()\n\n    def privStep(self, t):\n        if self.state == CInterval.SPaused or t < self.currT:\n            # Restarting from a pause.\n            self.privInitialize(t)\n        else:\n            if not self.__softStopped and t > self.softStopT:\n                self.__step(self.softStopT-self.currT)\n                self.__softStop()\n                self.__step(t-self.softStopT)\n            else:\n                self.__step(t-self.currT)\n            Interval.privStep(self,t)\n\n    def privFinalize(self):\n        Interval.privFinalize(self)\n        if self.cleanup and self.particleEffect:\n            self.particleEffect.cleanup()\n            self.particleEffect = None\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/interval/ParticleInterval.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/654cc874_ParticleInterval.json",
    "doc_id": "doc_163"
  }
}