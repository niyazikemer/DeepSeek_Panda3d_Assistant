{
  "content": "Bullet Hello World\n\nThis page intends to lead through a minimal \"hello world\" program using Panda3D and Bullet physics.\n\ncpp\n\nCompiling C++ Panda3D with Bullet code\n\nTo compile a Panda3D C++ program with Bullet, you will need to link directly against the Bullet libraries.\n\nThese are not included in the Panda3D SDK, but are included in a separate \"thirdparty tools\" download on the download page. You will need to add the appropriate Bullet include and library directories to your compiler settings.\n\nOn Ubuntu, we compile against the Bullet version that is included in the Ubuntu distribution, and you can use pkg-config to determine the include and library paths for Bullet.\n\nWorld\n\nIn order to use Bullet physics we need to have a BulletWorld. The world is Panda3D's term for a \"space\" or \"scene\". The world holds physical objects like rigid bodies, soft bodies or character controllers. It controls global parameters, such a gravity, and it advances the simulation state.\n\npython\n\nfrom panda3d.bullet import BulletWorld\nworld = BulletWorld()\nworld.setGravity(Vec3(0, 0, -9.81))\n\ncpp\n\nFirst, include Panda3D bullet binding headers.\n\n#include \"bulletWorld.h\"\n#include \"bulletPlaneShape.h\"\n#include \"bulletBoxShape.h\"\n...\nPT(BulletWorld) physics_world;\nphysics_world = new BulletWorld();\nphysics_world->set_gravity(0, 0, -9.81f);\n...\n\nThe above code creates a new world, and it sets the worlds gravity to a downward vector with length 9.81. While Bullet is in theory independent from any particular units it is recommended to stick with SI units (kilogram, meter, second). In SI units 9.81 m/s\u00b2 is the gravity on Earth's surface.\n\nNext we need to advance the simulation state. This is best done by a task which gets called each frame. We find out about the elapsed time (dt), and pass this value to the do_physics() method.\n\npython\n\ndef update(task):\n    dt = globalClock.getDt()\n    world.doPhysics(dt)\n    return task.cont\n\ntaskMgr.add(update, 'update')\n\ncpp\n\n...\nAsyncTask::DoneStatus update_scene(GenericAsyncTask* task, void* data) {\n    // Get dt (from Python example) and apply to do_physics(float, int, int);\n    ClockObject *co = ClockObject::get_global_clock();\n    physics_world->do_physics(co->get_dt(), 10, 1.0 / 180.0);\n\n    return AsyncTask::DS_cont;\n}\n...\nPT(GenericAsyncTask) task;\ntask = new GenericAsyncTask(\"Scene update\", &update_scene, nullptr);\ntask_mgr->add(task); // Note: task_mgr = AsyncTaskManager::get_global_ptr();\n...\n\nThe doPhysics method allows finer control on the way the simulation state is advanced. Internally Bullet splits a timestep into several substeps. We can pass a maximum number of substeps and the size of each substep, like show in the following code.\n\npython\n\nworld.doPhysics(dt, 10, 1.0/180.0)\n\ncpp\n\nphysics_world->do_physics(co->get_dt(), 10, 1.0 / 180.0);\n\nHere we have a maximum of 10 substeps, each with 1/180 seconds. Choosing smaller substeps will make the simulation more realistic, but performance will decrease too. Smaller substeps also reduce jitter.\n\nStatic bodies\n\nSo far we just have an empty world. We next need to add some objects. The most simple objects are static bodies. Static object don't change their position or orientation with time. Typical static objects are the ground or terrain, and houses or other non-moveable obstacles. Here we create a simple plane which will serve as a ground.\n\npython\n\nfrom panda3d.bullet import BulletPlaneShape\nfrom panda3d.bullet import BulletRigidBodyNode\n\nshape = BulletPlaneShape(Vec3(0, 0, 1), 1)\n\nnode = BulletRigidBodyNode('Ground')\nnode.addShape(shape)\n\nnp = render.attachNewNode(node)\nnp.setPos(0, 0, -2)\n\nworld.attachRigidBody(node)\n\ncpp\n\n...\nPT(BulletPlaneShape) floor_shape = new BulletPlaneShape(LVecBase3(0, 0, 1), 1);\nPT(BulletRigidBodyNode) floor_rigid_node = new BulletRigidBodyNode(\"Ground\");\n\nfloor_rigid_node->add_shape(floor_shape);\n\nNodePath np_ground = window->get_render().attach_new_node(floor_rigid_node);\nnp_ground.set_pos(0, 0, -2);\nphysics_world->attach(floor_rigid_node);\n...\n\nFirst we create a collision shape, in the case a BulletPlaneShape. We pass the plane's constant and normal vector within the shape's constructor. There is a separate page about setting up the various collision shapes offered by Bullet, so we won't go into more detail here.\n\nNext we create a rigid body and add the previously created shape. BulletRigidBodyNode is derived from PandaNode, and thus the rigid body can be placed within the Panda3D scene graph. you can also use methods like setPos or setH to place the rigid body node where you want it to be.\n\nFinally we need to attach the newly created rigid body node to the world. Only rigid bodies attached to the world will be considered when advancing the simulation state.\n\nDynamic bodies\n\nDynamic bodies are similar to static bodies. Except that dynamic bodies can be moved around the world by applying force or torque. To setup a dynamic body is almost the same as for static bodies. We will have to set one additional property though, the body's mass. Setting a positive finite mass will create a dynamic body, while setting the mass to zero will create a static body. Zero mass is a convention for setting an infinite mass, which is the same as making the body unmovable (static).\n\npython\n\nfrom panda3d.bullet import BulletBoxShape\n\nshape = BulletBoxShape(Vec3(0.5, 0.5, 0.5))\n\nnode = BulletRigidBodyNode('Box')\nnode.setMass(1.0)\nnode.addShape(shape)\n\nnp = render.attachNewNode(node)\nnp.setPos(0, 0, 2)\n\nworld.attachRigidBody(node)\n\ncpp\n\n...\nPT(BulletBoxShape) box_shape = new BulletBoxShape(LVecBase3(0.5, 0.5, 0.5));\nPT(BulletRigidBodyNode) box_rigid_node = new BulletRigidBodyNode(\"Box\");\n\nbox_rigid_node->set_mass(1.0f); // Gravity affects this rigid node.\nbox_rigid_node->add_shape(box_shape);\n\nNodePath np_box = window->get_render().attach_new_node(box_rigid_node);\nnp_box.set_pos(0, 0, 2);\nphysics_world->attach(box_rigid_node);\n...\n\nBullet will automatically update a rigid body node's position and orientation if is has changed after advancing the simulation state. So, if you have a GeomNode- e. g. a textured box - and reparent this geom node below the rigid body node, then the geom node will move around together with the rigid body. You don't have to synchronize the visual world with the physics world.\n\nThe Program\n\nLet's put everything learned on this page together into a single script, which is shown below. It assumes that you have an .egg model of a 1 by 1 by 1 box.\n\nwhen running the script you will see a box falling down onto an invisible plane. The plane is invisible simply because we didn't parent a visual mode below the plane's rigid body node. Of course we could have done so.\n\nThe model cube.egg used in this hello word sample can be found in the following archive: https://www.panda3d.org/download/noversion/bullet-samples.zip\n\ncpp\n\nNote\n\nSamples are currently available in Python code only.\n\npython\n\nimport direct.directbase.DirectStart\nfrom panda3d.core import Vec3\nfrom panda3d.bullet import BulletWorld\nfrom panda3d.bullet import BulletPlaneShape\nfrom panda3d.bullet import BulletRigidBodyNode\nfrom panda3d.bullet import BulletBoxShape\n\nbase.cam.setPos(0, -10, 0)\nbase.cam.lookAt(0, 0, 0)\n\n# World\nworld = BulletWorld()\nworld.setGravity(Vec3(0, 0, -9.81))\n\n# Plane\nshape = BulletPlaneShape(Vec3(0, 0, 1), 1)\nnode = BulletRigidBodyNode('Ground')\nnode.addShape(shape)\nnp = render.attachNewNode(node)\nnp.setPos(0, 0, -2)\nworld.attachRigidBody(node)\n\n# Box\nshape = BulletBoxShape(Vec3(0.5, 0.5, 0.5))\nnode = BulletRigidBodyNode('Box')\nnode.setMass(1.0)\nnode.addShape(shape)\nnp = render.attachNewNode(node)\nnp.setPos(0, 0, 2)\nworld.attachRigidBody(node)\nmodel = loader.loadModel('models/box.egg')\nmodel.flattenLight()\nmodel.reparentTo(np)\n\n# Update\ndef update(task):\n    dt = globalClock.getDt()\n    world.doPhysics(dt)\n    return task.cont\n\ntaskMgr.add(update, 'update')\nbase.run()\n\ncpp\n\n// Bullet Physics Example.\n// The following example is done from Python sources, Panda Reference and Panda Manual,\n// for more information, visit Panda3D and/or Bullet physics web site.\n\n// Compiling and Linking documentation and notes are not\n// covered in this file, check manual for more information.\n\n#include \"pandaFramework.h\"\n#include \"windowFramework.h\"\n#include \"nodePath.h\"\n#include \"clockObject.h\"\n\n#include \"asyncTask.h\"\n#include \"genericAsyncTask.h\"\n\n#include \"bulletWorld.h\"\n#include \"bulletPlaneShape.h\"\n#include \"bulletBoxShape.h\"\n\nBulletWorld *get_physics_world() {\n  // physics_world is supposed to be an global variable,\n  // but declaring global variables is not cool\n  // for good programmers lol, instead, should use static keyword.\n  static PT(BulletWorld) physics_world = new BulletWorld();\n  return physics_world.p();\n}\n\nAsyncTask::DoneStatus update_scene(GenericAsyncTask* task, void* data) {\n  // Get dt (from Python example) and apply to do_physics(float, int, int);\n  ClockObject *co = ClockObject::get_global_clock();\n  get_physics_world()->do_physics(co->get_dt(), 10, 1.0 / 180.0);\n\n  return AsyncTask::DS_cont;\n}\n\nint main(int argc, char *argv[]) {\n  // All variables.\n  PandaFramework framework;\n  WindowFramework *window;\n  NodePath camera;\n  PT(AsyncTaskManager) task_mgr;\n\n  // Init everything :D\n  framework.open_framework(argc, argv);\n  framework.set_window_title(\"Bullet Physics\");\n\n  window = framework.open_window();\n  window->enable_keyboard();\n  window->setup_trackball();\n\n  camera = window->get_camera_group();\n  task_mgr = AsyncTaskManager::get_global_ptr();\n\n  // Make physics simulation.\n  // Static world stuff.\n  get_physics_world()->set_gravity(0, 0, -9.81f);\n\n  PT(BulletPlaneShape) floor_shape = new BulletPlaneShape(LVecBase3(0, 0, 1), 1);\n  PT(BulletRigidBodyNode) floor_rigid_node = new BulletRigidBodyNode(\"Ground\");\n\n  floor_rigid_node->add_shape(floor_shape);\n\n  NodePath np_ground = window->get_render().attach_new_node(floor_rigid_node);\n  np_ground.set_pos(0, 0, -2);\n  get_physics_world()->attach(floor_rigid_node);\n\n  // Dynamic world stuff.\n  PT(BulletBoxShape) box_shape = new BulletBoxShape(LVecBase3(0.5, 0.5, 0.5));\n  PT(BulletRigidBodyNode) box_rigid_node = new BulletRigidBodyNode(\"Box\");\n\n  box_rigid_node->set_mass(1.0f); // Gravity affects this rigid node.\n  box_rigid_node->add_shape(box_shape);\n\n  NodePath np_box = window->get_render().attach_new_node(box_rigid_node);\n  np_box.set_pos(0, 0, 2);\n  get_physics_world()->attach(box_rigid_node);\n\n  NodePath np_box_model = window->load_model(framework.get_models(), \"models/box\");\n  np_box_model.set_pos(-0.5,-0.5,-0.5);\n  np_box.flatten_light();\n  np_box_model.reparent_to(np_box);\n\n  PT(GenericAsyncTask) task;\n  task = new GenericAsyncTask(\"Scene update\", &update_scene, nullptr);\n  task_mgr->add(task);\n\n  framework.main_loop();\n  framework.close_framework();\n\n  return (0);\n}",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/9e249116_hello-world.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/b9e9e720_9e249116_hello-world.json",
    "doc_id": "doc_584"
  }
}