{
  "content": "\"\"\"Contains the TaskThreaded and TaskThread classes.\"\"\"\n\n__all__ = ['TaskThreaded', 'TaskThread']\n\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom panda3d.core import ClockObject\n\nfrom .PythonUtil import SerialNumGen, Functor\n\n\nclass TaskThreaded:\n    \"\"\" derive from this if you need to do a bunch of CPU-intensive\n    processing and you don't want to hang up the show. Lets you break\n    up the processing over multiple frames \"\"\"\n    notify = directNotify.newCategory(\"TaskThreaded\")\n\n    _Serial = SerialNumGen()\n\n    def __init__(self, name, threaded=True, timeslice=None, callback=None):\n        # timeslice is how long this thread should take every frame.\n        self.__name = name\n        self.__threaded = threaded\n        if timeslice is None:\n            timeslice = .01\n        self.__timeslice = timeslice\n        self.__taskNames = set()\n        self._taskStartTime = None\n        self.__threads = set()\n        self._callback = callback\n\n    def finished(self):\n        if self._callback:\n            self._callback()\n\n    def destroy(self):\n        for taskName in self.__taskNames:\n            taskMgr.remove(taskName)\n        del self.__taskNames\n        for thread in self.__threads:\n            thread.tearDown()\n            thread._destroy()\n        del self.__threads\n        del self._callback\n        self.ignoreAll()\n\n    def getTimeslice(self):\n        return self.__timeslice\n\n    def setTimeslice(self, timeslice):\n        self.__timeslice = timeslice\n\n    def scheduleCallback(self, callback):\n        assert self.notify.debugCall()\n        if not self.__threaded:\n            callback()\n        else:\n            taskName = ('%s-ThreadedTask-%s' %\n                        (self.__name, TaskThreaded._Serial.next()))\n            assert taskName not in self.__taskNames\n            self.__taskNames.add(taskName)\n            taskMgr.add(Functor(self.__doCallback, callback, taskName),\n                        taskName)\n\n    def scheduleThread(self, thread):\n        assert self.notify.debugCall()\n        # pass in a TaskThread. TaskThreaded will take over ownership and\n        # cleanup responsibilities\n        thread._init(self)\n        thread.setUp()\n        if thread.isFinished():\n            thread._destroy()\n        else:\n            if not self.__threaded:\n                while not thread.isFinished():\n                    thread.run()\n                thread._destroy()\n            else:\n                assert not thread in self.__threads\n                self.__threads.add(thread)\n                taskName = ('%s-ThreadedTask-%s-%s' %\n                            (self.__name, thread.__class__.__name__,\n                             TaskThreaded._Serial.next()))\n                assert taskName not in self.__taskNames\n                self.__taskNames.add(taskName)\n                self.__threads.add(thread)\n                taskMgr.add(Functor(self._doThreadCallback, thread, taskName),\n                            taskName)\n\n    def _doCallback(self, callback, taskName, task):\n        assert self.notify.debugCall()\n        self.__taskNames.remove(taskName)\n        self._taskStartTime = ClockObject.getGlobalClock().getRealTime()\n        callback()\n        self._taskStartTime = None\n        return Task.done\n\n    def _doThreadCallback(self, thread, taskName, task):\n        assert self.notify.debugCall()\n        self._taskStartTime = ClockObject.getGlobalClock().getRealTime()\n        thread.run()\n        self._taskStartTime = None\n        if thread.isFinished():\n            thread._destroy()\n            self.__taskNames.remove(taskName)\n            self.__threads.remove(thread)\n            return Task.done\n        else:\n            return Task.cont\n\n    def taskTimeLeft(self):\n        \"\"\"returns True if there is time left for the current task callback\n        to run without going over the allotted timeslice\"\"\"\n        if self._taskStartTime is None:\n            # we must not be in a task callback, we must be running in non-threaded\n            # mode\n            return True\n        return (ClockObject.getGlobalClock().getRealTime() - self._taskStartTime) < self.__timeslice\n\nclass TaskThread:\n    # derive and override these four funcs\n    # TaskThreaded obj is available as 'self.parent'\n    # attributes of TaskThreaded obj are available directly as self.variable\n    # call self.finished() when you're done\n    def setUp(self):\n        pass\n    def run(self):\n        pass\n    def tearDown(self):\n        # undo what you did in setUp()\n        # this will be called if we get destroyed early\n        pass\n    def done(self):\n        # override this if you want to do stuff after the thread finishes\n        pass\n\n    # call this when your task is complete\n    def finished(self):\n        self.tearDown()\n        self._finished = True\n        self.done()\n    def isFinished(self):\n        return self._finished\n\n    # call this to find out if you've gone over your timeslice\n    def timeLeft(self):\n        return self.parent.taskTimeLeft()\n\n    def _init(self, parent):\n        self.parent = parent\n        self._finished = False\n    def _destroy(self):\n        del self.parent\n        del self._finished\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/TaskThreaded.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/e667161a_TaskThreaded.json",
    "doc_id": "doc_245"
  }
}