{
  "content": "\"\"\"\nThis module defines the various \"meta intervals\", which execute other\nintervals either in parallel or in a specified sequential order.\n\"\"\"\n\n__all__ = ['MetaInterval', 'Sequence', 'Parallel', 'ParallelEndTogether', 'Track']\n\nfrom panda3d.core import PStatCollector, ostream\nfrom panda3d.direct import CInterval, CMetaInterval\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom .IntervalManager import ivalMgr\nfrom . import Interval\nfrom direct.task.Task import TaskManager\n#if __debug__:\n#    import direct.showbase.PythonUtil as PythonUtil\n\nPREVIOUS_END = CMetaInterval.RSPreviousEnd\nPREVIOUS_START = CMetaInterval.RSPreviousBegin\nTRACK_START = CMetaInterval.RSLevelBegin\n\nclass MetaInterval(CMetaInterval):\n    # This is a Python-C++ hybrid class.  MetaInterval is a Python\n    # extension of the C++ class CMetaInterval, which adds some\n    # Python-specific features (like list management).\n\n    # This is the base class of Sequence, Parallel, and Track.\n\n    notify = directNotify.newCategory(\"MetaInterval\")\n\n    SequenceNum = 1\n    def __init__(self, *ivals, **kw):\n        #if __debug__:\n        #    self.debugInitTraceback = PythonUtil.StackTrace(\n        #        \"create interval\", 1, 10)\n\n        name = None\n        #if len(ivals) == 2 and isinstance(ivals[1], str):\n        #    # If the second parameter is a string, it's the name.\n        #    name = ivals[1]\n        #    ivals = ivals[0]\n        #else:\n\n        # Look for the name in the keyword params.\n        if 'name' in kw:\n            name = kw['name']\n            del kw['name']\n\n        # If the keyword \"autoPause\" or \"autoFinish\" is defined to\n        # non-zero, it means the interval may be automatically paused\n        # or finished when CIntervalManager::interrupt() is called.\n        # This is generally called only on a catastrophic situation\n        # (for instance, the connection to the server being lost) when\n        # we have to exit right away; these keywords indicate\n        # intervals that might not be cleaned up by their owners.\n\n        autoPause = 0\n        autoFinish = 0\n        if 'autoPause' in kw:\n            autoPause = kw['autoPause']\n            del kw['autoPause']\n        if 'autoFinish' in kw:\n            autoFinish = kw['autoFinish']\n            del kw['autoFinish']\n\n        # A duration keyword specifies the duration the interval will\n        # appear to have for the purposes of computing the start time\n        # for subsequent intervals in a sequence or track.\n        self.phonyDuration = -1\n        if 'duration' in kw:\n            self.phonyDuration = kw['duration']\n            del kw['duration']\n\n        if kw:\n            self.notify.error(\"Unexpected keyword parameters: %s\" % (list(kw.keys())))\n\n        # We must allow the old style: Track([ival0, ival1, ...]) as\n        # well as the new style: Track(ival0, ival1, ...)\n\n        # Note: this breaks in the case of a Track with one tuple:\n        # Track((0, ival0),).  We could go through some effort to fix\n        # this case, but for now I prefer just to document it as a\n        # bug, since it will go away when we eventually remove support\n        # for the old interface.\n        #if len(ivals) == 1 and \\\n        #   (isinstance(ivals[0], tuple) or \\\n        #    isinstance(ivals[0], list)):\n        #    self.ivals = ivals[0]\n        #else:\n\n        self.ivals = ivals\n\n        self.__ivalsDirty = 1\n\n        if name is None:\n            name = self.__class__.__name__ + '-%d'\n\n        if '%' in name:\n            name = name % (self.SequenceNum)\n            MetaInterval.SequenceNum += 1\n\n        CMetaInterval.__init__(self, name)\n        self.__manager = ivalMgr\n        self.setAutoPause(autoPause)\n        self.setAutoFinish(autoFinish)\n\n        self.pstats = None\n        if __debug__ and TaskManager.taskTimerVerbose:\n            self.pname = name.split('-', 1)[0]\n            self.pstats = PStatCollector(\"App:Tasks:ivalLoop:%s\" % (self.pname))\n\n        self.pythonIvals = []\n\n        # If we are running in debug mode, we validate the intervals\n        # in the list right away.  There's no good reason to do this,\n        # except that it makes it easier for the programmer to detect\n        # when a MetaInterval is misdefined at creation time.\n        assert self.validateComponents(self.ivals)\n\n\n\n    # Functions to make the MetaInterval object act just like a Python\n    # list of intervals:\n\n    def append(self, ival):\n        # Appends a single interval to the list so far.\n        if isinstance(self.ivals, tuple):\n            self.ivals = list(self.ivals)\n        self.ivals.append(ival)\n        self.__ivalsDirty = 1\n        assert self.validateComponent(ival)\n\n    def extend(self, ivals):\n        # Appends a list of intervals to the list so far.\n        self += ivals\n\n    def count(self, ival):\n        # Returns the number of occurrences of the indicated interval.\n        return self.ivals.count(ival)\n\n    def index(self, ival):\n        # Returns the position of the indicated interval within the list.\n        return self.ivals.index(ival)\n\n    def insert(self, index, ival):\n        # Inserts the given interval into the middle of the list.\n        if isinstance(self.ivals, tuple):\n            self.ivals = list(self.ivals)\n        self.ivals.insert(index, ival)\n        self.__ivalsDirty = 1\n        assert self.validateComponent(ival)\n\n    def pop(self, index = None):\n        # Returns element index (or the last element) and removes it\n        # from the list.\n        if isinstance(self.ivals, tuple):\n            self.ivals = list(self.ivals)\n        self.__ivalsDirty = 1\n        if index is None:\n            return self.ivals.pop()\n        else:\n            return self.ivals.pop(index)\n\n    def remove(self, ival):\n        # Removes the indicated interval from the list.\n        if isinstance(self.ivals, tuple):\n            self.ivals = list(self.ivals)\n        self.ivals.remove(ival)\n        self.__ivalsDirty = 1\n\n    def reverse(self):\n        # Reverses the order of the intervals.\n        if isinstance(self.ivals, tuple):\n            self.ivals = list(self.ivals)\n        self.ivals.reverse()\n        self.__ivalsDirty = 1\n\n    def sort(self, cmpfunc = None):\n        # Sorts the intervals. (?)\n        if isinstance(self.ivals, tuple):\n            self.ivals = list(self.ivals)\n        self.__ivalsDirty = 1\n        if cmpfunc is None:\n            self.ivals.sort()\n        else:\n            self.ivals.sort(cmpfunc)\n\n    def __len__(self):\n        return len(self.ivals)\n\n    def __getitem__(self, index):\n        return self.ivals[index]\n\n    def __setitem__(self, index, value):\n        if isinstance(self.ivals, tuple):\n            self.ivals = list(self.ivals)\n        self.ivals[index] = value\n        self.__ivalsDirty = 1\n        assert self.validateComponent(value)\n\n    def __delitem__(self, index):\n        if isinstance(self.ivals, tuple):\n            self.ivals = list(self.ivals)\n        del self.ivals[index]\n        self.__ivalsDirty = 1\n\n    def __getslice__(self, i, j):\n        if isinstance(self.ivals, tuple):\n            self.ivals = list(self.ivals)\n        return self.__class__(self.ivals[i: j])\n\n    def __setslice__(self, i, j, s):\n        if isinstance(self.ivals, tuple):\n            self.ivals = list(self.ivals)\n        self.ivals[i: j] = s\n        self.__ivalsDirty = 1\n        assert self.validateComponents(s)\n\n    def __delslice__(self, i, j):\n        if isinstance(self.ivals, tuple):\n            self.ivals = list(self.ivals)\n        del self.ivals[i: j]\n        self.__ivalsDirty = 1\n\n    def __iadd__(self, other):\n        if isinstance(self.ivals, tuple):\n            self.ivals = list(self.ivals)\n        if isinstance(other, MetaInterval):\n            assert self.__class__ == other.__class__\n            ivals = other.ivals\n        else:\n            ivals = list(other)\n        self.ivals += ivals\n        self.__ivalsDirty = 1\n        assert self.validateComponents(ivals)\n        return self\n\n    def __add__(self, other):\n        copy = self[:]\n        copy += other\n        return copy\n\n    # Functions to define sequence, parallel, and track behaviors:\n\n    def addSequence(self, list, name, relTime, relTo, duration):\n        # Adds the given list of intervals to the MetaInterval to be\n        # played one after the other.\n        self.pushLevel(name, relTime, relTo)\n        for ival in list:\n            self.addInterval(ival, 0.0, PREVIOUS_END)\n        self.popLevel(duration)\n\n    def addParallel(self, list, name, relTime, relTo, duration):\n        # Adds the given list of intervals to the MetaInterval to be\n        # played simultaneously; all will start at the same time.\n        self.pushLevel(name, relTime, relTo)\n        for ival in list:\n            self.addInterval(ival, 0.0, TRACK_START)\n        self.popLevel(duration)\n\n    def addParallelEndTogether(self, list, name, relTime, relTo, duration):\n        # Adds the given list of intervals to the MetaInterval to be\n        # played simultaneously; all will end at the same time, but\n        # the longest interval will be started first to achieve this.\n\n        maxDuration = 0\n        for ival in list:\n            maxDuration = max(maxDuration, ival.getDuration())\n\n        self.pushLevel(name, relTime, relTo)\n        for ival in list:\n            self.addInterval(ival, maxDuration - ival.getDuration(), TRACK_START)\n        self.popLevel(duration)\n\n    def addTrack(self, trackList, name, relTime, relTo, duration):\n        # Adds a \"track list\".  This is a list of tuples of the form:\n        #\n        #   (<delay>, <Interval>,\n        #       PREVIOUS_END | PREVIOUS_START | TRACK_START)\n        #\n        # where <delay> is a relative time, in seconds, for the\n        # <Interval> to start, relative to either the end of the\n        # previous interval (PREVIOUS_END), the start of the previous\n        # interval (PREVIOUS_START) or the start of the track list\n        # (TRACK_START).  If the relative code is omitted, the default\n        # is TRACK_START.\n        self.pushLevel(name, relTime, relTo)\n        for tupleObj in trackList:\n            if isinstance(tupleObj, tuple) or \\\n               isinstance(tupleObj, list):\n                relTime = tupleObj[0]\n                ival = tupleObj[1]\n                if len(tupleObj) >= 3:\n                    relTo = tupleObj[2]\n                else:\n                    relTo = TRACK_START\n                self.addInterval(ival, relTime, relTo)\n\n            else:\n                self.notify.error(\"Not a tuple in Track: %s\" % (tupleObj,))\n        self.popLevel(duration)\n\n    def addInterval(self, ival, relTime, relTo):\n        # Adds the given interval to the MetaInterval.\n\n        if isinstance(ival, CInterval):\n            # It's a C++-style Interval, so add it directly.\n            if getattr(ival, \"inPython\", 0):\n                # Actually, it's been flagged to run in Python, even\n                # though it's a C++ Interval.  It's probably got some\n                # Python functors that must be invoked at runtime to\n                # define some of its parameters.  Treat it as a Python\n                # interval.\n                index = len(self.pythonIvals)\n                self.pythonIvals.append(ival)\n                self.addExtIndex(index, ival.getName(), ival.getDuration(),\n                                 ival.getOpenEnded(), relTime, relTo)\n            elif isinstance(ival, MetaInterval):\n                # It's another MetaInterval, so copy in its intervals\n                # directly to this object.  We could just store the\n                # MetaInterval itself, which would work, but we get a\n                # performance advantage by flattening out the deeply\n                # nested hierarchy into a linear list within the root\n                # CMetaInterval object.\n                ival.applyIvals(self, relTime, relTo)\n            else:\n                # Nope, a perfectly ordinary C++ interval.  Hooray!\n                self.addCInterval(ival, relTime, relTo)\n\n        elif isinstance(ival, Interval.Interval):\n            # It's a Python-style Interval, so add it as an external.\n            index = len(self.pythonIvals)\n            self.pythonIvals.append(ival)\n            if self.pstats:\n                ival.pstats = PStatCollector(self.pstats, ival.pname)\n            self.addExtIndex(index, ival.getName(), ival.getDuration(),\n                             ival.getOpenEnded(), relTime, relTo)\n\n        else:\n            self.notify.error(\"Not an Interval: %s\" % (ival,))\n\n    # Functions to support automatic playback of MetaIntervals along\n    # with all of their associated Python callbacks:\n\n    def setManager(self, manager):\n        self.__manager = manager\n        CMetaInterval.setManager(self, manager)\n\n    def getManager(self):\n        return self.__manager\n\n    manager = property(getManager, setManager)\n\n    def setT(self, t):\n        self.__updateIvals()\n        CMetaInterval.setT(self, t)\n\n    t = property(CMetaInterval.getT, setT)\n\n    def start(self, startT = 0.0, endT = -1.0, playRate = 1.0):\n        self.__updateIvals()\n        self.setupPlay(startT, endT, playRate, 0)\n        self.__manager.addInterval(self)\n\n    def loop(self, startT = 0.0, endT = -1.0, playRate = 1.0):\n        self.__updateIvals()\n        self.setupPlay(startT, endT, playRate, 1)\n        self.__manager.addInterval(self)\n\n    def pause(self):\n        if self.getState() == CInterval.SStarted:\n            self.privInterrupt()\n        self.__manager.removeInterval(self)\n        self.privPostEvent()\n        return self.getT()\n\n    def resume(self, startT = None):\n        self.__updateIvals()\n        if startT is not None:\n            self.setT(startT)\n        self.setupResume()\n        self.__manager.addInterval(self)\n\n    def resumeUntil(self, endT):\n        self.__updateIvals()\n        self.setupResumeUntil(endT)\n        self.__manager.addInterval(self)\n\n    def finish(self):\n        self.__updateIvals()\n        state = self.getState()\n        if state == CInterval.SInitial:\n            self.privInstant()\n        elif state != CInterval.SFinal:\n            self.privFinalize()\n        self.__manager.removeInterval(self)\n        self.privPostEvent()\n\n    def clearToInitial(self):\n        # This is overloaded at the Python level to properly call\n        # pause() at the Python level, then upcall to finish the job\n        # at the C++ level.\n        self.pause()\n        CMetaInterval.clearToInitial(self)\n\n    # Internal functions:\n\n    def validateComponent(self, component):\n        # This is called only in debug mode to verify that the\n        # indicated component added to the MetaInterval is appropriate\n        # to this type of MetaInterval.  In most cases except Track,\n        # this is the same as asking that the component is itself an\n        # Interval.\n        return isinstance(component, CInterval) or \\\n               isinstance(component, Interval.Interval)\n\n    def validateComponents(self, components):\n        # This is called only in debug mode to verify that all the\n        # components on the indicated list are appropriate to this\n        # type of MetaInterval.\n        for component in components:\n            if not self.validateComponent(component):\n                return 0\n        return 1\n\n    def __updateIvals(self):\n        # The MetaInterval object does not create the C++ list of\n        # Intervals immediately; rather, it stores a Python list of\n        # Intervals that will be compiled into the C++ list the first\n        # time it is needed.\n\n        # This design allows us to avoid creation of the C++ list for\n        # nested MetaInterval objects, instead copying all nested\n        # MetaInterval hierarchy into the root CMetaInterval object,\n        # for a performance benefit.\n\n        # This function is called only on the root MetaInterval\n        # object, when it is time to build the C++ list for itself.\n\n        if self.__ivalsDirty:\n            self.clearIntervals()\n            self.applyIvals(self, 0, TRACK_START)\n            self.__ivalsDirty = 0\n\n    def clearIntervals(self):\n        # This overrides the function defined at the C++ level to\n        # reset the inPython flag.  Clearing out the intervals list\n        # allows us to run entirely in C++ again, at least until a new\n        # Python interval gets added.\n        CMetaInterval.clearIntervals(self)\n        self.inPython = 0\n\n    def applyIvals(self, meta, relTime, relTo):\n        # Add the intervals listed in this object to the given\n        # MetaInterval object at the C++ level.  This will make the\n        # other MetaInterval object ready to play the intervals.\n\n        # This function should be overridden in a derived class to\n        # change the intepretation of the intervals in this list.  In\n        # the case of a MetaInterval directly, this is valid only if\n        # the list has only zero or one intervals.\n\n        if len(self.ivals) == 0:\n            pass\n        elif len(self.ivals) == 1:\n            meta.addInterval(self.ivals[0], relTime, relTo)\n        else:\n            self.notify.error(\"Cannot build list from MetaInterval directly.\")\n\n    def setPlayRate(self, playRate):\n        \"\"\" Changes the play rate of the interval.  If the interval is\n        already started, this changes its speed on-the-fly.  Note that\n        since playRate is a parameter to start() and loop(), the next\n        call to start() or loop() will reset this parameter. \"\"\"\n\n        if self.isPlaying():\n            self.pause()\n            CMetaInterval.setPlayRate(self, playRate)\n            self.resume()\n        else:\n            CMetaInterval.setPlayRate(self, playRate)\n\n    play_rate = property(CMetaInterval.getPlayRate, setPlayRate)\n\n    def __doPythonCallbacks(self):\n        # This function invokes any Python-level Intervals that need\n        # to be invoked at this point in time.  It must be called\n        # after any call to setT() or setFinalT() or stepPlay(), or\n        # some such; basically any function that might invoke an\n        # interval.  The C++ base class will invoke whatever C++\n        # intervals it can, and then indicate the Python intervals\n        # that must be invoked through this interface.\n\n        ival = None\n        try:\n            while self.isEventReady():\n                index = self.getEventIndex()\n                t = self.getEventT()\n                eventType = self.getEventType()\n                self.popEvent()\n\n                ival = self.pythonIvals[index]\n                ival.privDoEvent(t, eventType)\n                ival.privPostEvent()\n                ival = None\n        except:\n            if ival is not None:\n                print(\"Exception occurred while processing %s of %s:\" % (ival.getName(), self.getName()))\n            else:\n                print(\"Exception occurred while processing %s:\" % (self.getName()))\n            print(self)\n            raise\n\n    def privDoEvent(self, t, event):\n        # This function overrides the C++ function to initialize the\n        # intervals first if necessary.\n        if self.pstats:\n            self.pstats.start()\n        self.__updateIvals()\n        CMetaInterval.privDoEvent(self, t, event)\n        if self.pstats:\n            self.pstats.stop()\n\n    def privPostEvent(self):\n        if self.pstats:\n            self.pstats.start()\n        self.__doPythonCallbacks()\n        CMetaInterval.privPostEvent(self)\n        if self.pstats:\n            self.pstats.stop()\n\n    def setIntervalStartTime(self, *args, **kw):\n        # This function overrides from the parent level to force it to\n        # update the interval list first, if necessary.\n\n        self.__updateIvals()\n        # Once we have monkeyed with the interval timings, we'd better\n        # run the whole thing as a monolithic Python interval, since\n        # we can't extract the ivals list back out and append them\n        # into a parent MetaInterval.\n        self.inPython = 1\n        return CMetaInterval.setIntervalStartTime(self, *args, **kw)\n\n    def getIntervalStartTime(self, *args, **kw):\n        # This function overrides from the parent level to force it to\n        # update the interval list first, if necessary.\n\n        self.__updateIvals()\n        return CMetaInterval.getIntervalStartTime(self, *args, **kw)\n\n\n    def getDuration(self):\n        # This function overrides from the parent level to force it to\n        # update the interval list first, if necessary.\n\n        self.__updateIvals()\n        return CMetaInterval.getDuration(self)\n\n    duration = property(getDuration)\n\n    def __repr__(self, *args, **kw):\n        # This function overrides from the parent level to force it to\n        # update the interval list first, if necessary.\n\n        self.__updateIvals()\n        return CMetaInterval.__repr__(self, *args, **kw)\n\n    def __str__(self, *args, **kw):\n        # This function overrides from the parent level to force it to\n        # update the interval list first, if necessary.\n\n        self.__updateIvals()\n        return CMetaInterval.__str__(self, *args, **kw)\n\n\n    def timeline(self, out = None):\n        # This function overrides from the parent level to force it to\n        # update the interval list first, if necessary.\n\n        self.__updateIvals()\n        if out is None:\n            out = ostream\n        CMetaInterval.timeline(self, out)\n\n    add_sequence = addSequence\n    add_parallel = addParallel\n    add_parallel_end_together = addParallelEndTogether\n    add_track = addTrack\n    add_interval = addInterval\n    set_manager = setManager\n    get_manager = getManager\n    set_t = setT\n    resume_until = resumeUntil\n    clear_to_initial = clearToInitial\n    clear_intervals = clearIntervals\n    set_play_rate = setPlayRate\n    priv_do_event = privDoEvent\n    priv_post_event = privPostEvent\n    set_interval_start_time = setIntervalStartTime\n    get_interval_start_time = getIntervalStartTime\n    get_duration = getDuration\n\n\nclass Sequence(MetaInterval):\n    def applyIvals(self, meta, relTime, relTo):\n        meta.addSequence(self.ivals, self.getName(),\n                         relTime, relTo, self.phonyDuration)\nclass Parallel(MetaInterval):\n    def applyIvals(self, meta, relTime, relTo):\n        meta.addParallel(self.ivals, self.getName(),\n                         relTime, relTo, self.phonyDuration)\n\nclass ParallelEndTogether(MetaInterval):\n    def applyIvals(self, meta, relTime, relTo):\n        meta.addParallelEndTogether(self.ivals, self.getName(),\n                         relTime, relTo, self.phonyDuration)\n\nclass Track(MetaInterval):\n    def applyIvals(self, meta, relTime, relTo):\n        meta.addTrack(self.ivals, self.getName(),\n                      relTime, relTo, self.phonyDuration)\n\n    def validateComponent(self, tupleObj):\n        # This is called only in debug mode to verify that the\n        # indicated component added to the MetaInterval is appropriate\n        # to this type of MetaInterval.  In most cases except Track,\n        # this is the same as asking that the component is itself an\n        # Interval.\n\n        if not (isinstance(tupleObj, tuple) or \\\n                isinstance(tupleObj, list)):\n            # It's not a tuple.\n            return 0\n\n        relTime = tupleObj[0]\n        ival = tupleObj[1]\n        if len(tupleObj) >= 3:\n            relTo = tupleObj[2]\n        else:\n            relTo = TRACK_START\n\n        if not (isinstance(relTime, float) or \\\n                isinstance(relTime, int)):\n            # First parameter is not a number.\n            return 0\n        if not MetaInterval.validateComponent(self, ival):\n            # Second parameter is not an interval.\n            return 0\n        if relTo != PREVIOUS_END and \\\n           relTo != PREVIOUS_START and \\\n           relTo != TRACK_START:\n            # Third parameter is an invalid value.\n            return 0\n\n        # Looks good.\n        return 1\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/interval/MetaInterval.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/4dc28cd4_MetaInterval.json",
    "doc_id": "doc_166"
  }
}