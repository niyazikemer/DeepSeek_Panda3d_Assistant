{
  "content": "\"\"\"LerpInterval module: contains the LerpInterval class\"\"\"\n\n__all__ = [\n    'LerpNodePathInterval', 'LerpPosInterval', 'LerpHprInterval',\n    'LerpQuatInterval', 'LerpScaleInterval', 'LerpShearInterval',\n    'LerpPosHprInterval', 'LerpPosQuatInterval',\n    'LerpHprScaleInterval', 'LerpQuatScaleInterval',\n    'LerpPosHprScaleInterval', 'LerpPosQuatScaleInterval',\n    'LerpPosHprScaleShearInterval', 'LerpPosQuatScaleShearInterval',\n    'LerpColorInterval', 'LerpColorScaleInterval',\n    'LerpTexOffsetInterval', 'LerpTexRotateInterval', 'LerpTexScaleInterval',\n    'LerpFunctionInterval', 'LerpFunc','LerpFunctionNoStateInterval','LerpFuncNS'\n]\n\nfrom panda3d.core import LOrientationf, NodePath\nfrom panda3d.direct import CInterval, CLerpNodePathInterval\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom . import Interval\nfrom . import LerpBlendHelpers\n\n#\n# Most of the intervals defined in this module--the group up here at\n# the front of the file--are now derived from a CInterval instead of\n# an Interval, so they can run in the low-level C++ code at high\n# performance.\n#\n\n\nclass LerpNodePathInterval(CLerpNodePathInterval):\n    # This is the base class for all of the lerps, defined below, that\n    # affect a property on a NodePath, like pos or hpr.\n    lerpNodePathNum = 1\n\n    def __init__(self, name, duration, blendType, bakeInStart, fluid,\n                 nodePath, other):\n        if name is None:\n            name = '%s-%d' % (self.__class__.__name__, self.lerpNodePathNum)\n            LerpNodePathInterval.lerpNodePathNum += 1\n        else:\n            # Allow the user to pass in a %d in the name and we'll go ahead\n            # and uniquify the name for them.\n            if \"%d\" in name:\n                name = name % LerpNodePathInterval.lerpNodePathNum\n                LerpNodePathInterval.lerpNodePathNum += 1\n\n        blendType = self.stringBlendType(blendType)\n        assert blendType != self.BTInvalid\n\n        if other is None:\n            other = NodePath()\n\n        CLerpNodePathInterval.__init__(self, name, duration, blendType,\n                                       bakeInStart, fluid, nodePath, other)\n\n    def anyCallable(self, *params):\n        # Returns true if any of the parameters listed is a callable\n        # functor, false if none of them are.  This is used by derived\n        # classes to determine if a functor was passed in for a\n        # parameter.\n\n        for param in params:\n            if callable(param):\n                return 1\n        return 0\n\n    def setupParam(self, func, param):\n        # Stores the indicated parameter by passing it to the given\n        # function (probably a C++ setter function).  If the param is\n        # a callable functor, calls it; otherwise, uses the param\n        # directly.\n        if param is not None:\n            if callable(param):\n                func(param())\n            else:\n                func(param)\n\n#####################################################################\n##\n##  It is legal to pass in a functor (a callable Python function that\n##  returns an appropriate value) for the any of the pos, hpr, scale,\n##  or shear parameters in the intervals below.  These will be\n##  evaluated at the time the interval starts in order to determine\n##  the actual final (or initial) position.  However, doing so forces\n##  the entire LerpInterval to be executed up in Python, instead of\n##  down in the low-level C++ code, at some performance cost.\n##\n##  If bakeInStart is true, the starting values (if unspecified) are\n##  computed at the time the interval runs for the first time, and\n##  then stored.  If bakeInStart is false, the starting values are\n##  recomputed each frame based on the current value and the time\n##  delta since the last time the interval ran, which allows show code\n##  to manipulate the node even while it is being lerped.\n##\n##  If fluid is true for a LerpPos-style interval, then the pos is set\n##  via NodePath.setFluidPos() instead of NodePath.setPos(), causing\n##  the collision system to treat the motion as continuous and test\n##  for collisions against the entire motion path, instead of as\n##  discrete position updates.  This has no meaning for Lerp intervals\n##  that do not adjust pos.\n##\n#####################################################################\n\n\nclass LerpPosInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, pos, startPos = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, fluid = 0, name = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, fluid, nodePath, other)\n\n        # Check for functors in the input parameters.\n        self.paramSetup = self.anyCallable(pos, startPos)\n        if self.paramSetup:\n            self.endPos = pos\n            self.startPos = startPos\n            self.inPython = 1\n        else:\n            self.setEndPos(pos)\n            if startPos is not None:\n                self.setStartPos(startPos)\n\n    def privDoEvent(self, t, event):\n        # This function is only used if Python functors were passed in\n        # for some of the input parameters.\n        if self.paramSetup and event == CInterval.ETInitialize:\n            self.setupParam(self.setEndPos, self.endPos)\n            self.setupParam(self.setStartPos, self.startPos)\n        LerpNodePathInterval.privDoEvent(self, t, event)\n\n\nclass LerpHprInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, hpr,\n                 startHpr = None, startQuat = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, fluid = 0, name = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, fluid, nodePath, other)\n\n        # Check for functors in the input parameters.\n        self.paramSetup = self.anyCallable(hpr, startHpr, startQuat)\n        if self.paramSetup:\n            self.endHpr = hpr\n            self.startHpr = startHpr\n            self.startQuat = startQuat\n            self.inPython = 1\n        else:\n            self.setEndHpr(hpr)\n            if startHpr is not None:\n                self.setStartHpr(startHpr)\n            if startQuat is not None:\n                self.setStartQuat(startQuat)\n\n    def privDoEvent(self, t, event):\n        # This function is only used if Python functors were passed in\n        # for some of the input parameters.\n        if self.paramSetup and event == CInterval.ETInitialize:\n            self.setupParam(self.setEndHpr, self.endHpr)\n            self.setupParam(self.setStartHpr, self.startHpr)\n            self.setupParam(self.setStartQuat, self.startQuat)\n        LerpNodePathInterval.privDoEvent(self, t, event)\n\n\nclass LerpQuatInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, quat = None,\n                 startHpr = None, startQuat = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, fluid = 0, name = None, hpr = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, fluid, nodePath, other)\n\n        if not quat:\n            # If we didn't specify a quat, we're allowed to specify a\n            # hpr instead, which is converted to the equivalent quat.\n            assert hpr\n            quat = LOrientationf()\n            quat.setHpr(hpr)\n\n        # Check for functors in the input parameters.\n        self.paramSetup = self.anyCallable(quat, startHpr, startQuat)\n        if self.paramSetup:\n            self.endQuat = quat\n            self.startHpr = startHpr\n            self.startQuat = startQuat\n            self.inPython = 1\n        else:\n            self.setEndQuat(quat)\n            if startHpr is not None:\n                self.setStartHpr(startHpr)\n            if startQuat is not None:\n                self.setStartQuat(startQuat)\n\n    def privDoEvent(self, t, event):\n        # This function is only used if Python functors were passed in\n        # for some of the input parameters.\n        if self.paramSetup and event == CInterval.ETInitialize:\n            self.setupParam(self.setEndQuat, self.endQuat)\n            self.setupParam(self.setStartHpr, self.startHpr)\n            self.setupParam(self.setStartQuat, self.startQuat)\n        LerpNodePathInterval.privDoEvent(self, t, event)\n\n\nclass LerpScaleInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, scale, startScale = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, fluid = 0, name = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, fluid, nodePath, other)\n        # Check for functors in the input parameters.\n        self.paramSetup = self.anyCallable(scale, startScale)\n        if self.paramSetup:\n            self.endScale = scale\n            self.startScale = startScale\n            self.inPython = 1\n        else:\n            self.setEndScale(scale)\n            if startScale is not None:\n                self.setStartScale(startScale)\n\n    def privDoEvent(self, t, event):\n        # This function is only used if Python functors were passed in\n        # for some of the input parameters.\n        if self.paramSetup and event == CInterval.ETInitialize:\n            self.setupParam(self.setEndScale, self.endScale)\n            self.setupParam(self.setStartScale, self.startScale)\n        LerpNodePathInterval.privDoEvent(self, t, event)\n\n\nclass LerpShearInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, shear, startShear = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, fluid = 0, name = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, fluid, nodePath, other)\n        # Check for functors in the input parameters.\n        self.paramSetup = self.anyCallable(shear, startShear)\n        if self.paramSetup:\n            self.endShear = shear\n            self.startShear = startShear\n            self.inPython = 1\n        else:\n            self.setEndShear(shear)\n            if startShear is not None:\n                self.setStartShear(startShear)\n\n    def privDoEvent(self, t, event):\n        # This function is only used if Python functors were passed in\n        # for some of the input parameters.\n        if self.paramSetup and event == CInterval.ETInitialize:\n            self.setupParam(self.setEndShear, self.endShear)\n            self.setupParam(self.setStartShear, self.startShear)\n        LerpNodePathInterval.privDoEvent(self, t, event)\n\n\nclass LerpPosHprInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, pos, hpr,\n                 startPos = None, startHpr = None, startQuat = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, fluid = 0, name = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, fluid, nodePath, other)\n        # Check for functors in the input parameters.\n        self.paramSetup = self.anyCallable(pos, startPos, hpr, startHpr, startQuat)\n        if self.paramSetup:\n            self.endPos = pos\n            self.startPos = startPos\n            self.endHpr = hpr\n            self.startHpr = startHpr\n            self.startQuat = startQuat\n            self.inPython = 1\n        else:\n            self.setEndPos(pos)\n            if startPos is not None:\n                self.setStartPos(startPos)\n            self.setEndHpr(hpr)\n            if startHpr is not None:\n                self.setStartHpr(startHpr)\n            if startQuat is not None:\n                self.setStartQuat(startQuat)\n\n    def privDoEvent(self, t, event):\n        # This function is only used if Python functors were passed in\n        # for some of the input parameters.\n        if self.paramSetup and event == CInterval.ETInitialize:\n            self.setupParam(self.setEndPos, self.endPos)\n            self.setupParam(self.setStartPos, self.startPos)\n            self.setupParam(self.setEndHpr, self.endHpr)\n            self.setupParam(self.setStartHpr, self.startHpr)\n            self.setupParam(self.setStartQuat, self.startQuat)\n        LerpNodePathInterval.privDoEvent(self, t, event)\n\n\nclass LerpPosQuatInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, pos, quat = None,\n                 startPos = None, startHpr = None, startQuat = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, fluid = 0, name = None, hpr = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, fluid, nodePath, other)\n\n        if not quat:\n            # If we didn't specify a quat, we're allowed to specify a\n            # hpr instead, which is converted to the equivalent quat.\n            assert hpr\n            quat = LOrientationf()\n            quat.setHpr(hpr)\n\n        # Check for functors in the input parameters.\n        self.paramSetup = self.anyCallable(pos, startPos, quat, startHpr, startQuat)\n        if self.paramSetup:\n            self.endPos = pos\n            self.startPos = startPos\n            self.endQuat = quat\n            self.startHpr = startHpr\n            self.startQuat = startQuat\n            self.inPython = 1\n        else:\n            self.setEndPos(pos)\n            if startPos is not None:\n                self.setStartPos(startPos)\n            self.setEndQuat(quat)\n            if startHpr is not None:\n                self.setStartHpr(startHpr)\n            if startQuat is not None:\n                self.setStartQuat(startQuat)\n\n    def privDoEvent(self, t, event):\n        # This function is only used if Python functors were passed in\n        # for some of the input parameters.\n        if self.paramSetup and event == CInterval.ETInitialize:\n            self.setupParam(self.setEndPos, self.endPos)\n            self.setupParam(self.setStartPos, self.startPos)\n            self.setupParam(self.setEndQuat, self.endQuat)\n            self.setupParam(self.setStartHpr, self.startHpr)\n            self.setupParam(self.setStartQuat, self.startQuat)\n        LerpNodePathInterval.privDoEvent(self, t, event)\n\n\nclass LerpHprScaleInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, hpr, scale,\n                 startHpr = None, startQuat = None, startScale = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, fluid = 0, name = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, fluid, nodePath, other)\n\n        # Check for functors in the input parameters.\n        self.paramSetup = self.anyCallable(hpr, startHpr, startQuat, scale, startScale)\n        if self.paramSetup:\n            self.endHpr = hpr\n            self.startHpr = startHpr\n            self.startQuat = startQuat\n            self.endScale = scale\n            self.startScale = startScale\n            self.inPython = 1\n        else:\n            self.setEndHpr(hpr)\n            if startHpr is not None:\n                self.setStartHpr(startHpr)\n            if startQuat is not None:\n                self.setStartQuat(startQuat)\n            self.setEndScale(scale)\n            if startScale is not None:\n                self.setStartScale(startScale)\n\n    def privDoEvent(self, t, event):\n        # This function is only used if Python functors were passed in\n        # for some of the input parameters.\n        if self.paramSetup and event == CInterval.ETInitialize:\n            self.setupParam(self.setEndHpr, self.endHpr)\n            self.setupParam(self.setStartHpr, self.startHpr)\n            self.setupParam(self.setStartQuat, self.startQuat)\n            self.setupParam(self.setEndScale, self.endScale)\n            self.setupParam(self.setStartScale, self.startScale)\n        LerpNodePathInterval.privDoEvent(self, t, event)\n\n\nclass LerpQuatScaleInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, quat = None, scale = None,\n                 hpr = None,\n                 startHpr = None, startQuat = None, startScale = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, fluid = 0, name = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, fluid, nodePath, other)\n\n        if not quat:\n            # If we didn't specify a quat, we're allowed to specify a\n            # hpr instead, which is converted to the equivalent quat.\n            assert hpr\n            quat = LOrientationf()\n            quat.setHpr(hpr)\n\n        assert scale\n\n        # Check for functors in the input parameters.\n        self.paramSetup = self.anyCallable(quat, startHpr, startQuat, scale, startScale)\n        if self.paramSetup:\n            self.endQuat = quat\n            self.startHpr = startHpr\n            self.startQuat = startQuat\n            self.endScale = scale\n            self.startScale = startScale\n            self.inPython = 1\n        else:\n            self.setEndQuat(quat)\n            if startHpr is not None:\n                self.setStartHpr(startHpr)\n            if startQuat is not None:\n                self.setStartQuat(startQuat)\n            self.setEndScale(scale)\n            if startScale is not None:\n                self.setStartScale(startScale)\n\n    def privDoEvent(self, t, event):\n        # This function is only used if Python functors were passed in\n        # for some of the input parameters.\n        if self.paramSetup and event == CInterval.ETInitialize:\n            self.setupParam(self.setEndQuat, self.endQuat)\n            self.setupParam(self.setStartHpr, self.startHpr)\n            self.setupParam(self.setStartQuat, self.startQuat)\n            self.setupParam(self.setEndScale, self.endScale)\n            self.setupParam(self.setStartScale, self.startScale)\n        LerpNodePathInterval.privDoEvent(self, t, event)\n\n\nclass LerpPosHprScaleInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, pos, hpr, scale,\n                 startPos = None, startHpr = None, startQuat = None,\n                 startScale = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, fluid = 0, name = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, fluid, nodePath, other)\n        # Check for functors in the input parameters.\n        self.paramSetup = self.anyCallable(pos, startPos, hpr, startHpr,\n                                           startQuat, scale, startScale)\n        if self.paramSetup:\n            self.endPos = pos\n            self.startPos = startPos\n            self.endHpr = hpr\n            self.startHpr = startHpr\n            self.startQuat = startQuat\n            self.endScale = scale\n            self.startScale = startScale\n            self.inPython = 1\n        else:\n            self.setEndPos(pos)\n            if startPos is not None:\n                self.setStartPos(startPos)\n            self.setEndHpr(hpr)\n            if startHpr is not None:\n                self.setStartHpr(startHpr)\n            if startQuat is not None:\n                self.setStartQuat(startQuat)\n            self.setEndScale(scale)\n            if startScale is not None:\n                self.setStartScale(startScale)\n\n    def privDoEvent(self, t, event):\n        # This function is only used if Python functors were passed in\n        # for some of the input parameters.\n        if self.paramSetup and event == CInterval.ETInitialize:\n            self.setupParam(self.setEndPos, self.endPos)\n            self.setupParam(self.setStartPos, self.startPos)\n            self.setupParam(self.setEndHpr, self.endHpr)\n            self.setupParam(self.setStartHpr, self.startHpr)\n            self.setupParam(self.setStartQuat, self.startQuat)\n            self.setupParam(self.setEndScale, self.endScale)\n            self.setupParam(self.setStartScale, self.startScale)\n        LerpNodePathInterval.privDoEvent(self, t, event)\n\n\nclass LerpPosQuatScaleInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, pos, quat = None, scale = None,\n                 startPos = None, startHpr = None, startQuat = None,\n                 startScale = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, fluid = 0, name = None, hpr = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, fluid, nodePath, other)\n\n        if not quat:\n            # If we didn't specify a quat, we're allowed to specify a\n            # hpr instead, which is converted to the equivalent quat.\n            assert hpr\n            quat = LOrientationf()\n            quat.setHpr(hpr)\n\n        assert scale\n\n        # Check for functors in the input parameters.\n        self.paramSetup = self.anyCallable(pos, startPos, quat, startHpr,\n                                           startQuat, scale, startScale)\n        if self.paramSetup:\n            self.endPos = pos\n            self.startPos = startPos\n            self.endQuat = quat\n            self.startHpr = startHpr\n            self.startQuat = startQuat\n            self.endScale = scale\n            self.startScale = startScale\n            self.inPython = 1\n        else:\n            self.setEndPos(pos)\n            if startPos is not None:\n                self.setStartPos(startPos)\n            self.setEndQuat(quat)\n            if startHpr is not None:\n                self.setStartHpr(startHpr)\n            if startQuat is not None:\n                self.setStartQuat(startQuat)\n            self.setEndScale(scale)\n            if startScale is not None:\n                self.setStartScale(startScale)\n\n    def privDoEvent(self, t, event):\n        # This function is only used if Python functors were passed in\n        # for some of the input parameters.\n        if self.paramSetup and event == CInterval.ETInitialize:\n            self.setupParam(self.setEndPos, self.endPos)\n            self.setupParam(self.setStartPos, self.startPos)\n            self.setupParam(self.setEndQuat, self.endQuat)\n            self.setupParam(self.setStartHpr, self.startHpr)\n            self.setupParam(self.setStartQuat, self.startQuat)\n            self.setupParam(self.setEndScale, self.endScale)\n            self.setupParam(self.setStartScale, self.startScale)\n        LerpNodePathInterval.privDoEvent(self, t, event)\n\n\nclass LerpPosHprScaleShearInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, pos, hpr, scale, shear,\n                 startPos = None, startHpr = None, startQuat = None,\n                 startScale = None, startShear = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, fluid = 0, name = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, fluid, nodePath, other)\n        # Check for functors in the input parameters.\n        self.paramSetup = self.anyCallable(pos, startPos, hpr, startHpr,\n                                           startQuat, scale, startScale,\n                                           shear, startShear)\n        if self.paramSetup:\n            self.endPos = pos\n            self.startPos = startPos\n            self.endHpr = hpr\n            self.startHpr = startHpr\n            self.startQuat = startQuat\n            self.endScale = scale\n            self.startScale = startScale\n            self.endShear = shear\n            self.startShear = startShear\n            self.inPython = 1\n        else:\n            self.setEndPos(pos)\n            if startPos is not None:\n                self.setStartPos(startPos)\n            self.setEndHpr(hpr)\n            if startHpr is not None:\n                self.setStartHpr(startHpr)\n            if startQuat is not None:\n                self.setStartQuat(startQuat)\n            self.setEndScale(scale)\n            if startScale is not None:\n                self.setStartScale(startScale)\n            self.setEndShear(shear)\n            if startShear is not None:\n                self.setStartShear(startShear)\n\n    def privDoEvent(self, t, event):\n        # This function is only used if Python functors were passed in\n        # for some of the input parameters.\n        if self.paramSetup and event == CInterval.ETInitialize:\n            self.setupParam(self.setEndPos, self.endPos)\n            self.setupParam(self.setStartPos, self.startPos)\n            self.setupParam(self.setEndHpr, self.endHpr)\n            self.setupParam(self.setStartHpr, self.startHpr)\n            self.setupParam(self.setStartQuat, self.startQuat)\n            self.setupParam(self.setEndScale, self.endScale)\n            self.setupParam(self.setStartScale, self.startScale)\n            self.setupParam(self.setEndShear, self.endShear)\n            self.setupParam(self.setStartShear, self.startShear)\n        LerpNodePathInterval.privDoEvent(self, t, event)\n\n\nclass LerpPosQuatScaleShearInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, pos, quat = None, scale = None,\n                 shear = None,\n                 startPos = None, startHpr = None, startQuat = None,\n                 startScale = None, startShear = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, fluid = 0, name = None, hpr = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, fluid, nodePath, other)\n\n        if not quat:\n            # If we didn't specify a quat, we're allowed to specify a\n            # hpr instead, which is converted to the equivalent quat.\n            assert hpr\n            quat = LOrientationf()\n            quat.setHpr(hpr)\n\n        assert scale\n        assert shear\n\n        # Check for functors in the input parameters.\n        self.paramSetup = self.anyCallable(pos, startPos, quat, startHpr,\n                                           startQuat, scale, startScale,\n                                           shear, startShear)\n        if self.paramSetup:\n            self.endPos = pos\n            self.startPos = startPos\n            self.endQuat = quat\n            self.startHpr = startHpr\n            self.startQuat = startQuat\n            self.endScale = scale\n            self.startScale = startScale\n            self.endShear = shear\n            self.startShear = startShear\n            self.inPython = 1\n        else:\n            self.setEndPos(pos)\n            if startPos is not None:\n                self.setStartPos(startPos)\n            self.setEndQuat(quat)\n            if startHpr is not None:\n                self.setStartHpr(startHpr)\n            if startQuat is not None:\n                self.setStartQuat(startQuat)\n            self.setEndScale(scale)\n            if startScale is not None:\n                self.setStartScale(startScale)\n            self.setEndShear(shear)\n            if startShear is not None:\n                self.setStartShear(startShear)\n\n    def privDoEvent(self, t, event):\n        # This function is only used if Python functors were passed in\n        # for some of the input parameters.\n        if self.paramSetup and event == CInterval.ETInitialize:\n            self.setupParam(self.setEndPos, self.endPos)\n            self.setupParam(self.setStartPos, self.startPos)\n            self.setupParam(self.setEndQuat, self.endQuat)\n            self.setupParam(self.setStartHpr, self.startHpr)\n            self.setupParam(self.setStartQuat, self.startQuat)\n            self.setupParam(self.setEndScale, self.endScale)\n            self.setupParam(self.setStartScale, self.startScale)\n            self.setupParam(self.setEndShear, self.endShear)\n            self.setupParam(self.setStartShear, self.startShear)\n        LerpNodePathInterval.privDoEvent(self, t, event)\n\n\nclass LerpColorInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, color, startColor = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, name = None, override = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, 0, nodePath, other)\n        self.setEndColor(color)\n        if startColor is not None:\n            self.setStartColor(startColor)\n        if override is not None:\n            self.setOverride(override)\n\n\nclass LerpColorScaleInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, colorScale, startColorScale = None,\n                 other = None, blendType = 'noBlend',\n                 bakeInStart = 1, name = None, override = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, 0, nodePath, other)\n        self.setEndColorScale(colorScale)\n        if startColorScale is not None:\n            self.setStartColorScale(startColorScale)\n        if override is not None:\n            self.setOverride(override)\n\n\nclass LerpTexOffsetInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, texOffset, startTexOffset = None,\n                 other = None, blendType = 'noBlend',\n                 textureStage = None,\n                 bakeInStart = 1, name = None, override = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, 0, nodePath, other)\n        self.setEndTexOffset(texOffset)\n        if startTexOffset is not None:\n            self.setStartTexOffset(startTexOffset)\n        if textureStage is not None:\n            self.setTextureStage(textureStage)\n        if override is not None:\n            self.setOverride(override)\n\n\nclass LerpTexRotateInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, texRotate, startTexRotate = None,\n                 other = None, blendType = 'noBlend',\n                 textureStage = None,\n                 bakeInStart = 1, name = None, override = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, 0, nodePath, other)\n        self.setEndTexRotate(texRotate)\n        if startTexRotate is not None:\n            self.setStartTexRotate(startTexRotate)\n        if textureStage is not None:\n            self.setTextureStage(textureStage)\n        if override is not None:\n            self.setOverride(override)\n\n\nclass LerpTexScaleInterval(LerpNodePathInterval):\n    def __init__(self, nodePath, duration, texScale, startTexScale = None,\n                 other = None, blendType = 'noBlend',\n                 textureStage = None,\n                 bakeInStart = 1, name = None, override = None):\n        LerpNodePathInterval.__init__(self, name, duration, blendType,\n                                      bakeInStart, 0, nodePath, other)\n        self.setEndTexScale(texScale)\n        if startTexScale is not None:\n            self.setStartTexScale(startTexScale)\n        if textureStage is not None:\n            self.setTextureStage(textureStage)\n        if override is not None:\n            self.setOverride(override)\n\n\n#\n# The remaining intervals defined in this module are the old-school\n# Python-based intervals.\n#\n\n\nclass LerpFunctionNoStateInterval(Interval.Interval):\n    \"\"\"\n    Class used to execute a function over time.  Function can access fromData\n    and toData to perform blend.  If fromData and toData not specified, will\n    execute the given function passing in values ranging from 0 to 1\n\n    This is different from a standard LerpFunction, in that it assumes\n    the function is not modifying any state that needs to be kept; so\n    that it will only call the function while the lerp is actually\n    running, and will not be guaranteed to call the function with its\n    final value of the lerp.  In particular, if the lerp interval\n    happens to get skipped over completely, it will not bother to call\n    the function at all.\n    \"\"\"\n\n    # Interval counter\n    lerpFunctionIntervalNum = 1\n    # create LerpFunctionInterval DirectNotify category\n    notify = directNotify.newCategory('LerpFunctionNoStateInterval')\n    # Class methods\n\n    def __init__(self, function, duration = 0.0, fromData = 0, toData = 1,\n                 blendType = 'noBlend', extraArgs = [], name = None):\n        \"\"\"__init__(function, duration, fromData, toData, name)\n        \"\"\"\n        # Record instance variables\n        self.function = function\n        self.fromData = fromData\n        self.toData = toData\n        self.blendType = LerpBlendHelpers.getBlend(blendType)\n        self.extraArgs = extraArgs\n        # Generate unique name if necessary\n        if name is None:\n            name = ('LerpFunctionInterval-%d' %\n                    LerpFunctionNoStateInterval.lerpFunctionIntervalNum)\n            LerpFunctionNoStateInterval.lerpFunctionIntervalNum += 1\n        else:\n            # Allow the user to pass in a %d in the name and we'll go ahead\n            # and uniquify the name for them.\n            if \"%d\" in name:\n                name = name % LerpFunctionNoStateInterval.lerpFunctionIntervalNum\n                LerpFunctionNoStateInterval.lerpFunctionIntervalNum += 1\n\n        # Initialize superclass\n        Interval.Interval.__init__(self, name, duration)\n\n    #def privDoEvent(self, t, event):\n        #print(\"doing event\", t, event)\n        #bt = self.blendType(t/self.duration)\n        #data = (self.fromData * (1 - bt)) + (self.toData * bt)\n        ## Evaluate function\n        #apply(self.function, [data] + self.extraArgs)\n        #self.state = CInterval.SStarted\n        #self.currT = t\n\n    def privStep(self, t):\n        # Evaluate the function\n        #print(\"doing priv step\", t)\n        if t >= self.duration:\n            # Set to end value\n            if t > self.duration:\n                print(\"after end\")\n            #apply(self.function, [self.toData] + self.extraArgs)\n        elif self.duration == 0.0:\n            # Zero duration, just use endpoint\n            self.function(*[self.toData] + self.extraArgs)\n        else:\n            # In the middle of the lerp, compute appropriate blended value\n            bt = self.blendType(t/self.duration)\n            data = (self.fromData * (1 - bt)) + (self.toData * bt)\n            # Evaluate function\n            self.function(*[data] + self.extraArgs)\n\n        # Print debug information\n        #assert self.notify.debug('updateFunc() - %s: t = %f' % (self.name, t))\n\n        self.state = CInterval.SStarted\n        self.currT = t\n\n# New interface\n\n\nclass LerpFuncNS(LerpFunctionNoStateInterval):\n    def __init__(self, *args, **kw):\n        LerpFunctionNoStateInterval.__init__(self, *args, **kw)\n\n\nclass LerpFunctionInterval(Interval.Interval):\n    \"\"\"\n    Class used to execute a function over time.  Function can access fromData\n    and toData to perform blend.  If fromData and toData not specified, will\n    execute the given function passing in values ranging from 0 to 1\n    \"\"\"\n\n    # Interval counter\n    lerpFunctionIntervalNum = 1\n    # create LerpFunctionInterval DirectNotify category\n    notify = directNotify.newCategory('LerpFunctionInterval')\n    # Class methods\n\n    def __init__(self, function, duration = 0.0, fromData = 0, toData = 1,\n                 blendType = 'noBlend', extraArgs = [], name = None):\n        \"\"\"__init__(function, duration, fromData, toData, name)\n        \"\"\"\n        # Record instance variables\n        self.function = function\n        self.fromData = fromData\n        self.toData = toData\n        self.blendType = LerpBlendHelpers.getBlend(blendType)\n        self.extraArgs = extraArgs\n        # Generate unique name if necessary\n        if name is None:\n            if hasattr(function, '__name__'):\n                name = function.__name__\n            else:\n                name = '<' + function.__class__.__name__ + '>'\n            name = ('LerpFunctionInterval-%s-%d' %\n                    (name,\n                     LerpFunctionInterval.lerpFunctionIntervalNum))\n            LerpFunctionInterval.lerpFunctionIntervalNum += 1\n        else:\n            # Allow the user to pass in a %d in the name and we'll go ahead\n            # and uniquify the name for them.\n            if \"%d\" in name:\n                name = name % LerpFunctionInterval.lerpFunctionIntervalNum\n                LerpFunctionInterval.lerpFunctionIntervalNum += 1\n\n        # Initialize superclass\n        Interval.Interval.__init__(self, name, duration)\n\n    def privStep(self, t):\n        # Evaluate the function\n        #print(\"doing priv step\", t)\n        if t >= self.duration:\n            # Set to end value\n            self.function(*[self.toData] + self.extraArgs)\n        elif self.duration == 0.0:\n            # Zero duration, just use endpoint\n            self.function(*[self.toData] + self.extraArgs)\n        else:\n            # In the middle of the lerp, compute appropriate blended value\n            bt = self.blendType(t/self.duration)\n            data = (self.fromData * (1 - bt)) + (self.toData * bt)\n            # Evaluate function\n            self.function(*[data] + self.extraArgs)\n\n        # Print debug information\n        #assert self.notify.debug('updateFunc() - %s: t = %f' % (self.name, t))\n\n        self.state = CInterval.SStarted\n        self.currT = t\n\n# New interface\n\n\nclass LerpFunc(LerpFunctionInterval):\n    def __init__(self, *args, **kw):\n        LerpFunctionInterval.__init__(self, *args, **kw)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/interval/LerpInterval.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/d377e678_LerpInterval.json",
    "doc_id": "doc_156"
  }
}