{
  "content": "\"\"\"\nDefines ObjectMgrBase\n\"\"\"\n\nimport os\nimport time\nimport copy\n\nfrom panda3d.core import ConfigVariableString, Filename, Mat4, NodePath\nfrom direct.actor.Actor import Actor\nfrom direct.showbase.PythonUtil import Functor\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom .ActionMgr import ActionTransformObj, ActionUpdateObjectProp\nfrom . import ObjectGlobals as OG\n\n\n# python wrapper around a panda.NodePath object\nclass PythonNodePath(NodePath):\n    def __init__(self,node):\n        NodePath.__init__(self, node)\n\n\nclass ObjectMgrBase:\n    \"\"\" ObjectMgr will create, manage, update objects in the scene \"\"\"\n\n    def __init__(self, editor):\n        self.editor = editor\n\n        # main obj repository of objects in the scene\n        self.objects = {}\n        self.npIndex = {}\n        self.saveData = []\n        self.objectsLastXform = {}\n\n        self.lastUid = ''\n        self.lastUidMode = 0\n        self.currNodePath = None\n        self.currLiveNP = None\n\n        self.Actor = []\n        self.findActors(base.render)\n        self.Nodes = []\n        self.findNodes(base.render)\n\n    def reset(self):\n        base.direct.deselectAllCB()\n\n        for id in list(self.objects.keys()):\n            try:\n                self.objects[id][OG.OBJ_NP].removeNode()\n            except Exception:\n                pass\n            del self.objects[id]\n\n        for np in list(self.npIndex.keys()):\n            del self.npIndex[np]\n\n        self.objects = {}\n        self.npIndex = {}\n        self.saveData = []\n        self.Actor = []\n        self.Nodes = []\n\n    def genUniqueId(self):\n        # [gjeon] to solve the problem of unproper $USERNAME\n        userId = os.path.basename(os.path.expandvars('$USERNAME'))\n        if userId == '':\n            userId = ConfigVariableString(\"le-user-id\").value\n        if userId == '':\n            userId = 'unknown'\n        newUid = str(time.time()) + userId\n        # prevent duplicates from being generated in the same frame (this can\n        # happen when creating several new objects at once)\n        if self.lastUid == newUid:\n            # append a value to the end to uniquify the id\n            newUid = newUid + str(self.lastUidMod)\n            self.lastUidMod = self.lastUidMod + 1\n        else:\n            self.lastUid = newUid\n            self.lastUidMod = 0\n        return newUid\n\n    def addNewCurveFromFile(self, curveInfo, degree, uid=None, parent=None, fSelectObject=True, nodePath=None):\n        \"\"\" function to add new curve to the scene from file\"\"\"\n        curve = []\n        curveControl = []\n\n        #transfer the curve information from simple positions into control nodes\n        for item in curveInfo:\n            controler = base.render.attachNewNode(\"controler\")\n            controler = base.loader.loadModel('models/misc/smiley')\n            controlerPathname = f'controler{item[0]}'\n            controler.setName(controlerPathname)\n            controler.setPos(item[1])\n            controler.setColor(0, 0, 0, 1)\n            controler.setScale(0.2)\n            controler.reparentTo(base.render)\n            controler.setTag('OBJRoot', '1')\n            controler.setTag('Controller', '1')\n            curve.append((None, item[1]))\n            curveControl.append((item[0], controler))\n\n        self.editor.curveEditor.degree = degree\n        self.editor.curveEditor.ropeUpdate(curve)\n        #add new curve to the scene\n        curveObjNP = self.addNewCurve(curveControl, degree, uid, parent, fSelectObject, nodePath=self.editor.curveEditor.currentRope)\n        curveObj = self.findObjectByNodePath(curveObjNP)\n        self.editor.objectMgr.updateObjectPropValue(curveObj, 'Degree', degree, fSelectObject=False, fUndo=False)\n\n        for item in curveControl:\n            item[1].reparentTo(curveObjNP)\n            item[1].hide()\n\n        curveControl = []\n        curve = []\n        self.editor.curveEditor.currentRope = None\n\n        return curveObjNP\n\n    def addNewCurve(self, curveInfo, degree, uid=None, parent=None, fSelectObject=True, nodePath=None):\n        \"\"\" function to add new curve to the scene\"\"\"\n        if parent is None:\n            parent = self.editor.NPParent\n\n        if uid is None:\n            uid = self.genUniqueId()\n\n        if self.editor:\n            objDef = self.editor.objectPalette.findItem('__Curve__')\n\n        if nodePath is None:\n            # we need to create curve\n            # and then create newobj with newly created curve\n            pass\n        else:\n            newobj = nodePath\n\n        newobj.reparentTo(parent)\n        newobj.setTag('OBJRoot', '1')\n\n        # populate obj data using default values\n        properties = {}\n        for key in objDef.properties.keys():\n            properties[key] = objDef.properties[key][OG.PROP_DEFAULT]\n\n        properties['Degree'] = degree\n        properties['curveInfo'] = curveInfo\n\n        # insert obj data to main repository\n        self.objects[uid] = [uid, newobj, objDef, None, None, properties, (1,1,1,1)]\n        self.npIndex[NodePath(newobj)] = uid\n\n        if self.editor:\n            if fSelectObject:\n                self.editor.select(newobj, fUndo=0)\n            self.editor.ui.sceneGraphUI.add(newobj, parent)\n            self.editor.fNeedToSave = True\n\n        return newobj\n\n    def addNewObject(self, typeName, uid = None, model = None, parent=None, anim = None, fSelectObject=True, nodePath=None, nameStr=None):\n        \"\"\" function to add new obj to the scene \"\"\"\n        if parent is None:\n            parent = self.editor.NPParent\n\n        if uid is None:\n            uid = self.genUniqueId()\n\n        if self.editor:\n            objDef = self.editor.objectPalette.findItem(typeName)\n            if objDef is None:\n                objDef = self.editor.protoPalette.findItem(typeName)\n        else: # when loaded outside of LE\n            objDef = base.objectPalette.findItem(typeName)\n            if objDef is None:\n                objDef = base.protoPalette.findItem(typeName)\n        newobj = None\n        if objDef and not isinstance(objDef, dict):\n            if not hasattr(objDef, 'createFunction'):\n                return newobj\n            if nodePath is None:\n                if objDef.createFunction:\n                    funcName = objDef.createFunction[OG.FUNC_NAME]\n                    funcArgs = copy.deepcopy(objDef.createFunction[OG.FUNC_ARGS])\n\n                    for pair in list(funcArgs.items()):\n                        if pair[1] == OG.ARG_NAME:\n                            funcArgs[pair[0]] = nameStr\n                        elif pair[1] == OG.ARG_PARENT:\n                            funcArgs[pair[0]] = parent\n\n                    if isinstance(funcName, str):\n                        if funcName.startswith('.'):\n                            # when it's using default objectHandler\n                            if self.editor:\n                                func = Functor(getattr(self.editor, \"objectHandler%s\"%funcName))\n                            else: # when loaded outside of LE\n                                func = Functor(getattr(base, \"objectHandler%s\"%funcName))\n                        else:\n                            # when it's not using default objectHandler, whole name of the handling obj\n                            # should be included in function name\n                            func = Functor(eval(funcName))\n                    else:\n                        func = funcName\n                    # create new obj using function and keyword arguments defined in ObjectPalette\n                    newobj = func(**funcArgs)\n                elif objDef.actor:\n                    if model is None:\n                        model = objDef.model\n                    try:\n                        newobj = Actor(model)\n                    except Exception:\n                        newobj = Actor(Filename.fromOsSpecific(model).getFullpath())\n                    if hasattr(objDef, 'animDict') and objDef.animDict != {}:\n                        objDef.anims = objDef.animDict.get(model)\n\n                elif objDef.model is not None:\n                    # since this obj is simple model let's load the model\n                    if model is None:\n                        model = objDef.model\n                    try:\n                        newobjModel = base.loader.loadModel(model)\n                    except Exception:\n                        newobjModel = base.loader.loadModel(Filename.fromOsSpecific(model).getFullpath(), okMissing=True)\n                    if newobjModel:\n                        self.flatten(newobjModel, model, objDef, uid)\n                        newobj = PythonNodePath(newobjModel)\n                    else:\n                        newobj = None\n\n                else:\n                    newobj = hidden.attachNewNode(objDef.name)\n            else:\n                newobj = nodePath\n\n            i = 0\n            for i in range(len(objDef.anims)):\n                animFile = objDef.anims[i]\n                # load new anim\n                animName = os.path.basename(animFile)\n                if i < len(objDef.animNames):\n                    animName = objDef.animNames[i]\n                newAnim = newobj.loadAnims({animName:animFile})\n\n                if anim:\n                    if anim == animFile:\n                        newobj.loop(animName)\n                else:\n                    if i == 0:\n                        anim = animFile\n                        newobj.loop(animName)\n\n            if newobj is None:\n                return None\n\n            newobj.reparentTo(parent)\n            newobj.setTag('OBJRoot', '1')\n\n            # populate obj data using default values\n            properties = {}\n            for key in objDef.properties.keys():\n                properties[key] = objDef.properties[key][OG.PROP_DEFAULT]\n\n            # insert obj data to main repository\n            self.objects[uid] = [uid, newobj, objDef, model, anim, properties, (1,1,1,1)]\n            self.npIndex[NodePath(newobj)] = uid\n\n            if self.editor:\n                if fSelectObject:\n                    self.editor.select(newobj, fUndo=0)\n                self.editor.ui.sceneGraphUI.add(newobj, parent)\n                self.editor.fNeedToSave = True\n        return newobj\n\n    def removeObjectById(self, uid):\n        obj = self.findObjectById(uid)\n        nodePath = obj[OG.OBJ_NP]\n\n        for i in range(0, len(self.Actor)):\n            if self.Actor[i] == obj:\n                del self.Actor[i]\n                break\n        for i in range(0, len(self.Nodes)):\n            if self.Nodes[i][OG.OBJ_UID] == uid:\n                del self.Nodes[i]\n                break\n        self.editor.animMgr.removeAnimInfo(obj[OG.OBJ_UID])\n\n        del self.objects[uid]\n        del self.npIndex[nodePath]\n\n        # remove children also\n        for child in nodePath.getChildren():\n            if child.hasTag('OBJRoot'):\n                self.removeObjectByNodePath(child)\n        nodePath.remove()\n\n        self.editor.fNeedToSave = True\n\n    def removeObjectByNodePath(self, nodePath):\n        uid = self.npIndex.get(nodePath)\n        if uid:\n            for i in range(0, len(self.Actor)):\n                if self.Actor[i][OG.OBJ_UID] == uid:\n                    del self.Actor[i]\n                    break\n            for i in range(0, len(self.Nodes)):\n                if self.Nodes[i][OG.OBJ_UID] == uid:\n                    del self.Nodes[i]\n                    break\n            self.editor.animMgr.removeAnimInfo(uid)\n\n            del self.objects[uid]\n            del self.npIndex[nodePath]\n\n        # remove children also\n        for child in nodePath.getChildren():\n            if child.hasTag('OBJRoot'):\n                self.removeObjectByNodePath(child)\n        self.editor.fNeedToSave = True\n\n    def findObjectById(self, uid):\n        return self.objects.get(uid)\n\n    def findObjectByNodePath(self, nodePath):\n        uid = self.npIndex.get(NodePath(nodePath))\n        if uid is None:\n            return None\n        else:\n            return self.objects[uid]\n\n    def findObjectByNodePathBelow(self, nodePath):\n        for ancestor in nodePath.getAncestors():\n            if ancestor.hasTag('OBJRoot'):\n                return self.findObjectByNodePath(ancestor)\n\n        return None\n\n    def findObjectsByTypeName(self, typeName):\n        results = []\n        for uid in self.objects.keys():\n            obj = self.objects[uid]\n            if obj[OG.OBJ_DEF].name == typeName:\n                results.append(obj)\n\n        return results\n\n    def deselectAll(self):\n        self.currNodePath = None\n        taskMgr.remove('_le_updateObjectUITask')\n        self.editor.ui.objectPropertyUI.clearPropUI()\n        self.editor.ui.sceneGraphUI.tree.UnselectAll()\n\n    def selectObject(self, nodePath, fLEPane=0):\n        obj = self.findObjectByNodePath(nodePath)\n        if obj is None:\n            return\n        self.selectObjectCB(obj, fLEPane)\n\n    def selectObjectCB(self, obj, fLEPane):\n        self.currNodePath = obj[OG.OBJ_NP]\n        self.objectsLastXform[obj[OG.OBJ_UID]] = Mat4(self.currNodePath.getMat())\n        # [gjeon] to connect transform UI with nodepath's transform\n        self.spawnUpdateObjectUITask()\n        self.updateObjectPropertyUI(obj)\n        #import pdb;pdb.set_trace()\n        if fLEPane == 0:\n            self.editor.ui.sceneGraphUI.select(obj[OG.OBJ_UID])\n\n        if not obj[OG.OBJ_DEF].movable:\n            if base.direct.widget.fActive:\n                base.direct.widget.toggleWidget()\n\n    def updateObjectPropertyUI(self, obj):\n        objDef = obj[OG.OBJ_DEF]\n        objProp = obj[OG.OBJ_PROP]\n        self.editor.ui.objectPropertyUI.updateProps(obj, objDef.movable)\n        self.editor.fNeedToSave = True\n\n    def onEnterObjectPropUI(self, event):\n        taskMgr.remove('_le_updateObjectUITask')\n        self.editor.ui.bindKeyEvents(False)\n\n    def onLeaveObjectPropUI(self, event):\n        self.spawnUpdateObjectUITask()\n        self.editor.ui.bindKeyEvents(True)\n\n    def spawnUpdateObjectUITask(self):\n        if self.currNodePath is None:\n            return\n\n        taskMgr.remove('_le_updateObjectUITask')\n        t = Task.Task(self.updateObjectUITask)\n        t.np = self.currNodePath\n        taskMgr.add(t, '_le_updateObjectUITask')\n\n    def updateObjectUITask(self, state):\n        self.editor.ui.objectPropertyUI.propX.setValue(state.np.getX())\n        self.editor.ui.objectPropertyUI.propY.setValue(state.np.getY())\n        self.editor.ui.objectPropertyUI.propZ.setValue(state.np.getZ())\n\n        h = state.np.getH()\n        while h < 0:\n            h = h + 360.0\n\n        while h > 360:\n            h = h - 360.0\n\n        p = state.np.getP()\n        while p < 0:\n            p = p + 360.0\n\n        while p > 360:\n            p = p - 360.0\n\n        r = state.np.getR()\n        while r < 0:\n            r = r + 360.0\n\n        while r > 360:\n            r = r - 360.0\n\n        self.editor.ui.objectPropertyUI.propH.setValue(h)\n        self.editor.ui.objectPropertyUI.propP.setValue(p)\n        self.editor.ui.objectPropertyUI.propR.setValue(r)\n\n        self.editor.ui.objectPropertyUI.propSX.setValue(state.np.getSx())\n        self.editor.ui.objectPropertyUI.propSY.setValue(state.np.getSy())\n        self.editor.ui.objectPropertyUI.propSZ.setValue(state.np.getSz())\n\n        return Task.cont\n\n    def updateObjectTransform(self, event):\n        if self.currNodePath is None:\n            return\n\n        np = hidden.attachNewNode('temp')\n        np.setX(float(self.editor.ui.objectPropertyUI.propX.getValue()))\n        np.setY(float(self.editor.ui.objectPropertyUI.propY.getValue()))\n        np.setZ(float(self.editor.ui.objectPropertyUI.propZ.getValue()))\n\n        h = float(self.editor.ui.objectPropertyUI.propH.getValue())\n        while h < 0:\n            h = h + 360.0\n\n        while h > 360:\n            h = h - 360.0\n\n        p = float(self.editor.ui.objectPropertyUI.propP.getValue())\n        while p < 0:\n            p = p + 360.0\n\n        while p > 360:\n            p = p - 360.0\n\n        r = float(self.editor.ui.objectPropertyUI.propR.getValue())\n        while r < 0:\n            r = r + 360.0\n\n        while r > 360:\n            r = r - 360.0\n\n        np.setH(h)\n        np.setP(p)\n        np.setR(r)\n\n        np.setSx(float(self.editor.ui.objectPropertyUI.propSX.getValue()))\n        np.setSy(float(self.editor.ui.objectPropertyUI.propSY.getValue()))\n        np.setSz(float(self.editor.ui.objectPropertyUI.propSZ.getValue()))\n\n        obj = self.findObjectByNodePath(self.currNodePath)\n        action = ActionTransformObj(self.editor, obj[OG.OBJ_UID], Mat4(np.getMat()))\n        self.editor.actionMgr.push(action)\n        np.remove()\n        action()\n        self.editor.fNeedToSave = True\n\n    def setObjectTransform(self, uid, xformMat):\n        obj = self.findObjectById(uid)\n        if obj:\n            obj[OG.OBJ_NP].setMat(xformMat)\n        self.editor.fNeedToSave = True\n\n    def updateObjectColor(self, r, g, b, a, np=None):\n        if np is None:\n            np = self.currNodePath\n\n        obj = self.findObjectByNodePath(np)\n        if not obj:\n            return\n        obj[OG.OBJ_RGBA] = (r,g,b,a)\n        for child in np.getChildren():\n            if not child.hasTag('OBJRoot') and\\\n               not child.hasTag('_le_sys') and\\\n               child.getName() != 'bboxLines':\n                child.setTransparency(1)\n                child.setColorScale(r, g, b, a)\n        self.editor.fNeedToSave = True\n\n    def updateObjectModel(self, model, obj, fSelectObject=True):\n        \"\"\" replace object's model \"\"\"\n        if obj[OG.OBJ_MODEL] != model:\n            base.direct.deselectAllCB()\n\n            objNP = obj[OG.OBJ_NP]\n            objDef = obj[OG.OBJ_DEF]\n            objRGBA = obj[OG.OBJ_RGBA]\n            uid = obj[OG.OBJ_UID]\n\n            # load new model\n            if objDef.actor:\n                try:\n                    newobj = Actor(model)\n                except Exception:\n                    newobj = Actor(Filename.fromOsSpecific(model).getFullpath())\n            else:\n                newobjModel = base.loader.loadModel(model, okMissing=True)\n                if newobjModel is None:\n                    print(\"Can't load model %s\"%model)\n                    return\n                self.flatten(newobjModel, model, objDef, uid)\n                newobj = PythonNodePath(newobjModel)\n            newobj.setTag('OBJRoot', '1')\n\n            # reparent children\n            objNP.findAllMatches(\"=OBJRoot\").reparentTo(newobj)\n\n            # reparent to parent\n            newobj.reparentTo(objNP.getParent())\n\n            # copy transform\n            newobj.setPos(objNP.getPos())\n            newobj.setHpr(objNP.getHpr())\n            newobj.setScale(objNP.getScale())\n\n            # copy RGBA data\n            self.updateObjectColor(objRGBA[0], objRGBA[1], objRGBA[2], objRGBA[3], newobj)\n\n            # delete old geom\n            del self.npIndex[NodePath(objNP)]\n            objNP.removeNode()\n\n            # register new geom\n            obj[OG.OBJ_NP] = newobj\n            obj[OG.OBJ_MODEL] = model\n            self.npIndex[NodePath(newobj)] = obj[OG.OBJ_UID]\n\n            # update scene graph label\n            self.editor.ui.sceneGraphUI.changeLabel(obj[OG.OBJ_UID], newobj.getName())\n\n            self.editor.fNeedToSave = True\n            # update anim if necessary\n            animList = obj[OG.OBJ_DEF].animDict.get(model)\n            if animList:\n                self.updateObjectAnim(animList[0], obj, fSelectObject=fSelectObject)\n            else:\n                if fSelectObject:\n                    base.direct.select(newobj, fUndo=0)\n\n    def updateObjectAnim(self, anim, obj, fSelectObject=True):\n        \"\"\" replace object's anim \"\"\"\n        if obj[OG.OBJ_ANIM] != anim:\n            base.direct.deselectAllCB()\n            objNP = obj[OG.OBJ_NP]\n\n            # load new anim\n            animName = os.path.basename(anim)\n            newAnim = objNP.loadAnims({animName:anim})\n            objNP.loop(animName)\n            obj[OG.OBJ_ANIM] = anim\n            if fSelectObject:\n                base.direct.select(objNP, fUndo=0)\n\n            self.editor.fNeedToSave = True\n\n    def updateObjectModelFromUI(self, event, obj):\n        \"\"\" replace object's model with one selected from UI \"\"\"\n        model = event.GetString()\n        if model is not None:\n            self.updateObjectModel(model, obj)\n\n    def updateObjectAnimFromUI(self, event, obj):\n        \"\"\" replace object's anim with one selected from UI \"\"\"\n        anim = event.GetString()\n        if anim is not None:\n            self.updateObjectAnim(anim, obj)\n\n    def updateObjectProperty(self, event, obj, propName):\n        \"\"\"\n        When an obj's property is updated in UI,\n        this will update it's value in data structure.\n        And call update function if defined.\n        \"\"\"\n\n        objDef = obj[OG.OBJ_DEF]\n        objProp = obj[OG.OBJ_PROP]\n\n        propDef = objDef.properties[propName]\n        if propDef is None:\n            return\n\n        propType = propDef[OG.PROP_TYPE]\n        propDataType = propDef[OG.PROP_DATATYPE]\n\n        if propType == OG.PROP_UI_SLIDE:\n            if len(propDef) <= OG.PROP_RANGE:\n                return\n\n            strVal = event.GetString()\n            if strVal == '':\n                min = float(propDef[OG.PROP_RANGE][OG.RANGE_MIN])\n                max = float(propDef[OG.PROP_RANGE][OG.RANGE_MAX])\n                intVal = event.GetInt()\n                if intVal is None:\n                    return\n                val = intVal / 100.0 * (max - min) + min\n            else:\n                val = strVal\n\n        elif propType == OG.PROP_UI_ENTRY:\n            val = event.GetString()\n\n        elif propType == OG.PROP_UI_SPIN:\n            val = event.GetInt()\n\n        elif propType == OG.PROP_UI_CHECK:\n            if event.GetInt():\n                val = True\n            else:\n                val = False\n\n        elif propType == OG.PROP_UI_RADIO:\n            val = event.GetString()\n\n        elif propType == OG.PROP_UI_COMBO:\n            val = event.GetString()\n\n        elif propType == OG.PROP_UI_COMBO_DYNAMIC:\n            val = event.GetString()\n\n        else:\n            # unsupported property type\n            return\n\n        # now update object prop value and call update function\n        self.updateObjectPropValue(obj, propName, val, \\\n                                   fSelectObject=(propType != OG.PROP_UI_SLIDE)\n                                   )\n\n    def updateObjectPropValue(self, obj, propName, val, fSelectObject=False, fUndo=True):\n        \"\"\"\n        Update object property value and\n        call update function if defined.\n        \"\"\"\n        objDef = obj[OG.OBJ_DEF]\n        objProp = obj[OG.OBJ_PROP]\n\n        propDef = objDef.properties[propName]\n        propDataType = propDef[OG.PROP_DATATYPE]\n\n        if propDataType != OG.PROP_BLIND:\n            val = OG.TYPE_CONV[propDataType](val)\n            oldVal = objProp[propName]\n\n            if propDef[OG.PROP_FUNC] is None:\n                func = None\n                undoFunc = None\n            else:\n                funcName = propDef[OG.PROP_FUNC][OG.FUNC_NAME]\n                funcArgs = propDef[OG.PROP_FUNC][OG.FUNC_ARGS]\n\n                # populate keyword arguments\n                kwargs = {}\n                undoKwargs = {}\n                for key in funcArgs.keys():\n                    if funcArgs[key] == OG.ARG_VAL:\n                        kwargs[key] = val\n                        undoKwargs[key] = oldVal\n                    elif funcArgs[key] == OG.ARG_OBJ:\n                        undoKwargs[key] = obj\n                        objProp[propName] = val\n                        kwargs[key] = obj\n                    elif funcArgs[key] == OG.ARG_NOLOADING:\n                        kwargs[key] = fSelectObject\n                        undoKwargs[key] = fSelectObject\n                    else:\n                        kwargs[key] = funcArgs[key]\n                        undoKwargs[key] = funcArgs[key]\n\n                if isinstance(funcName, str):\n                    if funcName.startswith('.'):\n                        if self.editor:\n                            func = Functor(getattr(self.editor, \"objectHandler%s\"%funcName), **kwargs)\n                            undoFunc = Functor(getattr(self.editor, \"objectHandler%s\"%funcName), **undoKwargs)\n                        else: # when loaded outside of LE\n                            func = Functor(getattr(base, \"objectHandler%s\"%funcName), **kwargs)\n                            undoFunc = Functor(getattr(base, \".objectHandler%s\"%funcName), **undoKwargs)\n                    else:\n                        func = Functor(eval(funcName), **kwargs)\n                        undoFunc = Functor(eval(funcName), **undoKwargs)\n                else:\n                    func = Functor(funcName, **kwargs)\n                    undoFunc = Functor(funcName, **undoKwargs)\n\n                # finally call update function\n                #func(**kwargs)\n        else:\n            oldVal = objProp[propName]\n            func = None\n            undoFunc = None\n        action = ActionUpdateObjectProp(self.editor, fSelectObject, obj, propName, val, oldVal, func, undoFunc)\n        if fUndo:\n            self.editor.actionMgr.push(action)\n        action()\n\n        if self.editor:\n            self.editor.fNeedToSave = True\n            if fSelectObject:\n                base.direct.select(obj[OG.OBJ_NP], fUndo=0)\n\n    def updateCurve(self, val, obj):\n        curve = obj[OG.OBJ_NP]\n        degree = int(val)\n        curveNode = obj[OG.OBJ_PROP]['curveInfo']\n        curveInfor = []\n        for item in curveNode:\n            curveInfor.append((None, item[1].getPos()))\n        curve.setup(degree, curveInfor)\n\n    def updateObjectProperties(self, nodePath, propValues):\n        \"\"\"\n        When a saved level is loaded,\n        update an object's properties\n        And call update function if defined.\n        \"\"\"\n        obj = self.findObjectByNodePath(nodePath)\n\n        if obj:\n            for propName in propValues:\n                self.updateObjectPropValue(obj, propName, propValues[propName])\n\n    def traverse(self, parent, parentId = None):\n        \"\"\"\n        Trasverse scene graph to gather data for saving\n        \"\"\"\n        for child in parent.getChildren():\n            if child.hasTag('OBJRoot') and not child.hasTag('Controller'):\n                obj = self.findObjectByNodePath(child)\n\n                if obj:\n                    uid = obj[OG.OBJ_UID]\n                    np = obj[OG.OBJ_NP]\n                    objDef = obj[OG.OBJ_DEF]\n                    objModel = obj[OG.OBJ_MODEL]\n                    objAnim = obj[OG.OBJ_ANIM]\n                    objProp = obj[OG.OBJ_PROP]\n                    objRGBA = obj[OG.OBJ_RGBA]\n\n                    if parentId:\n                        parentStr = \"objects['%s']\"%parentId\n                    else:\n                        parentStr = \"None\"\n\n                    if objModel:\n                        modelStr = \"'%s'\"%objModel\n                    else:\n                        modelStr = \"None\"\n\n                    if objAnim:\n                        animStr = \"'%s'\"%objAnim\n                    else:\n                        animStr = \"None\"\n\n                    if objDef.named:\n                        nameStr = \"'%s'\"%np.getName()\n                    else:\n                        nameStr = \"None\"\n\n                    if objDef.name == '__Curve__':\n                        #transfer the curve information from control nodes into simple positions for file save\n                        objCurveInfo = obj[OG.OBJ_PROP]['curveInfo']\n                        self.objDegree = obj[OG.OBJ_PROP]['Degree']\n                        newobjCurveInfo = []\n                        for item in objCurveInfo:\n                            newobjCurveInfo.append((item[0], item[1].getPos()))\n\n                        self.saveData.append(\"\\nobjects['%s'] = objectMgr.addNewCurveFromFile(%s, %s, '%s', %s, False, None)\"%(uid, newobjCurveInfo, self.objDegree, uid, parentStr))\n                    else:\n                        self.saveData.append(\"\\nobjects['%s'] = objectMgr.addNewObject('%s', '%s', %s, %s, %s, False, None, %s)\"%(uid, objDef.name, uid, modelStr, parentStr, animStr, nameStr))\n\n                    self.saveData.append(\"if objects['%s']:\"%uid)\n                    self.saveData.append(\"    objects['%s'].setPos(%s)\"%(uid, np.getPos()))\n                    self.saveData.append(\"    objects['%s'].setHpr(%s)\"%(uid, np.getHpr()))\n                    self.saveData.append(\"    objects['%s'].setScale(%s)\"%(uid, np.getScale()))\n                    self.saveData.append(\"    objectMgr.updateObjectColor(%f, %f, %f, %f, objects['%s'])\"%(objRGBA[0], objRGBA[1], objRGBA[2], objRGBA[3], uid))\n\n                    if objDef.name == '__Curve__':\n                        pass\n                    else:\n                        self.saveData.append(\"    objectMgr.updateObjectProperties(objects['%s'], %s)\"%(uid,objProp))\n\n                self.traverse(child, uid)\n\n    def getSaveData(self):\n        self.saveData = []\n        self.getPreSaveData()\n        self.traverse(base.render)\n        self.getPostSaveData()\n        return self.saveData\n\n    def getPreSaveData(self):\n        \"\"\"\n        if there are additional data to be saved before main data\n        you can override this function to populate data\n        \"\"\"\n\n    def getPostSaveData(self):\n        \"\"\"\n        if there are additional data to be saved after main data\n        you can override this function to populate data\n        \"\"\"\n\n    def duplicateObject(self, nodePath, parent=None):\n        obj = self.findObjectByNodePath(nodePath)\n        if obj is None:\n            return None\n        objDef = obj[OG.OBJ_DEF]\n        objModel = obj[OG.OBJ_MODEL]\n        objAnim = obj[OG.OBJ_ANIM]\n        objRGBA = obj[OG.OBJ_RGBA]\n\n        if parent is None:\n            parentNP = nodePath.getParent()\n            parentObj = self.findObjectByNodePath(parentNP)\n            if parentObj is None:\n                parent = parentNP\n            else:\n                parent = parentObj[OG.OBJ_NP]\n\n        newObjNP = self.addNewObject(objDef.name, parent=parent, fSelectObject = False)\n\n        # copy transform data\n        newObjNP.setPos(obj[OG.OBJ_NP].getPos())\n        newObjNP.setHpr(obj[OG.OBJ_NP].getHpr())\n        newObjNP.setScale(obj[OG.OBJ_NP].getScale())\n\n        newObj = self.findObjectByNodePath(NodePath(newObjNP))\n        if newObj is None:\n            return None\n        # copy model info\n        self.updateObjectModel(obj[OG.OBJ_MODEL], newObj, fSelectObject=False)\n\n        # copy anim info\n        self.updateObjectAnim(obj[OG.OBJ_ANIM], newObj, fSelectObject=False)\n\n        # copy other properties\n        for key in obj[OG.OBJ_PROP]:\n            self.updateObjectPropValue(newObj, key, obj[OG.OBJ_PROP][key])\n        return newObjNP\n\n    def duplicateChild(self, nodePath, parent):\n        children = nodePath.findAllMatches('=OBJRoot')\n        for childNP in children:\n            newChildObjNP = self.duplicateObject(childNP, parent)\n            if newChildObjNP is not None:\n                self.duplicateChild(childNP, newChildObjNP)\n\n    def duplicateSelected(self):\n        selectedNPs = base.direct.selected.getSelectedAsList()\n        duplicatedNPs = []\n        for nodePath in selectedNPs:\n            newObjNP = self.duplicateObject(nodePath)\n            if newObjNP is not None:\n                self.duplicateChild(nodePath, newObjNP)\n                duplicatedNPs.append(newObjNP)\n\n        base.direct.deselectAllCB()\n        for newNodePath in duplicatedNPs:\n            base.direct.select(newNodePath, fMultiSelect = 1, fUndo=0)\n\n        self.editor.fNeedToSave = True\n\n    def makeSelectedLive(self):\n        obj = self.findObjectByNodePath(base.direct.selected.last)\n        if obj:\n            if self.currLiveNP:\n                self.currLiveNP.clearColorScale()\n                if self.currLiveNP == obj[OG.OBJ_NP]:\n                    self.currLiveNP = None\n                    return\n\n            self.currLiveNP = obj[OG.OBJ_NP]\n            self.currLiveNP.setColorScale(0, 1, 0, 1)\n\n    def replaceObjectWithTypeName(self, obj, typeName):\n        uid = obj[OG.OBJ_UID]\n        objNP = obj[OG.OBJ_NP]\n        mat = objNP.getMat()\n        parentObj = self.findObjectByNodePath(objNP.getParent())\n        if parentObj:\n            parentNP = parentObj[OG.OBJ_NP]\n        else:\n            parentNP = None\n        self.removeObjectById(uid)\n        self.editor.ui.sceneGraphUI.delete(uid)\n        newobj = self.addNewObject(typeName, uid, parent=parentNP, fSelectObject=False)\n        newobj.setMat(mat)\n\n    def flatten(self, newobjModel, model, objDef, uid):\n        # override this to flatten models\n        pass\n\n    def findActors(self, parent):\n        for child in parent.getChildren():\n            if child.hasTag('OBJRoot') and not child.hasTag('Controller'):\n                obj = self.findObjectByNodePath(child)\n\n                if obj:\n                    if isinstance(obj[OG.OBJ_NP],Actor):\n                        self.Actor.append(obj)\n\n                self.findActors(child)\n\n    def findNodes(self, parent):\n        for child in parent.getChildren():\n            if child.hasTag('OBJRoot') and not child.hasTag('Controller'):\n                obj = self.findObjectByNodePath(child)\n\n                if obj:\n                    self.Nodes.append(obj)\n\n                self.findActors(child)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/leveleditor/ObjectMgrBase.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/a86148df_ObjectMgrBase.json",
    "doc_id": "doc_34"
  }
}