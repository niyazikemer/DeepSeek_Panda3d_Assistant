{
  "content": "\"\"\"\nDial Class: Velocity style controller for floating point values with\n             a label, entry (validated), and scale\n\"\"\"\n\n__all__ = ['Dial', 'AngleDial', 'DialWidget']\n\nfrom .Valuator import Valuator, VALUATOR_MINI, VALUATOR_FULL\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom panda3d.core import ClockObject\nimport math\nimport operator\nimport Pmw\nimport tkinter as tk\n\nTWO_PI = 2.0 * math.pi\nONEPOINTFIVE_PI = 1.5 * math.pi\nPOINTFIVE_PI = 0.5 * math.pi\nINNER_SF = 0.2\n\nDIAL_FULL_SIZE = 45\nDIAL_MINI_SIZE = 30\n\n\nclass Dial(Valuator):\n    \"\"\"\n    Valuator widget which includes an angle dial and an entry for setting\n    floating point values\n    \"\"\"\n\n    def __init__(self, parent = None, **kw):\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            ('style',             VALUATOR_FULL,  INITOPT),\n            ('base',              0.0,            self.setBase),\n            ('delta',             1.0,            self.setDelta),\n            ('fSnap',             0,              self.setSnap),\n            ('fRollover',         1,              self.setRollover),\n        )\n        self.defineoptions(kw, optiondefs)\n        Valuator.__init__(self, parent)\n        self.initialiseoptions(Dial)\n\n    def createValuator(self):\n        self._valuator = self.createcomponent(\n            'valuator',\n            (('dial', 'valuator'),),\n            None,\n            DialWidget,\n            (self.interior(),),\n            style = self['style'],\n            command = self.setEntry,\n            value = self['value'])\n        self._valuator._widget.bind('<Double-ButtonPress-1>', self.mouseReset)\n\n    def packValuator(self):\n        if self['style'] == VALUATOR_FULL:\n            self._valuator.grid(rowspan = 2, columnspan = 2,\n                                padx = 2, pady = 2)\n            if self._label:\n                self._label.grid(row = 0, column = 2, sticky = tk.EW)\n            self._entry.grid(row = 1, column = 2, sticky = tk.EW)\n            self.interior().columnconfigure(2, weight = 1)\n        else:\n            if self._label:\n                self._label.grid(row=0, column=0, sticky = tk.EW)\n            self._entry.grid(row=0, column=1, sticky = tk.EW)\n            self._valuator.grid(row=0, column=2, padx = 2, pady = 2)\n            self.interior().columnconfigure(0, weight = 1)\n\n    def addValuatorPropertiesToDialog(self):\n        self.addPropertyToDialog(\n            'base',\n            {'widget': self._valuator,\n             'type': 'real',\n             'help': 'Dial value = base + delta * numRevs'})\n        self.addPropertyToDialog(\n            'delta',\n            {'widget': self._valuator,\n             'type': 'real',\n             'help': 'Dial value = base + delta * numRevs'})\n        self.addPropertyToDialog(\n            'numSegments',\n            {'widget': self._valuator,\n             'type': 'integer',\n             'help': 'Number of segments to divide dial into.'})\n\n    def addValuatorMenuEntries(self):\n        # The popup menu\n        self._fSnap = tk.IntVar()\n        self._fSnap.set(self['fSnap'])\n        self._popupMenu.add_checkbutton(label = 'Snap',\n                                        variable = self._fSnap,\n                                        command = self._setSnap)\n        self._fRollover = tk.IntVar()\n        self._fRollover.set(self['fRollover'])\n        if self['fAdjustable']:\n            self._popupMenu.add_checkbutton(label = 'Rollover',\n                                            variable = self._fRollover,\n                                            command = self._setRollover)\n\n    def setBase(self):\n        \"\"\" Set Dial base value: value = base + delta * numRevs \"\"\"\n        self._valuator['base'] = self['base']\n\n    def setDelta(self):\n        \"\"\" Set Dial delta value: value = base + delta * numRevs \"\"\"\n        self._valuator['delta'] = self['delta']\n\n    def _setSnap(self):\n        \"\"\" Menu command to turn Dial angle snap on/off \"\"\"\n        self._valuator['fSnap'] = self._fSnap.get()\n\n    def setSnap(self):\n        \"\"\" Turn Dial angle snap on/off \"\"\"\n        self._fSnap.set(self['fSnap'])\n        # Call menu command to send down to valuator\n        self._setSnap()\n\n    def _setRollover(self):\n        \"\"\"\n        Menu command to turn Dial rollover on/off (i.e. does value accumulate\n        every time you complete a revolution of the dial?)\n        \"\"\"\n        self._valuator['fRollover'] = self._fRollover.get()\n\n    def setRollover(self):\n        \"\"\" Turn Dial rollover (accumulation of a sum) on/off \"\"\"\n        self._fRollover.set(self['fRollover'])\n        # Call menu command to send down to valuator\n        self._setRollover()\n\n\nclass AngleDial(Dial):\n    def __init__(self, parent = None, **kw):\n        # Set the typical defaults for a 360 degree angle dial\n        optiondefs = (\n            ('delta',             360.0,          None),\n            ('fRollover',         0,              None),\n            ('dial_numSegments',  12,             None),\n        )\n        self.defineoptions(kw, optiondefs)\n        # Initialize the superclass\n        Dial.__init__(self, parent)\n        # Needed because this method checks if self.__class__ is myClass\n        # where myClass is the argument passed into inialiseoptions\n        self.initialiseoptions(AngleDial)\n\n\nclass DialWidget(Pmw.MegaWidget):\n    def __init__(self, parent = None, **kw):\n        #define the megawidget options\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            # Appearance\n            ('style',           VALUATOR_FULL,      INITOPT),\n            ('size',            None,           INITOPT),\n            ('relief',          tk.SUNKEN,      self.setRelief),\n            ('borderwidth',     2,              self.setBorderwidth),\n            ('background',      'white',        self.setBackground),\n            # Number of segments the dial is divided into\n            ('numSegments',     10,             self.setNumSegments),\n            # Behavior\n            # Initial value of dial, use self.set to change value\n            ('value',           0.0,            INITOPT),\n            ('numDigits',       2,              self.setNumDigits),\n            # Dial specific options\n            ('base',            0.0,            None),\n            ('delta',           1.0,            None),\n            # Snap to angle on/off\n            ('fSnap',           0,              None),\n            # Do values rollover (i.e. accumulate) with multiple revolutions\n            ('fRollover',       1,              None),\n            # Command to execute on dial updates\n            ('command',         None,           None),\n            # Extra data to be passed to command function\n            ('commandData',     [],             None),\n            # Callback's to execute during mouse interaction\n            ('preCallback',     None,           None),\n            ('postCallback',    None,           None),\n            # Extra data to be passed to callback function, needs to be a list\n            ('callbackData',    [],             None),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Initialize the superclass\n        Pmw.MegaWidget.__init__(self, parent)\n\n        # Set up some local and instance variables\n        # Create the components\n        interior = self.interior()\n\n        # Current value\n        self.value = self['value']\n\n        # Running total which increments/decrements every time around dial\n        self.rollCount = 0\n\n        # Base dial size on style, if size not specified,\n        if not self['size']:\n            if self['style'] == VALUATOR_FULL:\n                size = DIAL_FULL_SIZE\n            else:\n                size = DIAL_MINI_SIZE\n        else:\n            size = self['size']\n\n        # Radius of the dial\n        radius = self.radius = int(size/2.0)\n        # Radius of the inner knob\n        inner_radius = max(3, radius * INNER_SF)\n\n        # The canvas\n        self._widget = self.createcomponent('canvas', (), None,\n                                            tk.Canvas, (interior,),\n                                            width = size, height = size,\n                                            background = self['background'],\n                                            highlightthickness = 0,\n                                            scrollregion = (-radius, -radius,\n                                                            radius, radius))\n        self._widget.pack(expand = 1, fill = tk.BOTH)\n\n        # The dial face (no outline/fill, primarily for binding mouse events)\n        self._widget.create_oval(-radius, -radius, radius, radius,\n                                 outline = '',\n                                 tags = ('dial',))\n\n        # The indicator\n        self._widget.create_line(0, 0, 0, -radius, width = 2,\n                                 tags = ('indicator', 'dial'))\n\n        # The central knob\n        self._widget.create_oval(-inner_radius, -inner_radius,\n                                 inner_radius, inner_radius,\n                                 fill = 'grey50',\n                                 tags = ('knob',))\n\n        # Add event bindings\n        self._widget.tag_bind('dial', '<ButtonPress-1>', self.mouseDown)\n        self._widget.tag_bind('dial', '<B1-Motion>', self.mouseMotion)\n        self._widget.tag_bind('dial', '<Shift-B1-Motion>',\n                              self.shiftMouseMotion)\n        self._widget.tag_bind('dial', '<ButtonRelease-1>', self.mouseUp)\n        self._widget.tag_bind('knob', '<ButtonPress-1>', self.knobMouseDown)\n        self._widget.tag_bind('knob', '<B1-Motion>', self.updateDialSF)\n        self._widget.tag_bind('knob', '<ButtonRelease-1>', self.knobMouseUp)\n        self._widget.tag_bind('knob', '<Enter>', self.highlightKnob)\n        self._widget.tag_bind('knob', '<Leave>', self.restoreKnob)\n\n        # Make sure input variables processed\n        self.initialiseoptions(DialWidget)\n\n    def set(self, value, fCommand = 1):\n        \"\"\"\n        self.set(value, fCommand = 1)\n        Set dial to new value, execute command if fCommand == 1\n        \"\"\"\n        # Adjust for rollover\n        if not self['fRollover']:\n            if value > self['delta']:\n                self.rollCount = 0\n            value = self['base'] + ((value - self['base']) % self['delta'])\n        # Send command if any\n        if fCommand and (self['command'] is not None):\n            self['command'](*[value] + self['commandData'])\n        # Record value\n        self.value = value\n\n    def get(self):\n        \"\"\"\n        self.get()\n        Get current dial value\n        \"\"\"\n        return self.value\n\n    ## Canvas callback functions\n    # Dial\n    def mouseDown(self, event):\n        self._onButtonPress()\n        self.lastAngle = dialAngle = self.computeDialAngle(event)\n        self.computeValueFromAngle(dialAngle)\n\n    def mouseUp(self, event):\n        self._onButtonRelease()\n\n    def shiftMouseMotion(self, event):\n        self.mouseMotion(event, 1)\n\n    def mouseMotion(self, event, fShift = 0):\n        dialAngle = self.computeDialAngle(event, fShift)\n        self.computeValueFromAngle(dialAngle)\n\n    def computeDialAngle(self, event, fShift = 0):\n        x = self._widget.canvasx(event.x)\n        y = self._widget.canvasy(event.y)\n        rawAngle = math.atan2(y, x)\n        # Snap to grid\n        # Convert to dial coords to do snapping\n        dialAngle = rawAngle + POINTFIVE_PI\n        if operator.xor(self['fSnap'], fShift):\n            dialAngle = round(dialAngle / self.snapAngle) * self.snapAngle\n        return dialAngle\n\n    def computeValueFromAngle(self, dialAngle):\n        delta = self['delta']\n        dialAngle = dialAngle % TWO_PI\n        # Check for rollover, if necessary\n        if (self.lastAngle > ONEPOINTFIVE_PI) and (dialAngle < POINTFIVE_PI):\n            self.rollCount += 1\n        elif (self.lastAngle < POINTFIVE_PI) and (dialAngle > ONEPOINTFIVE_PI):\n            self.rollCount -= 1\n        self.lastAngle = dialAngle\n        # Update value\n        newValue = self['base'] + (self.rollCount + (dialAngle/TWO_PI)) * delta\n        self.set(newValue)\n\n    def updateIndicator(self, value):\n        # compute new indicator angle\n        delta = self['delta']\n        factors = divmod(value - self['base'], delta)\n        self.rollCount = factors[0]\n        self.updateIndicatorRadians((factors[1]/delta) * TWO_PI)\n\n    def updateIndicatorDegrees(self, degAngle):\n        self.updateIndicatorRadians(degAngle * (math.pi/180.0))\n\n    def updateIndicatorRadians(self, dialAngle):\n        rawAngle = dialAngle - POINTFIVE_PI\n        # Compute end points\n        endx = math.cos(rawAngle) * self.radius\n        endy = math.sin(rawAngle) * self.radius\n        # Draw new indicator\n        self._widget.coords('indicator', endx * INNER_SF, endy * INNER_SF,\n                            endx, endy)\n\n    # Knob velocity controller\n    def knobMouseDown(self, event):\n        self._onButtonPress()\n        self.knobSF = 0.0\n        self.updateTask = taskMgr.add(self.updateDialTask, 'updateDial')\n        self.updateTask.lastTime = ClockObject.getGlobalClock().getFrameTime()\n\n    def updateDialTask(self, state):\n        # Update value\n        currT = ClockObject.getGlobalClock().getFrameTime()\n        dt = currT - state.lastTime\n        self.set(self.value + self.knobSF * dt)\n        state.lastTime = currT\n        return Task.cont\n\n    def updateDialSF(self, event):\n        x = self._widget.canvasx(event.x)\n        y = self._widget.canvasy(event.y)\n        offset = max(0, abs(x) - Valuator.deadband)\n        if offset == 0:\n            return 0\n        sf = math.pow(Valuator.sfBase,\n                      self.minExp + offset/Valuator.sfDist)\n        if x > 0:\n            self.knobSF = sf\n        else:\n            self.knobSF = -sf\n\n    def knobMouseUp(self, event):\n        taskMgr.remove(self.updateTask)\n        self.knobSF = 0.0\n        self._onButtonRelease()\n\n    def setNumDigits(self):\n        # Set minimum exponent to use in velocity task\n        self.minExp = math.floor(-self['numDigits']/\n                                 math.log10(Valuator.sfBase))\n\n    # Methods to modify dial characteristics\n    def setRelief(self):\n        self.interior()['relief'] = self['relief']\n\n    def setBorderwidth(self):\n        self.interior()['borderwidth'] = self['borderwidth']\n\n    def setBackground(self):\n        self._widget['background'] = self['background']\n\n    def setNumSegments(self):\n        self._widget.delete('ticks')\n        # Based upon input snap angle, how many ticks\n        numSegments = self['numSegments']\n        # Compute snapAngle (radians)\n        self.snapAngle = snapAngle = TWO_PI / numSegments\n        # Create the ticks at the snap angles\n        for ticknum in range(numSegments):\n            angle = snapAngle * ticknum\n            # convert to canvas coords\n            angle = angle - POINTFIVE_PI\n            # Compute tick endpoints\n            startx = math.cos(angle) * self.radius\n            starty = math.sin(angle) * self.radius\n            # Elongate ticks at 90 degree points\n            if (angle % POINTFIVE_PI) == 0.0:\n                sf = 0.6\n            else:\n                sf = 0.8\n            endx = startx * sf\n            endy = starty * sf\n            self._widget.create_line(startx, starty, endx, endy,\n                                     tags = ('ticks','dial'))\n\n    def highlightKnob(self, event):\n        self._widget.itemconfigure('knob', fill = 'black')\n\n    def restoreKnob(self, event):\n        self._widget.itemconfigure('knob', fill = 'grey50')\n\n    # To call user callbacks\n    def _onButtonPress(self, *args):\n        \"\"\" User redefinable callback executed on button press \"\"\"\n        if self['preCallback']:\n            self['preCallback'](*self['callbackData'])\n\n    def _onButtonRelease(self, *args):\n        \"\"\" User redefinable callback executed on button release \"\"\"\n        if self['postCallback']:\n            self['postCallback'](*self['callbackData'])\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/tkwidgets/Dial.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/1ea25aa1_Dial.json",
    "doc_id": "doc_198"
  }
}