{
  "content": "Auxiliary Bitplane Control\n\nThe framebuffer always contains a color bitplane and a depth bitplane. It may also have a stencil bitplane or accumulation bitplane. In addition, if it is a render-to-texture framebuffer, it may have auxiliary bitplanes. These allow more or less arbitrary user-defined data to be stored along with each pixel in the framebuffer, alongside its color and depth value.\n\nThe main use case for this is to pass along additional information to a postprocessing shader, which operates on the pixels of the rendered image. For example, the cartoon inking shader needs to have the normal vector of every rendered pixel in order to determine where the edges of the objects are.\n\nWhen per-pixel lighting is enabled via the shader generator <the-shader-generator>, the shader generator can be asked to produce extra data into the auxiliary bitplanes. This is done by setting an .AuxBitplaneAttrib:\n\npython\n\nnp.setAttrib(AuxBitplaneAttrib.make(bits))\n\ncpp\n\nnp.set_attrib(AuxBitplaneAttrib::make(bits));\n\nWhere bits is a set of bits indicating what should be written into the auxiliary bitplanes.\n\nAlthough the framebuffer's alpha channel is not technically an auxiliary bitplane, it can be thought of as such, since it is not generally used to store any data of value, since alpha blending has already occurred before the values are written to the framebuffer.\n\nWhen the shader generator is not enabled, this attrib has no effect.\n\nValues That Can be Requested\n\nThe following is a list of bits that can be passed to .AuxBitplaneAttrib.make():\n\npython\n\ncpp",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/bb797688_auxiliary-bitplane-control.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/2fd4e877_bb797688_auxiliary-bitplane-control.json",
    "doc_id": "doc_456"
  }
}