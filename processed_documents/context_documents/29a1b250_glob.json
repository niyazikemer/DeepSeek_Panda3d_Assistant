{
  "content": "\"\"\" This module reimplements Python's native glob module using Panda\nvfs constructs.  This enables Python to interface more easily with Panda's\nvirtual file system. \"\"\"\n\nimport os\nimport fnmatch\n\nfrom direct.stdpy import file\n\n__all__ = [\"glob\", \"iglob\"]\n\ndef glob(pathname):\n    \"\"\"Return a list of paths matching a pathname pattern.\n\n    The pattern may contain simple shell-style wildcards a la fnmatch.\n\n    \"\"\"\n    return list(iglob(pathname))\n\ndef iglob(pathname):\n    \"\"\"Return an iterator which yields the paths matching a pathname pattern.\n\n    The pattern may contain simple shell-style wildcards a la fnmatch.\n\n    \"\"\"\n    if not has_magic(pathname):\n        if file.lexists(pathname):\n            yield pathname\n        return\n    dirname, basename = os.path.split(pathname)\n    if not dirname:\n        for name in glob1(os.curdir, basename):\n            yield name\n        return\n    if has_magic(dirname):\n        dirs = iglob(dirname)\n    else:\n        dirs = [dirname]\n    if has_magic(basename):\n        glob_in_dir = glob1\n    else:\n        glob_in_dir = glob0\n    for dirname in dirs:\n        for name in glob_in_dir(dirname, basename):\n            yield os.path.join(dirname, name)\n\n# These 2 helper functions non-recursively glob inside a literal directory.\n# They return a list of basenames. repr(glob1) accepts a pattern while `glob0`\n# takes a literal basename (so it only has to check for its existence).\n\ndef glob1(dirname, pattern):\n    if not dirname:\n        dirname = os.curdir\n    try:\n        names = file.listdir(dirname)\n    except os.error:\n        return []\n    if pattern[0] != '.':\n        names = [x for x in names if x[0] != '.']\n    return fnmatch.filter(names, pattern)\n\ndef glob0(dirname, basename):\n    if basename == '':\n        # repr(os.path.split()) returns an empty basename for paths ending with a\n        # directory separator.  'q*x/' should match only directories.\n        if file.isdir(dirname):\n            return [basename]\n    else:\n        if file.lexists(os.path.join(dirname, basename)):\n            return [basename]\n    return []\n\n\ndef has_magic(s):\n    if isinstance(s, bytes):\n        return b'*' in s or b'?' in s or b'[' in s\n    else:\n        return '*' in s or '?' in s or '[' in s\n\n\ndef escape(pathname):\n    drive, pathname = os.path.splitdrive(pathname)\n    if isinstance(pathname, bytes):\n        newpath = bytearray(drive)\n        for c in pathname:\n            if c == 42 or c == 63 or c == 91:\n                newpath += bytes((91, c, 93))\n            else:\n                newpath.append(c)\n        return bytes(newpath)\n    else:\n        newpath = drive\n        for c in pathname:\n            if c == '*' or c == '?' or c == '[':\n                newpath += '[' + c + ']'\n            else:\n                newpath += c\n        return newpath\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/stdpy/glob.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/29a1b250_glob.json",
    "doc_id": "doc_203"
  }
}