{
  "content": "from direct.directnotify.DirectNotifyGlobal import directNotify\n\nclass DoHierarchy:\n    \"\"\"\n    This table has been a source of memory leaks, with DoIds getting left in the table indefinitely.\n    DoHierarchy guards access to the table and ensures correctness.\n    \"\"\"\n    notify = directNotify.newCategory(\"DoHierarchy\")\n\n    def __init__(self):\n        # parentId->zoneId->set(child DoIds)\n        self._table = {}\n        self._allDoIds = set()\n\n    def isEmpty(self):\n        assert (len(self._table) == 0) == (len(self._allDoIds) == 0)\n        return len(self._table) == 0 and len(self._allDoIds) == 0\n\n    def __len__(self):\n        return len(self._allDoIds)\n\n    def clear(self):\n        assert self.notify.debugCall()\n        self._table = {}\n        self._allDoIds = set()\n\n    def getDoIds(self, getDo, parentId, zoneId=None, classType=None):\n        \"\"\"\n        Args:\n            parentId: any distributed object id.\n            zoneId: a uint32, defaults to None (all zones).  Try zone 2 if\n                you're not sure which zone to use (0 is a bad/null zone and\n                1 has had reserved use in the past as a no messages zone, while\n                2 has traditionally been a global, uber, misc stuff zone).\n            dclassType: a distributed class type filter, defaults to None\n                (no filter).\n\n        If dclassName is None then all objects in the zone are returned;\n        otherwise the list is filtered to only include objects of that type.\n        \"\"\"\n        parent=self._table.get(parentId)\n        if parent is None:\n            return []\n        if zoneId is None:\n            r = []\n            for zone in parent.values():\n                for obj in zone:\n                    r.append(obj)\n        else:\n            r = parent.get(zoneId, [])\n        if classType is not None:\n            a = []\n            for doId in r:\n                obj = getDo(doId)\n                if isinstance(obj, classType):\n                    a.append(doId)\n            r = a\n        return r\n\n    def storeObjectLocation(self, do, parentId, zoneId):\n        doId = do.doId\n        if doId in self._allDoIds:\n            self.notify.error(\n                'storeObjectLocation(%s %s) already in _allDoIds; duplicate generate()? or didn\\'t clean up previous instance of DO?' % (\n                do.__class__.__name__, do.doId))\n        parentZoneDict = self._table.setdefault(parentId, {})\n        zoneDoSet = parentZoneDict.setdefault(zoneId, set())\n        zoneDoSet.add(doId)\n        self._allDoIds.add(doId)\n        self.notify.debug('storeObjectLocation: %s(%s) @ (%s, %s)' % (\n            do.__class__.__name__, doId, parentId, zoneId))\n\n    def deleteObjectLocation(self, do, parentId, zoneId):\n        doId = do.doId\n        if doId not in self._allDoIds:\n            self.notify.error(\n                'deleteObjectLocation(%s %s) not in _allDoIds; duplicate delete()? or invalid previous location on a new object?' % (\n                do.__class__.__name__, do.doId))\n        # jbutler: temp hack to get by the assert, this will be fixed soon\n        if doId not in self._allDoIds:\n            return\n        parentZoneDict = self._table.get(parentId)\n        if parentZoneDict is not None:\n            zoneDoSet = parentZoneDict.get(zoneId)\n            if zoneDoSet is not None:\n                if doId in zoneDoSet:\n                    zoneDoSet.remove(doId)\n                    self._allDoIds.remove(doId)\n                    self.notify.debug('deleteObjectLocation: %s(%s) @ (%s, %s)' % (\n                        do.__class__.__name__, doId, parentId, zoneId))\n                    if len(zoneDoSet) == 0:\n                        del parentZoneDict[zoneId]\n                        if len(parentZoneDict) == 0:\n                            del self._table[parentId]\n                else:\n                    self.notify.error(\n                        \"deleteObjectLocation: objId: %s not found\" % doId)\n            else:\n                self.notify.error(\n                    \"deleteObjectLocation: zoneId: %s not found\" % zoneId)\n        else:\n            self.notify.error(\n                \"deleteObjectLocation: parentId: %s not found\" % parentId)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/DoHierarchy.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/79f8b556_DoHierarchy.json",
    "doc_id": "doc_320"
  }
}