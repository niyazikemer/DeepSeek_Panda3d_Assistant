{
  "content": "Keyboard Support\n\nKeyboard events\n\nPanda3D has keyboard support built-in. Keyboard presses send Events <tasks-and-event-handling>. Each keyboard key will send an event when it is first pressed down, when it is released, and one repeatedly while it is pressed.\n\ncpp\n\nBegin first by enabling keyboard events from the WindowFramework object:\n\nwindow->enable_keyboard();\n\nThe events can be accepted with the following code:\n\npython\n\nself.accept(<event name>, <function>)\nself.accept(<event name>, <function>, <parameters list>)\nself.acceptOnce(<event name>, <function>)\nself.acceptOnce(<event name>, <function>, <parameters list>)\n\n<event name> is a string that labels the event. <function> is a python function to be called when the event is sent. <parameters list> is a python list of parameters to use to call <function>.\n\ncpp\n\nframework->define_key(<event name>, <description>, <function>, nullptr);\nframework->define_key(<event name>, <description>, <function>, <data>);\n\n<event name> is a string that labels the event. <function> is an EventCallbackFunction to be called when the event is sent. <data> is an arbitrary pointer to be passed when the framework calls <function>.\n\npython\n\nIf you're wondering which events are being fired for certain keyboard activity, it is advised to call base.messenger.toggleVerbose(). This will cause Panda3D to print out all the events that are being sent to the command-line prompt. This way, you can find out which keyboard key corresponds to which event name.\n\nIn general, the keyboard event naming follows the following rules:\n\nKeys that type a character are named that character. It is always lowercase, even when shift or caps lock is pressed. (Shift and other modifiers are explained below.)\n\n\"a\", \"b\", \"3\", \"[\", etc. not \"A\", \"B\", \"#\", \"{\"\n\nThe key down event is named for the key.\n\nThe keyboard autorepeat is named for the key + \"-repeat\" e.g.\n\n\"a-repeat\", \"2-repeat\", \"[-repeat\"\n\nThe key up event is named for the key + \"-up\" e.g.\n\n\"a-up\", \"2-up\", \"[-up\"\n\nAll key events (including \"-up\") have a corresponding time event labeled\n\n\"time-\" + <key name>\n\npython\n\nHere is an example of time reading in code:\n\nclass ReadKeys(DirectObject.DirectObject):\n    def __init__(self):\n        self.accept('time-a-repeat', self.printRepeat)\n\n    def printRepeat(self, when):\n        print(\"repeat a\", when)\n\nKeys that don't type a character are labeled as follows:\n\n\"escape\", \"f\"+\"1-12\" (e.g. \"f1\",\"f2\",...\"f12\"), \"print_screen\",\n\"scroll_lock\", \"backspace\", \"insert\", \"home\", \"page_up\", \"num_lock\",\n\"tab\",  \"delete\", \"end\", \"page_down\", \"caps_lock\", \"enter\", \"arrow_left\",\n\"arrow_up\", \"arrow_down\", \"arrow_right\", \"shift\", \"lshift\", \"rshift\",\n\"control\", \"alt\", \"lcontrol\", \"lalt\", \"space\", \"ralt\", \"rcontrol\"\n\nNote that some key combinations (like print_screen on Windows) may be intercepted by the operating system and may therefore not be available. If you want to be able to catch these keys, you need to find some way to prevent the system from intercepting the events. (however, \"print_screen-up\" is still available in most cases.)\n\nSome physical keys are distinguishable from the events that they fire, and some are not. The modifier keys distinguish between left and right, but send a neutral event as well. (e.g. the left shift key sends both \"lshift\" and \"shift\" events when pressed) Save for \"num_lock\", \"*\", and \"+\" the numpad keys are indistinguishable from the main keyboard counterparts. (e.g. when Num Lock is on the both the numpad and keyboard 1 keys send \"1\")\n\nHere are some examples in code:\n\npython\n\n# Calls the function __spam() on the k key event.\nself.accept('k', self.__spam)\n\n# Calls __spam(eggs, sausage, bacon) on release of the K key.\nself.accept('k-up', self.__spam, [eggs, sausage, bacon,])\n\n# Exit on pressing the escape button.\nself.accept('escape', sys.exit)\n\n# Call spamAndEggs when up is pressed and at autorepeat if held.\nself.accept('arrow_up', self.spamAndEggs)\nself.accept('arrow_up-repeat', self.spamAndEggs)\n\n# Calls when the up arrow key is released.\nself.accept('arrow_up-up', self.spamAndEggs)\n\ncpp\n\n// Calls the function __spam(const Event* eventPtr, void* dataPtr) on the k key event.\nframework->define_key(\"k\", \"call k\", __spam, nullptr);\nframework->define_key(\"k\", \"call k\", __spam, &data);\n\n// Call spamAndEggs(const Event* eventPtr, void* dataPtr) when up is pressed\n// and at autorepeat if held.\nframework->define_key(\"arrow_up\", \"spam and egg\", spamAndEggs, nullptr);\nframework->define_key(\"arrow_up-repeat\", \"spam and egg\", spamAndEggs, nullptr);\n\n// Calls when the up arrow key is released\nframework->define_key(\"arrow_up-up\", \"spam and egg\", spamAndEggs, nullptr);\n\nNote\n\nWhen the Panda window is minimized or Panda3D loses focus, the \"-up\" event is sent for all currently held keys. Read this forum thread to learn more: https://discourse.panda3d.org/t/not-a-bug-solved-bug-with-up-events/4266\n\nModifier keys\n\nWhen a key is pressed while a modifier key is pressed, such as shift, control or alt, it is not sent in the usual way. Instead, the event name is modified by prepending the name of the modifier key to the event name, separated by a dash, in the order \"shift\", \"control\", \"alt\", for example:\n\n\"shift-a\" \"shift-control-alt-a\" \"shift-alt-a\"\n\nThese compound events don't send a \"time-\" event. If you need one, use the \"time-\" event sent by one of the keys in the combination.\n\nThe modifier compound events may optionally be turned off, in which case the \"a\" event and the \"shift\" event will be sent separately:\n\npython\n\nbase.mouseWatcherNode.set_modifier_buttons(ModifierButtons())\nbase.buttonThrowers[0].node().set_modifier_buttons(ModifierButtons())\n\ncpp\n\nPT(MouseWatcher) mouse_watcher;\nmouse_watcher = DCAST(MouseWatcher, window->get_mouse().node());\n\nif (mouse_watcher != nullptr) {\n  mouse_watcher->set_modifier_buttons(ModifierButtons());\n}\n\nButtonThrower *bt = DCAST(ButtonThrower, window->get_mouse().get_child(0).node());\nif (bt != nullptr) {\n  bt->set_modifier_buttons(ModifierButtons());\n}\n\nPolling interface\n\nThe above interfaces make use of events to cause a method to be called when the key pressed or released. However, in some situations, it may be more desirable to instead ask Panda every frame whether or not a certain key is pressed. In this situation, you can use the polling interface instead, via the ~.MouseWatcher.is_button_down() method on the MouseWatcher node. (The name of this class is a bit misleading - it listens for keyboard events as well.)\n\npython\n\nforward_speed = 5.0 # units per second\nbackward_speed = 2.0\nforward_button = KeyboardButton.ascii_key('w')\nbackward_button = KeyboardButton.ascii_key('s')\n\ndef move_task(self, task):\n    speed = 0.0\n\n    # Check if the player is holding W or S\n    is_down = base.mouseWatcherNode.is_button_down\n\n    if is_down(forward_button):\n        speed += forward_speed\n\n    if is_down(backward_button):\n        speed -= backward_speed\n\n    # Move the player\n    y_delta = speed * globalClock.get_dt()\n    self.player.set_y(self.player, y_delta)\n\nKeystroke events\n\nThe interfaces described above are useful for listening for predetermined key presses, like navigational keys or hot keys, but not for text input. Not only are there no events for fancy keys in foreign languages, but a single key press may not necessarily associate with a single letter to be entered in a text field. This is because some international characters can only be typed using multiple key presses.\n\nTherefore, Panda3D has a concept of a keystroke event, which is used for text input. Panda3D uses this under the hood for all GUI text entry. If you are writing your own GUI widgets, it may be desirable for you to catch your own keystroke events. To do this, it is first necessary to inform Panda3D which event name should be sent when a keystroke occurs, after which you can accept it as you would with any other event:\n\nbase.buttonThrowers[0].node().setKeystrokeEvent('keystroke')\nself.accept('keystroke', self.myFunc)\n\ndef myFunc(self, keyname):\n    print(keyname)\n\nRaw keyboard events\n\nNormally, when you listen for a keyboard event, the user's configured keyboard layout is taken into account. This may present problems for key bindings that are determined by position on the keyboard. For instance, when using the popular WASD control scheme for navigating the player, someone who's using an AZERTY or dvorak keyboard layout may have to bend their fingers in an unnatural way in order to use this scheme!\n\nIn light of this, Panda3D 1.9.0 introduced some features that will help to solve this problem. The easiest way to fix this problem is to instead refer to the keys by how they would appear on an ANSI US (QWERTY) keyboard layout. To do this, you can prepend the raw- prefix to any key event. This will cause Panda3D to ignore the user's configured keyboard layout, and instead report the key as if the user had set his keyboard layout to ANSI US. It does this by interpreting the raw scancode as sent by the hardware, rather than the virtual key as reported by the operating system. (Note that raw events do not have prefixes for modifier keys.)\n\nThis works for simple cases, but it is often necessary to have more specific information about the way the keys are mapped in the user's system. For example, showing \"press W to move forward\" may be confusing on someone with an AZERTY layout, in which case it is more appropriate to say \"press Z to move forward\". When the application has a configuration screen for the keyboard control scheme, acquiring more information about the mapping may also be necessary.\n\nThis can be done using the ~.GraphicsWindow.get_keyboard_map() method on the GraphicsWindow object, returning a .ButtonMap object, which can be used to find out which virtual key event will be fired for a certain raw keyboard button:\n\npython\n\n# Get the current keyboard layout.\n# This may be a somewhat expensive operation, so don't call\n# it all the time, instead storing the result when possible.\nmap = base.win.get_keyboard_map()\n\n# Use this to print all key mappings\nprint(map)\n\n# Find out which virtual key is associated with the ANSI US \"w\"\nw_button = map.get_mapped_button(\"w\")\n\n# Get a textual representation for the button\nw_label = map.get_mapped_button_label(\"w\")\nif not w_label:\n    # There is none, use the event name instead.\n    w_label = str(w_button)\nw_label = w_label.capitalize()\n\n# Use this label to tell the player which button to press.\nself.tutorial_text = \"Press %s to move forward.\" % (w_label)\n\n# Poll to check if the button is pressed...\nif base.mouseWatcherNode.is_button_down(w_button):\n    print(\"%s is currently pressed\" % (w_label))\n\n# ...or register event handlers\nself.accept(\"%s\" % (w_button), self.start_moving_forward)\nself.accept(\"%s-up\" % (w_button), self.stop_moving_forward)\n\ncpp\n\n// Get the current keyboard layout.\n// This may be a somewhat expensive operation, so don't call\n// it all the time, instead storing the result when possible.\nPT(ButtonMap) map = window->get_keyboard_map();\n\n// Use this to print all key mappings\nmap->write(std::cout);\n\n// Find out which virtual key is associated with the ANSI US \"w\"\nButtonHandle w_button = map.get_mapped_button(\"w\");\n\n// Get a textual representation for the button\nstd::string w_label = map.get_mapped_button_label(\"w\");\nif (w_label) {\n  // There is none, use the event name instead.\n  w_label = w_button.get_name();\n}\nw_label = downcase(w_label); // from string_utils.h\nw_label[0] = toupper(w_label[0]);\n\n// Use this label to tell the player which button to press.\nstd::ostringstream str;\nstr << \"Press \" << w_label << \" to move forward.\";\n\n// Poll to check if the button is pressed...\nif (mouse_watcher->is_button_down(w_button)) {\n  std::cout << w_label << \" is currently pressed\" << std::endl;\n}\n\n// ...or register event handlers\nframework->define_key(w_button.get_name(), start_moving_forward, nullptr);\nframework->define_key(w_button.get_name() + \"-up\", stop_moving_forward, nullptr);\n\nThe above code example also illustrates the use of the ~.ButtonMap.get_mapped_button_label() function to get a textual representation for the button, if the operating system provides it. This is most useful for keys like \"shift\" or \"enter\", which may be called differently on different keyboards or in different languages. However, this is both system-dependent and locale-dependent. You should not rely on it being present, and if it is, you should not rely on consistent formatting or capitalization.\n\nOf course, it is always advisable to still add in a configuration screen so that users can customize key bindings in case they find a particular control scheme difficult to use.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/571e1192_keyboard-support.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/66219fe4_571e1192_keyboard-support.json",
    "doc_id": "doc_711"
  }
}