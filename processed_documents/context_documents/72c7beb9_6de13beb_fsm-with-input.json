{
  "content": "FSM with input\n\npython\n\nAnother common use for FSM's is to provide an abstraction for AI state. For this purpose, you would like to supply an \"input\" string to the FSM and let the FSM decide which state it should transition to rather than explicitly specifying the target state name. Consider the following FSM state diagram:\n\ntransitions\n\nrankdir=TB node [style=rounded, shape=box]\n\nNorth -> West [ label=\" left\" ]; West -> South [ label=\" left\" ]; South -> East [ label=\" left\", constraint=false ]; East -> North [ label=\" left\", constraint=false ];\n\nNorth:n -> North:n [ label=\"straight\" ]; West:s -> West:s [ label=\"straight\" ]; South:s -> South:s [ label=\"straight\" ]; East:n -> East:n [ label=\"straight\" ];\n\n{ rank=same; West; South } { rank=same; North; East }\n\nHere the text next to an arrow represents the \"input\" string given to the FSM, and the direction of the arrow represents the state transition that should be made for that particular input string, from the indicated starting state.\n\nIn this example, we have encoded a simple FSM that determines which compass direction a character will be facing after either turning left or continuing straight. The input will be either \"left\" or \"straight\", and the result is a transition to a new state that represents the new compass direction, based on the previous compass direction. If we request \"left\" from state North, the FSM transitions to state West. On the other hand, if we request \"left\" from state South, the FSM transitions to state East. If we request \"straight\" from any state, the FSM should remain in its current state.\n\nTo implement this in Panda3D, we define a number of filter functions, one for each state. The purpose of this function is to decide what state to transition to next, if any, on receipt of a particular input.\n\nA filter function is created by defining a python method named filterStateName(), where StateName is the name of the FSM state to which this filter function applies. The filterStateName method receives two parameters, a string and a tuple of arguments (the arguments contain the optional additional arguments that might have been passed to the fsm.request() call; it's usually an empty tuple). The filter function should return the name of the state to transition to. If the transition should be disallowed, the filter function can either return None to quietly ignore it, or it can raise an exception. For example:\n\nclass CompassDir(FSM):\n\n    def filterNorth(self, request, args):\n        if request == 'straight':\n            return 'North'\n        elif request == 'left':\n            return 'West'\n        else:\n            return None\n\n    def filterWest(self, request, args):\n        if request == 'straight':\n            return 'West'\n        elif request == 'left':\n            return 'South'\n        else:\n            return None\n\n    def filterSouth(self, request, args):\n        if request == 'straight':\n            return 'South'\n        elif request == 'left':\n            return 'East'\n        else:\n            return None\n\n    def filterEast(self, request, args):\n        if request == 'straight':\n            return 'East'\n        elif request == 'left':\n            return 'North'\n        else:\n            return None\n\nNote that input strings, by convention, should begin with a lowercase letter, as opposed to state names, which should begin with an uppercase letter. This allows you to make the distinction between requesting a state directly, and feeding a particular input string to an FSM. To feed input to this FSM, you would use the request() call, just as before:\n\nmyfsm.request('left') # or myfsm.request_left()\nmyfsm.request('left')\nmyfsm.request('straight') # or myfsm.request_straight()\nmyfsm.request('left')\n\nIf the FSM had been in state North originally, after the above sequence of operations it would now be in state East.\n\nThe defaultFilter method\n\nAlthough defining a series of individual filter methods gives you the most flexibility, for many FSM's you may not need this much explicit control. For these cases, you can simply define a defaultFilter method that does everything you need. If a particular filterStateName() method does not exist, then the FSM will call the method named defaultFilter() instead; you can put any logic here that handles the general case.\n\nFor instance, we could have defined the above FSM using just the defaultFilter method, and a lookup table:\n\nclass CompassDir(FSM):\n    nextState = {\n        ('North', 'straight') : 'North',\n        ('North', 'left') : 'West',\n        ('West', 'straight') : 'West',\n        ('West', 'left') : 'South',\n        ('South', 'straight') : 'South',\n        ('South', 'left') : 'East',\n        ('East', 'straight') : 'East',\n        ('East', 'left') : 'North',\n    }\n\n    def defaultFilter(self, request, args):\n        key = (self.state, request)\n        return self.nextState.get(key)\n\nThe base FSM class defines a ~direct.fsm.FSM.FSM.defaultFilter() method that implements the default FSM transition rules (that is, allow all direct-to-state (uppercase) transition requests unless self.defaultTransitions is defined; in either case, quietly ignore input (lowercase) requests).\n\nIn practice, you can mix- and-match the use of the defaultFilter method and your own custom methods. The defaultFilter method will be called only if a particular state's custom filter method does not exist. If a particular state's filterStateName method is defined, that method will be called upon a new request; it can do any custom logic you require (and it can call up to the defaultFilter method if you like).\n\ncpp\n\nThis section does not apply to C++ users.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/6de13beb_fsm-with-input.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/72c7beb9_6de13beb_fsm-with-input.json",
    "doc_id": "doc_528"
  }
}