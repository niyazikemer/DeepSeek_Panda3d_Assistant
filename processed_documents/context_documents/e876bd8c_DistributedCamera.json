{
  "content": "from panda3d.core import ConfigVariableInt, GeomNode, NodePath, PerspectiveLens, Point3, VBase2\nfrom direct.fsm.FSM import FSM\nfrom direct.interval.IntervalGlobal import LerpScaleInterval, Sequence\nfrom direct.distributed.DistributedObject import DistributedObject\nfrom direct.showbase.MessengerGlobal import messenger\n\n_camera_id = ConfigVariableInt('camera-id', -1)\n_aware_of_cameras = ConfigVariableInt('aware-of-cameras', 0)\n\n\nclass Fixture(NodePath, FSM):\n    def __init__(self, id, parent, pos, hpr, fov):\n        NodePath.__init__(self, 'cam-%s' % id)\n        FSM.__init__(self, '%s-fsm' % self.getName())\n        self.id = id\n        self.lens = PerspectiveLens()\n        self.lens.setFov(base.camLens.getFov())\n\n        model = base.loader.loadModel('models/misc/camera', okMissing = True)\n        model.reparentTo(self)\n\n        self.reparentTo(parent)\n        self.setPos(pos)\n        self.setHpr(hpr)\n        self.setFov(fov)\n        self.setLightOff(100)\n        self.hide()\n\n        self.scaleIval = None\n        self.recordingInProgress = False\n        self.dirty = False\n\n    def __str__(self):\n        return 'Fixture(%d, \\'%s\\', %s, %s, %s)' % (self.id, self.state, self.getPos(), self.getHpr(), self.getFov())\n\n    def pack(self):\n        return 'Camera(%s, %s, %s)' % (self.getPos(), self.getHpr(), self.getFov())\n\n    def setId(self, id):\n        self.id = id\n\n    def setFov(self, fov):\n        \"\"\"\n        fov should be a VBase2.  Use VBase2(0) to indicate default.\n        \"\"\"\n        if fov != VBase2(0):\n            self.lens.setFov(fov)\n        self.setupFrustum()\n\n    def adjustFov(self, x, y):\n        fov = self.lens.getFov()\n        self.lens.setFov(fov[0]+x, fov[1]+y)\n        self.dirty = True\n\n    def getFov(self):\n        return self.lens.getFov()\n\n    def setupFrustum(self):\n        oldFrustum = self.find('frustum')\n        if oldFrustum:\n            oldFrustum.detachNode()\n\n        self.attachNewNode(GeomNode('frustum')).node().addGeom(self.lens.makeGeometry())\n\n    def setRecordingInProgress(self, inProgress):\n        self.recordingInProgress = inProgress\n        if self.recordingInProgress and _camera_id.value >= 0:\n            self.hide()\n        else:\n            self.show()\n\n    def show(self):\n        if _aware_of_cameras and not self.recordingInProgress:\n            NodePath.show(self)\n\n    def getScaleIval(self):\n        if not self.scaleIval:\n            self.scaleIval = Sequence(LerpScaleInterval(self.getChild(0), 0.25, 2, startScale = 1, blendType = 'easeInOut'),\n                                      LerpScaleInterval(self.getChild(0), 0.25, 1, startScale = 2, blendType = 'easeInOut'))\n        return self.scaleIval\n\n    def setState(self, state):\n        self.request(state)\n\n    def defaultFilter(self, request, args):\n        if request == self.getCurrentOrNextState():\n            return None\n        return FSM.defaultFilter(self, request, args)\n\n    def exitOff(self):\n        self.accept('recordingInProgress', self.setRecordingInProgress)\n\n    def enterOff(self):\n        self.ignore('recordingInProgress')\n\n        if self.scaleIval:\n            self.scaleIval.finish()\n            self.scaleIval = None\n\n        self.hide()\n\n    def enterStandby(self):\n        self.show()\n        if self.id == _camera_id.value:\n            self.setColorScale(3,0,0,1)\n            self.getScaleIval().loop()\n        else:\n            self.setColorScale(3,3,0,1)\n            self.getScaleIval().finish()\n\n    def enterBlinking(self):\n        self.show()\n        self.setColorScale(0,3,0,1)\n        self.getScaleIval().loop()\n\n    def exitBlinking(self):\n        if self.scaleIval:\n            self.scaleIval.finish()\n\n    def enterRecording(self):\n        if _camera_id.value == self.id:\n            self.demand('Using')\n        else:\n            self.show()\n            self.setColorScale(3,0,0,1)\n            self.getScaleIval().loop()\n\n    def exitRecording(self):\n        if self.scaleIval:\n            self.scaleIval.finish()\n\n    def enterUsing(self, args = []):\n        localAvatar.b_setGameState('Camera')\n        base.camera.setPosHpr(0,0,0,0,0,0)\n        base.camera.reparentTo(self)\n        self.hide()\n\n        base.cam.node().setLens(self.lens)\n\n        if args and args[0]:\n            self.accept('arrow_left', self.adjustFov, [-0.5,0])\n            self.accept('arrow_left-repeat', self.adjustFov, [-2,0])\n            self.accept('arrow_right', self.adjustFov, [0.5,0])\n            self.accept('arrow_right-repeat', self.adjustFov, [2,0])\n            self.accept('arrow_down', self.adjustFov, [0,-0.5])\n            self.accept('arrow_down-repeat', self.adjustFov, [0,-2])\n            self.accept('arrow_up', self.adjustFov, [0,0.5])\n            self.accept('arrow_up-repeat', self.adjustFov, [0,2])\n\n        # Could be toggled on/off on a fixture by fixture basis\n        # if added to the dc definition of the Fixture struct and\n        # saved out to the Camera file.\n        lodNodes = render.findAllMatches('**/+LODNode')\n        for lodNode in lodNodes:\n            lodNode.node().forceSwitch(lodNode.node().getHighestSwitch())\n\n\n    def exitUsing(self):\n        self.ignore('arrow_left')\n        self.ignore('arrow_left-repeat')\n        self.ignore('arrow_right')\n        self.ignore('arrow_right-repeat')\n        self.ignore('arrow_down')\n        self.ignore('arrow_down-repeat')\n        self.ignore('arrow_up')\n        self.ignore('arrow_up-repeat')\n\n        base.cam.node().setLens(base.camLens)\n        localAvatar.b_setGameState('LandRoam')\n        self.show()\n\n        if self.dirty:\n            messenger.send('refresh-fixture', [self.id, self.pack()])\n            self.dirty = False\n\n\nclass DistributedCamera(DistributedObject):\n    def __init__(self, cr):\n        DistributedObject.__init__(self, cr)\n        self.parent = None\n        self.fixtures = {}\n        self.cameraId = _camera_id.value\n\n    def __getitem__(self, index):\n        return self.fixtures.get(index)\n\n    def __str__(self):\n        out = ''\n        for fixture in self.fixtures.values():\n            out = '%s\\n%s' % (out, fixture)\n        return out[1:]\n\n    def pack(self):\n        out = ''\n        for fixture in self.fixtures.values():\n            out = '%s\\n%s' % (out, fixture.pack())\n        return out[1:]\n\n    def disable(self):\n        self.ignore('escape')\n\n        self.parent = None\n\n        for fixture in self.fixtures.values():\n            fixture.cleanup()\n            fixture.detachNode()\n        self.fixtures = {}\n\n        DistributedObject.disable(self)\n\n    def getOV(self):\n        return self.cr.doId2ownerView.get(self.getDoId())\n\n    def setCamParent(self, doId):\n        if doId != self.parent:\n            if not doId:\n                self.parent = render\n            else:\n                self.parent = self.cr.getDo(doId)\n\n            for fix in self.fixtures.values():\n                fix.reparentTo(self.parent)\n\n    def getCamParent(self):\n        return self.parent\n\n    def setFixtures(self, fixtures):\n        for x in range(len(fixtures), len(self.fixtures)):\n            fixture = self.fixtures.pop(x)\n            fixture.cleanup()\n            fixture.detachNode()\n\n        recordingInProgress = False\n        for x,fixture in enumerate(fixtures):\n            pos = Point3(*(fixture[:3]))\n            hpr = Point3(*(fixture[3:6]))\n            fov = VBase2(*(fixture[6:8]))\n            state = fixture[8]\n\n            if x not in self.fixtures:\n                self.fixtures[x] = Fixture(x, self.parent, Point3(0), hpr = Point3(0), fov = VBase2(0))\n\n            fix = self.fixtures.get(x)\n            fix.setId(x)\n            fix.setPosHpr(pos,hpr)\n            fix.setState(state)\n            fix.setFov(fov)\n            recordingInProgress |= state == 'Recording'\n\n        messenger.send('recordingInProgress', [recordingInProgress])\n\n    def testFixture(self, index):\n        fixture = self.fixtures.get(index)\n        if fixture:\n            fixture.request('Using', [True])\n            self.accept('escape', self.stopTesting, [index])\n\n    def stopTesting(self, index):\n        fixture = self.fixtures.get(index)\n        if fixture:\n            self.ignore('escape')\n            fixture.request('Standby')\n            localAvatar.b_setGameState('LandRoam')\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/DistributedCamera.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/e876bd8c_DistributedCamera.json",
    "doc_id": "doc_329"
  }
}