{
  "content": "\"\"\"\nShadowPlacer.py places a shadow.\n\nIt traces a line from a light source to the opposing surface.\nOr it may do that later, right now it puts a node on the surface under\nthe its parent node.\n\"\"\"\n\n__all__ = ['ShadowPlacer']\n\nfrom direct.controls.ControlManager import CollisionHandlerRayStart\nfrom direct.directnotify import DirectNotifyGlobal\nfrom panda3d.core import (\n    BitMask32,\n    CollisionHandlerFloor,\n    CollisionNode,\n    CollisionRay,\n    CollisionTraverser,\n    NodePath,\n)\nfrom . import DirectObject\n\nclass ShadowPlacer(DirectObject.DirectObject):\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"ShadowPlacer\")\n\n    if __debug__:\n        count = 0\n        activeCount = 0\n\n    # special methods\n    def __init__(self, cTrav, shadowNodePath,\n            wallCollideMask, floorCollideMask):\n        self.isActive = 0 # Is the placer \"on\".  This is also printed in the debugCall.\n        assert self.notify.debugCall()\n        DirectObject.DirectObject.__init__(self)\n        self.setup(cTrav, shadowNodePath,\n            wallCollideMask, floorCollideMask)\n        if __debug__:\n            self.count += 1\n            self.debugDisplay()\n\n    def setup(self, cTrav, shadowNodePath,\n            wallCollideMask, floorCollideMask):\n        \"\"\"\n        Set up the collisions\n        \"\"\"\n        assert self.notify.debugCall()\n        assert not shadowNodePath.isEmpty()\n        assert not hasattr(self, \"cTrav\") # Protect from setup() being called again.\n\n        if not cTrav:\n            # set up the shadow collision traverser\n            base.initShadowTrav()\n            cTrav = base.shadowTrav\n\n        self.cTrav = cTrav\n        self.shadowNodePath = shadowNodePath\n\n        floorOffset = 0.025\n        # Set up the collison ray\n        # This is a ray cast down to detect floor polygons\n        self.cRay = CollisionRay(0.0, 0.0, CollisionHandlerRayStart, 0.0, 0.0, -1.0)\n        cRayNode = CollisionNode('shadowPlacer')\n        cRayNode.addSolid(self.cRay)\n        self.cRayNodePath = NodePath(cRayNode)\n        self.cRayBitMask = floorCollideMask\n        cRayNode.setFromCollideMask(self.cRayBitMask)\n        cRayNode.setIntoCollideMask(BitMask32.allOff())\n\n        # set up floor collision mechanism\n        self.lifter = CollisionHandlerFloor()\n        #self.lifter.setInPattern(\"on-floor\")\n        #self.lifter.setOutPattern(\"off-floor\")\n        self.lifter.setOffset(floorOffset)\n        self.lifter.setReach(4.0)\n\n        # activate the collider with the traverser and pusher\n        #self.on()\n\n        self.lifter.addCollider(self.cRayNodePath, shadowNodePath)\n\n    def delete(self):\n        assert self.notify.debugCall()\n        self.off()\n        if __debug__:\n            assert not self.isActive\n            self.count -= 1\n            self.debugDisplay()\n        del self.cTrav\n\n        del self.shadowNodePath\n\n        del self.cRay\n        #del self.cRayNode\n        self.cRayNodePath.removeNode()\n        del self.cRayNodePath\n\n        del self.lifter\n\n    def on(self):\n        \"\"\"\n        Turn on the shadow placement.  The shadow z position will\n        start being updated until a call to off() is made.\n        \"\"\"\n        assert self.notify.debugCall(\"activeCount=%s\"%(self.activeCount,))\n        if self.isActive:\n            assert self.cTrav.hasCollider(self.cRayNodePath)\n            return\n        assert not self.cTrav.hasCollider(self.cRayNodePath)\n        self.cRayNodePath.reparentTo(self.shadowNodePath.getParent())\n        self.cTrav.addCollider(self.cRayNodePath, self.lifter)\n        self.isActive = 1\n        if __debug__:\n            self.activeCount += 1\n            self.debugDisplay()\n\n    def off(self):\n        \"\"\"\n        Turn off the shadow placement.  The shadow will still be\n        there, but the z position will not be updated until a call\n        to on() is made.\n        \"\"\"\n        assert self.notify.debugCall(\"activeCount=%s\"%(self.activeCount,))\n        if not self.isActive:\n            assert not self.cTrav.hasCollider(self.cRayNodePath)\n            return\n        assert self.cTrav.hasCollider(self.cRayNodePath)\n        didIt = self.cTrav.removeCollider(self.cRayNodePath)\n        assert didIt\n        # Now that we have disabled collisions, make one more pass\n        # right now to ensure we aren't standing in a wall.\n        self.oneTimeCollide()\n        self.cRayNodePath.detachNode()\n        self.isActive = 0\n        if __debug__:\n            self.activeCount -= 1\n            self.debugDisplay()\n\n    def oneTimeCollide(self):\n        \"\"\"\n        Makes one quick collision pass for the avatar, for instance as\n        a one-time straighten-things-up operation after collisions\n        have been disabled.\n        \"\"\"\n        assert self.notify.debugCall()\n        tempCTrav = CollisionTraverser(\"oneTimeCollide\")\n        tempCTrav.addCollider(self.cRayNodePath, self.lifter)\n        tempCTrav.traverse(render)\n\n    def resetToOrigin(self):\n        if self.shadowNodePath:\n            self.shadowNodePath.setPos(0,0,0)\n\n    if __debug__:\n        def debugDisplay(self):\n            \"\"\"for debugging\"\"\"\n            if self.notify.getDebug():\n                message = \"%d active (%d total), %d colliders\"%(\n                self.activeCount, self.count, self.cTrav.getNumColliders())\n                self.notify.debug(message)\n                onScreenDebug.add(\"ShadowPlacers\", message)\n            return 1 # to allow assert self.debugDisplay()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/ShadowPlacer.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/ee959aee_ShadowPlacer.json",
    "doc_id": "doc_265"
  }
}