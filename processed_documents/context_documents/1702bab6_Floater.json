{
  "content": "\"\"\"\nFloater Class: Velocity style controller for floating point values with\n                a label, entry (validated), and scale\n\"\"\"\n\n__all__ = ['Floater', 'FloaterWidget', 'FloaterGroup']\n\nfrom .Valuator import Valuator, VALUATOR_MINI, VALUATOR_FULL\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom panda3d.core import ClockObject\nimport math\nimport Pmw\nimport tkinter as tk\n\nFLOATER_WIDTH = 22\nFLOATER_HEIGHT = 18\n\n\nclass Floater(Valuator):\n    def __init__(self, parent = None, **kw):\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            ('style',  VALUATOR_MINI,   INITOPT),\n        )\n        self.defineoptions(kw, optiondefs)\n        # Initialize the superclass\n        Valuator.__init__(self, parent)\n        self.initialiseoptions(Floater)\n\n    def createValuator(self):\n        self._valuator = self.createcomponent('valuator',\n                                              (('floater', 'valuator'),),\n                                              None,\n                                              FloaterWidget,\n                                              (self.interior(),),\n                                              command = self.setEntry,\n                                              value = self['value'])\n        self._valuator._widget.bind('<Double-ButtonPress-1>', self.mouseReset)\n\n    def packValuator(self):\n        # Position components\n        if self._label:\n            self._label.grid(row=0, column=0, sticky = tk.EW)\n        self._entry.grid(row=0, column=1, sticky = tk.EW)\n        self._valuator.grid(row=0, column=2, padx = 2, pady = 2)\n        self.interior().columnconfigure(0, weight = 1)\n\n\nclass FloaterWidget(Pmw.MegaWidget):\n    def __init__(self, parent = None, **kw):\n        #define the megawidget options\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            # Appearance\n            ('width',           FLOATER_WIDTH,      INITOPT),\n            ('height',          FLOATER_HEIGHT,     INITOPT),\n            ('relief',          tk.RAISED,          self.setRelief),\n            ('borderwidth',     2,                  self.setBorderwidth),\n            ('background',      'grey75',           self.setBackground),\n            # Behavior\n            # Initial value of floater, use self.set to change value\n            ('value',           0.0,            INITOPT),\n            ('numDigits',       2,              self.setNumDigits),\n            # Command to execute on floater updates\n            ('command',         None,           None),\n            # Extra data to be passed to command function\n            ('commandData',     [],             None),\n            # Callback's to execute during mouse interaction\n            ('preCallback',     None,           None),\n            ('postCallback',    None,           None),\n            # Extra data to be passed to callback function, needs to be a list\n            ('callbackData',    [],             None),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Initialize the superclass\n        Pmw.MegaWidget.__init__(self, parent)\n\n        # Set up some local and instance variables\n        # Create the components\n        interior = self.interior()\n\n        # Current value\n        self.value = self['value']\n\n        # The canvas\n        width = self['width']\n        height = self['height']\n        self._widget = self.createcomponent('canvas', (), None,\n                                            tk.Canvas, (interior,),\n                                            width = width,\n                                            height = height,\n                                            background = self['background'],\n                                            highlightthickness = 0,\n                                            scrollregion = (-width/2.0,\n                                                            -height/2.0,\n                                                            width/2.0,\n                                                            height/2.0))\n        self._widget.pack(expand = 1, fill = tk.BOTH)\n\n        # The floater icon\n        self._widget.create_polygon(-width/2.0, 0, -2.0, -height/2.0,\n                                    -2.0, height/2.0,\n                                    fill = 'grey50',\n                                    tags = ('floater',))\n        self._widget.create_polygon(width/2.0, 0, 2.0, height/2.0,\n                                    2.0, -height/2.0,\n                                    fill = 'grey50',\n                                    tags = ('floater',))\n\n        # Add event bindings\n        self._widget.bind('<ButtonPress-1>', self.mouseDown)\n        self._widget.bind('<B1-Motion>', self.updateFloaterSF)\n        self._widget.bind('<ButtonRelease-1>', self.mouseUp)\n        self._widget.bind('<Enter>', self.highlightWidget)\n        self._widget.bind('<Leave>', self.restoreWidget)\n\n        # Make sure input variables processed\n        self.initialiseoptions(FloaterWidget)\n\n    def set(self, value, fCommand = 1):\n        \"\"\"\n        self.set(value, fCommand = 1)\n        Set floater to new value, execute command if fCommand == 1\n        \"\"\"\n        # Send command if any\n        if fCommand and (self['command'] is not None):\n            self['command'](*[value] + self['commandData'])\n        # Record value\n        self.value = value\n\n    def updateIndicator(self, value):\n        # Nothing visible to update on this type of widget\n        pass\n\n    def get(self):\n        \"\"\"\n        self.get()\n        Get current floater value\n        \"\"\"\n        return self.value\n\n    ## Canvas callback functions\n    # Floater velocity controller\n    def mouseDown(self, event):\n        \"\"\" Begin mouse interaction \"\"\"\n        # Exectute user redefinable callback function (if any)\n        self['relief'] = tk.SUNKEN\n        if self['preCallback']:\n            self['preCallback'](*self['callbackData'])\n        self.velocitySF = 0.0\n        self.updateTask = taskMgr.add(self.updateFloaterTask,\n                                        'updateFloater')\n        self.updateTask.lastTime = ClockObject.getGlobalClock().getFrameTime()\n\n    def updateFloaterTask(self, state):\n        \"\"\"\n        Update floaterWidget value based on current scaleFactor\n        Adjust for time to compensate for fluctuating frame rates\n        \"\"\"\n        currT = ClockObject.getGlobalClock().getFrameTime()\n        dt = currT - state.lastTime\n        self.set(self.value + self.velocitySF * dt)\n        state.lastTime = currT\n        return Task.cont\n\n    def updateFloaterSF(self, event):\n        \"\"\"\n        Update velocity scale factor based of mouse distance from origin\n        \"\"\"\n        x = self._widget.canvasx(event.x)\n        y = self._widget.canvasy(event.y)\n        offset = max(0, abs(x) - Valuator.deadband)\n        if offset == 0:\n            return 0\n        sf = math.pow(Valuator.sfBase,\n                      self.minExp + offset/Valuator.sfDist)\n        if x > 0:\n            self.velocitySF = sf\n        else:\n            self.velocitySF = -sf\n\n    def mouseUp(self, event):\n        taskMgr.remove(self.updateTask)\n        self.velocitySF = 0.0\n        # Execute user redefinable callback function (if any)\n        if self['postCallback']:\n            self['postCallback'](*self['callbackData'])\n        self['relief'] = tk.RAISED\n\n    def setNumDigits(self):\n        \"\"\"\n        Adjust minimum exponent to use in velocity task based\n        upon the number of digits to be displayed in the result\n        \"\"\"\n        self.minExp = math.floor(-self['numDigits']/\n                                 math.log10(Valuator.sfBase))\n\n    # Methods to modify floater characteristics\n    def setRelief(self):\n        self.interior()['relief'] = self['relief']\n\n    def setBorderwidth(self):\n        self.interior()['borderwidth'] = self['borderwidth']\n\n    def setBackground(self):\n        self._widget['background'] = self['background']\n\n    def highlightWidget(self, event):\n        self._widget.itemconfigure('floater', fill = 'black')\n\n    def restoreWidget(self, event):\n        self._widget.itemconfigure('floater', fill = 'grey50')\n\n\nclass FloaterGroup(Pmw.MegaToplevel):\n    def __init__(self, parent = None, **kw):\n\n        # Default group size\n        DEFAULT_DIM = 1\n        # Default value depends on *actual* group size, test for user input\n        DEFAULT_VALUE = [0.0] * kw.get('dim', DEFAULT_DIM)\n        DEFAULT_LABELS = ['v[%d]' % x for x in range(kw.get('dim', DEFAULT_DIM))]\n\n        #define the megawidget options\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            ('dim',             DEFAULT_DIM,            INITOPT),\n            ('side',            tk.TOP,                 INITOPT),\n            ('title',           'Floater Group',        None),\n            # A tuple of initial values, one for each floater\n            ('value',    DEFAULT_VALUE,          INITOPT),\n            # The command to be executed any time one of the floaters is updated\n            ('command',         None,                   None),\n            # A tuple of labels, one for each floater\n            ('labels',          DEFAULT_LABELS,         self._updateLabels),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Initialize the toplevel widget\n        Pmw.MegaToplevel.__init__(self, parent)\n\n        # Create the components\n        interior = self.interior()\n        # Get a copy of the initial value (making sure its a list)\n        self._value = list(self['value'])\n\n        # The Menu Bar\n        self.balloon = Pmw.Balloon()\n        menubar = self.createcomponent('menubar', (), None,\n                                       Pmw.MenuBar, (interior,),\n                                       balloon = self.balloon)\n        menubar.pack(fill=tk.X)\n\n        # FloaterGroup Menu\n        menubar.addmenu('Floater Group', 'Floater Group Operations')\n        menubar.addmenuitem(\n            'Floater Group', 'command', 'Reset the Floater Group panel',\n            label = 'Reset',\n            command = lambda s = self: s.reset())\n        menubar.addmenuitem(\n            'Floater Group', 'command', 'Dismiss Floater Group panel',\n            label = 'Dismiss', command = self.withdraw)\n\n        menubar.addmenu('Help', 'Floater Group Help Operations')\n        self.toggleBalloonVar = tk.IntVar()\n        self.toggleBalloonVar.set(0)\n        menubar.addmenuitem('Help', 'checkbutton',\n                            'Toggle balloon help',\n                            label = 'Balloon Help',\n                            variable = self.toggleBalloonVar,\n                            command = self.toggleBalloon)\n\n        self.floaterList = []\n        for index in range(self['dim']):\n            # Add a group alias so you can configure the floaters via:\n            #   fg.configure(Valuator_XXX = YYY)\n            f = self.createcomponent(\n                'floater%d' % index, (), 'Valuator', Floater,\n                (interior,), value = self._value[index],\n                text = self['labels'][index])\n            # Do this separately so command doesn't get executed during construction\n            f['command'] = lambda val, s=self, i=index: s._floaterSetAt(i, val)\n            f.pack(side = self['side'], expand = 1, fill = tk.X)\n            self.floaterList.append(f)\n\n        # Make sure floaters are initialized\n        self.set(self['value'])\n\n        # Make sure input variables processed\n        self.initialiseoptions(FloaterGroup)\n\n    def _updateLabels(self):\n        if self['labels']:\n            for index in range(self['dim']):\n                self.floaterList[index]['text'] = self['labels'][index]\n\n    def toggleBalloon(self):\n        if self.toggleBalloonVar.get():\n            self.balloon.configure(state = 'balloon')\n        else:\n            self.balloon.configure(state = 'none')\n\n    def get(self):\n        return self._value\n\n    def getAt(self, index):\n        return self._value[index]\n\n    # This is the command is used to set the groups value\n    def set(self, value, fCommand = 1):\n        for i in range(self['dim']):\n            self._value[i] = value[i]\n            # Update floater, but don't execute its command\n            self.floaterList[i].set(value[i], 0)\n        if fCommand and (self['command'] is not None):\n            self['command'](self._value)\n\n    def setAt(self, index, value):\n        # Update floater and execute its command\n        self.floaterList[index].set(value)\n\n    # This is the command used by the floater\n    def _floaterSetAt(self, index, value):\n        self._value[index] = value\n        if self['command']:\n            self['command'](self._value)\n\n    def reset(self):\n        self.set(self['value'])\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/tkwidgets/Floater.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/1702bab6_Floater.json",
    "doc_id": "doc_195"
  }
}