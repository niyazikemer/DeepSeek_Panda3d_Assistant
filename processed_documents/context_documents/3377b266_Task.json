{
  "content": "\"\"\" This module defines a Python-level wrapper around the C++\n:class:`~panda3d.core.AsyncTaskManager` interface.  It replaces the old\nfull-Python implementation of the Task system.\n\nFor more information about the task system, consult the\n:ref:`tasks-and-event-handling` page in the programming manual.\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = ['Task', 'TaskManager',\n           'cont', 'done', 'again', 'pickup', 'exit',\n           'sequence', 'loop', 'pause']\n\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.showbase.PythonUtil import Functor, ScratchPad\nfrom direct.showbase.MessengerGlobal import messenger\nfrom typing import Any, Callable, Coroutine, Final, Generator, Sequence, TypeVar, Union\nimport types\nimport random\nimport importlib\nimport sys\n\n# On Android, there's no use handling SIGINT, and in fact we can't, since we\n# run the application in a separate thread from the main thread.\nsignal: types.ModuleType | None\nif hasattr(sys, 'getandroidapilevel'):\n    signal = None\nelse:\n    try:\n        import _signal as signal  # type: ignore[import-not-found, no-redef]\n    except ImportError:\n        signal = None\n\nfrom panda3d.core import (\n    AsyncTask,\n    AsyncTaskPause,\n    AsyncTaskManager,\n    AsyncTaskSequence,\n    ClockObject,\n    ConfigVariableBool,\n    GlobPattern,\n    PythonTask,\n    Thread,\n)\nfrom direct.extensions_native import HTTPChannel_extensions # pylint: disable=unused-import\n\n# The following variables are typing constructs used in annotations\n# to succinctly express all the types that can be converted into tasks.\n_T = TypeVar('_T', covariant=True)\n_TaskCoroutine = Union[Coroutine[Any, None, _T], Generator[Any, None, _T]]\n_TaskFunction = Callable[..., Union[int, _TaskCoroutine[Union[int, None]], None]]\n_FuncOrTask = Union[_TaskFunction, _TaskCoroutine[Any], AsyncTask]\n\n\ndef print_exc_plus() -> None:\n    \"\"\"\n    Print the usual traceback information, followed by a listing of all the\n    local variables in each frame.\n    \"\"\"\n    import traceback\n\n    tb = sys.exc_info()[2]\n    assert tb is not None\n    while 1:\n        if not tb.tb_next:\n            break\n        tb = tb.tb_next\n    stack = []\n    f: types.FrameType | None = tb.tb_frame\n    while f:\n        stack.append(f)\n        f = f.f_back\n    stack.reverse()\n    traceback.print_exc()\n    print(\"Locals by frame, innermost last\")\n    for frame in stack:\n        print(\"\")\n        print(\"Frame %s in %s at line %s\" % (frame.f_code.co_name,\n                                             frame.f_code.co_filename,\n                                             frame.f_lineno))\n        for key, value in list(frame.f_locals.items()):\n            #We have to be careful not to cause a new error in our error\n            #printer! Calling str() on an unknown object could cause an\n            #error we don't want.\n            try:\n                valueStr = str(value)\n            except Exception:\n                valueStr = \"<ERROR WHILE PRINTING VALUE>\"\n            print(\"\\t%20s = %s\" % (key, valueStr))\n\n\n# For historical purposes, we remap the C++-defined enumeration to\n# these Python names, and define them both at the module level, here,\n# and at the class level (below).  The preferred access is via the\n# class level.\ndone: Final = AsyncTask.DSDone\ncont: Final = AsyncTask.DSCont\nagain: Final = AsyncTask.DSAgain\npickup: Final = AsyncTask.DSPickup\nexit: Final = AsyncTask.DSExit\n\n#: Task aliases to :class:`panda3d.core.PythonTask` for historical purposes.\nTask = PythonTask\n\n# Copy the module-level enums above into the class level.  This funny\n# syntax is necessary because it's a C++-wrapped extension type, not a\n# true Python class.\n# We can't override 'done', which is already a known method.  We have a\n# special check in PythonTask for when the method is being returned.\n#Task.DtoolClassDict['done'] = done\nTask.DtoolClassDict['cont'] = cont\nTask.DtoolClassDict['again'] = again\nTask.DtoolClassDict['pickup'] = pickup\nTask.DtoolClassDict['exit'] = exit\n\n# Alias the AsyncTaskPause constructor as Task.pause().\npause = AsyncTaskPause\nTask.DtoolClassDict['pause'] = staticmethod(pause)\n\ngather = Task.gather\nshield = Task.shield\n\n\ndef sequence(*taskList: AsyncTask) -> AsyncTaskSequence:\n    seq = AsyncTaskSequence('sequence')\n    for task in taskList:\n        seq.addTask(task)\n    return seq\n\n\nTask.DtoolClassDict['sequence'] = staticmethod(sequence)\n\n\ndef loop(*taskList: AsyncTask) -> AsyncTaskSequence:\n    seq = AsyncTaskSequence('loop')\n    for task in taskList:\n        seq.addTask(task)\n    seq.setRepeatCount(-1)\n    return seq\n\n\nTask.DtoolClassDict['loop'] = staticmethod(loop)\n\n\nclass TaskManager:\n    notify = directNotify.newCategory(\"TaskManager\")\n\n    taskTimerVerbose = ConfigVariableBool('task-timer-verbose', False)\n    extendedExceptions = ConfigVariableBool('extended-exceptions', False)\n    pStatsTasks = ConfigVariableBool('pstats-tasks', False)\n\n    MaxEpochSpeed = 1.0/30.0\n\n    __prevHandler: Any\n\n    def __init__(self) -> None:\n        self.mgr = AsyncTaskManager.getGlobalPtr()\n\n        self.resumeFunc: Callable[[], object] | None = None\n        self.globalClock = self.mgr.getClock()\n        self.stepping = False\n        self.running = False\n        self.destroyed = False\n        self.fKeyboardInterrupt = False\n        self.interruptCount = 0\n        if signal:\n            self.__prevHandler = signal.default_int_handler\n\n        self._frameProfileQueue: list[tuple[int, Any, Callable[[], object] | None]] = []\n\n        # this will be set when it's safe to import StateVar\n        self._profileFrames: Any = None\n        self._frameProfiler = None\n        self._profileTasks: Any = None\n        self._taskProfiler = None\n        self._taskProfileInfo = ScratchPad(\n            taskId = None,\n            profiled = False,\n            session = None,\n        )\n\n    def finalInit(self) -> None:\n        # This function should be called once during startup, after\n        # most things are imported.\n        from direct.fsm.StatePush import StateVar\n        self._profileTasks = StateVar(False)\n        self.setProfileTasks(ConfigVariableBool('profile-task-spikes', 0).getValue())\n        self._profileFrames = StateVar(False)\n        self.setProfileFrames(ConfigVariableBool('profile-frames', 0).getValue())\n\n    def destroy(self) -> None:\n        # This should be safe to call multiple times.\n        self.running = False\n        self.notify.info(\"TaskManager.destroy()\")\n        self.destroyed = True\n        self._frameProfileQueue.clear()\n        self.mgr.cleanup()\n\n    def __getClock(self) -> ClockObject:\n        return self.mgr.getClock()\n\n    def setClock(self, clockObject: ClockObject) -> None:\n        self.mgr.setClock(clockObject)\n        self.globalClock = clockObject\n\n    clock = property(__getClock, setClock)\n\n    def invokeDefaultHandler(self, signalNumber, stackFrame):\n        print('*** allowing mid-frame keyboard interrupt.')\n        # Restore default interrupt handler\n        if signal:\n            signal.signal(signal.SIGINT, self.__prevHandler)\n        # and invoke it\n        raise KeyboardInterrupt\n\n    def keyboardInterruptHandler(self, signalNumber, stackFrame):\n        self.fKeyboardInterrupt = 1\n        self.interruptCount += 1\n        if self.interruptCount == 1:\n            print('* interrupt by keyboard')\n        elif self.interruptCount == 2:\n            print('** waiting for end of frame before interrupting...')\n            # The user must really want to interrupt this process\n            # Next time around invoke the default handler\n            signal.signal(signal.SIGINT, self.invokeDefaultHandler)\n\n    def getCurrentTask(self) -> AsyncTask | None:\n        \"\"\" Returns the task currently executing on this thread, or\n        None if this is being called outside of the task manager. \"\"\"\n\n        return Thread.getCurrentThread().getCurrentTask()\n\n    def hasTaskChain(self, chainName: str) -> bool:\n        \"\"\" Returns true if a task chain with the indicated name has\n        already been defined, or false otherwise.  Note that\n        setupTaskChain() will implicitly define a task chain if it has\n        not already been defined, or modify an existing one if it has,\n        so in most cases there is no need to check this method\n        first. \"\"\"\n\n        return self.mgr.findTaskChain(chainName) is not None\n\n    def setupTaskChain(\n        self,\n        chainName: str,\n        numThreads: int | None = None,\n        tickClock: bool | None = None,\n        threadPriority: int | None = None,\n        frameBudget: float | None = None,\n        frameSync: bool | None = None,\n        timeslicePriority: bool | None = None,\n    ) -> None:\n        \"\"\"Defines a new task chain.  Each task chain executes tasks\n        potentially in parallel with all of the other task chains (if\n        numThreads is more than zero).  When a new task is created, it\n        may be associated with any of the task chains, by name (or you\n        can move a task to another task chain with\n        task.setTaskChain()).  You can have any number of task chains,\n        but each must have a unique name.\n\n        numThreads is the number of threads to allocate for this task\n        chain.  If it is 1 or more, then the tasks on this task chain\n        will execute in parallel with the tasks on other task chains.\n        If it is greater than 1, then the tasks on this task chain may\n        execute in parallel with themselves (within tasks of the same\n        sort value).\n\n        If tickClock is True, then this task chain will be responsible\n        for ticking the global clock each frame (and thereby\n        incrementing the frame counter).  There should be just one\n        task chain responsible for ticking the clock, and usually it\n        is the default, unnamed task chain.\n\n        threadPriority specifies the priority level to assign to\n        threads on this task chain.  It may be one of TPLow, TPNormal,\n        TPHigh, or TPUrgent.  This is passed to the underlying\n        threading system to control the way the threads are scheduled.\n\n        frameBudget is the maximum amount of time (in seconds) to\n        allow this task chain to run per frame.  Set it to -1 to mean\n        no limit (the default).  It's not directly related to\n        threadPriority.\n\n        frameSync is true to force the task chain to sync to the\n        clock.  When this flag is false, the default, the task chain\n        will finish all of its tasks and then immediately start from\n        the first task again, regardless of the clock frame.  When it\n        is true, the task chain will finish all of its tasks and then\n        wait for the clock to tick to the next frame before resuming\n        the first task.  This only makes sense for threaded tasks\n        chains; non-threaded task chains are automatically\n        synchronous.\n\n        timeslicePriority is False in the default mode, in which each\n        task runs exactly once each frame, round-robin style,\n        regardless of the task's priority value; or True to change the\n        meaning of priority so that certain tasks are run less often,\n        in proportion to their time used and to their priority value.\n        See AsyncTaskManager.setTimeslicePriority() for more.\n        \"\"\"\n\n        chain = self.mgr.makeTaskChain(chainName)\n        if numThreads is not None:\n            chain.setNumThreads(numThreads)\n        if tickClock is not None:\n            chain.setTickClock(tickClock)\n        if threadPriority is not None:\n            chain.setThreadPriority(threadPriority)\n        if frameBudget is not None:\n            chain.setFrameBudget(frameBudget)\n        if frameSync is not None:\n            chain.setFrameSync(frameSync)\n        if timeslicePriority is not None:\n            chain.setTimeslicePriority(timeslicePriority)\n\n    def hasTaskNamed(self, taskName: str) -> bool:\n        \"\"\"Returns true if there is at least one task, active or\n        sleeping, with the indicated name. \"\"\"\n\n        return bool(self.mgr.findTask(taskName))\n\n    def getTasksNamed(self, taskName: str) -> list[AsyncTask]:\n        \"\"\"Returns a list of all tasks, active or sleeping, with the\n        indicated name. \"\"\"\n        return list(self.mgr.findTasks(taskName))\n\n    def getTasksMatching(self, taskPattern: GlobPattern | str) -> list[AsyncTask]:\n        \"\"\"Returns a list of all tasks, active or sleeping, with a\n        name that matches the pattern, which can include standard\n        shell globbing characters like \\\\*, ?, and []. \"\"\"\n\n        return list(self.mgr.findTasksMatching(GlobPattern(taskPattern)))\n\n    def getAllTasks(self) -> list[AsyncTask]:\n        \"\"\"Returns list of all tasks, active and sleeping, in\n        arbitrary order. \"\"\"\n        return list(self.mgr.getTasks())\n\n    def getTasks(self) -> list[AsyncTask]:\n        \"\"\"Returns list of all active tasks in arbitrary order. \"\"\"\n        return list(self.mgr.getActiveTasks())\n\n    def getDoLaters(self) -> list[AsyncTask]:\n        \"\"\"Returns list of all sleeping tasks in arbitrary order. \"\"\"\n        return list(self.mgr.getSleepingTasks())\n\n    def doMethodLater(\n        self,\n        delayTime: float,\n        funcOrTask: _FuncOrTask,\n        name: str | None,\n        extraArgs: Sequence | None = None,\n        sort: int | None = None,\n        priority: int | None = None,\n        taskChain: str | None = None,\n        uponDeath: Callable[[], object] | None = None,\n        appendTask: bool = False,\n        owner = None,\n    ) -> AsyncTask:\n        \"\"\"Adds a task to be performed at some time in the future.\n        This is identical to `add()`, except that the specified\n        delayTime is applied to the Task object first, which means\n        that the task will not begin executing until at least the\n        indicated delayTime (in seconds) has elapsed.\n\n        After delayTime has elapsed, the task will become active, and\n        will run in the soonest possible frame thereafter.  If you\n        wish to specify a task that will run in the next frame, use a\n        delayTime of 0.\n        \"\"\"\n\n        if delayTime < 0:\n            assert self.notify.warning('doMethodLater: added task: %s with negative delay: %s' % (name, delayTime))\n\n        task = self.__setupTask(funcOrTask, name, priority, sort, extraArgs, taskChain, appendTask, owner, uponDeath)\n        task.setDelay(delayTime)\n        self.mgr.add(task)\n        return task\n\n    do_method_later = doMethodLater\n\n    def add(\n        self,\n        funcOrTask: _FuncOrTask,\n        name: str | None = None,\n        sort: int | None = None,\n        extraArgs: Sequence | None = None,\n        priority: int | None = None,\n        uponDeath: Callable[[], object] | None = None,\n        appendTask: bool = False,\n        taskChain: str | None = None,\n        owner = None,\n        delay: float | None = None,\n    ) -> AsyncTask:\n        \"\"\"\n        Add a new task to the taskMgr.  The task will begin executing\n        immediately, or next frame if its sort value has already\n        passed this frame.\n\n        Parameters:\n            funcOrTask: either an existing Task object (not already\n                added to the task manager), or a callable function\n                object. If this is a function, a new Task object will be\n                created and returned. You may also pass in a coroutine\n                object.\n\n            name (str): the name to assign to the Task.  Required,\n                unless you are passing in a Task object that already has\n                a name.\n\n            extraArgs (list): the list of arguments to pass to the task\n                function.  If this is omitted, the list is just the task\n                object itself.\n\n            appendTask (bool): If this is true, then the task object\n                itself will be appended to the end of the extraArgs list\n                before calling the function.\n\n            sort (int): the sort value to assign the task.  The default\n                sort is 0.  Within a particular task chain, it is\n                guaranteed that the tasks with a lower sort value will\n                all run before tasks with a higher sort value run.\n\n            priority (int): the priority at which to run the task.  The\n                default priority is 0.  Higher priority tasks are run\n                sooner, and/or more often.  For historical purposes, if\n                you specify a priority without also specifying a sort,\n                the priority value is understood to actually be a sort\n                value. (Previously, there was no priority value, only a\n                sort value, and it was called \"priority\".)\n\n            uponDeath (bool): a function to call when the task\n                terminates, either because it has run to completion, or\n                because it has been explicitly removed.\n\n            taskChain (str): the name of the task chain to assign the\n                task to.\n\n            owner: an optional Python object that is declared as the\n                \"owner\" of this task for maintenance purposes.  The\n                owner must have two methods:\n                ``owner._addTask(self, task)``, which is called when the\n                task begins, and ``owner._clearTask(self, task)``, which\n                is called when the task terminates.  This is all the\n                ownermeans.\n\n            delay: an optional amount of seconds to wait before starting\n                the task (equivalent to doMethodLater).\n\n        Returns:\n            The new Task object that has been added, or the original\n            Task object that was passed in.\n        \"\"\"\n\n        task = self.__setupTask(funcOrTask, name, priority, sort, extraArgs, taskChain, appendTask, owner, uponDeath)\n        if delay is not None:\n            task.setDelay(delay)\n        self.mgr.add(task)\n        return task\n\n    def __setupTask(\n        self,\n        funcOrTask: _FuncOrTask,\n        name: str | None,\n        priority: int | None,\n        sort: int | None,\n        extraArgs: Sequence | None,\n        taskChain: str | None,\n        appendTask: bool,\n        owner,\n        uponDeath: Callable[[], object] | None,\n    ) -> AsyncTask:\n        wasTask = False\n        if isinstance(funcOrTask, AsyncTask):\n            task = funcOrTask\n            wasTask = True\n        elif hasattr(funcOrTask, '__call__') or \\\n             hasattr(funcOrTask, 'cr_await') or \\\n             isinstance(funcOrTask, types.GeneratorType):\n            # It's a function, coroutine, or something emulating a coroutine.\n            task = PythonTask(funcOrTask)\n            if name is None:\n                name = getattr(funcOrTask, '__qualname__', None) or \\\n                       getattr(funcOrTask, '__name__', None)\n        else:\n            self.notify.error(\n                'add: Tried to add a task that was not a Task or a func')\n\n        if hasattr(task, 'setArgs'):\n            # It will only accept arguments if it's a PythonTask.\n            if extraArgs is None:\n                if wasTask:\n                    extraArgs = task.getArgs()\n                    #do not append the task to an existing task. It was already there\n                    #from the last time it was addeed\n                    appendTask = False\n                else:\n                    extraArgs = []\n                    appendTask = True\n            task.setArgs(extraArgs, appendTask)\n        elif extraArgs is not None:\n            self.notify.error(\n                'Task %s does not accept arguments.' % (repr(task)))\n\n        if name is not None:\n            task.setName(name)\n        assert task.hasName()\n\n        # For historical reasons, if priority is specified but not\n        # sort, it really means sort.\n        if priority is not None and sort is None:\n            task.setSort(priority)\n        else:\n            if priority is not None:\n                task.setPriority(priority)\n            if sort is not None:\n                task.setSort(sort)\n\n        if taskChain is not None:\n            task.setTaskChain(taskChain)\n\n        if owner is not None:\n            task.setOwner(owner)\n\n        if uponDeath is not None:\n            task.setUponDeath(uponDeath)\n\n        return task\n\n    def remove(self, taskOrName: AsyncTask | str | list[AsyncTask | str]) -> int:\n        \"\"\"Removes a task from the task manager.  The task is stopped,\n        almost as if it had returned task.done.  (But if the task is\n        currently executing, it will finish out its current frame\n        before being removed.)  You may specify either an explicit\n        Task object, or the name of a task.  If you specify a name,\n        all tasks with the indicated name are removed.  Returns the\n        number of tasks removed. \"\"\"\n\n        if isinstance(taskOrName, AsyncTask):\n            return self.mgr.remove(taskOrName)\n        elif isinstance(taskOrName, list):\n            count = 0\n            for task in taskOrName:\n                count += self.remove(task)\n            return count\n        else:\n            tasks = self.mgr.findTasks(taskOrName)\n            return self.mgr.remove(tasks)\n\n    def removeTasksMatching(self, taskPattern: GlobPattern | str) -> int:\n        \"\"\"Removes all tasks whose names match the pattern, which can\n        include standard shell globbing characters like \\\\*, ?, and [].\n        See also :meth:`remove()`.\n\n        Returns the number of tasks removed.\n        \"\"\"\n        tasks = self.mgr.findTasksMatching(GlobPattern(taskPattern))\n        return self.mgr.remove(tasks)\n\n    def step(self) -> None:\n        \"\"\"Invokes the task manager for one frame, and then returns.\n        Normally, this executes each task exactly once, though task\n        chains that are in sub-threads or that have frame budgets\n        might execute their tasks differently. \"\"\"\n\n        startFrameTime = self.globalClock.getRealTime()\n\n        # Replace keyboard interrupt handler during task list processing\n        # so we catch the keyboard interrupt but don't handle it until\n        # after task list processing is complete.\n        self.fKeyboardInterrupt = False\n        self.interruptCount = 0\n\n        if signal:\n            self.__prevHandler = signal.signal(signal.SIGINT, self.keyboardInterruptHandler)\n\n        try:\n            self.mgr.poll()\n\n            # This is the spot for an internal yield function\n            nextTaskTime = self.mgr.getNextWakeTime()\n            self.doYield(startFrameTime, nextTaskTime)\n\n        finally:\n            # Restore previous interrupt handler\n            if signal:\n                signal.signal(signal.SIGINT, self.__prevHandler)\n                self.__prevHandler = signal.default_int_handler\n\n        if self.fKeyboardInterrupt:\n            raise KeyboardInterrupt\n\n    def run(self) -> None:\n        \"\"\"Starts the task manager running.  Does not return until an\n        exception is encountered (including KeyboardInterrupt). \"\"\"\n\n        if sys.platform == 'emscripten':\n            return\n\n        # Set the clock to have last frame's time in case we were\n        # Paused at the prompt for a long time\n        t = self.globalClock.getFrameTime()\n        timeDelta = t - self.globalClock.getRealTime()\n        self.globalClock.setRealTime(t)\n        messenger.send(\"resetClock\", [timeDelta])\n\n        if self.resumeFunc is not None:\n            self.resumeFunc()\n\n        if self.stepping:\n            self.step()\n        else:\n            self.running = True\n            while self.running:\n                try:\n                    if len(self._frameProfileQueue) > 0:\n                        numFrames, session, callback = self._frameProfileQueue.pop(0)\n\n                        def _profileFunc(numFrames: int = numFrames) -> None:\n                            self._doProfiledFrames(numFrames)\n                        session.setFunc(_profileFunc)\n                        session.run()\n                        del _profileFunc\n                        if callback:\n                            callback()\n                        session.release()\n                    else:\n                        self.step()\n                except KeyboardInterrupt:\n                    self.stop()\n                except SystemExit:\n                    self.stop()\n                    raise\n                except IOError as ioError:\n                    code, message = self._unpackIOError(ioError)\n                    # Since upgrading to Python 2.4.1, pausing the execution\n                    # often gives this IOError during the sleep function:\n                    #     IOError: [Errno 4] Interrupted function call\n                    # So, let's just handle that specific exception and stop.\n                    # All other IOErrors should still get raised.\n                    # Only problem: legit IOError 4s will be obfuscated.\n                    if code == 4:\n                        self.stop()\n                    else:\n                        raise\n                except Exception as e:\n                    if self.extendedExceptions:\n                        self.stop()\n                        print_exc_plus()\n                    else:\n                        from direct.showbase import ExceptionVarDump\n                        if ExceptionVarDump.wantStackDumpLog and \\\n                           ExceptionVarDump.dumpOnExceptionInit:\n                            ExceptionVarDump._varDump__print(e)\n                        raise\n                except:\n                    if self.extendedExceptions:\n                        self.stop()\n                        print_exc_plus()\n                    else:\n                        raise\n\n        self.mgr.stopThreads()\n\n    def _unpackIOError(self, ioError):\n        # IOError unpack from http://www.python.org/doc/essays/stdexceptions/\n        # this needs to be in its own method, exceptions that occur inside\n        # a nested try block are not caught by the inner try block's except\n        try:\n            (code, message) = ioError\n        except Exception:\n            code = 0\n            message = ioError\n        return code, message\n\n    def stop(self) -> None:\n        # Set a flag so we will stop before beginning next frame\n        self.running = False\n\n    def __tryReplaceTaskMethod(self, task, oldMethod, newFunction):\n        if not isinstance(task, PythonTask):\n            return 0\n\n        method = task.getFunction()\n        if isinstance(method, types.MethodType):\n            function = method.__func__\n        else:\n            function = method\n        if function == oldMethod:\n            newMethod = types.MethodType(newFunction, method.__self__)\n            task.setFunction(newMethod)\n            # Found a match\n            return 1\n        return 0\n\n    def replaceMethod(self, oldMethod, newFunction):\n        numFound = 0\n        for task in self.getAllTasks():\n            numFound += self.__tryReplaceTaskMethod(task, oldMethod, newFunction)\n        return numFound\n\n    def popupControls(self):\n        # Don't use a regular import, to prevent ModuleFinder from picking\n        # it up as a dependency when building a .p3d package.\n        TaskManagerPanel = importlib.import_module('direct.tkpanels.TaskManagerPanel')\n        return TaskManagerPanel.TaskManagerPanel(self)\n\n    def getProfileSession(self, name=None):\n        # call to get a profile session that you can modify before passing to profileFrames()\n        if name is None:\n            name = 'taskMgrFrameProfile'\n\n        # Defer this import until we need it: some Python\n        # distributions don't provide the profile and pstats modules.\n        PS = importlib.import_module('direct.showbase.ProfileSession')\n        return PS.ProfileSession(name)\n\n    def profileFrames(self, num=None, session=None, callback=None):\n        if num is None:\n            num = 1\n        if session is None:\n            session = self.getProfileSession()\n        # make sure the profile session doesn't get destroyed before we're done with it\n        session.acquire()\n        self._frameProfileQueue.append((num, session, callback))\n\n    def _doProfiledFrames(self, numFrames):\n        for i in range(numFrames):\n            self.step()\n\n    def getProfileFrames(self):\n        return self._profileFrames.get()\n\n    def getProfileFramesSV(self):\n        return self._profileFrames\n\n    def setProfileFrames(self, profileFrames):\n        self._profileFrames.set(profileFrames)\n        if (not self._frameProfiler) and profileFrames:\n            # import here due to import dependencies\n            FP = importlib.import_module('direct.task.FrameProfiler')\n            self._frameProfiler = FP.FrameProfiler()\n\n    def getProfileTasks(self):\n        return self._profileTasks.get()\n\n    def getProfileTasksSV(self):\n        return self._profileTasks\n\n    def setProfileTasks(self, profileTasks):\n        self._profileTasks.set(profileTasks)\n        if (not self._taskProfiler) and profileTasks:\n            # import here due to import dependencies\n            TP = importlib.import_module('direct.task.TaskProfiler')\n            self._taskProfiler = TP.TaskProfiler()\n\n    def logTaskProfiles(self, name=None):\n        if self._taskProfiler:\n            self._taskProfiler.logProfiles(name)\n\n    def flushTaskProfiles(self, name=None):\n        if self._taskProfiler:\n            self._taskProfiler.flush(name)\n\n    def _setProfileTask(self, task):\n        if self._taskProfileInfo.session:\n            self._taskProfileInfo.session.release()\n            self._taskProfileInfo.session = None\n        self._taskProfileInfo = ScratchPad(\n            taskFunc = task.getFunction(),\n            taskArgs = task.getArgs(),\n            task = task,\n            profiled = False,\n            session = None,\n        )\n\n        # Temporarily replace the task's own function with our\n        # _profileTask method.\n        task.setFunction(self._profileTask)\n        task.setArgs([self._taskProfileInfo], True)\n\n    def _profileTask(self, profileInfo, task):\n        # This is called instead of the task function when we have\n        # decided to profile a task.\n\n        assert profileInfo.task == task\n        # don't profile the same task twice in a row\n        assert not profileInfo.profiled\n\n        # Restore the task's proper function for next time.\n        appendTask = False\n        taskArgs = profileInfo.taskArgs\n        if taskArgs and taskArgs[-1] == task:\n            appendTask = True\n            taskArgs = taskArgs[:-1]\n        task.setArgs(taskArgs, appendTask)\n        task.setFunction(profileInfo.taskFunc)\n\n        # Defer this import until we need it: some Python\n        # distributions don't provide the profile and pstats modules.\n        PS = importlib.import_module('direct.showbase.ProfileSession')\n        profileSession = PS.ProfileSession('profiled-task-%s' % task.getName(),\n                                           Functor(profileInfo.taskFunc, *profileInfo.taskArgs))\n        ret = profileSession.run()\n\n        # set these values *after* profiling in case we're profiling the TaskProfiler\n        profileInfo.session = profileSession\n        profileInfo.profiled = True\n\n        return ret\n\n    def _hasProfiledDesignatedTask(self):\n        # have we run a profile of the designated task yet?\n        return self._taskProfileInfo.profiled\n\n    def _getLastTaskProfileSession(self):\n        return self._taskProfileInfo.session\n\n    def _getRandomTask(self):\n        # Figure out when the next frame is likely to expire, so we\n        # won't grab any tasks that are sleeping for a long time.\n        now = self.globalClock.getFrameTime()\n        avgFrameRate = self.globalClock.getAverageFrameRate()\n        if avgFrameRate < .00001:\n            avgFrameDur = 0.\n        else:\n            avgFrameDur = (1. / self.globalClock.getAverageFrameRate())\n        next = now + avgFrameDur\n\n        # Now grab a task at random, until we find one that we like.\n        tasks = self.mgr.getTasks()\n        i = random.randrange(tasks.getNumTasks())\n        task = tasks.getTask(i)\n        while not isinstance(task, PythonTask) or \\\n              task.getWakeTime() > next:\n            tasks.removeTask(i)\n            i = random.randrange(tasks.getNumTasks())\n            task = tasks.getTask(i)\n        return task\n\n    def __repr__(self) -> str:\n        return str(self.mgr)\n\n    # In the event we want to do frame time managment, this is the\n    # function to replace or overload.\n    def doYield(self, frameStartTime: float, nextScheduledTaskTime: float) -> None:\n        pass\n\n    #def doYieldExample(self, frameStartTime, nextScheduledTaskTime):\n    #    minFinTime = frameStartTime + self.MaxEpochSpeed\n    #    if nextScheduledTaskTime > 0 and nextScheduledTaskTime < minFinTime:\n    #        print(' Adjusting Time')\n    #        minFinTime = nextScheduledTaskTime\n    #    delta = minFinTime - self.globalClock.getRealTime()\n    #    while delta > 0.002:\n    #        print ' sleep %s'% (delta)\n    #        time.sleep(delta)\n    #        delta = minFinTime - self.globalClock.getRealTime()\n\n\nif __debug__:\n    def checkLeak():\n        import gc\n        gc.enable()\n        from direct.showbase.DirectObject import DirectObject\n        from direct.task.TaskManagerGlobal import taskMgr\n\n        class TestClass(DirectObject):\n            def doTask(self, task):\n                return task.done\n        obj = TestClass()\n        startRefCount = sys.getrefcount(obj)\n        print('sys.getrefcount(obj): %s' % sys.getrefcount(obj))\n        print('** addTask')\n        t = obj.addTask(obj.doTask, 'test')\n        print('sys.getrefcount(obj): %s' % sys.getrefcount(obj))\n        print('task.getRefCount(): %s' % t.getRefCount())\n        print('** removeTask')\n        obj.removeTask('test')\n        print('sys.getrefcount(obj): %s' % sys.getrefcount(obj))\n        print('task.getRefCount(): %s' % t.getRefCount())\n        print('** step')\n        taskMgr.step()\n        taskMgr.step()\n        taskMgr.step()\n        print('sys.getrefcount(obj): %s' % sys.getrefcount(obj))\n        print('task.getRefCount(): %s' % t.getRefCount())\n        print('** task release')\n        t = None\n        print('sys.getrefcount(obj): %s' % sys.getrefcount(obj))\n        assert sys.getrefcount(obj) == startRefCount\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/task/Task.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/3377b266_Task.json",
    "doc_id": "doc_210"
  }
}