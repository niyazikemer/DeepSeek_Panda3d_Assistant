{
  "content": "\"\"\" Class used to create and control joybox device \"\"\"\nfrom direct.showbase.DirectObject import DirectObject\nfrom .DirectDeviceManager import ANALOG_DEADBAND, ANALOG_MAX, ANALOG_MIN, DirectDeviceManager\nfrom direct.directtools.DirectUtil import CLAMP\nfrom direct.gui import OnscreenText\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom panda3d.core import ButtonRegistry, ButtonThrower, ClockObject, NodePath, VBase3, Vec3\n\nimport math\n\n#TODO: Handle interaction between widget, followSelectedTask and updateTask\n\n# BUTTONS\nL_STICK = 0\nL_UPPER = 1\nL_LOWER = 2\nR_STICK = 3\nR_UPPER = 4\nR_LOWER = 5\n# ANALOGS\nNULL_AXIS = -1\nL_LEFT_RIGHT = 0\nL_FWD_BACK = 1\nL_TWIST = 2\nL_SLIDE = 3\nR_LEFT_RIGHT = 4\nR_FWD_BACK = 5\nR_TWIST = 6\nR_SLIDE = 7\n\nJOYBOX_MIN = ANALOG_MIN + ANALOG_DEADBAND\nJOYBOX_MAX = ANALOG_MAX - ANALOG_DEADBAND\nJOYBOX_RANGE = JOYBOX_MAX - JOYBOX_MIN\n\nJOYBOX_TREAD_SEPERATION = 1.0\n\n\nclass DirectJoybox(DirectObject):\n    joyboxCount = 0\n    xyzMultiplier = 1.0\n    hprMultiplier = 1.0\n\n    def __init__(self, device = 'CerealBox', nodePath = None, headingNP = None):\n        from direct.showbase.ShowBaseGlobal import base\n        if nodePath is None:\n            nodePath = base.direct.camera\n        if headingNP is None:\n            headingNP = base.direct.camera\n        # See if device manager has been initialized\n        if base.direct.deviceManager is None:\n            base.direct.deviceManager = DirectDeviceManager()\n        # Set name\n        DirectJoybox.joyboxCount += 1\n        self.name = 'Joybox-' + repr(DirectJoybox.joyboxCount)\n        # Get buttons and analogs\n        self.device = device\n        self.analogs = base.direct.deviceManager.createAnalogs(self.device)\n        self.buttons = base.direct.deviceManager.createButtons(self.device)\n        self.aList = [0, 0, 0, 0, 0, 0, 0, 0]\n        self.bList = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        # For joybox fly mode\n        # Default is joe mode\n        self.mapping = [R_LEFT_RIGHT, R_FWD_BACK, L_FWD_BACK,\n                        R_TWIST, L_TWIST, NULL_AXIS]\n        self.modifier = [1, 1, 1, -1, -1, 0]\n        # Initialize time\n        self.lastTime = ClockObject.getGlobalClock().getFrameTime()\n        # Record node path\n        self.nodePath = nodePath\n        self.headingNP = headingNP\n        self.useHeadingNP = False\n        self.rotateInPlace = False\n        self.floatingNP = NodePath(\"floating\")\n        # Ref CS for orbit mode\n        self.refCS = base.direct.cameraControl.coaMarker\n        self.tempCS = base.direct.group.attachNewNode('JoyboxTempCS')\n        # Text object to display current mode\n        self.readout = OnscreenText.OnscreenText(\n            pos = (-0.9, 0.95),\n            font = base.direct.font,\n            mayChange = 1)\n        # List of functions to cycle through\n        self.modeList = [self.joeMode, self.driveMode, self.orbitMode]\n        # Pick initial mode\n        self.updateFunc = self.joyboxFly\n        self.modeName = 'Joe Mode'\n        # Auxiliary data\n        self.auxData = []\n        # Button registry\n        self.addButtonEvents()\n        # Spawn update task\n        self.enable()\n\n    def setHeadingNodePath(self,np):\n\n        self.headingNP = np\n\n    def enable(self):\n        # Kill existing task\n        self.disable()\n        # Accept button events\n        self.acceptSwitchModeEvent()\n        self.acceptUprightCameraEvent()\n        # Update task\n        taskMgr.add(self.updateTask, self.name + '-updateTask')\n\n    def disable(self):\n        taskMgr.remove(self.name + '-updateTask')\n        # Ignore button events\n        self.ignoreSwitchModeEvent()\n        self.ignoreUprightCameraEvent()\n\n    def destroy(self):\n        self.disable()\n        self.tempCS.removeNode()\n\n    def addButtonEvents(self):\n        self.breg = ButtonRegistry.ptr()\n        # MRM: Hard coded!\n        for i in range(8):\n            self.buttons.setButtonMap(\n                i, self.breg.getButton(self.getEventName(i)))\n        self.eventThrower = self.buttons.getNodePath().attachNewNode(\n            ButtonThrower('JB Button Thrower'))\n\n    def setNodePath(self, nodePath):\n        self.nodePath = nodePath\n\n    def getNodePath(self):\n        return self.nodePath\n\n    def setRefCS(self, refCS):\n        self.refCS = refCS\n\n    def getRefCS(self):\n        return self.refCS\n\n    def getEventName(self, index):\n        return self.name + '-button-' + repr(index)\n\n    def setXyzMultiplier(self, multiplier):\n        DirectJoybox.xyzMultiplier = multiplier\n\n    def getXyzMultiplier(self):\n        return DirectJoybox.xyzMultiplier\n\n    def setHprMultiplier(self, multiplier):\n        DirectJoybox.hprMultiplier = multiplier\n\n    def getHprMultiplier(self):\n        return DirectJoybox.hprMultiplier\n\n    def updateTask(self, state):\n        # old optimization\n        #self.updateValsUnrolled()\n        self.updateVals()\n        self.updateFunc()\n        return Task.cont\n\n    def updateVals(self):\n        # Update delta time\n        cTime = ClockObject.getGlobalClock().getFrameTime()\n        self.deltaTime = cTime - self.lastTime\n        self.lastTime = cTime\n        # Update analogs\n        for i in range(len(self.analogs)):\n            self.aList[i] = self.normalizeChannel(i)\n        # Update buttons\n        for i in range(len(self.buttons)):\n            try:\n                self.bList[i] = self.buttons[i]\n            except IndexError:\n                # That channel may not have been updated yet\n                self.bList[i] = 0\n\n    def updateValsUnrolled(self):\n        # Update delta time\n        cTime = ClockObject.getGlobalClock().getFrameTime()\n        self.deltaTime = cTime - self.lastTime\n        self.lastTime = cTime\n        # Update analogs\n        for chan in range(len(self.analogs)):\n            val = self.analogs.getControlState(chan)\n            # Zero out values in deadband\n            if val < 0:\n                val = min(val + ANALOG_DEADBAND, 0.0)\n            else:\n                val = max(val - ANALOG_DEADBAND, 0.0)\n            # Scale up rotating knob values\n            if chan == L_TWIST or chan == R_TWIST:\n                val *= 3.0\n            # Now clamp value between minVal and maxVal\n            val = CLAMP(val, JOYBOX_MIN, JOYBOX_MAX)\n            self.aList[chan] = 2.0*((val - JOYBOX_MIN)/JOYBOX_RANGE) - 1\n        # Update buttons\n        for i in range(len(self.buttons)):\n            try:\n                self.bList[i] = self.buttons.getButtonState(i)\n            except IndexError:\n                # That channel may not have been updated yet\n                self.bList[i] = 0\n\n    def acceptSwitchModeEvent(self, button = R_UPPER):\n        self.accept(self.getEventName(button), self.switchMode)\n\n    def ignoreSwitchModeEvent(self, button = R_UPPER):\n        self.ignore(self.getEventName(button))\n\n    def switchMode(self):\n        try:\n            # Get current mode\n            self.modeFunc = self.modeList[0]\n            # Rotate mode list\n            self.modeList = self.modeList[1:] + self.modeList[:1]\n            # Call new mode\n            self.modeFunc()\n        except IndexError:\n            pass\n\n    def showMode(self, modeText):\n        def hideText(state, s=self):\n            s.readout.setText('')\n            return Task.done\n        taskMgr.remove(self.name + '-showMode')\n        # Update display\n        self.readout.setText(modeText)\n        t = taskMgr.doMethodLater(3.0, hideText, self.name + '-showMode')\n        t.setUponDeath(hideText)\n\n    def acceptUprightCameraEvent(self, button = L_UPPER):\n        self.accept(self.getEventName(button),\n                    base.direct.cameraControl.orbitUprightCam)\n\n    def ignoreUprightCameraEvent(self, button = L_UPPER):\n        self.ignore(self.getEventName(button))\n\n    def setMode(self, func, name):\n        self.disable()\n        self.updateFunc = func\n        self.modeName = name\n        self.showMode(self.modeName)\n        self.enable()\n\n    def setUseHeadingNP(self, enabled):\n        self.useHeadingNP = enabled\n\n    def setRotateInPlace(self, enabled):\n        self.rotateInPlace = enabled\n\n    def joyboxFly(self):\n        # Do nothing if no nodePath selected\n        if self.nodePath is None:\n            return\n\n        hprScale = ((self.aList[L_SLIDE] + 1.0) *\n                    50.0 * DirectJoybox.hprMultiplier)\n        posScale = ((self.aList[R_SLIDE] + 1.0) *\n                    50.0 * DirectJoybox.xyzMultiplier)\n\n        def getAxisVal(index, s=self):\n            try:\n                return s.aList[s.mapping[index]]\n            except IndexError:\n                # If it is a null axis return 0\n                return 0.0\n\n        x = getAxisVal(0) * self.modifier[0]\n        y = getAxisVal(1) * self.modifier[1]\n        z = getAxisVal(2) * self.modifier[2]\n        pos = Vec3(x, y, z) * (posScale * self.deltaTime)\n\n        h = getAxisVal(3) * self.modifier[3]\n        p = getAxisVal(4) * self.modifier[4]\n        r = getAxisVal(5) * self.modifier[5]\n        hpr = Vec3(h, p, r) * (hprScale * self.deltaTime)\n\n        # if we are using a heading nodepath, we want\n        # to drive in the direction we are facing,\n        # however, we don't want the z component to change\n        if self.useHeadingNP and self.headingNP is not None:\n            oldZ = pos.getZ()\n            pos = self.nodePath.getRelativeVector(self.headingNP, pos)\n            pos.setZ(oldZ)\n            # if we are using a heading NP we might want to rotate\n            # in place around that NP\n            if self.rotateInPlace:\n                parent = self.nodePath.getParent()\n                self.floatingNP.reparentTo(parent)\n                self.floatingNP.setPos(self.headingNP,0,0,0)\n                self.floatingNP.setHpr(0,0,0)\n                self.nodePath.wrtReparentTo(self.floatingNP)\n                self.floatingNP.setHpr(hpr)\n                self.nodePath.wrtReparentTo(parent)\n                hpr = Vec3(0,0,0)\n\n        self.nodePath.setPosHpr(self.nodePath, pos, hpr)\n\n    def joeMode(self):\n        self.mapping = [R_LEFT_RIGHT, R_FWD_BACK, L_FWD_BACK,\n                        R_TWIST, L_TWIST, NULL_AXIS]\n        self.modifier = [1, 1, 1, -1, -1, 0]\n        self.setMode(self.joyboxFly, 'Joe Mode')\n\n    def basicMode(self):\n        self.mapping = [NULL_AXIS, R_FWD_BACK, NULL_AXIS,\n                        R_LEFT_RIGHT, NULL_AXIS, NULL_AXIS]\n        self.modifier = [0, 1, 0, -1, 0, 0]\n        self.setMode(self.joyboxFly, 'Basic Mode')\n\n    def fpsMode(self):\n        self.mapping = [L_LEFT_RIGHT,R_FWD_BACK,L_FWD_BACK,\n                        R_LEFT_RIGHT, NULL_AXIS, NULL_AXIS]\n        self.modifier = [1, 1, 1, -1, 0, 0]\n        self.setMode(self.joyboxFly, 'FPS Mode')\n\n    def tankMode(self):\n        self.setMode(self.tankFly, 'Tank Mode')\n\n    def nullMode(self):\n        self.setMode(self.nullFly, 'Null Mode')\n\n    def lucMode(self):\n        self.mapping = [R_LEFT_RIGHT, R_FWD_BACK, L_FWD_BACK,\n                        R_TWIST, L_TWIST, L_LEFT_RIGHT]\n        self.modifier = [1, 1, 1, -1, -1, 0]\n        self.setMode(self.joyboxFly, 'Luc Mode')\n\n    def driveMode(self):\n        self.mapping = [L_LEFT_RIGHT, R_FWD_BACK, R_TWIST,\n                        R_LEFT_RIGHT, L_FWD_BACK, NULL_AXIS]\n        self.modifier = [1, 1, -1, -1, -1, 0]\n        self.setMode(self.joyboxFly, 'Drive Mode')\n\n    def lookAtMode(self):\n        self.mapping = [R_LEFT_RIGHT, R_TWIST, R_FWD_BACK,\n                        L_LEFT_RIGHT, L_FWD_BACK, NULL_AXIS]\n        self.modifier = [1, 1, 1, -1, 1, 0]\n        self.setMode(self.joyboxFly, 'Look At Mode')\n\n    def lookAroundMode(self):\n        self.mapping = [NULL_AXIS, NULL_AXIS, NULL_AXIS,\n                        R_LEFT_RIGHT, R_FWD_BACK, NULL_AXIS]\n        self.modifier = [0, 0, 0, -1, -1, 0]\n        self.setMode(self.joyboxFly, 'Lookaround Mode')\n\n    def demoMode(self):\n        self.mapping = [R_LEFT_RIGHT, R_FWD_BACK, L_FWD_BACK,\n                        R_TWIST, NULL_AXIS, NULL_AXIS]\n        self.modifier = [1, 1, 1, -1, 0, 0]\n        self.setMode(self.joyboxFly, 'Demo Mode')\n\n    def hprXyzMode(self):\n        self.mapping = [R_LEFT_RIGHT, R_FWD_BACK, R_TWIST,\n                        L_TWIST, L_FWD_BACK, L_LEFT_RIGHT]\n        self.modifier = [1, 1, -1, -1, -1, 1]\n        self.setMode(self.joyboxFly, 'HprXyz Mode')\n\n    def mopathMode(self):\n        self.mapping = [R_LEFT_RIGHT, R_FWD_BACK, R_TWIST,\n                        L_LEFT_RIGHT, L_FWD_BACK, L_LEFT_RIGHT]\n        self.modifier = [1, 1, -1, -1, 1, 0]\n        self.setMode(self.joyboxFly, 'Mopath Mode')\n\n    def walkthruMode(self):\n        self.mapping = [R_LEFT_RIGHT, R_FWD_BACK, L_TWIST,\n                        R_TWIST, L_FWD_BACK, L_LEFT_RIGHT]\n        self.modifier = [1, 1, -1, -1, -1, 1]\n        self.setMode(self.joyboxFly, 'Walkthru Mode')\n\n    def spaceMode(self):\n        self.setMode(self.spaceFly, 'Space Mode')\n\n    def nullFly(self):\n        return\n\n    def tankFly(self):\n\n        leftTreadSpeed  = (self.normalizeChannel(L_SLIDE,.1,100) *\n                           DirectJoybox.xyzMultiplier) * self.aList[L_FWD_BACK]\n        rightTreadSpeed = (self.normalizeChannel(R_SLIDE,.1,100) *\n                           DirectJoybox.xyzMultiplier) * self.aList[R_FWD_BACK]\n\n        forwardSpeed = (leftTreadSpeed + rightTreadSpeed)*.5\n        headingSpeed = math.atan2(leftTreadSpeed - rightTreadSpeed,\n                                  JOYBOX_TREAD_SEPERATION)\n        headingSpeed = 180/3.14159 * headingSpeed\n\n        dh = -1.0*headingSpeed * self.deltaTime*.3\n        dy = forwardSpeed * self.deltaTime\n\n        self.nodePath.setH(self.nodePath,dh)\n        self.nodePath.setY(self.nodePath,dy)\n\n    def spaceFly(self):\n        # Do nothing if no nodePath selected\n        if self.nodePath is None:\n            return\n        hprScale = (self.normalizeChannel(L_SLIDE, 0.1, 100) *\n                    DirectJoybox.hprMultiplier)\n        posScale = (self.normalizeChannel(R_SLIDE, 0.1, 100) *\n                    DirectJoybox.xyzMultiplier)\n        dr = -1 * hprScale * self.aList[R_TWIST] * self.deltaTime\n        dp = -1 * hprScale * self.aList[R_FWD_BACK] * self.deltaTime\n        dh = -1 * hprScale * self.aList[R_LEFT_RIGHT] * self.deltaTime\n        self.nodePath.setHpr(self.nodePath, dh, dp, dr)\n        dy = posScale * self.aList[L_FWD_BACK] * self.deltaTime\n        self.nodePath.setY(self.nodePath, dy)\n\n    def planetMode(self, auxData = []):\n        self.auxData = auxData\n        self.setMode(self.planetFly, 'Space Mode')\n\n    def planetFly(self):\n        # Do nothing if no nodePath selected\n        if self.nodePath is None:\n            return\n        hprScale = (self.normalizeChannel(L_SLIDE, 0.1, 100) *\n                    DirectJoybox.hprMultiplier)\n        posScale = (self.normalizeChannel(R_SLIDE, 0.1, 100) *\n                    DirectJoybox.xyzMultiplier)\n        dr = -1 * hprScale * self.aList[R_TWIST] * self.deltaTime\n        dp = -1 * hprScale * self.aList[R_FWD_BACK] * self.deltaTime\n        dh = -1 * hprScale * self.aList[R_LEFT_RIGHT] * self.deltaTime\n        self.nodePath.setHpr(self.nodePath, dh, dp, dr)\n        dy = posScale * self.aList[L_FWD_BACK] * self.deltaTime\n        dPos = VBase3(0, dy, 0)\n        for planet, radius in self.auxData:\n            # Are we within min radius?\n            # How far above planet are we?\n            np2planet = Vec3(self.nodePath.getPos(planet))\n            # Compute dist\n            offsetDist = np2planet.length()\n            # Above threshold, leave velocity vec as is\n            if offsetDist > (1.2 * radius):\n                pass\n            else:\n                # Getting close, slow things down\n                # Compute normal vector through node Path\n                oNorm = Vec3()\n                oNorm.assign(np2planet)\n                oNorm.normalize()\n                # Xform fly vec to planet space\n                dPlanet = self.nodePath.getMat(planet).xformVec(Vec3(0, dy, 0))\n                # Compute radial component of fly vec\n                dotProd = oNorm.dot(dPlanet)\n                if dotProd < 0:\n                    # Trying to fly below radius, compute radial component\n                    radialComponent = oNorm * dotProd\n                    # How far above?\n                    above = offsetDist - radius\n                    # Set sf accordingly\n                    sf = max(1.0 - (max(above, 0.0)/(0.2 * radius)), 0.0)\n                    # Subtract scaled radial component\n                    dPlanet -= radialComponent * (sf * sf)\n                    #dPlanet -= radialComponent\n                    # Convert back to node path space\n                    dPos.assign(planet.getMat(self.nodePath).xformVec(dPlanet))\n        # Set pos accordingly\n        self.nodePath.setPos(self.nodePath, dPos)\n\n    def orbitMode(self):\n        self.setMode(self.orbitFly, 'Orbit Mode')\n\n    def orbitFly(self):\n        # Do nothing if no nodePath selected\n        if self.nodePath is None:\n            return\n        hprScale = (self.normalizeChannel(L_SLIDE, 0.1, 100) *\n                    DirectJoybox.hprMultiplier)\n        posScale = (self.normalizeChannel(R_SLIDE, 0.1, 100) *\n                    DirectJoybox.xyzMultiplier)\n        r = -0.01 * posScale * self.aList[R_TWIST] * self.deltaTime\n        rx = hprScale * self.aList[R_LEFT_RIGHT] * self.deltaTime\n        ry = -hprScale * self.aList[R_FWD_BACK] * self.deltaTime\n        x = posScale * self.aList[L_LEFT_RIGHT] * self.deltaTime\n        z = posScale * self.aList[L_FWD_BACK] * self.deltaTime\n        h = -1 * hprScale * self.aList[L_TWIST] * self.deltaTime\n        # Move dcs\n        self.nodePath.setX(self.nodePath, x)\n        self.nodePath.setZ(self.nodePath, z)\n        self.nodePath.setH(self.nodePath, h)\n        self.orbitNode(rx, ry, 0)\n        pos = self.nodePath.getPos(self.refCS)\n        if Vec3(pos).length() < 0.005:\n            pos.set(0, -0.01, 0)\n        # Now move on out\n        pos.assign(pos * (1 + r))\n        self.nodePath.setPos(self.refCS, pos)\n\n    def orbitNode(self, h, p, r):\n        # Position the temp node path at the ref CS\n        self.tempCS.setPos(self.refCS, 0, 0, 0)\n        # Orient the temp node path to align with the orbiting node path\n        self.tempCS.setHpr(self.nodePath, 0, 0, 0)\n        # Record the position of the orbiter wrt the helper\n        pos = self.nodePath.getPos(self.tempCS)\n        # Turn the temp node path\n        self.tempCS.setHpr(self.tempCS, h, p, r)\n        # Position the orbiter \"back\" to its position wrt the helper\n        self.nodePath.setPos(self.tempCS, pos)\n        # Restore the original hpr of the orbiter\n        self.nodePath.setHpr(self.tempCS, 0, 0, 0)\n\n    # We need to override the DirectAnalog normalizeChannel to\n    # correct the ranges of the two twist axes of the joybox.\n\n    def normalizeChannel(self, chan, minVal = -1, maxVal = 1):\n        try:\n            if chan == L_TWIST or chan == R_TWIST:\n                # These channels have reduced range\n                return self.analogs.normalize(\n                    self.analogs.getControlState(chan), minVal, maxVal, 3.0)\n            else:\n                return self.analogs.normalize(\n                    self.analogs.getControlState(chan), minVal, maxVal)\n        except IndexError:\n            return 0.0\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/directdevices/DirectJoybox.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/60fa0dd8_DirectJoybox.json",
    "doc_id": "doc_113"
  }
}