{
  "content": "__all__ = [\"install\"]\n\nfrom panda3d.core import ConfigVariableBool\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.showbase.PythonUtil import fastRepr, Stack\nimport sys\nimport traceback\n\nnotify = directNotify.newCategory(\"ExceptionVarDump\")\n\nreentry = 0\n\n\ndef _varDump__init__(self, *args, **kArgs):\n    global reentry\n    if reentry > 0:\n        return\n    reentry += 1\n    # frame zero is this frame\n    f = 1\n    self._savedExcString = None\n    self._savedStackFrames = []\n    while True:\n        try:\n            frame = sys._getframe(f)\n        except ValueError as e:\n            break\n        else:\n            f += 1\n            self._savedStackFrames.append(frame)\n    self._moved__init__(*args, **kArgs)\n    reentry -= 1\n\n\nsReentry = 0\n\n\ndef _varDump__print(exc):\n    global sReentry\n    global notify\n    if sReentry > 0:\n        return\n    sReentry += 1\n    if not exc._savedExcString:\n        s = ''\n        foundRun = False\n        for frame in reversed(exc._savedStackFrames):\n            filename = frame.f_code.co_filename\n            codename = frame.f_code.co_name\n            if not foundRun and codename != 'run':\n                # don't print stack frames before run(),\n                # they contain builtins and are huge\n                continue\n            foundRun = True\n            s += '\\nlocals for %s:%s\\n' % (filename, codename)\n            locals = frame.f_locals\n            for var in locals:\n                obj = locals[var]\n                rep = fastRepr(obj)\n                s += '::%s = %s\\n' % (var, rep)\n        exc._savedExcString = s\n        exc._savedStackFrames = None\n    notify.info(exc._savedExcString)\n    sReentry -= 1\n\n\noldExcepthook = None\n# store these values here so that Task.py can always reliably access them\n# from its main exception handler\nwantStackDumpLog = False\nwantStackDumpUpload = False\nvariableDumpReasons: list = []\ndumpOnExceptionInit = False\n\n\nclass _AttrNotFound:\n    pass\n\n\ndef _excepthookDumpVars(eType, eValue, tb):\n    origTb = tb\n    excStrs = traceback.format_exception(eType, eValue, origTb)\n    s = 'printing traceback in case variable repr crashes the process...\\n'\n    for excStr in excStrs:\n        s += excStr\n    notify.info(s)\n    s = 'DUMPING STACK FRAME VARIABLES'\n    #import pdb;pdb.set_trace()\n    #foundRun = False\n    foundRun = True\n    while tb is not None:\n        frame = tb.tb_frame\n        code = frame.f_code\n        # this is a list of every string identifier used in this stack frame's code\n        codeNames = set(code.co_names)\n        # skip everything before the 'run' method, those frames have lots of\n        # not-useful information\n        if not foundRun:\n            if code.co_name == 'run':\n                foundRun = True\n            else:\n                tb = tb.tb_next\n                continue\n        s += '\\n  File \"%s\", line %s, in %s' % (\n            code.co_filename, frame.f_lineno, code.co_name)\n        stateStack = Stack()\n        # prime the stack with the variables we should visit from the frame's data structures\n        # grab all of the local, builtin and global variables that appear in the code's name list\n        name2obj = {}\n        for name, obj in frame.f_builtins.items():\n            if name in codeNames:\n                name2obj[name] = obj\n        for name, obj in frame.f_globals.items():\n            if name in codeNames:\n                name2obj[name] = obj\n        for name, obj in frame.f_locals.items():\n            if name in codeNames:\n                name2obj[name] = obj\n\n        traversedIds = set()\n        # push them in reverse alphabetical order so they'll be popped in the correct order\n        for name in sorted(name2obj, reverse=True):\n            stateStack.push([name, name2obj[name], traversedIds])\n\n        while len(stateStack) > 0:\n            name, obj, traversedIds = stateStack.pop()\n            #notify.info('%s, %s, %s' % (name, fastRepr(obj), traversedIds))\n            r = fastRepr(obj, maxLen=10)\n            if isinstance(r, str):\n                r = r.replace('\\n', '\\\\n')\n            s += '\\n    %s = %s' % (name, r)\n            # if we've already traversed through this object, don't traverse through it again\n            if id(obj) not in traversedIds:\n                attrName2obj = {}\n                for attrName in codeNames:\n                    attr = getattr(obj, attrName, _AttrNotFound)\n                    if attr is not _AttrNotFound:\n                        # prevent infinite recursion on method wrappers (__init__.__init__.__init__...)\n                        try:\n                            className = attr.__class__.__name__\n                        except Exception:\n                            pass\n                        else:\n                            if className == 'method-wrapper':\n                                continue\n                        attrName2obj[attrName] = attr\n                if len(attrName2obj) > 0:\n                    ids = set(traversedIds)\n                    ids.add(id(obj))\n                    # push them in reverse alphabetical order so they'll be popped in the correct order\n                    for attrName in sorted(attrName2obj, reverse=True):\n                        obj = attrName2obj[attrName]\n                        stateStack.push(['%s.%s' % (name, attrName), obj, ids])\n\n        tb = tb.tb_next\n\n    if foundRun:\n        s += '\\n'\n        if wantStackDumpLog:\n            notify.info(s)\n        if wantStackDumpUpload:\n            excStrs = traceback.format_exception(eType, eValue, origTb)\n            for excStr in excStrs:\n                s += excStr\n            timeMgr = None\n            try:\n                timeMgr = base.cr.timeManager\n            except Exception:\n                try:\n                    timeMgr = simbase.air.timeManager\n                except Exception:\n                    pass\n            if timeMgr:\n                timeMgr.setStackDump(s)\n\n    oldExcepthook(eType, eValue, origTb)\n\n\ndef install(log, upload):\n    \"\"\"Installs the exception hook.\"\"\"\n    global oldExcepthook\n    global wantStackDumpLog\n    global wantStackDumpUpload\n    global dumpOnExceptionInit\n\n    wantStackDumpLog = log\n    wantStackDumpUpload = upload\n\n    dumpOnExceptionInit = ConfigVariableBool('variable-dump-on-exception-init', False)\n    if dumpOnExceptionInit:\n        # this mode doesn't completely work because exception objects\n        # thrown by the interpreter don't get created until the\n        # stack has been unwound and an except block has been reached\n        if not hasattr(Exception, '_moved__init__'):\n            Exception._moved__init__ = Exception.__init__\n            Exception.__init__ = _varDump__init__\n    else:\n        if sys.excepthook is not _excepthookDumpVars:\n            oldExcepthook = sys.excepthook\n            sys.excepthook = _excepthookDumpVars\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/ExceptionVarDump.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/6ee4a724_ExceptionVarDump.json",
    "doc_id": "doc_273"
  }
}