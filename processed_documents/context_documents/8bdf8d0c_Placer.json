{
  "content": "\"\"\" DIRECT Nine DoF Manipulation Panel \"\"\"\n\n__all__ = ['Placer', 'place']\n\n# Import Tkinter, Pmw, and the dial code from this directory tree.\nfrom panda3d.core import NodePath, Vec3\nfrom direct.tkwidgets.AppShell import AppShell\nfrom direct.tkwidgets import Dial\nfrom direct.tkwidgets import Floater\nfrom direct.directtools.DirectGlobals import ZERO_VEC, UNIT_VEC\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.showbase import ShowBaseGlobal\nfrom direct.task.TaskManagerGlobal import taskMgr\nimport Pmw\nimport tkinter as tk\n\n#TODO: Task to monitor pose\n\n\nclass Placer(AppShell):\n    # Override class variables here\n    appname = 'Placer Panel'\n    frameWidth      = 625\n    frameHeight     = 215\n    usecommandarea = 0\n    usestatusarea  = 0\n\n    def __init__(self, parent = None, **kw):\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            ('title',       self.appname,       None),\n            ('nodePath',    ShowBaseGlobal.direct.camera,      None),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Call superclass initialization function\n        AppShell.__init__(self)\n\n        self.initialiseoptions(Placer)\n\n    def appInit(self):\n        # Initialize state\n        self.tempCS = ShowBaseGlobal.direct.group.attachNewNode('placerTempCS')\n        self.orbitFromCS = ShowBaseGlobal.direct.group.attachNewNode(\n            'placerOrbitFromCS')\n        self.orbitToCS = ShowBaseGlobal.direct.group.attachNewNode('placerOrbitToCS')\n        self.refCS = self.tempCS\n\n        # Dictionary keeping track of all node paths manipulated so far\n        self.nodePathDict = {}\n        self.nodePathDict['camera'] = ShowBaseGlobal.direct.camera\n        self.nodePathDict['widget'] = ShowBaseGlobal.direct.widget\n        self.nodePathNames = ['camera', 'widget', 'selected']\n\n        self.refNodePathDict = {}\n        self.refNodePathDict['parent'] = self['nodePath'].getParent()\n        self.refNodePathDict['render'] = render\n        self.refNodePathDict['camera'] = ShowBaseGlobal.direct.camera\n        self.refNodePathDict['widget'] = ShowBaseGlobal.direct.widget\n        self.refNodePathNames = ['parent', 'self', 'render',\n                                 'camera', 'widget', 'selected']\n\n        # Initial state\n        self.initPos = Vec3(0)\n        self.initHpr = Vec3(0)\n        self.initScale = Vec3(1)\n        self.deltaHpr = Vec3(0)\n\n        # Offset for orbital mode\n        self.posOffset = Vec3(0)\n\n        # Set up event hooks\n        self.undoEvents = [('DIRECT_undo', self.undoHook),\n                           ('DIRECT_pushUndo', self.pushUndoHook),\n                           ('DIRECT_undoListEmpty', self.undoListEmptyHook),\n                           ('DIRECT_redo', self.redoHook),\n                           ('DIRECT_pushRedo', self.pushRedoHook),\n                           ('DIRECT_redoListEmpty', self.redoListEmptyHook)]\n        for event, method in self.undoEvents:\n            self.accept(event, method)\n\n        # Init movement mode\n        self.movementMode = 'Relative To:'\n\n    def createInterface(self):\n        # The interior of the toplevel panel\n        interior = self.interior()\n        interior['relief'] = tk.FLAT\n        # Add placer commands to menubar\n        self.menuBar.addmenu('Placer', 'Placer Panel Operations')\n        self.menuBar.addmenuitem('Placer', 'command',\n                            'Zero Node Path',\n                            label = 'Zero All',\n                            command = self.zeroAll)\n        self.menuBar.addmenuitem('Placer', 'command',\n                            'Reset Node Path',\n                            label = 'Reset All',\n                            command = self.resetAll)\n        self.menuBar.addmenuitem('Placer', 'command',\n                            'Print Node Path Info',\n                            label = 'Print Info',\n                            command = self.printNodePathInfo)\n        self.menuBar.addmenuitem(\n            'Placer', 'command',\n            'Toggle widget visability',\n            label = 'Toggle Widget Vis',\n            command = ShowBaseGlobal.direct.toggleWidgetVis)\n        self.menuBar.addmenuitem(\n            'Placer', 'command',\n            'Toggle widget manipulation mode',\n            label = 'Toggle Widget Mode',\n            command = ShowBaseGlobal.direct.manipulationControl.toggleObjectHandlesMode)\n\n        # Get a handle to the menu frame\n        menuFrame = self.menuFrame\n        self.nodePathMenu = Pmw.ComboBox(\n            menuFrame, labelpos = tk.W, label_text = 'Node Path:',\n            entry_width = 20,\n            selectioncommand = self.selectNodePathNamed,\n            scrolledlist_items = self.nodePathNames)\n        self.nodePathMenu.selectitem('selected')\n        self.nodePathMenuEntry = (\n            self.nodePathMenu.component('entryfield_entry'))\n        self.nodePathMenuBG = (\n            self.nodePathMenuEntry.configure('background')[3])\n        self.nodePathMenu.pack(side = 'left', fill = 'x', expand = 1)\n        self.bind(self.nodePathMenu, 'Select node path to manipulate')\n\n        modeMenu = Pmw.OptionMenu(menuFrame,\n                                  items = ('Relative To:',\n                                           'Orbit:'),\n                                  initialitem = 'Relative To:',\n                                  command = self.setMovementMode,\n                                  menubutton_width = 8)\n        modeMenu.pack(side = 'left', expand = 0)\n        self.bind(modeMenu, 'Select manipulation mode')\n\n        self.refNodePathMenu = Pmw.ComboBox(\n            menuFrame, entry_width = 16,\n            selectioncommand = self.selectRefNodePathNamed,\n            scrolledlist_items = self.refNodePathNames)\n        self.refNodePathMenu.selectitem('parent')\n        self.refNodePathMenuEntry = (\n            self.refNodePathMenu.component('entryfield_entry'))\n        self.refNodePathMenu.pack(side = 'left', fill = 'x', expand = 1)\n        self.bind(self.refNodePathMenu, 'Select relative node path')\n\n        self.undoButton = tk.Button(menuFrame, text = 'Undo',\n                                    command = ShowBaseGlobal.direct.undo)\n        if ShowBaseGlobal.direct.undoList:\n            self.undoButton['state'] = 'normal'\n        else:\n            self.undoButton['state'] = 'disabled'\n        self.undoButton.pack(side = 'left', expand = 0)\n        self.bind(self.undoButton, 'Undo last operation')\n\n        self.redoButton = tk.Button(menuFrame, text = 'Redo',\n                                    command = ShowBaseGlobal.direct.redo)\n        if ShowBaseGlobal.direct.redoList:\n            self.redoButton['state'] = 'normal'\n        else:\n            self.redoButton['state'] = 'disabled'\n        self.redoButton.pack(side = 'left', expand = 0)\n        self.bind(self.redoButton, 'Redo last operation')\n\n        # Create and pack the Pos Controls\n        posGroup = Pmw.Group(interior,\n                             tag_pyclass = tk.Menubutton,\n                             tag_text = 'Position',\n                             tag_font=('MSSansSerif', 14),\n                             tag_activebackground = '#909090',\n                             ring_relief = tk.RIDGE)\n        posMenubutton = posGroup.component('tag')\n        self.bind(posMenubutton, 'Position menu operations')\n        posMenu = tk.Menu(posMenubutton, tearoff = 0)\n        posMenu.add_command(label = 'Set to zero', command = self.zeroPos)\n        posMenu.add_command(label = 'Reset initial',\n                            command = self.resetPos)\n        posMenubutton['menu'] = posMenu\n        posGroup.pack(side='left', fill = 'both', expand = 1)\n        posInterior = posGroup.interior()\n\n        # Create the dials\n        self.posX = self.createcomponent('posX', (), None,\n                                         Floater.Floater, (posInterior,),\n                                         text = 'X', relief = tk.FLAT,\n                                         value = 0.0,\n                                         label_foreground = 'Red')\n        self.posX['commandData'] = ['x']\n        self.posX['preCallback'] = self.xformStart\n        self.posX['postCallback'] = self.xformStop\n        self.posX['callbackData'] = ['x']\n        self.posX.pack(expand=1, fill='both')\n\n        self.posY = self.createcomponent('posY', (), None,\n                                         Floater.Floater, (posInterior,),\n                                         text = 'Y', relief = tk.FLAT,\n                                         value = 0.0,\n                                         label_foreground = '#00A000')\n        self.posY['commandData'] = ['y']\n        self.posY['preCallback'] = self.xformStart\n        self.posY['postCallback'] = self.xformStop\n        self.posY['callbackData'] = ['y']\n        self.posY.pack(expand=1, fill='both')\n\n        self.posZ = self.createcomponent('posZ', (), None,\n                                         Floater.Floater, (posInterior,),\n                                         text = 'Z', relief = tk.FLAT,\n                                         value = 0.0,\n                                         label_foreground = 'Blue')\n        self.posZ['commandData'] = ['z']\n        self.posZ['preCallback'] = self.xformStart\n        self.posZ['postCallback'] = self.xformStop\n        self.posZ['callbackData'] = ['z']\n        self.posZ.pack(expand=1, fill='both')\n\n        # Create and pack the Hpr Controls\n        hprGroup = Pmw.Group(interior,\n                             tag_pyclass = tk.Menubutton,\n                             tag_text = 'Orientation',\n                             tag_font=('MSSansSerif', 14),\n                             tag_activebackground = '#909090',\n                             ring_relief = tk.RIDGE)\n        hprMenubutton = hprGroup.component('tag')\n        self.bind(hprMenubutton, 'Orientation menu operations')\n        hprMenu = tk.Menu(hprMenubutton, tearoff = 0)\n        hprMenu.add_command(label = 'Set to zero', command = self.zeroHpr)\n        hprMenu.add_command(label = 'Reset initial', command = self.resetHpr)\n        hprMenubutton['menu'] = hprMenu\n        hprGroup.pack(side='left', fill = 'both', expand = 1)\n        hprInterior = hprGroup.interior()\n\n        # Create the dials\n        self.hprH = self.createcomponent('hprH', (), None,\n                                         Dial.AngleDial, (hprInterior,),\n                                         style = 'mini',\n                                         text = 'H', value = 0.0,\n                                         relief = tk.FLAT,\n                                         label_foreground = 'blue')\n        self.hprH['commandData'] = ['h']\n        self.hprH['preCallback'] = self.xformStart\n        self.hprH['postCallback'] = self.xformStop\n        self.hprH['callbackData'] = ['h']\n        self.hprH.pack(expand=1, fill='both')\n\n        self.hprP = self.createcomponent('hprP', (), None,\n                                         Dial.AngleDial, (hprInterior,),\n                                         style = 'mini',\n                                         text = 'P', value = 0.0,\n                                         relief = tk.FLAT,\n                                         label_foreground = 'red')\n        self.hprP['commandData'] = ['p']\n        self.hprP['preCallback'] = self.xformStart\n        self.hprP['postCallback'] = self.xformStop\n        self.hprP['callbackData'] = ['p']\n        self.hprP.pack(expand=1, fill='both')\n\n        self.hprR = self.createcomponent('hprR', (), None,\n                                         Dial.AngleDial, (hprInterior,),\n                                         style = 'mini',\n                                         text = 'R', value = 0.0,\n                                         relief = tk.FLAT,\n                                         label_foreground = '#00A000')\n        self.hprR['commandData'] = ['r']\n        self.hprR['preCallback'] = self.xformStart\n        self.hprR['postCallback'] = self.xformStop\n        self.hprR['callbackData'] = ['r']\n        self.hprR.pack(expand=1, fill='both')\n\n        # Create and pack the Scale Controls\n        # The available scaling modes\n        self.scalingMode = tk.StringVar()\n        self.scalingMode.set('Scale Uniform')\n        # The scaling widgets\n        scaleGroup = Pmw.Group(interior,\n                               tag_text = 'Scale Uniform',\n                               tag_pyclass = tk.Menubutton,\n                               tag_font=('MSSansSerif', 14),\n                               tag_activebackground = '#909090',\n                               ring_relief = tk.RIDGE)\n        self.scaleMenubutton = scaleGroup.component('tag')\n        self.bind(self.scaleMenubutton, 'Scale menu operations')\n        self.scaleMenubutton['textvariable'] = self.scalingMode\n\n        # Scaling menu\n        scaleMenu = tk.Menu(self.scaleMenubutton, tearoff = 0)\n        scaleMenu.add_command(label = 'Set to unity',\n                              command = self.unitScale)\n        scaleMenu.add_command(label = 'Reset initial',\n                              command = self.resetScale)\n        scaleMenu.add_radiobutton(label = 'Scale Free',\n                                      variable = self.scalingMode)\n        scaleMenu.add_radiobutton(label = 'Scale Uniform',\n                                      variable = self.scalingMode)\n        scaleMenu.add_radiobutton(label = 'Scale Proportional',\n                                      variable = self.scalingMode)\n        self.scaleMenubutton['menu'] = scaleMenu\n        # Pack group widgets\n        scaleGroup.pack(side='left', fill = 'both', expand = 1)\n        scaleInterior = scaleGroup.interior()\n\n        # Create the dials\n        self.scaleX = self.createcomponent('scaleX', (), None,\n                                           Floater.Floater, (scaleInterior,),\n                                           text = 'X Scale',\n                                           relief = tk.FLAT,\n                                           min = 0.0001, value = 1.0,\n                                           resetValue = 1.0,\n                                           label_foreground = 'Red')\n        self.scaleX['commandData'] = ['sx']\n        self.scaleX['callbackData'] = ['sx']\n        self.scaleX['preCallback'] = self.xformStart\n        self.scaleX['postCallback'] = self.xformStop\n        self.scaleX.pack(expand=1, fill='both')\n\n        self.scaleY = self.createcomponent('scaleY', (), None,\n                                           Floater.Floater, (scaleInterior,),\n                                           text = 'Y Scale',\n                                           relief = tk.FLAT,\n                                           min = 0.0001, value = 1.0,\n                                           resetValue = 1.0,\n                                           label_foreground = '#00A000')\n        self.scaleY['commandData'] = ['sy']\n        self.scaleY['callbackData'] = ['sy']\n        self.scaleY['preCallback'] = self.xformStart\n        self.scaleY['postCallback'] = self.xformStop\n        self.scaleY.pack(expand=1, fill='both')\n\n        self.scaleZ = self.createcomponent('scaleZ', (), None,\n                                           Floater.Floater, (scaleInterior,),\n                                           text = 'Z Scale',\n                                           relief = tk.FLAT,\n                                           min = 0.0001, value = 1.0,\n                                           resetValue = 1.0,\n                                           label_foreground = 'Blue')\n        self.scaleZ['commandData'] = ['sz']\n        self.scaleZ['callbackData'] = ['sz']\n        self.scaleZ['preCallback'] = self.xformStart\n        self.scaleZ['postCallback'] = self.xformStop\n        self.scaleZ.pack(expand=1, fill='both')\n\n        # Make sure appropriate labels are showing\n        self.setMovementMode('Relative To:')\n        # Set up placer for inital node path\n        self.selectNodePathNamed('init')\n        self.selectRefNodePathNamed('parent')\n        # Update place to reflect initial state\n        self.updatePlacer()\n        # Now that you're done setting up, attach commands\n        self.posX['command'] = self.xform\n        self.posY['command'] = self.xform\n        self.posZ['command'] = self.xform\n        self.hprH['command'] = self.xform\n        self.hprP['command'] = self.xform\n        self.hprR['command'] = self.xform\n        self.scaleX['command'] = self.xform\n        self.scaleY['command'] = self.xform\n        self.scaleZ['command'] = self.xform\n\n    ### WIDGET OPERATIONS ###\n\n    def setMovementMode(self, movementMode):\n        # Set prefix\n        namePrefix = ''\n        self.movementMode = movementMode\n        if movementMode == 'Relative To:':\n            namePrefix = 'Relative '\n        elif movementMode == 'Orbit:':\n            namePrefix = 'Orbit '\n        # Update pos widgets\n        self.posX['text'] = namePrefix + 'X'\n        self.posY['text'] = namePrefix + 'Y'\n        self.posZ['text'] = namePrefix + 'Z'\n        # Update hpr widgets\n        if movementMode == 'Orbit:':\n            namePrefix = 'Orbit delta '\n        self.hprH['text'] = namePrefix + 'H'\n        self.hprP['text'] = namePrefix + 'P'\n        self.hprR['text'] = namePrefix + 'R'\n        # Update temp cs and initialize widgets\n        self.updatePlacer()\n\n    def setScalingMode(self):\n        if self['nodePath']:\n            scale = self['nodePath'].getScale()\n            if scale[0] != scale[1] or \\\n               scale[0] != scale[2] or \\\n               scale[1] != scale[2]:\n                self.scalingMode.set('Scale Free')\n\n    def selectNodePathNamed(self, name):\n        nodePath = None\n        if name == 'init':\n            nodePath = self['nodePath']\n            # Add Combo box entry for the initial node path\n            self.addNodePath(nodePath)\n        elif name == 'selected':\n            nodePath = ShowBaseGlobal.direct.selected.last\n            # Add Combo box entry for this selected object\n            self.addNodePath(nodePath)\n        else:\n            nodePath = self.nodePathDict.get(name, None)\n            if nodePath is None:\n                # See if this evaluates into a node path\n                try:\n                    nodePath = eval(name)\n                    if isinstance(nodePath, NodePath):\n                        self.addNodePath(nodePath)\n                    else:\n                        # Good eval but not a node path, give up\n                        nodePath = None\n                except Exception:\n                    # Bogus eval\n                    nodePath = None\n                    # Clear bogus entry from listbox\n                    listbox = self.nodePathMenu.component('scrolledlist')\n                    listbox.setlist(self.nodePathNames)\n            else:\n                if name == 'widget':\n                    # Record relationship between selected nodes and widget\n                    ShowBaseGlobal.direct.selected.getWrtAll()\n        # Update active node path\n        self.setActiveNodePath(nodePath)\n\n    def setActiveNodePath(self, nodePath):\n        self['nodePath'] = nodePath\n        if self['nodePath']:\n            self.nodePathMenuEntry.configure(\n                background = self.nodePathMenuBG)\n            # Check to see if node path and ref node path are the same\n            if self.refCS is not None and self.refCS == self['nodePath']:\n                # Yes they are, use temp CS as ref\n                # This calls updatePlacer\n                self.setReferenceNodePath(self.tempCS)\n                # update listbox accordingly\n                self.refNodePathMenu.selectitem('parent')\n            else:\n                # Record initial value and initialize the widgets\n                self.updatePlacer()\n            # Record initial position\n            self.updateResetValues(self['nodePath'])\n            # Set scaling mode based on node path's current scale\n            self.setScalingMode()\n        else:\n            # Flash entry\n            self.nodePathMenuEntry.configure(background = 'Pink')\n\n    def selectRefNodePathNamed(self, name):\n        nodePath = None\n        if name == 'self':\n            nodePath = self.tempCS\n        elif name == 'selected':\n            nodePath = ShowBaseGlobal.direct.selected.last\n            # Add Combo box entry for this selected object\n            self.addRefNodePath(nodePath)\n        elif name == 'parent':\n            nodePath = self['nodePath'].getParent()\n        else:\n            nodePath = self.refNodePathDict.get(name, None)\n            if nodePath is None:\n                # See if this evaluates into a node path\n                try:\n                    nodePath = eval(name)\n                    if isinstance(nodePath, NodePath):\n                        self.addRefNodePath(nodePath)\n                    else:\n                        # Good eval but not a node path, give up\n                        nodePath = None\n                except Exception:\n                    # Bogus eval\n                    nodePath = None\n                    # Clear bogus entry from listbox\n                    listbox = self.refNodePathMenu.component('scrolledlist')\n                    listbox.setlist(self.refNodePathNames)\n        # Check to see if node path and ref node path are the same\n        if nodePath is not None and nodePath == self['nodePath']:\n            # Yes they are, use temp CS and update listbox accordingly\n            nodePath = self.tempCS\n            self.refNodePathMenu.selectitem('parent')\n        # Update ref node path\n        self.setReferenceNodePath(nodePath)\n\n    def setReferenceNodePath(self, nodePath):\n        self.refCS = nodePath\n        if self.refCS:\n            self.refNodePathMenuEntry.configure(\n                background = self.nodePathMenuBG)\n            # Update placer to reflect new state\n            self.updatePlacer()\n        else:\n            # Flash entry\n            self.refNodePathMenuEntry.configure(background = 'Pink')\n\n    def addNodePath(self, nodePath):\n        self.addNodePathToDict(nodePath, self.nodePathNames,\n                               self.nodePathMenu, self.nodePathDict)\n\n    def addRefNodePath(self, nodePath):\n        self.addNodePathToDict(nodePath, self.refNodePathNames,\n                               self.refNodePathMenu, self.refNodePathDict)\n\n    def addNodePathToDict(self, nodePath, names, menu, dict):\n        if not nodePath:\n            return\n        # Get node path's name\n        name = nodePath.getName()\n        if name in ['parent', 'render', 'camera']:\n            dictName = name\n        else:\n            # Generate a unique name for the dict\n            dictName = name + '-' + repr(hash(nodePath))\n        if dictName not in dict:\n            # Update combo box to include new item\n            names.append(dictName)\n            listbox = menu.component('scrolledlist')\n            listbox.setlist(names)\n            # Add new item to dictionary\n            dict[dictName] = nodePath\n        menu.selectitem(dictName)\n\n    def updatePlacer(self):\n        pos = Vec3(0)\n        hpr = Vec3(0)\n        scale = Vec3(1)\n        np = self['nodePath']\n        if np is not None and isinstance(np, NodePath):\n            # Update temp CS\n            self.updateAuxiliaryCoordinateSystems()\n            # Update widgets\n            if self.movementMode == 'Orbit:':\n                pos.assign(self.posOffset)\n                hpr.assign(ZERO_VEC)\n                scale.assign(np.getScale())\n            elif self.refCS:\n                pos.assign(np.getPos(self.refCS))\n                hpr.assign(np.getHpr(self.refCS))\n                scale.assign(np.getScale())\n        self.updatePosWidgets(pos)\n        self.updateHprWidgets(hpr)\n        self.updateScaleWidgets(scale)\n\n    def updateAuxiliaryCoordinateSystems(self):\n        # Temp CS\n        self.tempCS.setPosHpr(self['nodePath'], 0, 0, 0, 0, 0, 0)\n        # Orbit CS\n        # At reference\n        self.orbitFromCS.setPos(self.refCS, 0, 0, 0)\n        # But aligned with target\n        self.orbitFromCS.setHpr(self['nodePath'], 0, 0, 0)\n        # Also update to CS\n        self.orbitToCS.setPosHpr(self.orbitFromCS, 0, 0, 0, 0, 0, 0)\n        # Get offset from origin\n        self.posOffset.assign(self['nodePath'].getPos(self.orbitFromCS))\n\n    ### NODE PATH TRANSFORMATION OPERATIONS ###\n    def xform(self, value, axis):\n        if axis in ['sx', 'sy', 'sz']:\n            self.xformScale(value, axis)\n        elif self.movementMode == 'Relative To:':\n            self.xformRelative(value, axis)\n        elif self.movementMode == 'Orbit:':\n            self.xformOrbit(value, axis)\n        if self.nodePathMenu.get() == 'widget':\n            if ShowBaseGlobal.direct.manipulationControl.fSetCoa:\n                # Update coa based on current widget position\n                ShowBaseGlobal.direct.selected.last.mCoa2Dnp.assign(\n                    ShowBaseGlobal.direct.widget.getMat(ShowBaseGlobal.direct.selected.last))\n            else:\n                # Move the objects with the widget\n                ShowBaseGlobal.direct.selected.moveWrtWidgetAll()\n\n    def xformStart(self, data):\n        # Record undo point\n        self.pushUndo()\n        # If moving widget kill follow task and update wrts\n        if self.nodePathMenu.get() == 'widget':\n            taskMgr.remove('followSelectedNodePath')\n            # Record relationship between selected nodes and widget\n            ShowBaseGlobal.direct.selected.getWrtAll()\n        # Record initial state\n        self.deltaHpr = self['nodePath'].getHpr(self.refCS)\n        # Update placer to reflect new state\n        self.updatePlacer()\n\n    def xformStop(self, data):\n        # Throw event to signal manipulation done\n        # Send nodepath as a list\n        messenger.send('DIRECT_manipulateObjectCleanup', [[self['nodePath']]])\n        # Update placer to reflect new state\n        self.updatePlacer()\n        # If moving widget restart follow task\n        if self.nodePathMenu.get() == 'widget':\n            # Restart followSelectedNodePath task\n            ShowBaseGlobal.direct.manipulationControl.spawnFollowSelectedNodePathTask()\n\n    def xformRelative(self, value, axis):\n        nodePath = self['nodePath']\n        if nodePath is not None and self.refCS is not None:\n            if axis == 'x':\n                nodePath.setX(self.refCS, value)\n            elif axis == 'y':\n                nodePath.setY(self.refCS, value)\n            elif axis == 'z':\n                nodePath.setZ(self.refCS, value)\n            else:\n                if axis == 'h':\n                    self.deltaHpr.setX(value)\n                elif axis == 'p':\n                    self.deltaHpr.setY(value)\n                elif axis == 'r':\n                    self.deltaHpr.setZ(value)\n                # Put node path at new hpr\n                nodePath.setHpr(self.refCS, self.deltaHpr)\n\n    def xformOrbit(self, value, axis):\n        nodePath = self['nodePath']\n        if nodePath is not None and self.refCS is not None and \\\n           self.orbitFromCS is not None and self.orbitToCS is not None:\n            if axis == 'x':\n                self.posOffset.setX(value)\n            elif axis == 'y':\n                self.posOffset.setY(value)\n            elif axis == 'z':\n                self.posOffset.setZ(value)\n            elif axis == 'h':\n                self.orbitToCS.setH(self.orbitFromCS, value)\n            elif axis == 'p':\n                self.orbitToCS.setP(self.orbitFromCS, value)\n            elif axis == 'r':\n                self.orbitToCS.setR(self.orbitFromCS, value)\n            nodePath.setPosHpr(self.orbitToCS, self.posOffset, ZERO_VEC)\n\n    def xformScale(self, value, axis):\n        if self['nodePath']:\n            mode = self.scalingMode.get()\n            scale = self['nodePath'].getScale()\n            if mode == 'Scale Free':\n                if axis == 'sx':\n                    scale.setX(value)\n                elif axis == 'sy':\n                    scale.setY(value)\n                elif axis == 'sz':\n                    scale.setZ(value)\n            elif mode == 'Scale Uniform':\n                scale.set(value, value, value)\n            elif mode == 'Scale Proportional':\n                if axis == 'sx':\n                    sf = value / scale[0]\n                elif axis == 'sy':\n                    sf = value / scale[1]\n                elif axis == 'sz':\n                    sf = value / scale[2]\n                scale = scale * sf\n            self['nodePath'].setScale(scale)\n\n    def updatePosWidgets(self, pos):\n        self.posX.set(pos[0])\n        self.posY.set(pos[1])\n        self.posZ.set(pos[2])\n\n    def updateHprWidgets(self, hpr):\n        self.hprH.set(hpr[0])\n        self.hprP.set(hpr[1])\n        self.hprR.set(hpr[2])\n\n    def updateScaleWidgets(self, scale):\n        self.scaleX.set(scale[0])\n        self.scaleY.set(scale[1])\n        self.scaleZ.set(scale[2])\n\n    def zeroAll(self):\n        self.xformStart(None)\n        self.updatePosWidgets(ZERO_VEC)\n        self.updateHprWidgets(ZERO_VEC)\n        self.updateScaleWidgets(UNIT_VEC)\n        self.xformStop(None)\n\n    def zeroPos(self):\n        self.xformStart(None)\n        self.updatePosWidgets(ZERO_VEC)\n        self.xformStop(None)\n\n    def zeroHpr(self):\n        self.xformStart(None)\n        self.updateHprWidgets(ZERO_VEC)\n        self.xformStop(None)\n\n    def unitScale(self):\n        self.xformStart(None)\n        self.updateScaleWidgets(UNIT_VEC)\n        self.xformStop(None)\n\n    def updateResetValues(self, nodePath):\n        self.initPos.assign(nodePath.getPos())\n        self.posX['resetValue'] = self.initPos[0]\n        self.posY['resetValue'] = self.initPos[1]\n        self.posZ['resetValue'] = self.initPos[2]\n        self.initHpr.assign(nodePath.getHpr())\n        self.hprH['resetValue'] = self.initHpr[0]\n        self.hprP['resetValue'] = self.initHpr[1]\n        self.hprR['resetValue'] = self.initHpr[2]\n        self.initScale.assign(nodePath.getScale())\n        self.scaleX['resetValue'] = self.initScale[0]\n        self.scaleY['resetValue'] = self.initScale[1]\n        self.scaleZ['resetValue'] = self.initScale[2]\n\n    def resetAll(self):\n        if self['nodePath']:\n            self.xformStart(None)\n            self['nodePath'].setPosHprScale(\n                self.initPos, self.initHpr, self.initScale)\n            self.xformStop(None)\n\n    def resetPos(self):\n        if self['nodePath']:\n            self.xformStart(None)\n            self['nodePath'].setPos(self.initPos)\n            self.xformStop(None)\n\n    def resetHpr(self):\n        if self['nodePath']:\n            self.xformStart(None)\n            self['nodePath'].setHpr(self.initHpr)\n            self.xformStop(None)\n\n    def resetScale(self):\n        if self['nodePath']:\n            self.xformStart(None)\n            self['nodePath'].setScale(self.initScale)\n            self.xformStop(None)\n\n    def pushUndo(self, fResetRedo = 1):\n        ShowBaseGlobal.direct.pushUndo([self['nodePath']])\n\n    def undoHook(self, nodePathList = []):\n        # Reflect new changes\n        self.updatePlacer()\n\n    def pushUndoHook(self):\n        # Make sure button is reactivated\n        self.undoButton.configure(state = 'normal')\n\n    def undoListEmptyHook(self):\n        # Make sure button is deactivated\n        self.undoButton.configure(state = 'disabled')\n\n    def pushRedo(self):\n        ShowBaseGlobal.direct.pushRedo([self['nodePath']])\n\n    def redoHook(self, nodePathList = []):\n        # Reflect new changes\n        self.updatePlacer()\n\n    def pushRedoHook(self):\n        # Make sure button is reactivated\n        self.redoButton.configure(state = 'normal')\n\n    def redoListEmptyHook(self):\n        # Make sure button is deactivated\n        self.redoButton.configure(state = 'disabled')\n\n    def printNodePathInfo(self):\n        np = self['nodePath']\n        if np:\n            name = np.getName()\n            pos = np.getPos()\n            hpr = np.getHpr()\n            scale = np.getScale()\n            posString = '%.2f, %.2f, %.2f' % (pos[0], pos[1], pos[2])\n            hprString = '%.2f, %.2f, %.2f' % (hpr[0], hpr[1], hpr[2])\n            scaleString = '%.2f, %.2f, %.2f' % (scale[0], scale[1], scale[2])\n            print('NodePath: %s' % name)\n            print('Pos: %s' % posString)\n            print('Hpr: %s' % hprString)\n            print('Scale: %s' % scaleString)\n            print(('%s.setPosHprScale(%s, %s, %s)' %\n                   (name, posString, hprString, scaleString)))\n\n    def onDestroy(self, event):\n        # Remove hooks\n        for event, method in self.undoEvents:\n            self.ignore(event)\n        self.tempCS.removeNode()\n        self.orbitFromCS.removeNode()\n        self.orbitToCS.removeNode()\n\n\ndef place(nodePath):\n    return Placer(nodePath = nodePath)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/tkpanels/Placer.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/8bdf8d0c_Placer.json",
    "doc_id": "doc_63"
  }
}