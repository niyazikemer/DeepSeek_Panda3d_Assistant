{
  "content": "\"\"\"Contains objects that report different types of leaks to the\nContainerLeakDetector.\n\"\"\"\n\nfrom panda3d.core import ConfigVariableBool, MemoryUsage\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.showbase.PythonUtil import safeTypeName, typeName, uniqueName, serialNum\nfrom direct.showbase.Job import Job\nfrom direct.showbase.JobManagerGlobal import jobMgr\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.task.TaskManagerGlobal import taskMgr\nimport gc\nimport builtins\n\n\nclass LeakDetector:\n    def __init__(self):\n        # put this object just under __builtins__ where the\n        # ContainerLeakDetector will find it quickly\n        if not hasattr(builtins, \"leakDetectors\"):\n            builtins.leakDetectors = {}\n        self._leakDetectorsKey = self.getLeakDetectorKey()\n        if __dev__:\n            assert self._leakDetectorsKey not in builtins.leakDetectors\n        builtins.leakDetectors[self._leakDetectorsKey] = self\n\n    def destroy(self):\n        del builtins.leakDetectors[self._leakDetectorsKey]\n\n    def getLeakDetectorKey(self):\n        # this string will be shown to the end user and should ideally contain enough information to\n        # point to what is leaking\n        return '%s-%s' % (self.__class__.__name__, id(self))\n\n\nclass ObjectTypeLeakDetector(LeakDetector):\n    def __init__(self, otld, objType, generation):\n        self._otld = otld\n        self._objType = objType\n        self._generation = generation\n        LeakDetector.__init__(self)\n\n    def destroy(self):\n        self._otld = None\n        LeakDetector.destroy(self)\n\n    def getLeakDetectorKey(self):\n        return '%s-%s' % (self._objType, self.__class__.__name__)\n\n    def __len__(self):\n        num = self._otld._getNumObjsOfType(self._objType, self._generation)\n        self._generation = self._otld._getGeneration()\n        return num\n\n\nclass ObjectTypesLeakDetector(LeakDetector):\n    # are we accumulating any particular Python object type?\n    def __init__(self):\n        LeakDetector.__init__(self)\n        self._type2ld = {}\n        self._type2count = {}\n        self._generation = 0\n        self._thisLdGen = 0\n\n    def destroy(self):\n        for ld in self._type2ld.values():\n            ld.destroy()\n        LeakDetector.destroy(self)\n\n    def _recalc(self):\n        objs = gc.get_objects()\n        self._type2count = {}\n        for obj in objs:\n            objType = safeTypeName(obj)\n            if objType not in self._type2ld:\n                self._type2ld[objType] = ObjectTypeLeakDetector(self, objType, self._generation)\n            self._type2count.setdefault(objType, 0)\n            self._type2count[objType] += 1\n        self._generation += 1\n\n    def _getGeneration(self):\n        return self._generation\n\n    def _getNumObjsOfType(self, objType, otherGen):\n        if self._generation == otherGen:\n            self._recalc()\n        return self._type2count.get(objType, 0)\n\n    def __len__(self):\n        if self._generation == self._thisLdGen:\n            self._recalc()\n        self._thisLdGen = self._generation\n        return len(self._type2count)\n\n\nclass GarbageLeakDetector(LeakDetector):\n    # are we accumulating Python garbage?\n    def __len__(self):\n        # do a garbage collection\n        oldFlags = gc.get_debug()\n        gc.set_debug(0)\n        gc.collect()\n        numGarbage = len(gc.garbage)\n        del gc.garbage[:]\n        gc.set_debug(oldFlags)\n        return numGarbage\n\n\nclass SceneGraphLeakDetector(LeakDetector):\n    # is a scene graph leaking nodes?\n    def __init__(self, render):\n        LeakDetector.__init__(self)\n        self._render = render\n        if ConfigVariableBool('leak-scene-graph', False):\n            self._leakTaskName = 'leakNodes-%s' % serialNum()\n            self._leakNode()\n\n    def destroy(self):\n        if hasattr(self, '_leakTaskName'):\n            taskMgr.remove(self._leakTaskName)\n        del self._render\n        LeakDetector.destroy(self)\n\n    def __len__(self):\n        return self._render.countNumDescendants()\n\n    def __repr__(self):\n        return 'SceneGraphLeakDetector(%s)' % self._render\n\n    def _leakNode(self, task=None):\n        self._render.attachNewNode('leakNode-%s' % serialNum())\n        taskMgr.doMethodLater(10, self._leakNode, self._leakTaskName)\n\n\nclass CppMemoryUsage(LeakDetector):\n    def __len__(self):\n        return MemoryUsage.getCurrentCppSize()\n\n\nclass TaskLeakDetectorBase:\n    def _getTaskNamePattern(self, taskName):\n        # get a generic string pattern from a task name by removing numeric characters\n        for i in (0, 1, 2, 3, 4, 5, 6, 7, 8, 9):\n            taskName = taskName.replace('%s' % i, '')\n        return taskName\n\n\nclass _TaskNamePatternLeakDetector(LeakDetector, TaskLeakDetectorBase):\n    # tracks the number of each individual task type\n    # e.g. are we leaking 'examine-<doId>' tasks\n    def __init__(self, taskNamePattern):\n        self._taskNamePattern = taskNamePattern\n        LeakDetector.__init__(self)\n\n    def __len__(self):\n        # count the number of tasks that match our task name pattern\n        numTasks = 0\n        for task in taskMgr.getTasks():\n            if self._getTaskNamePattern(task.name) == self._taskNamePattern:\n                numTasks += 1\n        for task in taskMgr.getDoLaters():\n            if self._getTaskNamePattern(task.name) == self._taskNamePattern:\n                numTasks += 1\n        return numTasks\n\n    def getLeakDetectorKey(self):\n        return '%s-%s' % (self._taskNamePattern, self.__class__.__name__)\n\n\nclass TaskLeakDetector(LeakDetector, TaskLeakDetectorBase):\n    # tracks the number task 'types' and creates leak detectors for each task type\n    def __init__(self):\n        LeakDetector.__init__(self)\n        self._taskName2collector = {}\n\n    def destroy(self):\n        for taskName, collector in self._taskName2collector.items():\n            collector.destroy()\n        del self._taskName2collector\n        LeakDetector.destroy(self)\n\n    def _processTaskName(self, taskName):\n        # if this is a new task name pattern, create a leak detector for that pattern\n        namePattern = self._getTaskNamePattern(taskName)\n        if namePattern not in self._taskName2collector:\n            self._taskName2collector[namePattern] = _TaskNamePatternLeakDetector(namePattern)\n\n    def __len__(self):\n        self._taskName2collector = {}\n        # update our table of task leak detectors\n        for task in taskMgr.getTasks():\n            self._processTaskName(task.name)\n        for task in taskMgr.getDoLaters():\n            self._processTaskName(task.name)\n        # are we leaking task types?\n        return len(self._taskName2collector)\n\n\nclass MessageLeakDetectorBase:\n    def _getMessageNamePattern(self, msgName):\n        # get a generic string pattern from a message name by removing numeric characters\n        for i in (0, 1, 2, 3, 4, 5, 6, 7, 8, 9):\n            msgName = msgName.replace('%s' % i, '')\n        return msgName\n\n\nclass _MessageTypeLeakDetector(LeakDetector, MessageLeakDetectorBase):\n    # tracks the number of objects that are listening to each message\n    def __init__(self, msgNamePattern):\n        self._msgNamePattern = msgNamePattern\n        self._msgNames = set()\n        LeakDetector.__init__(self)\n\n    def addMsgName(self, msgName):\n        # for efficiency, we keep the actual message names around\n        # for queries on the messenger\n        self._msgNames.add(msgName)\n\n    def __len__(self):\n        toRemove = set()\n        num = 0\n        for msgName in self._msgNames:\n            n = messenger._getNumListeners(msgName)\n            if n == 0:\n                toRemove.add(msgName)\n            else:\n                num += n\n        # remove message names that are no longer in the messenger\n        self._msgNames.difference_update(toRemove)\n        return num\n\n    def getLeakDetectorKey(self):\n        return '%s-%s' % (self._msgNamePattern, self.__class__.__name__)\n\n\nclass _MessageTypeLeakDetectorCreator(Job):\n    def __init__(self, creator):\n        Job.__init__(self, uniqueName(typeName(self)))\n        self._creator = creator\n\n    def destroy(self):\n        self._creator = None\n        Job.destroy(self)\n\n    def finished(self):\n        Job.finished(self)\n\n    def run(self):\n        for msgName in messenger._getEvents():\n            yield None\n            namePattern = self._creator._getMessageNamePattern(msgName)\n            if namePattern not in self._creator._msgName2detector:\n                self._creator._msgName2detector[namePattern] = _MessageTypeLeakDetector(namePattern)\n            self._creator._msgName2detector[namePattern].addMsgName(msgName)\n        yield Job.Done\n\n\nclass MessageTypesLeakDetector(LeakDetector, MessageLeakDetectorBase):\n    def __init__(self):\n        LeakDetector.__init__(self)\n        self._msgName2detector = {}\n        self._createJob = None\n        if ConfigVariableBool('leak-message-types', False):\n            self._leakers = []\n            self._leakTaskName = uniqueName('leak-message-types')\n            taskMgr.add(self._leak, self._leakTaskName)\n\n    def _leak(self, task):\n        self._leakers.append(DirectObject())\n        self._leakers[-1].accept('leak-msg', self._leak)\n        return task.cont\n\n    def destroy(self):\n        if hasattr(self, '_leakTaskName'):\n            taskMgr.remove(self._leakTaskName)\n            for leaker in self._leakers:\n                leaker.ignoreAll()\n            self._leakers = None\n        if self._createJob:\n            self._createJob.destroy()\n        self._createJob = None\n        for msgName, detector in self._msgName2detector.items():\n            detector.destroy()\n        del self._msgName2detector\n        LeakDetector.destroy(self)\n\n    def __len__(self):\n        if self._createJob:\n            if self._createJob.isFinished():\n                self._createJob.destroy()\n                self._createJob = None\n        self._createJob = _MessageTypeLeakDetectorCreator(self)\n        jobMgr.add(self._createJob)\n        # are we leaking message types?\n        return len(self._msgName2detector)\n\n\nclass _MessageListenerTypeLeakDetector(LeakDetector):\n    # tracks the number of each object type that is listening for events\n    def __init__(self, typeName):\n        self._typeName = typeName\n        LeakDetector.__init__(self)\n\n    def __len__(self):\n        numObjs = 0\n        for obj in messenger._getObjects():\n            if typeName(obj) == self._typeName:\n                numObjs += 1\n        return numObjs\n\n    def getLeakDetectorKey(self):\n        return '%s-%s' % (self._typeName, self.__class__.__name__)\n\n\nclass _MessageListenerTypeLeakDetectorCreator(Job):\n    def __init__(self, creator):\n        Job.__init__(self, uniqueName(typeName(self)))\n        self._creator = creator\n\n    def destroy(self):\n        self._creator = None\n        Job.destroy(self)\n\n    def finished(self):\n        Job.finished(self)\n\n    def run(self):\n        for obj in messenger._getObjects():\n            yield None\n            tName = typeName(obj)\n            if tName not in self._creator._typeName2detector:\n                self._creator._typeName2detector[tName] = (\n                    _MessageListenerTypeLeakDetector(tName))\n        yield Job.Done\n\n\nclass MessageListenerTypesLeakDetector(LeakDetector):\n    def __init__(self):\n        LeakDetector.__init__(self)\n        self._typeName2detector = {}\n        self._createJob = None\n        if ConfigVariableBool('leak-message-listeners', False):\n            self._leakers = []\n            self._leakTaskName = uniqueName('leak-message-listeners')\n            taskMgr.add(self._leak, self._leakTaskName)\n\n    def _leak(self, task):\n        self._leakers.append(DirectObject())\n        self._leakers[-1].accept(uniqueName('leak-msg-listeners'), self._leak)\n        return task.cont\n\n    def destroy(self):\n        if hasattr(self, '_leakTaskName'):\n            taskMgr.remove(self._leakTaskName)\n            for leaker in self._leakers:\n                leaker.ignoreAll()\n            self._leakers = None\n        if self._createJob:\n            self._createJob.destroy()\n        self._createJob = None\n        for typeName, detector in self._typeName2detector.items():\n            detector.destroy()\n        del self._typeName2detector\n        LeakDetector.destroy(self)\n\n    def __len__(self):\n        if self._createJob:\n            if self._createJob.isFinished():\n                self._createJob.destroy()\n                self._createJob = None\n        self._createJob = _MessageListenerTypeLeakDetectorCreator(self)\n        jobMgr.add(self._createJob)\n        # are we leaking listener types?\n        return len(self._typeName2detector)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/LeakDetectors.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/b67c5154_LeakDetectors.json",
    "doc_id": "doc_269"
  }
}