{
  "content": "\"\"\"Undocumented Module\"\"\"\n\n__all__ = ['Valuator', 'ValuatorGroup', 'ValuatorGroupPanel']\n\nfrom panda3d.core import Vec4\nfrom direct.directtools.DirectUtil import getTkColorString\nfrom . import WidgetPropertiesDialog\nimport tkinter as tk\nfrom tkinter.colorchooser import askcolor\nimport Pmw\n\nVALUATOR_MINI = 'mini'\nVALUATOR_FULL = 'full'\n\n\nclass Valuator(Pmw.MegaWidget):\n    sfBase = 3.0\n    sfDist = 7\n    deadband = 5\n    \"\"\" Base class for widgets used to interactively adjust numeric values \"\"\"\n\n    def __init__(self, parent = None, **kw):\n        #define the megawidget options\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            ('state',             tk.NORMAL,      self.setState),\n            # Widget appearance\n            ('relief',            tk.GROOVE,      None),\n            ('borderwidth',       2,              None),\n            ('text',              'Valuator',     self.setLabel),\n            # Initial and reset values\n            ('value',             0.0,            INITOPT),\n            ('resetValue',        0.0,            None),\n            # Behavior\n            ('min',               None,           None),\n            ('max',               None,           None),\n            ('resolution',        None,           None),\n            ('numDigits',         2,              self.setEntryFormat),\n            # Enable/disable popup menu\n            ('fAdjustable',       1,              None),\n            # Actions\n            ('command',           None,           None),\n            ('commandData',       [],             None),\n            ('fCommandOnInit',    0,              INITOPT),\n            # Callbacks to execute when updating widget's value\n            ('preCallback',       None,           None),\n            ('postCallback',      None,           None),\n            # Extra data to be passed to callback function, needs to be a list\n            ('callbackData',      [],             None),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Initialize the superclass\n        Pmw.MegaWidget.__init__(self, parent)\n\n        # Current adjusted (for min/max/resolution) value\n        self.adjustedValue = self['value']\n\n        # Create the components\n        interior = self.interior()\n        interior.configure(relief = self['relief'], bd = self['borderwidth'])\n\n        # The Valuator\n        self.createValuator()\n        # Set valuator callbacks for mouse start/stop\n        self._valuator['preCallback'] = self._mouseDown\n        self._valuator['postCallback'] = self._mouseUp\n\n        # The Label\n        if self['text'] is not None:\n            self._label = self.createcomponent('label', (), None,\n                                               tk.Label, (interior,),\n                                               text = self['text'],\n                                               font = ('MS Sans Serif', 12),\n                                               anchor = tk.CENTER)\n        else:\n            self._label = None\n\n        # The entry\n        self._entryVal = tk.StringVar()\n        self._entry = self.createcomponent('entry', (), None,\n                                           tk.Entry, (interior,),\n                                           justify = tk.RIGHT,\n                                           width = 12,\n                                           textvariable = self._entryVal)\n        self._entry.bind('<Return>', self.validateEntryInput)\n        self._entryBackground = self._entry.cget('background')\n\n        # Pack Valuator Widget\n        self.packValuator()\n\n        # Set reset value if none specified\n        if 'resetValue' not in kw:\n            self['resetValue'] = self['value']\n\n        if self['fAdjustable']:\n            # The popup menu\n            self._popupMenu = tk.Menu(interior, tearoff = 0)\n            self.addValuatorMenuEntries()\n            self._popupMenu.add_command(label = 'Reset',\n                                        command = self.reset)\n            self._popupMenu.add_command(label = 'Set to Zero',\n                                        command = self.zero)\n            self._popupMenu.add_command(\n                label = 'Properties...',\n                command = self._popupPropertiesDialog)\n            # Add key bindings\n            if self._label:\n                self._label.bind(\n                    '<ButtonPress-3>', self._popupValuatorMenu)\n            self._entry.bind(\n                '<ButtonPress-3>', self._popupValuatorMenu)\n            self._valuator._widget.bind(\n                '<ButtonPress-3>', self._popupValuatorMenu)\n\n            # A Dictionary of dictionaries for the popup property dialog\n            self.propertyDict = {\n                'state':\n                {'widget': self,\n                 'type': 'string',\n                 'help': 'Enter state: normal or disabled.'\n                 },\n\n                'text':\n                {'widget': self,\n                 'type': 'string',\n                 'help': 'Enter label text.'\n                 },\n\n                'min':\n                {'widget': self,\n                 'type': 'real',\n                 'fNone': 1,\n                 'help': 'Minimum allowable value. Enter None for no minimum.'},\n                'max':\n                {'widget': self,\n                 'type': 'real',\n                 'fNone': 1,\n                 'help': 'Maximum allowable value. Enter None for no maximum.'},\n                'numDigits':\n                {'widget': self,\n                 'type': 'integer',\n                 'help': 'Number of digits after decimal point.'\n                 },\n\n                'resolution':\n                {'widget': self,\n                 'type': 'real',\n                 'fNone': 1,\n                 'help':'Widget resolution. Enter None for no resolution .'\n                 },\n\n                'resetValue':\n                {'widget': self,\n                 'type': 'real',\n                 'help': 'Enter value to set widget to on reset.'}\n            }\n            # Property list defines the display order of the properties\n            self.propertyList = [\n                'state', 'text', 'min', 'max', 'numDigits',\n                'resolution', 'resetValue']\n            # Add any valuator specific properties\n            self.addValuatorPropertiesToDialog()\n\n        # Make sure input variables processed\n        self.fInit = self['fCommandOnInit']\n        self.initialiseoptions(Valuator)\n\n    def set(self, value, fCommand = 1):\n        \"\"\"\n        Update widget's value by setting valuator, which will in\n        turn update the entry.  fCommand flag (which is passed to the\n        valuator as commandData, which is then passed in turn to\n        self.setEntry) controls command execution.\n        \"\"\"\n        self._valuator['commandData'] = [fCommand]\n        self._valuator.set(value)\n        # Restore commandData to 1 so that interaction via valuator widget\n        # will result in command being executed, otherwise a set with\n        # commandData == 0 will stick and commands will not be executed\n        self._valuator['commandData'] = [1]\n\n    def get(self):\n        \"\"\" Return current widget value \"\"\"\n        return self.adjustedValue\n\n    def setEntry(self, value, fCommand = 1):\n        \"\"\"\n        Update value displayed in entry, fCommand flag controls\n        command execution\n        \"\"\"\n        # Clamp value\n        if self['min'] is not None:\n            if value < self['min']:\n                value = self['min']\n        if self['max'] is not None:\n            if value > self['max']:\n                value = self['max']\n        # Round by resolution\n        if self['resolution'] is not None:\n            value = round(value / self['resolution']) * self['resolution']\n        # Format value and use it to set entry\n        self._entryVal.set(self.entryFormat % value)\n        # Update indicator (if any) to reflect new adjusted value\n        self._valuator.updateIndicator(value)\n        # Execute command if required\n        if fCommand and self.fInit and (self['command'] is not None):\n            self['command'](*[value] + self['commandData'])\n        # Record adjusted value\n        self.adjustedValue = value\n        # Once initialization is finished, allow commands to execute\n        self.fInit = 1\n\n    def setEntryFormat(self):\n        \"\"\"\n        Change the number of significant digits in entry\n        \"\"\"\n        # Create new format string\n        self.entryFormat = \"%.\" + \"%df\" % self['numDigits']\n        # Update entry to reflect new format\n        self.setEntry(self.get())\n        # Pass info down to valuator to adjust valuator sensitivity\n        self._valuator['numDigits'] = self['numDigits']\n\n    def validateEntryInput(self, event):\n        \"\"\" Check validity of entry and if valid pass along to valuator \"\"\"\n        input = self._entryVal.get()\n        try:\n            # Reset background\n            self._entry.configure(background = self._entryBackground)\n            # Get new value and check validity\n            newValue = float(input)\n            # If OK, execute preCallback if one defined\n            self._preCallback()\n            # Call set to update valuator\n            self.set(newValue)\n            # Execute callback\n            self._postCallback()\n            # Update valuator to reflect adjusted value\n            # Don't execute command\n            self._valuator.set(self.adjustedValue, 0)\n        except ValueError:\n            # Invalid entry, flash background\n            self._entry.configure(background = 'Pink')\n\n    # Callbacks executed on mouse down/up\n    def _mouseDown(self):\n        \"\"\" Function to execute at start of mouse interaction \"\"\"\n        # Execute pre interaction callback\n        self._preCallback()\n\n    def _mouseUp(self):\n        \"\"\" Function to execute at end of mouse interaction \"\"\"\n        # Execute post interaction callback\n        self._postCallback()\n        # Update valuator to reflect adjusted value\n        # Don't execute command\n        self._valuator.set(self.adjustedValue, 0)\n\n    # Callback functions\n    def _preCallback(self):\n        if self['preCallback']:\n            self['preCallback'](*self['callbackData'])\n\n    def _postCallback(self):\n        # Exectute post callback if one defined\n        if self['postCallback']:\n            self['postCallback'](*self['callbackData'])\n\n    def setState(self):\n        \"\"\" Enable/disable widget \"\"\"\n        if self['state'] == tk.NORMAL:\n            self._entry['state'] = tk.NORMAL\n            self._entry['background'] = self._entryBackground\n            self._valuator._widget['state'] = tk.NORMAL\n        elif self['state'] == tk.DISABLED:\n            self._entry['background'] = 'grey75'\n            self._entry['state'] = tk.DISABLED\n            self._valuator._widget['state'] = tk.DISABLED\n\n    def setLabel(self):\n        \"\"\" Update label's text \"\"\"\n        if self._label:\n            self._label['text'] = self['text']\n\n    def zero(self):\n        \"\"\"\n        self.zero()\n        Set valuator to zero\n        \"\"\"\n        self.set(0.0)\n\n    def reset(self):\n        \"\"\"\n        self.reset()\n        Reset valuator to reset value\n        \"\"\"\n        self.set(self['resetValue'])\n\n    def mouseReset(self, event):\n        \"\"\"\n        Reset valuator to resetValue\n        \"\"\"\n        # If not over any canvas item\n        #if not self._widget.find_withtag(CURRENT):\n        self.reset()\n\n    # Popup dialog to adjust widget properties\n    def _popupValuatorMenu(self, event):\n        self._popupMenu.post(event.widget.winfo_pointerx(),\n                             event.widget.winfo_pointery())\n\n    def _popupPropertiesDialog(self):\n        WidgetPropertiesDialog.WidgetPropertiesDialog(\n            self.propertyDict,\n            propertyList = self.propertyList,\n            title = 'Widget Properties',\n            parent = self.interior())\n\n    def addPropertyToDialog(self, property, pDict):\n        self.propertyDict[property] = pDict\n        self.propertyList.append(property)\n\n    # Virtual functions to be redefined by subclass\n    def createValuator(self):\n        \"\"\" Function used by subclass to create valuator geometry \"\"\"\n\n    def packValuator(self):\n        \"\"\" Function used by subclass to pack widget \"\"\"\n\n    def addValuatorMenuEntries(self):\n        \"\"\" Function used by subclass to add menu entries to popup menu \"\"\"\n\n    def addValuatorPropertiesToDialog(self):\n        \"\"\" Function used by subclass to add properties to property dialog \"\"\"\n\n\nFLOATER = 'floater'\nDIAL = 'dial'\nANGLEDIAL = 'angledial'\nSLIDER = 'slider'\n\n\nclass ValuatorGroup(Pmw.MegaWidget):\n    def __init__(self, parent = None, **kw):\n\n        # Default group size\n        DEFAULT_DIM = 1\n        # Default value depends on *actual* group size, test for user input\n        DEFAULT_VALUE = [0.0] * kw.get('dim', DEFAULT_DIM)\n        DEFAULT_LABELS = ['v[%d]' % x for x in range(kw.get('dim', DEFAULT_DIM))]\n\n        #define the megawidget options\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            ('type',            FLOATER,                INITOPT),\n            ('dim',             DEFAULT_DIM,            INITOPT),\n            ('side',            tk.TOP,                 INITOPT),\n            # A list of initial values, one for each valuator\n            ('value',           DEFAULT_VALUE,          INITOPT),\n            ('min',             None,                   INITOPT),\n            ('max',             None,                   INITOPT),\n            ('resolution',      None,                   INITOPT),\n            ('numDigits',       2,                      self._setNumDigits),\n            # A tuple of labels, one for each valuator\n            ('labels',          DEFAULT_LABELS,         self._updateLabels),\n            # The command to be executed when one of the valuators is updated\n            ('command',         None,                   None),\n            # Callbacks to execute when updating widget's value\n            ('preCallback',       None,                 None),\n            ('postCallback',      None,                 None),\n            # Extra data to be passed to callback function, needs to be a list\n            ('callbackData',      [],                   None),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Initialize the toplevel widget\n        Pmw.MegaWidget.__init__(self, parent)\n\n        # Create the components\n        interior = self.interior()\n        # Get a copy of the initial value (making sure its a list)\n        self._value = list(self['value'])\n\n        # Create the valuators\n        self._valuatorList = []\n        for index in range(self['dim']):\n            # Add a group alias so you can configure the valuators via:\n            #   fg.configure(Valuator_XXX = YYY)\n            if self['type'] == DIAL:\n                from . import Dial\n                valuatorType = Dial.Dial\n            elif self['type'] == ANGLEDIAL:\n                from . import Dial\n                valuatorType = Dial.AngleDial\n            elif self['type'] == SLIDER:\n                from . import Slider\n                valuatorType = Slider.Slider\n            else:\n                from . import Floater\n                valuatorType = Floater.Floater\n            f = self.createcomponent(\n                'valuator%d' % index, (), 'valuator', valuatorType,\n                (interior,), value = self._value[index],\n                min = self['min'], max = self['max'],\n                resolution = self['resolution'],\n                text = self['labels'][index],\n                command = lambda val, i = index: self._valuatorSetAt(i, val),\n                preCallback = self._preCallback,\n                postCallback = self._postCallback,\n                callbackData = [self],\n            )\n            f.pack(side = self['side'], expand = 1, fill = tk.X)\n            self._valuatorList.append(f)\n\n        # Make sure valuators are initialized\n        self.set(self['value'], fCommand = 0)\n\n        # Make sure input variables processed\n        self.initialiseoptions(ValuatorGroup)\n\n    # This is the command is used to set the groups value\n    def set(self, value, fCommand = 1):\n        for i in range(self['dim']):\n            self._value[i] = value[i]\n            # Update valuator, but don't execute its command\n            self._valuatorList[i].set(value[i], 0)\n        if fCommand and (self['command'] is not None):\n            self['command'](self._value)\n\n    def setAt(self, index, value):\n        # Update valuator and execute its command\n        self._valuatorList[index].set(value)\n\n    # This is the command used by the valuator\n    def _valuatorSetAt(self, index, value):\n        self._value[index] = value\n        if self['command']:\n            self['command'](self._value)\n\n    def get(self):\n        return self._value\n\n    def getAt(self, index):\n        return self._value[index]\n\n    def _setNumDigits(self):\n        self['valuator_numDigits'] = self['numDigits']\n        self.formatString = '%0.' + '%df' % self['numDigits']\n\n    def _updateLabels(self):\n        if self['labels']:\n            for index in range(self['dim']):\n                self._valuatorList[index]['text'] = self['labels'][index]\n\n    def _preCallback(self, valGroup):\n        # Execute pre callback\n        if self['preCallback']:\n            self['preCallback'](*valGroup.get())\n\n    def _postCallback(self, valGroup):\n        # Execute post callback\n        if self['postCallback']:\n            self['postCallback'](*valGroup.get())\n\n    def __len__(self):\n        return self['dim']\n\n    def __repr__(self):\n        str = '[' + self.formatString % self._value[0]\n        for val in self._value[1:]:\n            str += ', ' + self.formatString % val\n        str += ']'\n        return str\n\n\nclass ValuatorGroupPanel(Pmw.MegaToplevel):\n    def __init__(self, parent = None, **kw):\n\n        # Default group size\n        DEFAULT_DIM = 1\n        # Default value depends on *actual* group size, test for user input\n        DEFAULT_VALUE = [0.0] * kw.get('dim', DEFAULT_DIM)\n        DEFAULT_LABELS = ['v[%d]' % x for x in range(kw.get('dim', DEFAULT_DIM))]\n\n        #define the megawidget options\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            ('type',            FLOATER,                INITOPT),\n            ('dim',             DEFAULT_DIM,            INITOPT),\n            ('side',            tk.TOP,                 INITOPT),\n            ('title',           'Valuator Group',       None),\n            # A list of initial values, one for each floater\n            ('value',           DEFAULT_VALUE,          INITOPT),\n            ('min',             None,                   INITOPT),\n            ('max',             None,                   INITOPT),\n            ('resolution',      None,                   INITOPT),\n            # A tuple of labels, one for each floater\n            ('labels',          DEFAULT_LABELS,         self._updateLabels),\n            ('numDigits',       2,                      self._setNumDigits),\n            # The command to be executed when one of the floaters is updated\n            ('command',         None,                   self._setCommand),\n            # Callbacks to execute when updating widget's value\n            ('preCallback',       None,                 self._setPreCallback),\n            ('postCallback',      None,                 self._setPostCallback),\n            # Extra data to be passed to callback function, needs to be a list\n            ('callbackData',      [],                   self._setCallbackData),\n            # Destroy or withdraw\n            ('fDestroy',        0,                      INITOPT)\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Initialize the toplevel widget\n        Pmw.MegaToplevel.__init__(self, parent)\n\n        # Create the components\n        interior = self.interior()\n\n        # The Menu Bar\n        self.balloon = Pmw.Balloon()\n        menubar = self.createcomponent('menubar', (), None,\n                                       Pmw.MenuBar, (interior,),\n                                       balloon = self.balloon)\n        menubar.pack(fill=tk.X)\n\n        # ValuatorGroup Menu\n        menubar.addmenu('Valuator Group', 'Valuator Group Operations')\n        menubar.addmenuitem(\n            'Valuator Group', 'command', 'Reset the Valuator Group panel',\n            label = 'Reset',\n            command = lambda s = self: s.reset())\n\n        if self['fDestroy']:\n            dismissCommand = self.destroy\n        else:\n            dismissCommand = self.withdraw\n\n        menubar.addmenuitem(\n            'Valuator Group', 'command', 'Dismiss Valuator Group panel',\n            label = 'Dismiss', command = dismissCommand)\n\n        menubar.addmenu('Help', 'Valuator Group Help Operations')\n        self.toggleBalloonVar = tk.IntVar()\n        self.toggleBalloonVar.set(0)\n        menubar.addmenuitem('Help', 'checkbutton',\n                            'Toggle balloon help',\n                            label = 'Balloon Help',\n                            variable = self.toggleBalloonVar,\n                            command = self.toggleBalloon)\n\n        # Create the valuator group\n        self.valuatorGroup = self.createcomponent(\n            'valuatorGroup',\n            (('valuator', 'valuatorGroup_valuator'),),\n            None, ValuatorGroup,\n            (interior,),\n            type = self['type'],\n            dim = self['dim'],\n            value = self['value'],\n            min = self['min'],\n            max = self['max'],\n            resolution = self['resolution'],\n            labels = self['labels'],\n            command = self['command'])\n        self.valuatorGroup.pack(expand = 1, fill = tk.X)\n\n        # Make sure input variables processed\n        self.initialiseoptions(ValuatorGroupPanel)\n\n    def toggleBalloon(self):\n        if self.toggleBalloonVar.get():\n            self.balloon.configure(state = 'balloon')\n        else:\n            self.balloon.configure(state = 'none')\n\n    def _updateLabels(self):\n        self.valuatorGroup['labels'] = self['labels']\n\n    def _setNumDigits(self):\n        self.valuatorGroup['numDigits'] = self['numDigits']\n\n    def _setCommand(self):\n        self.valuatorGroup['command'] = self['command']\n\n    def _setPreCallback(self):\n        self.valuatorGroup['preCallback'] = self['preCallback']\n\n    def _setPostCallback(self):\n        self.valuatorGroup['postCallback'] = self['postCallback']\n\n    def _setCallbackData(self):\n        self.valuatorGroup['callbackData'] = self['callbackData']\n\n    def reset(self):\n        self.set(self['value'])\n\n\nPmw.forwardmethods(ValuatorGroupPanel, ValuatorGroup, 'valuatorGroup')\n\n\ndef rgbPanel(nodePath, callback = None, style = 'mini'):\n    from direct.showbase.MessengerGlobal import messenger\n\n    def onRelease(r, g, b, a, nodePath = nodePath):\n        messenger.send('RGBPanel_setColor', [nodePath, r, g, b, a])\n\n    def popupColorPicker():\n        # Can pass in current color with: color = (255, 0, 0)\n        color = askcolor(\n            parent = vgp.interior(),\n            # Initialize it to current color\n            initialcolor = tuple(vgp.get()[:3]))[0]\n        if color:\n            vgp.set((color[0], color[1], color[2], vgp.getAt(3)))\n\n    def printToLog():\n        c=nodePath.getColor()\n        print(\"Vec4(%.3f, %.3f, %.3f, %.3f)\"%(c[0], c[1], c[2], c[3]))\n\n    # Check init color\n    if nodePath.hasColor():\n        initColor = nodePath.getColor() * 255.0\n    else:\n        initColor = Vec4(255)\n    # Create entry scale group\n    vgp = ValuatorGroupPanel(title = 'RGBA Panel: ' + nodePath.getName(),\n                             dim = 4,\n                             labels = ['R','G','B','A'],\n                             value = [int(initColor[0]),\n                                      int(initColor[1]),\n                                      int(initColor[2]),\n                                      int(initColor[3])],\n                             type = 'slider',\n                             valuator_style = style,\n                             valuator_min = 0,\n                             valuator_max = 255,\n                             valuator_resolution = 1,\n                             # Destroy not withdraw panel on dismiss\n                             fDestroy = 1)\n    # Update menu button\n    vgp.component('menubar').component('Valuator Group-button')['text'] = (\n        'RGBA Panel')\n\n    # Set callback\n    vgp['postCallback'] = onRelease\n\n    # Add a print button which will also serve as a color tile\n    pButton = tk.Button(vgp.interior(), text = 'Print to Log',\n                        bg = getTkColorString(initColor),\n                        command = printToLog)\n    pButton.pack(expand = 1, fill = tk.BOTH)\n\n    # Update menu\n    menubar = vgp.component('menubar')\n    menubar.deletemenuitems('Valuator Group', 1, 1)\n\n    # Some helper functions\n    # Clear color\n    menubar.addmenuitem(\n        'Valuator Group', 'command',\n        label='Clear Color', command=lambda: nodePath.clearColor())\n    # Set Clear Transparency\n    menubar.addmenuitem(\n        'Valuator Group', 'command',\n        label='Set Transparency', command=lambda: nodePath.setTransparency(1))\n    menubar.addmenuitem(\n        'Valuator Group', 'command',\n        label='Clear Transparency', command=lambda: nodePath.clearTransparency())\n\n    # System color picker\n    menubar.addmenuitem(\n        'Valuator Group', 'command',\n        label='Popup Color Picker', command=popupColorPicker)\n\n    menubar.addmenuitem(\n        'Valuator Group', 'command',\n        label='Print to log', command=printToLog)\n\n    menubar.addmenuitem(\n        'Valuator Group', 'command', 'Dismiss Valuator Group panel',\n        label='Dismiss', command=vgp.destroy)\n\n    def setNodePathColor(color):\n        nodePath.setColor(color[0]/255.0, color[1]/255.0,\n                          color[2]/255.0, color[3]/255.0)\n        # Update color chip button\n        pButton['bg'] = getTkColorString(color)\n        # Execute callback to pass along color info\n        if callback:\n            callback(color)\n    vgp['command'] = setNodePathColor\n\n    return vgp\n\n\ndef lightRGBPanel(light, style = 'mini'):\n    # Color picker for lights\n    def popupColorPicker():\n        # Can pass in current color with: color = (255, 0, 0)\n        color = askcolor(\n            parent = vgp.interior(),\n            # Initialize it to current color\n            initialcolor = tuple(vgp.get()[:3]))[0]\n        if color:\n            vgp.set((color[0], color[1], color[2], vgp.getAt(3)))\n\n    def printToLog():\n        n = light.getName()\n        c=light.getColor()\n        print(n + (\".setColor(Vec4(%.3f, %.3f, %.3f, %.3f))\" %\n                   (c[0], c[1], c[2], c[3])))\n    # Check init color\n    initColor = light.getColor() * 255.0\n    # Create entry scale group\n    vgp = ValuatorGroupPanel(title = 'RGBA Panel: ' + light.getName(),\n                             dim = 4,\n                             labels = ['R','G','B','A'],\n                             value = [int(initColor[0]),\n                                      int(initColor[1]),\n                                      int(initColor[2]),\n                                      int(initColor[3])],\n                             type = 'slider',\n                             valuator_style = style,\n                             valuator_min = 0,\n                             valuator_max = 255,\n                             valuator_resolution = 1,\n                             # Destroy not withdraw panel on dismiss\n                             fDestroy = 1)\n    # Update menu button\n    vgp.component('menubar').component('Valuator Group-button')['text'] = (\n        'Light Control Panel')\n\n    # Add a print button which will also serve as a color tile\n    pButton = tk.Button(vgp.interior(), text = 'Print to Log',\n                        bg = getTkColorString(initColor),\n                        command = printToLog)\n    pButton.pack(expand = 1, fill = tk.BOTH)\n\n    # Update menu\n    menubar = vgp.component('menubar')\n    # System color picker\n    menubar.addmenuitem(\n        'Valuator Group', 'command',\n        label='Popup Color Picker', command=popupColorPicker)\n    menubar.addmenuitem(\n        'Valuator Group', 'command',\n        label='Print to log', command=printToLog)\n\n    def setLightColor(color):\n        light.setColor(Vec4(color[0]/255.0, color[1]/255.0,\n                            color[2]/255.0, color[3]/255.0))\n        # Update color chip button\n        pButton['bg'] = getTkColorString(color)\n    vgp['command'] = setLightColor\n    return vgp\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/tkwidgets/Valuator.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/8197ab73_Valuator.json",
    "doc_id": "doc_196"
  }
}