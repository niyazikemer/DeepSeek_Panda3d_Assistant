{
  "content": "# This tutorial provides an example of creating a character and having it walk\n# around using PandAI and dynamic obstacle pathfinding\n\nfrom direct.showbase.ShowBase import ShowBase\nfrom panda3d.core import *\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.interval.IntervalGlobal import *\nfrom direct.task import Task\nfrom direct.actor.Actor import Actor\nimport random\nimport sys\nimport os\nfrom direct.gui.DirectGui import *\nfrom direct.gui.OnscreenText import OnscreenText\n\nfrom panda3d.ai import *\n\nbase = ShowBase()\n\nspeed = 0.2\nturnspeed = 3.5\n\n# Figure out what directory this program is in.\nMYDIR = os.path.abspath(sys.path[0])\nMYDIR = Filename.fromOsSpecific(MYDIR).getFullpath()\n\nfont = loader.loadFont(\"cmss12\")\n\n\n# Function to put instructions on the screen.\ndef addInstructions(pos, msg):\n    return OnscreenText(text=msg, style=1, fg=(1, 1, 1, 1), font=font,\n                        pos=(-1.3, pos), align=TextNode.ALeft, scale=.05)\n\n\n# Function to put title on the screen.\ndef addTitle(text):\n    return OnscreenText(text=text, style=1, fg=(1, 1, 1, 1), font=font,\n                        pos=(1.3, -0.95), align=TextNode.ARight, scale=.07)\n\n\nclass World(DirectObject):\n\n    def __init__(self):\n\n        self.keyMap = {\"left\": 0, \"right\": 0, \"forward\": 0}\n\n        #base.disableMouse()\n        base.cam.setPosHpr(0, -210, 135, 0, 327, 0)\n        self.done = []\n        for i in range(4):\n            self.done.append(False)\n        self.toggle = False\n        self.firstTime = False\n\n        addTitle(\"Pandai Tutorial: Dynamic Avoidance of Moving Obstacles\")\n        addInstructions(0.95, \"[ESC]: Quit\")\n        addInstructions(0.90, \"[Arrow Keys]: Move the blue Ralph\")\n        addInstructions(0.85, \"Try and move the blue Ralph in the path of the \"\n                              \"other Ralphs\")\n\n        self.loadModels()\n        self.setAI()\n\n    def loadModels(self):\n\n        self.environ1 = loader.loadModel(\"models/skydome\")\n        self.environ1.reparentTo(render)\n        self.environ1.setPos(0, 0, 0)\n        self.environ1.setScale(1)\n\n        self.environ2 = loader.loadModel(\"models/skydome\")\n        self.environ2.reparentTo(render)\n        self.environ2.setP(180)\n        self.environ2.setH(270)\n        self.environ2.setScale(1)\n\n        self.environ = loader.loadModel(\"models/plane_demo1\")\n        self.environ.reparentTo(render)\n        self.environ.setPos(0, 0, 0)\n\n        self.Target = Actor(\"models/ralph\",\n                            {\"run\": \"models/ralph-run\",\n                             \"walk\": \"models/ralph-walk\"})\n        self.Target.setColor(0, 0, 1)\n        self.Target.setPos(60, -60, 0)\n        self.Target.setScale(2)\n        self.Target.reparentTo(render)\n        self.Target.loop(\"run\")\n        self.Targetforward = NodePath(\"Targetforward\")\n        self.Targetforward.setPos(0, -1, 0)\n        self.Targetforward.reparentTo(self.Target)\n\n        # Create the main character, Ralph\n        self.ralph = []\n        self.positions = []\n        self.positions_new = []\n        for i in range(4):\n            self.ralph.append(Actor(\"models/ralph\",\n                                    {\"run\": \"models/ralph-run\",\n                                     \"walk\": \"models/ralph-walk\"}))\n            self.ralph[i].reparentTo(render)\n            self.ralph[i].setScale(2)\n\n            self.positions.append(NodePath(str(i)))\n            self.positions_new.append(NodePath(str(i)))\n            if i < 2:\n                self.ralph[i].setPos(Point3(-61, -34 + (i * 40), 0))\n            else:\n                self.ralph[i].setPos(Point3(61, -34 + ((i - 2) * 40), 0))\n\n            self.positions.append(NodePath(str(i)))\n            self.positions_new.append(NodePath(str(i)))\n\n        self.positions[0].setPos(Point3(-61, -34 + ((0) * 40), 0))\n        self.positions[1].setPos(Point3(-53, -34 + ((1) * 40), 0))\n        self.positions[2].setPos(Point3(53, -44 + ((0) * 40), 0))\n        self.positions[3].setPos(Point3(61, -24 + ((1) * 40), 0))\n\n        self.positions_new[0].setPos(Point3(61, -44 + ((0) * 40), 0))\n        self.positions_new[1].setPos(Point3(53, -44 + ((1) * 40), 0))\n        self.positions_new[2].setPos(Point3(-53, -24 + ((0) * 40), 0))\n        self.positions_new[3].setPos(Point3(-61, -24 + ((1) * 40), 0))\n\n    def setAI(self):\n        # Creating AI World\n        self.AIworld = AIWorld(render)\n\n        #self.accept(\"enter\", self.setMove)\n        # Movement\n        self.accept(\"arrow_left\", self.setKey, [\"left\", 1])\n        self.accept(\"arrow_right\", self.setKey, [\"right\", 1])\n        self.accept(\"arrow_up\", self.setKey, [\"forward\", 1])\n        self.accept(\"arrow_left-up\", self.setKey, [\"left\", 0])\n        self.accept(\"arrow_right-up\", self.setKey, [\"right\", 0])\n        self.accept(\"arrow_up-up\", self.setKey, [\"forward\", 0])\n\n        self.AIchar = []\n        self.AIbehaviors = []\n        for i in range(4):\n            maxForce = 25 - (5 * random.random())\n            char = AICharacter(\"ralph\", self.ralph[i], 60, 0.05, maxForce)\n            self.AIchar.append(char)\n            self.AIworld.addAiChar(char)\n            self.AIbehaviors.append(char.getAiBehaviors())\n            self.AIbehaviors[i].initPathFind(\"models/navmesh.csv\")\n\n        # AI World update\n        taskMgr.add(self.AIUpdate, \"AIUpdate\")\n\n        taskMgr.add(self.Mover, \"mover\")\n\n        self.setMove(1)\n\n    def setMove(self, type):\n        if type == 1:\n            for i in range(4):\n                if i == 0:\n                    self.AIbehaviors[i].pathFindTo(self.positions_new[0], \"addPath\")\n                    self.AIbehaviors[i].addDynamicObstacle(self.ralph[2])\n                if i == 1:\n                    self.AIbehaviors[i].pathFindTo(self.positions_new[1], \"addPath\")\n                    self.AIbehaviors[i].addDynamicObstacle(self.ralph[3])\n                if i == 2:\n                    self.AIbehaviors[i].pathFindTo(self.positions_new[2], \"addPath\")\n                if i == 3:\n                    self.AIbehaviors[i].pathFindTo(self.positions_new[3], \"addPath\")\n                if self.firstTime is False:\n                    self.AIbehaviors[i].addDynamicObstacle(self.Target)\n                self.ralph[i].loop(\"run\")\n\n            self.firstTime = True\n\n        if type == 2:\n            for i in range(4):\n                if i == 0:\n                    self.AIbehaviors[i].pathFindTo(self.positions[0], \"addPath\")\n                if i == 1:\n                    self.AIbehaviors[i].pathFindTo(self.positions[1], \"addPath\")\n                if i == 2:\n                    self.AIbehaviors[i].pathFindTo(self.positions[2], \"addPath\")\n                if i == 3:\n                    self.AIbehaviors[i].pathFindTo(self.positions[3], \"addPath\")\n\n                self.ralph[i].loop(\"run\")\n\n    # To update the AIWorld\n    def AIUpdate(self, task):\n        self.AIworld.update()\n        for i in range(4):\n            status = self.AIbehaviors[i].behaviorStatus(\"pursue\")\n            if status == \"done\" or status == \"paused\":\n                self.done[i] = True\n\n        j = 0\n        for i in range(4):\n            if self.done[i] is True:\n                j += 1\n\n        if j == 4:\n            self.toggle = not self.toggle\n            if self.toggle is True:\n                self.setMove(2)\n            else:\n                self.setMove(1)\n            for i in range(4):\n                self.done[i] = False\n\n        return Task.cont\n\n    def setKey(self, key, value):\n        self.keyMap[key] = value\n\n    def Mover(self, task):\n        startPos = self.Target.getPos()\n\n        if self.keyMap[\"left\"] != 0:\n            self.Target.setH(self.Target.getH() + turnspeed)\n        if self.keyMap[\"right\"] != 0:\n            self.Target.setH(self.Target.getH() - turnspeed)\n        if self.keyMap[\"forward\"] != 0:\n            forwardvector = self.Targetforward.getPos(render) - startPos\n            self.Target.setPos(startPos + forwardvector * speed)\n\n        return Task.cont\n\n\nw = World()\nbase.run()\n",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/2506a810_dynamic-obstacles.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/1968aecc_2506a810_dynamic-obstacles.json",
    "doc_id": "doc_2"
  }
}