{
  "content": "import math\nfrom panda3d.core import (\n    BitMask32,\n    BoundingHexahedron,\n    CSDefault,\n    Mat4,\n    NodePath,\n    Point3,\n    VBase3,\n    VBase4,\n    Vec3,\n    decomposeMatrix,\n    deg2Rad,\n)\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.showbase.ShowBaseGlobal import hidden\nfrom direct.showbase import ShowBaseGlobal\nfrom . import DirectGlobals as DG\nfrom .DirectUtil import useDirectRenderStyle\nfrom .DirectGeometry import (\n    LineNodePath,\n    getCrankAngle,\n    getNearProjectionPoint,\n    getScreenXY,\n    planeIntersect,\n    relHpr,\n)\nfrom .DirectSelection import SelectionRay\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom copy import deepcopy\nfrom typing import Optional\n\n\nclass DirectManipulationControl(DirectObject):\n    def __init__(self):\n        # Create the grid\n        self.objectHandles = ObjectHandles()\n        self.hitPt = Point3(0)\n        self.prevHit = Vec3(0)\n\n        self.widgetList: list[ObjectHandles] = []\n\n        self.hitPtScale = Point3(0) # [gjeon] to be used in new LE's camera control\n        self.prevHitScale = Vec3(0) # [gjeon] to be used in new LE's camera control\n\n        self.rotationCenter = Point3(0)\n        self.initScaleMag = 1\n        self.manipRef = ShowBaseGlobal.direct.group.attachNewNode('manipRef')\n        self.hitPtDist = 0\n        self.constraint: Optional[str] = None\n        self.rotateAxis = 'x'\n        self.lastCrankAngle = 0\n        self.fSetCoa = 0\n        self.fHitInit = 1\n        self.fScaleInit = 1\n        self.fScaleInit1 = 1 # [gjeon] to be used in new LE's camera control\n        self.fWidgetTop = 0\n        self.fFreeManip = 1\n        self.fScaling3D = 0\n        self.fScaling1D = 0\n        self.fMovable = 1\n        self.mode = None\n        self.worldSpaceManip = False\n        #turn this on to enable separate handles for scaling\n        self.useSeparateScaleHandles = False\n        self.actionEvents = [\n            ['DIRECT-mouse1', self.manipulationStart],\n            ['DIRECT-mouse1Up', self.manipulationStop],\n            ['tab', self.toggleObjectHandlesMode],\n##             ['.', self.objectHandles.multiplyScalingFactorBy, 2.0],\n##             ['>', self.objectHandles.multiplyScalingFactorBy, 2.0],\n##             [',', self.objectHandles.multiplyScalingFactorBy, 0.5],\n##             ['<', self.objectHandles.multiplyScalingFactorBy, 0.5],\n            ['DIRECT-widgetScaleUp', self.scaleWidget, 2.0],\n            ['DIRECT-widgetScaleDown', self.scaleWidget, 0.5],\n            ['shift-f', self.objectHandles.growToFit],\n            ['i', self.plantSelectedNodePath],\n        ]\n        self.defaultSkipFlags = DG.SKIP_HIDDEN | DG.SKIP_BACKFACE\n        self.optionalSkipFlags = 0\n        self.unmovableTagList = []\n\n        # [gjeon] flag to enable selection while other manipulation is disabled\n        self.fAllowSelectionOnly = 0\n\n        # [gjeon] flag to enable marquee selection feature\n        self.fAllowMarquee = 0\n        self.marquee = None\n\n        # [gjeon] for new LE's multi-view support\n        self.fMultiView = 0\n\n        # [gjeon] to support grid snapping\n        self.fGridSnap = 0\n\n    def scaleWidget(self, factor):\n        if hasattr(ShowBaseGlobal.direct, 'widget'):\n            ShowBaseGlobal.direct.widget.multiplyScalingFactorBy(factor)\n        else:\n            self.objectHandles.multiplyScalingFactorBy(factor)\n\n    def supportMultiView(self):\n        if self.fMultiView:\n            return\n\n        self.objectHandles.hide(BitMask32.bit(0))\n        self.objectHandles.hide(BitMask32.bit(1))\n        self.objectHandles.hide(BitMask32.bit(2))\n\n        self.topViewWidget = ObjectHandles('topViewWidget')\n        self.frontViewWidget = ObjectHandles('frontViewWidget')\n        self.leftViewWidget = ObjectHandles('leftViewWidget')\n        self.widgetList = [self.topViewWidget, self.frontViewWidget, self.leftViewWidget, self.objectHandles]\n\n        self.topViewWidget.hide(BitMask32.bit(1))\n        self.topViewWidget.hide(BitMask32.bit(2))\n        self.topViewWidget.hide(BitMask32.bit(3))\n\n        self.frontViewWidget.hide(BitMask32.bit(0))\n        self.frontViewWidget.hide(BitMask32.bit(2))\n        self.frontViewWidget.hide(BitMask32.bit(3))\n\n        self.leftViewWidget.hide(BitMask32.bit(0))\n        self.leftViewWidget.hide(BitMask32.bit(1))\n        self.leftViewWidget.hide(BitMask32.bit(3))\n\n        self.fMultiView = 1\n\n    def manipulationStart(self, modifiers):\n        # Start out in select mode\n        self.mode = 'select'\n\n        if ShowBaseGlobal.direct.cameraControl.useMayaCamControls and modifiers == 4:\n            self.mode = 'camera'\n\n        if self.fAllowSelectionOnly:\n            return\n\n        if self.fScaling1D == 0 and\\\n           self.fScaling3D == 0:\n\n            # Check for a widget hit point\n            entry = ShowBaseGlobal.direct.iRay.pickWidget(skipFlags = DG.SKIP_WIDGET)\n            # Did we hit a widget?\n            if entry:\n                # Yes!\n                self.hitPt.assign(entry.getSurfacePoint(entry.getFromNodePath()))\n                self.hitPtDist = Vec3(self.hitPt).length()\n                # Constraint determined by nodes name\n                self.constraint = entry.getIntoNodePath().getName()\n            else:\n                # Nope, off the widget, no constraint\n                self.constraint = None\n                # [gjeon] to prohibit unwanted object movement while direct window doesn't have focus\n                if ShowBaseGlobal.direct.cameraControl.useMayaCamControls and not ShowBaseGlobal.direct.gotControl(modifiers) \\\n                   and not self.fAllowMarquee:\n                    return\n        else:\n            entry = None\n\n        if not ShowBaseGlobal.direct.gotAlt(modifiers):\n            if entry:\n                # Check to see if we are moving the object\n                # We are moving the object if we either wait long enough\n                taskMgr.doMethodLater(DG.MANIPULATION_MOVE_DELAY,\n                                      self.switchToMoveMode,\n                                      'manip-move-wait')\n                # Or we move far enough\n                self.moveDir = None\n                watchMouseTask = Task.Task(self.watchMouseTask)\n                watchMouseTask.initX = ShowBaseGlobal.direct.dr.mouseX\n                watchMouseTask.initY = ShowBaseGlobal.direct.dr.mouseY\n                taskMgr.add(watchMouseTask, 'manip-watch-mouse')\n            else:\n                if ShowBaseGlobal.direct.fControl:\n                    self.mode = 'move'\n                    self.manipulateObject()\n                elif not ShowBaseGlobal.direct.fAlt and self.fAllowMarquee:\n                    self.moveDir = None\n                    watchMarqueeTask = Task.Task(self.watchMarqueeTask)\n                    watchMarqueeTask.initX = ShowBaseGlobal.direct.dr.mouseX\n                    watchMarqueeTask.initY = ShowBaseGlobal.direct.dr.mouseY\n                    taskMgr.add(watchMarqueeTask, 'manip-marquee-mouse')\n\n    def switchToWorldSpaceMode(self):\n        self.worldSpaceManip = True\n\n    def switchToLocalSpaceMode(self):\n        self.worldSpaceManip = False\n\n    def switchToMoveMode(self, state):\n        taskMgr.remove('manip-watch-mouse')\n        self.mode = 'move'\n        self.manipulateObject()\n        return Task.done\n\n    def watchMouseTask(self, state):\n        if (abs(state.initX - ShowBaseGlobal.direct.dr.mouseX) > 0.01 or\n            abs(state.initY - ShowBaseGlobal.direct.dr.mouseY) > 0.01):\n            taskMgr.remove('manip-move-wait')\n            self.mode = 'move'\n            self.manipulateObject()\n            return Task.done\n        else:\n            return Task.cont\n\n    def watchMarqueeTask(self, state):\n        taskMgr.remove('manip-watch-mouse')\n        taskMgr.remove('manip-move-wait')\n        self.mode = 'select'\n        self.drawMarquee(state.initX, state.initY)\n        return Task.cont\n\n    def drawMarquee(self, startX, startY):\n        if self.marquee:\n            self.marquee.removeNode()\n            self.marquee = None\n\n        if ShowBaseGlobal.direct.cameraControl.useMayaCamControls and ShowBaseGlobal.direct.fAlt:\n            return\n        if ShowBaseGlobal.direct.fControl:\n            return\n\n        endX = ShowBaseGlobal.direct.dr.mouseX\n        endY = ShowBaseGlobal.direct.dr.mouseY\n\n        if (abs(endX - startX) < 0.01 and\n            abs(endY - startY) < 0.01):\n            return\n\n        self.marquee = LineNodePath(ShowBaseGlobal.base.render2d, 'marquee', 0.5, VBase4(.8, .6, .6, 1))\n        self.marqueeInfo = (startX, startY, endX, endY)\n        self.marquee.drawLines([\n            [(startX, 0, startY), (startX, 0, endY)],\n            [(startX, 0, endY), (endX, 0, endY)],\n            [(endX, 0, endY), (endX, 0, startY)],\n            [(endX, 0, startY), (startX, 0, startY)]])\n        self.marquee.create()\n\n        if self.fMultiView:\n            DG.LE_showInOneCam(self.marquee, ShowBaseGlobal.direct.camera.getName())\n\n    def manipulationStop(self):\n        taskMgr.remove('manipulateObject')\n        taskMgr.remove('manip-move-wait')\n        taskMgr.remove('manip-watch-mouse')\n        taskMgr.remove('manip-marquee-mouse')\n        direct = ShowBaseGlobal.direct\n        # depending on flag.....\n        if self.mode == 'select':\n            base = ShowBaseGlobal.base\n            # Check for object under mouse\n            # Don't intersect with hidden or backfacing objects, as well as any\n            # optionally specified things\n            skipFlags = self.defaultSkipFlags | self.optionalSkipFlags\n            # Skip camera (and its children), unless control key is pressed\n            skipFlags |= DG.SKIP_CAMERA * (1 - base.getControl())\n\n            if self.marquee:\n                self.marquee.removeNode()\n                self.marquee = None\n                direct.deselectAll()\n\n                startX = self.marqueeInfo[0]\n                startY = self.marqueeInfo[1]\n                endX = self.marqueeInfo[2]\n                endY = self.marqueeInfo[3]\n\n                fll = Point3(0, 0, 0)\n                flr = Point3(0, 0, 0)\n                fur = Point3(0, 0, 0)\n                ful = Point3(0, 0, 0)\n                nll = Point3(0, 0, 0)\n                nlr = Point3(0, 0, 0)\n                nur = Point3(0, 0, 0)\n                nul = Point3(0, 0, 0)\n\n                lens = direct.cam.node().getLens()\n                lens.extrude((startX, startY), nul, ful)\n                lens.extrude((endX, startY), nur, fur)\n                lens.extrude((endX, endY), nlr, flr)\n                lens.extrude((startX, endY), nll, fll)\n\n                marqueeFrustum = BoundingHexahedron(fll, flr, fur, ful, nll, nlr, nur, nul)\n                marqueeFrustum.xform(direct.cam.getNetTransform().getMat())\n\n                base.marqueeFrustum = marqueeFrustum\n\n                def findTaggedNodePath(nodePath):\n                    # Select tagged object if present\n                    for tag in direct.selected.tagList:\n                        if nodePath.hasNetTag(tag):\n                            nodePath = nodePath.findNetTag(tag)\n                            return nodePath\n                    return None\n\n                selectionList = []\n                for geom in base.render.findAllMatches(\"**/+GeomNode\"):\n                    if (skipFlags & DG.SKIP_HIDDEN) and geom.isHidden():\n                        # Skip if hidden node\n                        continue\n##                     elif (skipFlags & DG.SKIP_BACKFACE) and direct.iRay.isEntryBackfacing():\n##                         # Skip, if backfacing poly\n##                         pass\n                    elif (skipFlags & DG.SKIP_CAMERA) and \\\n                         (base.camera in geom.getAncestors()):\n                        # Skip if parented to a camera.\n                        continue\n                    # Can pick unpickable, use the first visible node\n                    elif (skipFlags & DG.SKIP_UNPICKABLE) and \\\n                         (geom.getName() in direct.iRay.unpickable):\n                        # Skip if in unpickable list\n                        continue\n\n                    nodePath = findTaggedNodePath(geom)\n                    if nodePath in selectionList:\n                        continue\n\n                    bb = geom.getBounds()\n                    bbc = bb.makeCopy()\n                    bbc.xform(geom.getParent().getNetTransform().getMat())\n\n                    boundingSphereTest = marqueeFrustum.contains(bbc)\n                    if boundingSphereTest > 1:\n                        if boundingSphereTest == 7:\n                            if nodePath not in selectionList:\n                                selectionList.append(nodePath)\n                        else:\n                            tMat = Mat4(geom.getMat())\n                            geom.clearMat()\n                            # Get bounds\n                            min = Point3(0)\n                            max = Point3(0)\n                            geom.calcTightBounds(min, max)\n                            # Restore transform\n                            geom.setMat(tMat)\n\n                            fll = Point3(min[0], max[1], min[2])\n                            flr = Point3(max[0], max[1], min[2])\n                            fur = max\n                            ful = Point3(min[0], max[1], max[2])\n                            nll = min\n                            nlr = Point3(max[0], min[1], min[2])\n                            nur = Point3(max[0], min[1], max[2])\n                            nul = Point3(min[0], min[1], max[2])\n\n                            tbb = BoundingHexahedron(fll, flr, fur, ful, nll, nlr, nur, nul)\n\n                            tbb.xform(geom.getNetTransform().getMat())\n\n                            tightBoundTest = marqueeFrustum.contains(tbb)\n\n                            if tightBoundTest > 1:\n                                if nodePath not in selectionList:\n                                    selectionList.append(nodePath)\n\n                for nodePath in selectionList:\n                    direct.select(nodePath, 1)\n\n            else:\n                entry = direct.iRay.pickGeom(skipFlags = skipFlags)\n                if entry:\n                    # Record hit point information\n                    self.hitPt.assign(entry.getSurfacePoint(entry.getFromNodePath()))\n                    self.hitPtDist = Vec3(self.hitPt).length()\n                    # Select it\n                    direct.select(entry.getIntoNodePath(), direct.fShift)\n                else:\n                    direct.deselectAll()\n        #elif self.mode == 'move':\n        self.manipulateObjectCleanup()\n\n        self.mode = None\n\n    def manipulateObjectCleanup(self):\n        direct = ShowBaseGlobal.direct\n        if self.fScaling3D or self.fScaling1D:\n            # We had been scaling, need to reset object handles\n            if hasattr(direct, 'widget'):\n                direct.widget.transferObjectHandlesScale()\n            else:\n                self.objectHandles.transferObjectHandlesScale()\n            self.fScaling3D = 0\n            self.fScaling1D = 0\n        direct.selected.highlightAll()\n        if hasattr(direct, 'widget'):\n            direct.widget.showAllHandles()\n        else:\n            self.objectHandles.showAllHandles()\n        if direct.clusterMode == 'client':\n            direct.cluster(\n                'direct.manipulationControl.objectHandles.showAllHandles()')\n        if hasattr(direct, 'widget'):\n            direct.widget.hideGuides()\n        else:\n            self.objectHandles.hideGuides()\n\n        # Restart followSelectedNodePath task\n        self.spawnFollowSelectedNodePathTask()\n        messenger.send('DIRECT_manipulateObjectCleanup',\n                       [direct.selected.getSelectedAsList()])\n\n    def spawnFollowSelectedNodePathTask(self):\n        # If nothing selected, just return\n        if not ShowBaseGlobal.direct.selected.last:\n            return\n        # Clear out old task to make sure\n        taskMgr.remove('followSelectedNodePath')\n        # Where are the object handles relative to the selected object\n        pos = VBase3(0)\n        hpr = VBase3(0)\n        decomposeMatrix(ShowBaseGlobal.direct.selected.last.mCoa2Dnp,\n                        VBase3(0), hpr, pos, CSDefault)\n        # Create the task\n        t = Task.Task(self.followSelectedNodePathTask)\n        # Update state variables\n        t.pos = pos\n        t.hpr = hpr\n        t.base = ShowBaseGlobal.direct.selected.last\n        # Spawn the task\n        taskMgr.add(t, 'followSelectedNodePath')\n\n    def followSelectedNodePathTask(self, state):\n        if hasattr(ShowBaseGlobal.direct, \"manipulationControl\") and ShowBaseGlobal.direct.manipulationControl.fMultiView:\n            for widget in ShowBaseGlobal.direct.manipulationControl.widgetList:\n                if self.worldSpaceManip:\n                    widget.setPos(state.base, state.pos)\n                    widget.setHpr(ShowBaseGlobal.base.render, VBase3(0))\n                else:\n                    widget.setPosHpr(state.base, state.pos, state.hpr)\n        else:\n            widget = ShowBaseGlobal.direct.widget\n            if self.worldSpaceManip:\n                widget.setPos(state.base, state.pos)\n                widget.setHpr(ShowBaseGlobal.base.render, VBase3(0))\n            else:\n                widget.setPosHpr(state.base, state.pos, state.hpr)\n        return Task.cont\n\n    def enableManipulation(self):\n        # Accept events\n        for event in self.actionEvents:\n            self.accept(event[0], event[1], extraArgs = event[2:])\n\n        self.fAllowSelectionOnly = 0\n\n    def disableManipulation(self, allowSelectionOnly=False):\n        # Ignore events\n        for event in self.actionEvents:\n            self.ignore(event[0])\n\n        # [gjeon] to enable selection while other manipulation is disabled\n        if allowSelectionOnly:\n            self.fAllowSelectionOnly = allowSelectionOnly\n            self.accept('DIRECT-mouse1', self.manipulationStart)\n            self.accept('DIRECT-mouse1Up', self.manipulationStop)\n\n        self.removeManipulateObjectTask()\n        taskMgr.remove('manipulateObject')\n        taskMgr.remove('manip-move-wait')\n        taskMgr.remove('manip-watch-mouse')\n        taskMgr.remove('highlightWidgetTask')\n\n    def toggleObjectHandlesMode(self):\n        if self.fMovable:\n            self.fSetCoa = 1 - self.fSetCoa\n\n            if self.fSetCoa:\n                if hasattr(ShowBaseGlobal.direct, 'widget'):\n                    ShowBaseGlobal.direct.widget.coaModeColor()\n                else:\n                    self.objectHandles.coaModeColor()\n            else:\n                if hasattr(ShowBaseGlobal.direct, 'widget'):\n                    ShowBaseGlobal.direct.widget.manipModeColor()\n                else:\n                    self.objectHandles.manipModeColor()\n        else:\n            if hasattr(ShowBaseGlobal.direct, 'widget'):\n                ShowBaseGlobal.direct.widget.disabledModeColor()\n            else:\n                self.objectHandles.disabledModeColor()\n\n    def removeManipulateObjectTask(self):\n        taskMgr.remove('manipulateObject')\n\n    def enableWidgetMove(self):\n        self.fMovable = 1\n        if self.fSetCoa:\n            if hasattr(ShowBaseGlobal.direct, 'widget'):\n                ShowBaseGlobal.direct.widget.coaModeColor()\n            else:\n                self.objectHandles.coaModeColor()\n        else:\n            if hasattr(ShowBaseGlobal.direct, 'widget'):\n                ShowBaseGlobal.direct.widget.manipModeColor()\n            else:\n                self.objectHandles.manipModeColor()\n\n    def disableWidgetMove(self):\n        self.fMovable = 0\n        if hasattr(ShowBaseGlobal.direct, 'widget'):\n            ShowBaseGlobal.direct.widget.disabledModeColor()\n        else:\n            self.objectHandles.disabledModeColor()\n\n    #--------------------------------------------------------------------------\n    # Function:   get edit types list for specified objects which indicate\n    #             how editable the objects are\n    # Parameters: object, list of object to get edit types for\n    # Changes:    none\n    # Returns:    list of edit types\n    #--------------------------------------------------------------------------\n    def getEditTypes(self, objects):\n        # See if any of the selected in the don't manipulate tag list\n        editTypes = 0\n        for tag in self.unmovableTagList:\n            for selected in objects:\n                unmovableTag = selected.getTag(tag)\n                if unmovableTag:\n                    # check value of unmovableTag to see if it is\n                    # completely uneditable or if it allows only certain\n                    # types of editing\n                    editTypes |= int(unmovableTag)\n        return editTypes\n\n    def manipulateObject(self):\n        # Only do this if something is selected\n        direct = ShowBaseGlobal.direct\n        selectedList = direct.selected.getSelectedAsList()\n        # See if any of the selected are completely uneditable\n        editTypes = self.getEditTypes(selectedList)\n        if (editTypes & DG.EDIT_TYPE_UNEDITABLE) == DG.EDIT_TYPE_UNEDITABLE:\n            return\n        self.currEditTypes = editTypes\n        if selectedList:\n            # Remove the task to keep the widget attached to the object\n            taskMgr.remove('followSelectedNodePath')\n            # and the task to highlight the widget\n            taskMgr.remove('highlightWidgetTask')\n            # Set manipulation flag\n            self.fManip = 1\n            # Record undo point\n            direct.pushUndo(direct.selected)\n            # Update object handles visibility\n            if hasattr(direct, 'widget'):\n                direct.widget.showGuides()\n                direct.widget.hideAllHandles()\n                direct.widget.showHandle(self.constraint)\n            else:\n                self.objectHandles.showGuides()\n                self.objectHandles.hideAllHandles()\n                self.objectHandles.showHandle(self.constraint)\n            if direct.clusterMode == 'client':\n                oh = 'direct.manipulationControl.objectHandles'\n                cluster = direct.cluster\n                cluster(oh + '.showGuides()', 0)\n                cluster(oh + '.hideAllHandles()', 0)\n                cluster(oh + ('.showHandle(\"%s\")'% self.constraint), 0)\n            # Record relationship between selected nodes and widget\n            direct.selected.getWrtAll()\n            # hide the bbox of the selected objects during interaction\n            direct.selected.dehighlightAll()\n            # Send event to signal start of manipulation\n            messenger.send('DIRECT_manipulateObjectStart')\n            # Manipulate the real object with the constraint\n            # The constraint is passed as the name of the node\n            self.spawnManipulateObjectTask()\n\n    def spawnManipulateObjectTask(self):\n        # reset hit-pt flag\n        self.fHitInit = 1\n        self.fScaleInit = 1\n        if not self.fScaling1D and\\\n           not self.fScaling3D:\n            self.fScaleInit1 = 1\n        # record initial offset between widget and camera\n        t = Task.Task(self.manipulateObjectTask)\n        t.fMouseX = abs(ShowBaseGlobal.direct.dr.mouseX) > 0.9\n        t.fMouseY = abs(ShowBaseGlobal.direct.dr.mouseY) > 0.9\n        if t.fMouseX:\n            t.constrainedDir = 'y'\n        else:\n            t.constrainedDir = 'x'\n        # Compute widget's xy coords in screen space\n        t.coaCenter = getScreenXY(ShowBaseGlobal.direct.widget)\n        # These are used to rotate about view vector\n        if t.fMouseX and t.fMouseY:\n            t.lastAngle = getCrankAngle(t.coaCenter)\n        taskMgr.add(t, 'manipulateObject')\n\n    def manipulateObjectTask(self, state):\n        if self.fScaling1D:\n            self.scale1D(state)\n        elif self.fScaling3D:\n            self.scale3D(state)\n        else:\n            # Widget takes precedence\n            if self.constraint:\n                type = self.constraint[2:]\n                if self.useSeparateScaleHandles:\n                    if type == 'post' and not self.currEditTypes & DG.EDIT_TYPE_UNMOVABLE:\n                        self.xlate1D(state)\n                    elif type == 'disc' and not self.currEditTypes & DG.EDIT_TYPE_UNMOVABLE:\n                        self.xlate2D(state)\n                    elif type == 'ring' and not self.currEditTypes & DG.EDIT_TYPE_UNROTATABLE:\n                        self.rotate1D(state)\n                    elif type == 'scale' and not self.currEditTypes & DG.EDIT_TYPE_UNSCALABLE:\n                        if ShowBaseGlobal.direct.fShift:\n                            self.fScaling3D = 1\n                            self.scale3D(state)\n                        else:\n                            self.fScaling1D = 1\n                            self.scale1D(state)\n                else:\n                    if ShowBaseGlobal.direct.fControl and not self.currEditTypes & DG.EDIT_TYPE_UNSCALABLE:\n                        if type == 'post':\n                            # [gjeon] non-uniform scaling\n                            self.fScaling1D = 1\n                            self.scale1D(state)\n                        else:\n                            # [gjeon] uniform scaling\n                            self.fScaling3D = 1\n                            self.scale3D(state)\n                    else:\n                        if type == 'post' and not self.currEditTypes & DG.EDIT_TYPE_UNMOVABLE:\n                            self.xlate1D(state)\n                        elif type == 'disc' and not self.currEditTypes & DG.EDIT_TYPE_UNMOVABLE:\n                            self.xlate2D(state)\n                        elif type == 'ring' and not self.currEditTypes & DG.EDIT_TYPE_UNROTATABLE:\n                            self.rotate1D(state)\n            # No widget interaction, determine free manip mode\n            elif self.fFreeManip and not self.useSeparateScaleHandles:\n                # If we've been scaling and changed modes, reset object handles\n                if 0 and (self.fScaling1D or self.fScaling3D) and (not ShowBaseGlobal.direct.fAlt):\n                    if hasattr(ShowBaseGlobal.direct, 'widget'):\n                        ShowBaseGlobal.direct.widget.transferObjectHandleScale()\n                    else:\n                        self.objectHandles.transferObjectHandlesScale()\n\n                    self.fScaling1D = 0\n                    self.fScaling3D = 0\n                # Alt key switches to a scaling mode\n                if ShowBaseGlobal.direct.fControl and not self.currEditTypes & DG.EDIT_TYPE_UNSCALABLE:\n                    self.fScaling3D = 1\n                    self.scale3D(state)\n                # Otherwise, manip mode depends on where you started\n                elif state.fMouseX and state.fMouseY and not self.currEditTypes & DG.EDIT_TYPE_UNROTATABLE:\n                    # In the corner, spin around camera's axis\n                    self.rotateAboutViewVector(state)\n                elif state.fMouseX or state.fMouseY and not self.currEditTypes & DG.EDIT_TYPE_UNMOVABLE:\n                    # Mouse started elsewhere in the outer frame, rotate\n                    self.rotate2D(state)\n                elif not self.currEditTypes & DG.EDIT_TYPE_UNMOVABLE:\n                    # Mouse started in central region, xlate\n                    # Mode depends on shift key\n                    if ShowBaseGlobal.direct.fShift or ShowBaseGlobal.direct.fControl:\n                        self.xlateCamXY(state)\n                    else:\n                        self.xlateCamXZ(state)\n            else:\n                return Task.done\n        if self.fSetCoa:\n            # Update coa based on current widget position\n            ShowBaseGlobal.direct.selected.last.mCoa2Dnp.assign(\n                ShowBaseGlobal.direct.widget.getMat(ShowBaseGlobal.direct.selected.last))\n        else:\n            # Move the objects with the widget\n            ShowBaseGlobal.direct.selected.moveWrtWidgetAll()\n        # Continue\n        return Task.cont\n\n    def addTag(self, tag):\n        if tag not in self.unmovableTagList:\n            self.unmovableTagList.append(tag)\n\n    def removeTag(self, tag):\n        self.unmovableTagList.remove(tag)\n\n    def gridSnapping(self, nodePath, offset):\n        offsetX = nodePath.getX() + offset.getX()\n        offsetY = nodePath.getY() + offset.getY()\n        offsetZ = nodePath.getZ() + offset.getZ()\n\n        if offsetX < 0.0:\n            signX = -1.0\n        else:\n            signX = 1.0\n        modX = math.fabs(offsetX) % ShowBaseGlobal.direct.grid.gridSpacing\n        floorX = math.floor(math.fabs(offsetX) / ShowBaseGlobal.direct.grid.gridSpacing)\n        if modX < ShowBaseGlobal.direct.grid.gridSpacing / 2.0:\n            offsetX = signX * floorX * ShowBaseGlobal.direct.grid.gridSpacing\n        else:\n            offsetX = signX * (floorX + 1) * ShowBaseGlobal.direct.grid.gridSpacing\n\n        if offsetY < 0.0:\n            signY = -1.0\n        else:\n            signY = 1.0\n        modY = math.fabs(offsetY) % ShowBaseGlobal.direct.grid.gridSpacing\n        floorY = math.floor(math.fabs(offsetY) / ShowBaseGlobal.direct.grid.gridSpacing)\n        if modY < ShowBaseGlobal.direct.grid.gridSpacing / 2.0:\n            offsetY = signY * floorY * ShowBaseGlobal.direct.grid.gridSpacing\n        else:\n            offsetY = signY * (floorY + 1) * ShowBaseGlobal.direct.grid.gridSpacing\n\n        if offsetZ < 0.0:\n            signZ = -1.0\n        else:\n            signZ = 1.0\n        modZ = math.fabs(offsetZ) % ShowBaseGlobal.direct.grid.gridSpacing\n        floorZ = math.floor(math.fabs(offsetZ) / ShowBaseGlobal.direct.grid.gridSpacing)\n        if modZ < ShowBaseGlobal.direct.grid.gridSpacing / 2.0:\n            offsetZ = signZ * floorZ * ShowBaseGlobal.direct.grid.gridSpacing\n        else:\n            offsetZ = signZ * (floorZ + 1) * ShowBaseGlobal.direct.grid.gridSpacing\n\n        return Point3(offsetX, offsetY, offsetZ)\n\n    ### WIDGET MANIPULATION METHODS ###\n    def xlate1D(self, state):\n        assert self.constraint is not None\n\n        # Constrained 1D Translation along widget axis\n        # Compute nearest hit point along axis and try to keep\n        # that point as close to the current mouse position as possible\n        # what point on the axis is the mouse pointing at?\n        self.hitPt.assign(self.objectHandles.getAxisIntersectPt(\n            self.constraint[:1]))\n        # use it to see how far to move the widget\n        if self.fHitInit:\n            # First time through, just record that point\n            self.fHitInit = 0\n            self.prevHit.assign(self.hitPt)\n        else:\n            # Move widget to keep hit point as close to mouse as possible\n            offset = self.hitPt - self.prevHit\n\n            if hasattr(ShowBaseGlobal.direct, \"manipulationControl\") and ShowBaseGlobal.direct.manipulationControl.fMultiView:\n                for widget in ShowBaseGlobal.direct.manipulationControl.widgetList:\n                    if self.fGridSnap:\n                        widget.setPos(self.gridSnapping(widget, offset))\n                    else:\n                        widget.setPos(widget, offset)\n                #if ShowBaseGlobal.direct.camera.getName() != 'persp':\n                    #self.prevHit.assign(self.hitPt)\n            else:\n                if self.fGridSnap:\n                    ShowBaseGlobal.direct.widget.setPos(self.gridSnapping(ShowBaseGlobal.direct.widget, offset))\n                else:\n                    ShowBaseGlobal.direct.widget.setPos(ShowBaseGlobal.direct.widget, offset)\n\n    def xlate2D(self, state):\n        assert self.constraint is not None\n\n        # Constrained 2D (planar) translation\n        # Compute point of intersection of ray from eyepoint through cursor\n        # to one of the three orthogonal planes on the widget.\n        # This point tracks all subsequent mouse movements\n        self.hitPt.assign(self.objectHandles.getWidgetIntersectPt(\n            ShowBaseGlobal.direct.widget, self.constraint[:1]))\n\n        # use it to see how far to move the widget\n        if self.fHitInit:\n            # First time through just record hit point\n            self.fHitInit = 0\n            self.prevHit.assign(self.hitPt)\n        else:\n            offset = self.hitPt - self.prevHit\n\n            if hasattr(ShowBaseGlobal.direct, \"manipulationControl\") and ShowBaseGlobal.direct.manipulationControl.fMultiView:\n                for widget in ShowBaseGlobal.direct.manipulationControl.widgetList:\n                    if self.fGridSnap:\n                        widget.setPos(self.gridSnapping(widget, offset))\n                    else:\n                        widget.setPos(widget, offset)\n                if ShowBaseGlobal.direct.camera.getName() != 'persp':\n                    self.prevHit.assign(self.hitPt)\n            else:\n                if self.fGridSnap:\n                    ShowBaseGlobal.direct.widget.setPos(self.gridSnapping(ShowBaseGlobal.direct.widget, offset))\n                else:\n                    ShowBaseGlobal.direct.widget.setPos(ShowBaseGlobal.direct.widget, offset)\n\n    def rotate1D(self, state):\n        assert self.constraint is not None\n\n        # Constrained 1D rotation about the widget's main axis (X, Y, or Z)\n        # Rotation depends upon circular motion of the mouse about the\n        # projection of the widget's origin on the image plane\n        # A complete circle about the widget results in a change in\n        # orientation of 360 degrees.\n\n        # First initialize hit point/rotation angle\n        if self.fHitInit:\n            self.fHitInit = 0\n            self.rotateAxis = self.constraint[:1]\n            self.fWidgetTop = self.widgetCheck('top?')\n            self.rotationCenter = getScreenXY(ShowBaseGlobal.direct.widget)\n            self.lastCrankAngle = getCrankAngle(self.rotationCenter)\n\n        # Rotate widget based on how far cursor has swung around origin\n        newAngle = getCrankAngle(self.rotationCenter)\n        deltaAngle = self.lastCrankAngle - newAngle\n        if self.fWidgetTop:\n            deltaAngle = -1 * deltaAngle\n        if self.rotateAxis == 'x':\n            if hasattr(ShowBaseGlobal.direct, \"manipulationControl\") and ShowBaseGlobal.direct.manipulationControl.fMultiView:\n                for widget in ShowBaseGlobal.direct.manipulationControl.widgetList:\n                    widget.setP(widget, deltaAngle)\n            else:\n                ShowBaseGlobal.direct.widget.setP(ShowBaseGlobal.direct.widget, deltaAngle)\n        elif self.rotateAxis == 'y':\n            if hasattr(ShowBaseGlobal.direct, \"manipulationControl\") and ShowBaseGlobal.direct.manipulationControl.fMultiView:\n                for widget in ShowBaseGlobal.direct.manipulationControl.widgetList:\n                    widget.setR(widget, deltaAngle)\n            else:\n                ShowBaseGlobal.direct.widget.setR(ShowBaseGlobal.direct.widget, deltaAngle)\n        elif self.rotateAxis == 'z':\n            if hasattr(ShowBaseGlobal.direct, \"manipulationControl\") and ShowBaseGlobal.direct.manipulationControl.fMultiView:\n                for widget in ShowBaseGlobal.direct.manipulationControl.widgetList:\n                    widget.setH(widget, deltaAngle)\n            else:\n                ShowBaseGlobal.direct.widget.setH(ShowBaseGlobal.direct.widget, deltaAngle)\n        # Record crank angle for next time around\n        self.lastCrankAngle = newAngle\n\n    def widgetCheck(self, type):\n        assert self.constraint is not None\n\n        # Utility to see if we are looking at the top or bottom of\n        # a 2D planar widget or if we are looking at a 2D planar widget\n        # edge on\n        # Based upon angle between view vector from eye through the\n        # widget's origin and one of the three principle axes\n        axis = self.constraint[:1]\n        # First compute vector from eye through widget origin\n        mWidget2Cam = ShowBaseGlobal.direct.widget.getMat(ShowBaseGlobal.direct.camera)\n        # And determine where the viewpoint is relative to widget\n        pos = VBase3(0)\n        decomposeMatrix(mWidget2Cam, VBase3(0), VBase3(0), pos,\n                        CSDefault)\n        widgetDir = Vec3(pos)\n        widgetDir.normalize()\n        # Convert specified widget axis to view space\n        if axis == 'x':\n            widgetAxis = Vec3(mWidget2Cam.xformVec(DG.X_AXIS))\n        elif axis == 'y':\n            widgetAxis = Vec3(mWidget2Cam.xformVec(DG.Y_AXIS))\n        elif axis == 'z':\n            widgetAxis = Vec3(mWidget2Cam.xformVec(DG.Z_AXIS))\n        widgetAxis.normalize()\n        if type == 'top?':\n            # Check sign of angle between two vectors\n            return widgetDir.dot(widgetAxis) < 0.\n        elif type == 'edge?':\n            # Checking to see if we are viewing edge-on\n            # Check angle between two vectors\n            return abs(widgetDir.dot(widgetAxis)) < .2\n\n    ### FREE MANIPULATION METHODS ###\n    def xlateCamXZ(self, state):\n        \"\"\"Constrained 2D motion parallel to the camera's image plane\n        This moves the object in the camera's XZ plane\"\"\"\n        # reset fHitInit in case we later switch to manip mode\n        self.fHitInit = 1\n        # Reset scaling init flag\n        self.fScaleInit = 1\n        # Where is the widget relative to current camera view\n        vWidget2Camera = ShowBaseGlobal.direct.widget.getPos(ShowBaseGlobal.direct.camera)\n        x = vWidget2Camera[0]\n        y = vWidget2Camera[1]\n        z = vWidget2Camera[2]\n        # Move widget (and objects) based upon mouse motion\n        # Scaled up accordingly based upon widget distance\n        dr = ShowBaseGlobal.direct.dr\n\n        ShowBaseGlobal.direct.widget.setX(\n            ShowBaseGlobal.direct.camera,\n            x + 0.5 * dr.mouseDeltaX * dr.nearWidth * (y/dr.near))\n        ShowBaseGlobal.direct.widget.setZ(\n            ShowBaseGlobal.direct.camera,\n            z + 0.5 * dr.mouseDeltaY * dr.nearHeight * (y/dr.near))\n\n    def xlateCamXY(self, state):\n        \"\"\"Constrained 2D motion perpendicular to camera's image plane\n        This moves the object in the camera's XY plane if shift is held\n        Moves object toward camera if control is held\n        \"\"\"\n        # Reset scaling init flag\n        self.fScaleInit = 1\n        # Now, where is the widget relative to current camera view\n        vWidget2Camera = ShowBaseGlobal.direct.widget.getPos(ShowBaseGlobal.direct.camera)\n        # If this is first time around, record initial y distance\n        if self.fHitInit:\n            self.fHitInit = 0\n            # Use distance to widget to scale motion along Y\n            self.xlateSF = Vec3(vWidget2Camera).length()\n            # Get widget's current xy coords in screen space\n            coaCenter = getNearProjectionPoint(ShowBaseGlobal.direct.widget)\n            self.deltaNearX = coaCenter[0] - ShowBaseGlobal.direct.dr.nearVec[0]\n        # Which way do we move the object?\n        if ShowBaseGlobal.direct.fControl:\n            moveDir = Vec3(vWidget2Camera)\n            # If widget is behind camera invert vector\n            if moveDir[1] < 0.0:\n                moveDir.assign(moveDir * -1)\n            moveDir.normalize()\n        else:\n            moveDir = Vec3(DG.Y_AXIS)\n        # Move selected objects\n        dr = ShowBaseGlobal.direct.dr\n        # Scale move dir\n        moveDir.assign(moveDir * (2.0 * dr.mouseDeltaY * self.xlateSF))\n        # Add it to current widget offset\n        vWidget2Camera += moveDir\n        # The object, however, stays at the same relative point to mouse in X\n        vWidget2Camera.setX((dr.nearVec[0] + self.deltaNearX) *\n                            (vWidget2Camera[1]/dr.near))\n\n        # Move widget\n        ShowBaseGlobal.direct.widget.setPos(ShowBaseGlobal.direct.camera, vWidget2Camera)\n\n    def rotate2D(self, state):\n        \"\"\" Virtual trackball rotation of widget \"\"\"\n        # Reset init flag in case we switch to another mode\n        self.fHitInit = 1\n        # Reset scaling init flag\n        self.fScaleInit = 1\n        tumbleRate = 360\n        # If moving outside of center, ignore motion perpendicular to edge\n        if ((state.constrainedDir == 'y') and (abs(ShowBaseGlobal.direct.dr.mouseX) > 0.9)):\n            deltaX = 0\n            deltaY = ShowBaseGlobal.direct.dr.mouseDeltaY\n        elif ((state.constrainedDir == 'x') and (abs(ShowBaseGlobal.direct.dr.mouseY) > 0.9)):\n            deltaX = ShowBaseGlobal.direct.dr.mouseDeltaX\n            deltaY = 0\n        else:\n            deltaX = ShowBaseGlobal.direct.dr.mouseDeltaX\n            deltaY = ShowBaseGlobal.direct.dr.mouseDeltaY\n        # Mouse motion edge to edge of display region results in one full turn\n        relHpr(ShowBaseGlobal.direct.widget, ShowBaseGlobal.direct.camera, deltaX * tumbleRate,\n               -deltaY * tumbleRate, 0)\n\n    def rotateAboutViewVector(self, state):\n        # Reset init flag in case we switch to another mode\n        self.fHitInit = 1\n        # Reset scaling init flag\n        self.fScaleInit = 1\n        # Compute current angle\n        angle = getCrankAngle(state.coaCenter)\n        deltaAngle = angle - state.lastAngle\n        state.lastAngle = angle\n        # Mouse motion edge to edge of display region results in one full turn\n        relHpr(ShowBaseGlobal.direct.widget, ShowBaseGlobal.direct.camera, 0, 0, -deltaAngle)\n\n    def scale1D(self, state):\n        assert self.constraint is not None\n\n        direct = ShowBaseGlobal.direct\n        if hasattr(direct, \"manipulationControl\") and direct.manipulationControl.fMultiView:\n            self.hitPtScale.assign(self.objectHandles.getAxisIntersectPt(self.constraint[:1]))\n            self.hitPtScale = self.objectHandles.getMat().xformVec(self.hitPtScale)\n            if self.fScaleInit1:\n                # First time through just record hit point\n                self.fScaleInit1 = 0\n                self.prevHitScale.assign(self.hitPtScale)\n                self.origScale = direct.widget.getScale()\n            else:\n                widgetPos = direct.widget.getPos()\n                d0 = (self.prevHitScale).length()\n                if d0 == 0: #make sure we don't divide by zero\n                    d0 = 0.001\n                d1 = (self.hitPtScale).length()\n                if d1 == 0:  #make sure we don't set scale to zero\n                    d1 = 0.001\n                currScale = self.origScale\n                # Scale factor is ratio current mag with init mag\n                if self.constraint[:1] == 'x':\n                    currScale = Vec3(currScale.getX() * d1/d0, currScale.getY(), currScale.getZ())\n                elif self.constraint[:1] == 'y':\n                    currScale = Vec3(currScale.getX(), currScale.getY() * d1/d0, currScale.getZ())\n                elif self.constraint[:1] == 'z':\n                    currScale = Vec3(currScale.getX(), currScale.getY(), currScale.getZ() * d1/d0)\n                direct.widget.setScale(currScale)\n            return\n\n        # [gjeon] Constrained 1D scale of the selected node based upon up down mouse motion\n        if self.fScaleInit:\n            self.fScaleInit = 0\n            self.initScaleMag = Vec3(self.objectHandles.getAxisIntersectPt(self.constraint[:1])).length()\n            # record initial scale\n            self.initScale = direct.widget.getScale()\n        # Reset fHitInitFlag\n        self.fHitInit = 1\n\n        # reset the scale of the scaling widget so the calls to\n        # getAxisIntersectPt calculate the correct distance\n        direct.widget.setScale(1,1,1)\n\n        # Scale factor is ratio current mag with init mag\n        if self.constraint[:1] == 'x':\n            currScale = Vec3(self.initScale.getX() *\n                             self.objectHandles.getAxisIntersectPt('x').length() / self.initScaleMag,\n                             self.initScale.getY(), self.initScale.getZ())\n        elif self.constraint[:1] == 'y':\n            currScale = Vec3(self.initScale.getX(),\n                             self.initScale.getY() * self.objectHandles.getAxisIntersectPt('y').length() / self.initScaleMag,\n                             self.initScale.getZ())\n        elif self.constraint[:1] == 'z':\n            currScale = Vec3(self.initScale.getX(), self.initScale.getY(),\n                             self.initScale.getZ() * self.objectHandles.getAxisIntersectPt('z').length() / self.initScaleMag)\n\n        direct.widget.setScale(currScale)\n\n    def scale3D(self, state):\n        direct = ShowBaseGlobal.direct\n        if hasattr(direct, \"manipulationControl\") and direct.manipulationControl.fMultiView:\n            if self.useSeparateScaleHandles:\n                assert self.constraint is not None\n                self.hitPtScale.assign(self.objectHandles.getAxisIntersectPt(self.constraint[:1]))\n                self.hitPtScale = self.objectHandles.getMat().xformVec(self.hitPtScale)\n                if self.fScaleInit1:\n                    # First time through just record hit point\n                    self.fScaleInit1 = 0\n                    self.prevHitScale.assign(self.hitPtScale)\n                    self.origScale = direct.widget.getScale()\n                else:\n                    widgetPos = direct.widget.getPos()\n                    d0 = (self.prevHitScale).length()\n                    if d0 == 0: #make sure we don't divide by zero\n                        d0 = 0.001\n                    d1 = (self.hitPtScale).length()\n                    if d1 == 0:  #make sure we don't set scale to zero\n                        d1 = 0.001\n                    currScale = self.origScale\n                    # Scale factor is ratio current mag with init mag\n                    currScale = Vec3(currScale.getX() * d1/d0, currScale.getY() * d1/d0, currScale.getZ() * d1/d0)\n                    direct.widget.setScale(currScale)\n                return\n            else:\n                self.hitPtScale.assign(self.objectHandles.getMouseIntersectPt())\n\n                if self.fScaleInit1:\n                    # First time through just record hit point\n                    self.fScaleInit1 = 0\n                    self.prevHitScale.assign(self.hitPtScale)\n                    self.origScale = direct.widget.getScale()\n                else:\n                    widgetPos = direct.widget.getPos()\n                    d0 = (self.prevHitScale - widgetPos).length()\n                    if d0 == 0: #make sure we don't divide by zero\n                        d0 = 0.001\n                    d1 = (self.hitPtScale - widgetPos).length()\n                    if d1 == 0:\n                        d1 = 0.001  #make sure we don't set scale to zero\n                    currScale = self.origScale\n                    currScale = currScale * d1/d0\n                    direct.widget.setScale(currScale)\n                return\n        # Scale the selected node based upon up down mouse motion\n        # Mouse motion from edge to edge results in a factor of 4 scaling\n        # From midpoint to edge doubles or halves objects scale\n        if self.fScaleInit:\n            self.fScaleInit = 0\n            self.manipRef.setPos(direct.widget, 0, 0, 0)\n            self.manipRef.setHpr(direct.camera, 0, 0, 0)\n            self.initScaleMag = Vec3(\n                self.objectHandles.getWidgetIntersectPt(\n                self.manipRef, 'y')).length()\n            # record initial scale\n            self.initScale = direct.widget.getScale()\n        # Reset fHitInitFlag\n        self.fHitInit = 1\n        # Begin\n        # Scale factor is ratio current mag with init mag\n        currScale = (\n            self.initScale *\n            (self.objectHandles.getWidgetIntersectPt(\n            self.manipRef, 'y').length() /\n                self.initScaleMag)\n        )\n        direct.widget.setScale(currScale)\n\n    ## Utility functions ##\n    def plantSelectedNodePath(self):\n        \"\"\" Move selected object to intersection point of cursor on scene \"\"\"\n        # Check for intersection\n        entry = ShowBaseGlobal.direct.iRay.pickGeom(\n            skipFlags = DG.SKIP_HIDDEN | DG.SKIP_BACKFACE | DG.SKIP_CAMERA)\n        # MRM: Need to handle moving COA\n        if entry is not None and ShowBaseGlobal.direct.selected.last is not None:\n            # Record undo point\n            ShowBaseGlobal.direct.pushUndo(ShowBaseGlobal.direct.selected)\n            # Record wrt matrix\n            ShowBaseGlobal.direct.selected.getWrtAll()\n            # Move selected\n            ShowBaseGlobal.direct.widget.setPos(\n                ShowBaseGlobal.direct.camera, entry.getSurfacePoint(entry.getFromNodePath()))\n            # Move all the selected objects with widget\n            # Move the objects with the widget\n            ShowBaseGlobal.direct.selected.moveWrtWidgetAll()\n            # Let everyone know that something was moved\n            messenger.send('DIRECT_manipulateObjectCleanup',\n                           [ShowBaseGlobal.direct.selected.getSelectedAsList()])\n\n\nclass ObjectHandles(NodePath, DirectObject):\n    def __init__(self, name='objectHandles'):\n        # Initialize the superclass\n        NodePath.__init__(self)\n\n        # Load up object handles model and assign it to self\n        self.assign(ShowBaseGlobal.loader.loadModel('models/misc/objectHandles'))\n        self.setName(name)\n        self.scalingNode = NodePath(self)\n        self.scalingNode.setName('ohScalingNode')\n        self.ohScalingFactor = 1.0\n        self.directScalingFactor = 1.0\n        # To avoid recreating a vec every frame\n        self.hitPt = Vec3(0)\n        # Get a handle on the components\n        self.xHandles = self.find('**/X')\n        self.xPostGroup = self.xHandles.find('**/x-post-group')\n        self.xPostCollision = self.xHandles.find('**/x-post')\n        self.xRingGroup = self.xHandles.find('**/x-ring-group')\n        self.xRingCollision = self.xHandles.find('**/x-ring')\n        self.xDiscGroup = self.xHandles.find('**/x-disc-group')\n        self.xDisc = self.xHandles.find('**/x-disc-visible')\n        self.xDiscCollision = self.xHandles.find('**/x-disc')\n        self.xScaleGroup = deepcopy(self.xPostGroup)\n        self.xScaleGroup.setName('x-scale-group')\n        self.xScaleCollision = self.xScaleGroup.find('**/x-post')\n        self.xScaleCollision.setName('x-scale')\n\n        self.yHandles = self.find('**/Y')\n        self.yPostGroup = self.yHandles.find('**/y-post-group')\n        self.yPostCollision = self.yHandles.find('**/y-post')\n        self.yRingGroup = self.yHandles.find('**/y-ring-group')\n        self.yRingCollision = self.yHandles.find('**/y-ring')\n        self.yDiscGroup = self.yHandles.find('**/y-disc-group')\n        self.yDisc = self.yHandles.find('**/y-disc-visible')\n        self.yDiscCollision = self.yHandles.find('**/y-disc')\n        self.yScaleGroup = deepcopy(self.yPostGroup)\n        self.yScaleGroup.setName('y-scale-group')\n        self.yScaleCollision = self.yScaleGroup.find('**/y-post')\n        self.yScaleCollision.setName('y-scale')\n\n        self.zHandles = self.find('**/Z')\n        self.zPostGroup = self.zHandles.find('**/z-post-group')\n        self.zPostCollision = self.zHandles.find('**/z-post')\n        self.zRingGroup = self.zHandles.find('**/z-ring-group')\n        self.zRingCollision = self.zHandles.find('**/z-ring')\n        self.zDiscGroup = self.zHandles.find('**/z-disc-group')\n        self.zDisc = self.zHandles.find('**/z-disc-visible')\n        self.zDiscCollision = self.zHandles.find('**/z-disc')\n        self.zScaleGroup = deepcopy(self.zPostGroup)\n        self.zScaleGroup.setName('z-scale-group')\n        self.zScaleCollision = self.zScaleGroup.find('**/z-post')\n        self.zScaleCollision.setName('z-scale')\n\n        # Adjust visiblity, colors, and transparency\n        self.xPostCollision.hide()\n        self.xRingCollision.hide()\n        self.xScaleCollision.hide()\n        self.xDisc.setColor(1, 0, 0, .2)\n        self.yPostCollision.hide()\n        self.yRingCollision.hide()\n        self.yScaleCollision.hide()\n        self.yDisc.setColor(0, 1, 0, .2)\n        self.zPostCollision.hide()\n        self.zRingCollision.hide()\n        self.zScaleCollision.hide()\n        self.zDisc.setColor(0, 0, 1, .2)\n        # Augment geometry with lines\n        self.createObjectHandleLines()\n        # Create long markers to help line up in world\n        self.createGuideLines()\n        self.hideGuides()\n\n        # tag with name so they can skipped during iRay selection\n        self.xPostCollision.setTag('WidgetName',name)\n        self.yPostCollision.setTag('WidgetName',name)\n        self.zPostCollision.setTag('WidgetName',name)\n\n        self.xRingCollision.setTag('WidgetName',name)\n        self.yRingCollision.setTag('WidgetName',name)\n        self.zRingCollision.setTag('WidgetName',name)\n\n        self.xDiscCollision.setTag('WidgetName',name)\n        self.yDiscCollision.setTag('WidgetName',name)\n        self.zDiscCollision.setTag('WidgetName',name)\n\n        self.xScaleCollision.setTag('WidgetName',name)\n        self.yScaleCollision.setTag('WidgetName',name)\n        self.zScaleCollision.setTag('WidgetName',name)\n\n        # name disc geoms so they can be added to unpickables\n        self.xDisc.find(\"**/+GeomNode\").setName('x-disc-geom')\n        self.yDisc.find(\"**/+GeomNode\").setName('y-disc-geom')\n        self.zDisc.find(\"**/+GeomNode\").setName('z-disc-geom')\n\n        #turn scale off by default\n        self.disableHandles('scale')\n\n        # Start with widget handles hidden\n        self.fActive = 1\n        self.toggleWidget()\n\n        # Make sure object handles are never lit or drawn in wireframe\n        useDirectRenderStyle(self)\n\n    def coaModeColor(self):\n        self.setColor(.5, .5, .5, 0.5, 1)\n\n    def disabledModeColor(self):\n        self.setColor(0.1,0.1,0.1,0.1,1)\n\n    def manipModeColor(self):\n        self.clearColor()\n\n    def toggleWidget(self):\n        if self.fActive:\n            if hasattr(ShowBaseGlobal.direct, \"manipulationControl\") and ShowBaseGlobal.direct.manipulationControl.fMultiView:\n                for widget in ShowBaseGlobal.direct.manipulationControl.widgetList:\n                    widget.deactivate()\n            else:\n                self.deactivate()\n        else:\n            if hasattr(ShowBaseGlobal.direct, \"manipulationControl\") and ShowBaseGlobal.direct.manipulationControl.fMultiView:\n                for widget in ShowBaseGlobal.direct.manipulationControl.widgetList:\n                    widget.activate()\n                    widget.showWidgetIfActive()\n            else:\n                self.activate()\n\n    def activate(self):\n        self.scalingNode.reparentTo(self)\n        self.fActive = 1\n\n    def deactivate(self):\n        self.scalingNode.reparentTo(hidden)\n        self.fActive = 0\n\n    def showWidgetIfActive(self):\n        if self.fActive:\n            self.reparentTo(ShowBaseGlobal.direct.group)\n\n    def showWidget(self):\n        self.reparentTo(ShowBaseGlobal.direct.group)\n\n    def hideWidget(self):\n        self.reparentTo(hidden)\n\n    def enableHandles(self, handles):\n        if isinstance(handles, list):\n            for handle in handles:\n                self.enableHandle(handle)\n        elif handles == 'x':\n            self.enableHandles(['x-post','x-ring','x-disc', 'x-scale'])\n        elif handles == 'y':\n            self.enableHandles(['y-post','y-ring','y-disc', 'y-scale'])\n        elif handles == 'z':\n            self.enableHandles(['z-post','z-ring','z-disc', 'z-scale'])\n        elif handles == 'post':\n            self.enableHandles(['x-post','y-post','z-post'])\n        elif handles == 'ring':\n            self.enableHandles(['x-ring','y-ring','z-ring'])\n        elif handles == 'disc':\n            self.enableHandles(['x-disc','y-disc','z-disc'])\n        elif handles == 'scale':\n            self.enableHandles(['x-scale','y-scale','z-scale'])\n        elif handles == 'all':\n            self.enableHandles(['x-post','x-ring','x-disc','x-scale',\n                                'y-post','y-ring','y-disc','y-scale',\n                                'z-post','z-ring','z-disc','z-scale'])\n\n    def enableHandle(self, handle):\n        if handle == 'x-post':\n            self.xPostGroup.reparentTo(self.xHandles)\n        elif handle == 'x-ring':\n            self.xRingGroup.reparentTo(self.xHandles)\n        elif handle == 'x-disc':\n            self.xDiscGroup.reparentTo(self.xHandles)\n        elif handle == 'x-scale' and ShowBaseGlobal.direct.manipulationControl.useSeparateScaleHandles:\n            self.xScaleGroup.reparentTo(self.xHandles)\n        elif handle == 'y-post':\n            self.yPostGroup.reparentTo(self.yHandles)\n        elif handle == 'y-ring':\n            self.yRingGroup.reparentTo(self.yHandles)\n        elif handle == 'y-disc':\n            self.yDiscGroup.reparentTo(self.yHandles)\n        elif handle == 'y-scale' and ShowBaseGlobal.direct.manipulationControl.useSeparateScaleHandles:\n            self.yScaleGroup.reparentTo(self.yHandles)\n        elif handle == 'z-post':\n            self.zPostGroup.reparentTo(self.zHandles)\n        elif handle == 'z-ring':\n            self.zRingGroup.reparentTo(self.zHandles)\n        elif handle == 'z-disc':\n            self.zDiscGroup.reparentTo(self.zHandles)\n        elif handle == 'z-scale' and ShowBaseGlobal.direct.manipulationControl.useSeparateScaleHandles:\n            self.zScaleGroup.reparentTo(self.zHandles)\n\n    def disableHandles(self, handles):\n        if isinstance(handles, list):\n            for handle in handles:\n                self.disableHandle(handle)\n        elif handles == 'x':\n            self.disableHandles(['x-post','x-ring','x-disc','x-scale'])\n        elif handles == 'y':\n            self.disableHandles(['y-post','y-ring','y-disc','y-scale'])\n        elif handles == 'z':\n            self.disableHandles(['z-post','z-ring','z-disc','z-scale'])\n        elif handles == 'post':\n            self.disableHandles(['x-post','y-post','z-post'])\n        elif handles == 'ring':\n            self.disableHandles(['x-ring','y-ring','z-ring'])\n        elif handles == 'disc':\n            self.disableHandles(['x-disc','y-disc','z-disc'])\n        elif handles == 'scale':\n            self.disableHandles(['x-scale','y-scale','z-scale'])\n        elif handles == 'all':\n            self.disableHandles(['x-post','x-ring','x-disc','x-scale',\n                                 'y-post','y-ring','y-disc','y-scale',\n                                 'z-post','z-ring','z-disc','z-scale'])\n\n    def disableHandle(self, handle):\n        if handle == 'x-post':\n            self.xPostGroup.reparentTo(hidden)\n        elif handle == 'x-ring':\n            self.xRingGroup.reparentTo(hidden)\n        elif handle == 'x-disc':\n            self.xDiscGroup.reparentTo(hidden)\n        elif handle == 'x-scale':\n            self.xScaleGroup.reparentTo(hidden)\n        if handle == 'y-post':\n            self.yPostGroup.reparentTo(hidden)\n        elif handle == 'y-ring':\n            self.yRingGroup.reparentTo(hidden)\n        elif handle == 'y-disc':\n            self.yDiscGroup.reparentTo(hidden)\n        elif handle == 'y-scale':\n            self.yScaleGroup.reparentTo(hidden)\n        if handle == 'z-post':\n            self.zPostGroup.reparentTo(hidden)\n        elif handle == 'z-ring':\n            self.zRingGroup.reparentTo(hidden)\n        elif handle == 'z-disc':\n            self.zDiscGroup.reparentTo(hidden)\n        elif handle == 'z-scale':\n            self.zScaleGroup.reparentTo(hidden)\n\n    def showAllHandles(self):\n        self.xPost.show()\n        self.xRing.show()\n        self.xDisc.show()\n        self.xScale.show()\n        self.yPost.show()\n        self.yRing.show()\n        self.yDisc.show()\n        self.yScale.show()\n        self.zPost.show()\n        self.zRing.show()\n        self.zDisc.show()\n        self.zScale.show()\n\n    def hideAllHandles(self):\n        self.xPost.hide()\n        self.xRing.hide()\n        self.xDisc.hide()\n        self.xScale.hide()\n        self.yPost.hide()\n        self.yRing.hide()\n        self.yDisc.hide()\n        self.yScale.hide()\n        self.zPost.hide()\n        self.zRing.hide()\n        self.zDisc.hide()\n        self.zScale.hide()\n\n    def showHandle(self, handle):\n        if handle == 'x-post':\n            self.xPost.show()\n        elif handle == 'x-ring':\n            self.xRing.show()\n        elif handle == 'x-disc':\n            self.xDisc.show()\n        elif handle == 'x-scale':\n            self.xScale.show()\n        elif handle == 'y-post':\n            self.yPost.show()\n        elif handle == 'y-ring':\n            self.yRing.show()\n        elif handle == 'y-disc':\n            self.yDisc.show()\n        elif handle == 'y-scale':\n            self.yScale.show()\n        elif handle == 'z-post':\n            self.zPost.show()\n        elif handle == 'z-ring':\n            self.zRing.show()\n        elif handle == 'z-disc':\n            self.zDisc.show()\n        elif handle == 'z-scale':\n            self.zScale.show()\n\n    def showGuides(self):\n        self.guideLines.show()\n\n    def hideGuides(self):\n        self.guideLines.hide()\n\n    def setDirectScalingFactor(self, factor):\n        self.directScalingFactor = factor\n        self.setScalingFactor(1)\n\n    def setScalingFactor(self, scaleFactor):\n        self.ohScalingFactor = scaleFactor\n        self.scalingNode.setScale(self.ohScalingFactor * self.directScalingFactor)\n\n    def getScalingFactor(self):\n        return self.scalingNode.getScale()\n\n    def transferObjectHandlesScale(self):\n        # see how much object handles have been scaled\n        ohs = self.getScale()\n        sns = self.scalingNode.getScale()\n        # Transfer this to the scaling node\n        self.scalingNode.setScale(\n            ohs[0] * sns[0],\n            ohs[1] * sns[1],\n            ohs[2] * sns[2])\n        self.setScale(1)\n\n    def multiplyScalingFactorBy(self, factor):\n        self.ohScalingFactor = self.ohScalingFactor * factor\n        sf = self.ohScalingFactor * self.directScalingFactor\n        ival = self.scalingNode.scaleInterval(0.5, (sf, sf, sf),\n                                              blendType = 'easeInOut',\n                                              name = 'resizeObjectHandles')\n        ival.start()\n\n    def growToFit(self):\n        # Increase handles scale until they cover 30% of the min dimension\n        pos = ShowBaseGlobal.direct.widget.getPos(ShowBaseGlobal.direct.camera)\n        minDim = min(ShowBaseGlobal.direct.dr.nearWidth, ShowBaseGlobal.direct.dr.nearHeight)\n        sf = 0.15 * minDim * (pos[1]/ShowBaseGlobal.direct.dr.near)\n        self.ohScalingFactor = sf\n        sf = sf * self.directScalingFactor\n        ival = self.scalingNode.scaleInterval(0.5, (sf, sf, sf),\n                                              blendType = 'easeInOut',\n                                              name = 'resizeObjectHandles')\n        ival.start()\n\n    def createObjectHandleLines(self):\n        # X post\n        self.xPost = self.xPostGroup.attachNewNode('x-post-visible')\n        lines = LineNodePath(self.xPost)\n        lines.setColor(VBase4(1, 0, 0, 1))\n        lines.setThickness(5)\n        #lines.moveTo(0, 0, 0)\n        #lines.drawTo(1.5, 0, 0)\n        lines.moveTo(1.5, 0, 0)\n        #lines.create()\n        #lines = LineNodePath(self.xPost)\n        #lines.setColor(VBase4(1, 0, 0, 1))\n        #lines.setThickness(1.5)\n        #lines.moveTo(0, 0, 0)\n        lines.drawTo(-1.5, 0, 0)\n\n        arrowInfo0 = 1.3\n        arrowInfo1 = 0.1\n        #lines.setThickness(5)\n        lines.moveTo(1.5, 0, 0)\n        lines.drawTo(arrowInfo0, arrowInfo1, arrowInfo1)\n        lines.moveTo(1.5, 0, 0)\n        lines.drawTo(arrowInfo0, arrowInfo1, -1 * arrowInfo1)\n        lines.moveTo(1.5, 0, 0)\n        lines.drawTo(arrowInfo0, -1 * arrowInfo1, arrowInfo1)\n        lines.moveTo(1.5, 0, 0)\n        lines.drawTo(arrowInfo0, -1 * arrowInfo1, -1 * arrowInfo1)\n\n        lines.create()\n        lines.setName('x-post-line')\n\n        #X scale\n        self.xScale = self.xScaleGroup.attachNewNode('x-scale-visible')\n        lines = LineNodePath(self.xScale)\n        lines.setColor(VBase4(1, 0, 0, 1))\n        lines.setThickness(5)\n        lines.moveTo(1.3, 0, 0)\n        lines.drawTo(-1.5, 0, 0)\n\n        drawBox(lines, (1.3, 0, 0), 0.2)\n\n        lines.create()\n        lines.setName('x-scale-line')\n\n        # X ring\n        self.xRing = self.xRingGroup.attachNewNode('x-ring-visible')\n        lines = LineNodePath(self.xRing)\n        lines.setColor(VBase4(1, 0, 0, 1))\n        lines.setThickness(3)\n        lines.moveTo(0, 1, 0)\n        for ang in range(15, 370, 15):\n            lines.drawTo(0,\n                          math.cos(deg2Rad(ang)),\n                          math.sin(deg2Rad(ang)))\n        lines.create()\n        lines.setName('x-ring-line')\n\n        # Y post\n        self.yPost = self.yPostGroup.attachNewNode('y-post-visible')\n        lines = LineNodePath(self.yPost)\n        lines.setColor(VBase4(0, 1, 0, 1))\n        lines.setThickness(5)\n        #lines.moveTo(0, 0, 0)\n        #lines.drawTo(0, 1.5, 0)\n        lines.moveTo(0, 1.5, 0)\n        #lines.create()\n        #lines = LineNodePath(self.yPost)\n        #lines.setColor(VBase4(0, 1, 0, 1))\n        #lines.setThickness(1.5)\n        #lines.moveTo(0, 0, 0)\n        lines.drawTo(0, -1.5, 0)\n\n        #lines.setThickness(5)\n        lines.moveTo(0, 1.5, 0)\n        lines.drawTo(arrowInfo1, arrowInfo0, arrowInfo1)\n        lines.moveTo(0, 1.5, 0)\n        lines.drawTo(arrowInfo1, arrowInfo0, -1 * arrowInfo1)\n        lines.moveTo(0, 1.5, 0)\n        lines.drawTo(-1 * arrowInfo1, arrowInfo0, arrowInfo1)\n        lines.moveTo(0, 1.5, 0)\n        lines.drawTo(-1 * arrowInfo1, arrowInfo0, -1 * arrowInfo1)\n        lines.create()\n        lines.setName('y-post-line')\n\n        #Y scale\n        self.yScale = self.yScaleGroup.attachNewNode('y-scale-visible')\n        lines = LineNodePath(self.yScale)\n        lines.setColor(VBase4(0, 1, 0, 1))\n        lines.setThickness(5)\n        lines.moveTo(0, 1.3, 0)\n        lines.drawTo(0, -1.5, 0)\n\n        drawBox(lines, (0, 1.4, 0), 0.2)\n\n        lines.create()\n        lines.setName('y-scale-line')\n\n        # Y ring\n        self.yRing = self.yRingGroup.attachNewNode('y-ring-visible')\n        lines = LineNodePath(self.yRing)\n        lines.setColor(VBase4(0, 1, 0, 1))\n        lines.setThickness(3)\n        lines.moveTo(1, 0, 0)\n        for ang in range(15, 370, 15):\n            lines.drawTo(math.cos(deg2Rad(ang)),\n                          0,\n                          math.sin(deg2Rad(ang)))\n        lines.create()\n        lines.setName('y-ring-line')\n\n        # Z post\n        self.zPost = self.zPostGroup.attachNewNode('z-post-visible')\n        lines = LineNodePath(self.zPost)\n        lines.setColor(VBase4(0, 0, 1, 1))\n        lines.setThickness(5)\n        #lines.moveTo(0, 0, 0)\n        #lines.drawTo(0, 0, 1.5)\n        lines.moveTo(0, 0, 1.5)\n        #lines.create()\n        #lines = LineNodePath(self.zPost)\n        #lines.setColor(VBase4(0, 0, 1, 1))\n        #lines.setThickness(1.5)\n        #lines.moveTo(0, 0, 0)\n        lines.drawTo(0, 0, -1.5)\n\n        #lines.setThickness(5)\n        lines.moveTo(0, 0, 1.5)\n        lines.drawTo(arrowInfo1, arrowInfo1, arrowInfo0)\n        lines.moveTo(0, 0, 1.5)\n        lines.drawTo(arrowInfo1, -1 * arrowInfo1, arrowInfo0)\n        lines.moveTo(0, 0, 1.5)\n        lines.drawTo(-1 * arrowInfo1, arrowInfo1,  arrowInfo0)\n        lines.moveTo(0, 0, 1.5)\n        lines.drawTo(-1 * arrowInfo1, -1 * arrowInfo1, arrowInfo0)\n\n        lines.create()\n        lines.setName('z-post-line')\n\n        #Z scale\n        self.zScale = self.zScaleGroup.attachNewNode('z-scale-visible')\n        lines = LineNodePath(self.zScale)\n        lines.setColor(VBase4(0, 0, 1, 1))\n        lines.setThickness(5)\n        lines.moveTo(0, 0, 1.3)\n        lines.drawTo(0, 0, -1.5)\n\n        drawBox(lines, (0, 0, 1.4), 0.2)\n\n        lines.create()\n        lines.setName('y-scale-line')\n\n        # Z ring\n        self.zRing = self.zRingGroup.attachNewNode('z-ring-visible')\n        lines = LineNodePath(self.zRing)\n        lines.setColor(VBase4(0, 0, 1, 1))\n        lines.setThickness(3)\n        lines.moveTo(1, 0, 0)\n        for ang in range(15, 370, 15):\n            lines.drawTo(math.cos(deg2Rad(ang)),\n                          math.sin(deg2Rad(ang)),\n                          0)\n        lines.create()\n        lines.setName('z-ring-line')\n\n    def createGuideLines(self):\n        self.guideLines = self.attachNewNode('guideLines')\n        # X guide lines\n        lines = LineNodePath(self.guideLines)\n        lines.setColor(VBase4(1, 0, 0, 1))\n        lines.setThickness(0.5)\n        lines.moveTo(-500, 0, 0)\n        lines.drawTo(500, 0, 0)\n        lines.create()\n        lines.setName('x-guide')\n\n        # Y guide lines\n        lines = LineNodePath(self.guideLines)\n        lines.setColor(VBase4(0, 1, 0, 1))\n        lines.setThickness(0.5)\n        lines.moveTo(0, -500, 0)\n        lines.drawTo(0, 500, 0)\n        lines.create()\n        lines.setName('y-guide')\n\n        # Z guide lines\n        lines = LineNodePath(self.guideLines)\n        lines.setColor(VBase4(0, 0, 1, 1))\n        lines.setThickness(0.5)\n        lines.moveTo(0, 0, -500)\n        lines.drawTo(0, 0, 500)\n        lines.create()\n        lines.setName('z-guide')\n\n    def getAxisIntersectPt(self, axis):\n        if hasattr(ShowBaseGlobal.direct, \"manipulationControl\") and ShowBaseGlobal.direct.manipulationControl.fMultiView and\\\n           ShowBaseGlobal.direct.camera.getName() != 'persp':\n            # create ray from the camera to detect 3d position\n            iRay = SelectionRay(ShowBaseGlobal.direct.camera)\n            iRay.collider.setFromLens(ShowBaseGlobal.direct.camNode, ShowBaseGlobal.direct.dr.mouseX, ShowBaseGlobal.direct.dr.mouseY)\n            #iRay.collideWithBitMask(1)\n            iRay.collideWithBitMask(BitMask32.bit(21))\n            iRay.ct.traverse(ShowBaseGlobal.direct.grid)\n\n            if iRay.getNumEntries() == 0:\n                del iRay\n                return self.hitPt\n\n            entry = iRay.getEntry(0)\n            self.hitPt = entry.getSurfacePoint(self)\n            del iRay\n            if axis == 'x':\n                # We really only care about the nearest point on the axis\n                self.hitPt.setY(0)\n                self.hitPt.setZ(0)\n            elif axis == 'y':\n                self.hitPt.setX(0)\n                self.hitPt.setZ(0)\n            elif axis == 'z':\n                self.hitPt.setX(0)\n                self.hitPt.setY(0)\n            return self.hitPt\n\n        # Calc the xfrom from camera to widget\n        mCam2Widget = ShowBaseGlobal.direct.camera.getMat(ShowBaseGlobal.direct.widget)\n        lineDir = Vec3(mCam2Widget.xformVec(ShowBaseGlobal.direct.dr.nearVec))\n        lineDir.normalize()\n        # And determine where the viewpoint is relative to widget\n        lineOrigin = VBase3(0)\n        decomposeMatrix(mCam2Widget, VBase3(0), VBase3(0), lineOrigin,\n                        CSDefault)\n        # Now see where this hits the plane containing the 1D motion axis.\n        # Pick the intersection plane most normal to the intersection ray\n        # by comparing lineDir with plane normals.  The plane with the\n        # largest dotProduct is most \"normal\"\n        if axis == 'x':\n            if abs(lineDir.dot(DG.Y_AXIS)) > abs(lineDir.dot(DG.Z_AXIS)):\n                self.hitPt.assign(\n                    planeIntersect(lineOrigin, lineDir, DG.ORIGIN, DG.Y_AXIS))\n            else:\n                self.hitPt.assign(\n                    planeIntersect(lineOrigin, lineDir, DG.ORIGIN, DG.Z_AXIS))\n            # We really only care about the nearest point on the axis\n            self.hitPt.setY(0)\n            self.hitPt.setZ(0)\n        elif axis == 'y':\n            if abs(lineDir.dot(DG.X_AXIS)) > abs(lineDir.dot(DG.Z_AXIS)):\n                self.hitPt.assign(\n                    planeIntersect(lineOrigin, lineDir, DG.ORIGIN, DG.X_AXIS))\n            else:\n                self.hitPt.assign(\n                    planeIntersect(lineOrigin, lineDir, DG.ORIGIN, DG.Z_AXIS))\n            # We really only care about the nearest point on the axis\n            self.hitPt.setX(0)\n            self.hitPt.setZ(0)\n        elif axis == 'z':\n            if abs(lineDir.dot(DG.X_AXIS)) > abs(lineDir.dot(DG.Y_AXIS)):\n                self.hitPt.assign(\n                    planeIntersect(lineOrigin, lineDir, DG.ORIGIN, DG.X_AXIS))\n            else:\n                self.hitPt.assign(\n                    planeIntersect(lineOrigin, lineDir, DG.ORIGIN, DG.Y_AXIS))\n            # We really only care about the nearest point on the axis\n            self.hitPt.setX(0)\n            self.hitPt.setY(0)\n        return self.hitPt\n\n    def getMouseIntersectPt(self):\n        # create ray from the camera to detect 3d position\n        iRay = SelectionRay(ShowBaseGlobal.direct.camera)\n        iRay.collider.setFromLens(ShowBaseGlobal.direct.camNode, ShowBaseGlobal.direct.dr.mouseX, ShowBaseGlobal.direct.dr.mouseY)\n        #iRay.collideWithBitMask(1)\n        iRay.collideWithBitMask(BitMask32.bit(21))\n        iRay.ct.traverse(ShowBaseGlobal.direct.grid)\n\n        if iRay.getNumEntries() == 0:\n            del iRay\n            return Point3(0)\n\n        entry = iRay.getEntry(0)\n        hitPt = entry.getSurfacePoint(entry.getFromNodePath())\n\n        # create a temp nodePath to get the position\n        np = NodePath('temp')\n        np.setPos(ShowBaseGlobal.direct.camera, hitPt)\n        resultPt = Point3(0)\n        resultPt.assign(np.getPos())\n        np.removeNode()\n        del iRay\n        return resultPt\n\n    def getWidgetIntersectPt(self, nodePath, plane):\n        if hasattr(ShowBaseGlobal.direct, \"manipulationControl\") and ShowBaseGlobal.direct.manipulationControl.fMultiView and\\\n           ShowBaseGlobal.direct.camera.getName() != 'persp':\n            self.hitPt.assign(self.getMouseIntersectPt())\n            return self.hitPt\n\n        # Find out the point of interection of the ray passing though the mouse\n        # with the plane containing the 2D xlation or 1D rotation widgets\n\n        # Calc the xfrom from camera to the nodePath\n        mCam2NodePath = ShowBaseGlobal.direct.camera.getMat(nodePath)\n\n        # And determine where the viewpoint is relative to widget\n        lineOrigin = VBase3(0)\n        decomposeMatrix(mCam2NodePath, VBase3(0), VBase3(0), lineOrigin,\n                        CSDefault)\n\n        # Next we find the vector from viewpoint to the widget through\n        # the mouse's position on near plane.\n        # This defines the intersection ray\n        lineDir = Vec3(mCam2NodePath.xformVec(ShowBaseGlobal.direct.dr.nearVec))\n        lineDir.normalize()\n        # Find the hit point\n        if plane == 'x':\n            self.hitPt.assign(planeIntersect(\n                lineOrigin, lineDir, DG.ORIGIN, DG.X_AXIS))\n        elif plane == 'y':\n            self.hitPt.assign(planeIntersect(\n                lineOrigin, lineDir, DG.ORIGIN, DG.Y_AXIS))\n        elif plane == 'z':\n            self.hitPt.assign(planeIntersect(\n                lineOrigin, lineDir, DG.ORIGIN, DG.Z_AXIS))\n\n        return self.hitPt\n\n\ndef drawBox(lines, center, sideLength):\n    l = sideLength * 0.5\n    lines.moveTo(center[0] + l, center[1] + l, center[2] + l)\n    lines.drawTo(center[0] + l, center[1] + l, center[2] - l)\n    lines.drawTo(center[0] + l, center[1] - l, center[2] - l)\n    lines.drawTo(center[0] + l, center[1] - l, center[2] + l)\n    lines.drawTo(center[0] + l, center[1] + l, center[2] + l)\n\n    lines.moveTo(center[0] - l, center[1] + l, center[2] + l)\n    lines.drawTo(center[0] - l, center[1] + l, center[2] - l)\n    lines.drawTo(center[0] - l, center[1] - l, center[2] - l)\n    lines.drawTo(center[0] - l, center[1] - l, center[2] + l)\n    lines.drawTo(center[0] - l, center[1] + l, center[2] + l)\n\n    lines.moveTo(center[0] + l, center[1] + l, center[2] + l)\n    lines.drawTo(center[0] + l, center[1] + l, center[2] - l)\n    lines.drawTo(center[0] - l, center[1] + l, center[2] - l)\n    lines.drawTo(center[0] - l, center[1] + l, center[2] + l)\n    lines.drawTo(center[0] + l, center[1] + l, center[2] + l)\n\n    lines.moveTo(center[0] + l, center[1] - l, center[2] + l)\n    lines.drawTo(center[0] + l, center[1] - l, center[2] - l)\n    lines.drawTo(center[0] - l, center[1] - l, center[2] - l)\n    lines.drawTo(center[0] - l, center[1] - l, center[2] + l)\n    lines.drawTo(center[0] + l, center[1] - l, center[2] + l)\n\n    lines.moveTo(center[0] + l, center[1] + l, center[2] + l)\n    lines.drawTo(center[0] - l, center[1] + l, center[2] + l)\n    lines.drawTo(center[0] - l, center[1] - l, center[2] + l)\n    lines.drawTo(center[0] + l, center[1] - l, center[2] + l)\n    lines.drawTo(center[0] + l, center[1] + l, center[2] + l)\n\n    lines.moveTo(center[0] + l, center[1] + l, center[2] - l)\n    lines.drawTo(center[0] - l, center[1] + l, center[2] - l)\n    lines.drawTo(center[0] - l, center[1] - l, center[2] - l)\n    lines.drawTo(center[0] + l, center[1] - l, center[2] - l)\n    lines.drawTo(center[0] + l, center[1] + l, center[2] - l)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/directtools/DirectManipulation.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/4f678cc8_DirectManipulation.json",
    "doc_id": "doc_179"
  }
}