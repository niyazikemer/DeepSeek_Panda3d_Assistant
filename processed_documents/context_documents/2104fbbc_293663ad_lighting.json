{
  "content": "Lighting\n\nLighting Basics\n\nIn the real world, if you put a light in a room, objects in that room are illuminated. For example, if you put a table lamp in your living room, that lamp automatically illuminates your sofa and your chair. In a 3D engine like Panda3D, lights don't illuminate things automatically. Instead, you must tell the chair and the sofa to be illuminated by the lamp.\n\nSo to reiterate, lighting a scene in Panda3D consists of two steps:\n\nCreating lights, and positioning them within the scene.\n\nTelling the other objects to be illuminated by the lights.\n\nPanda3D defines four different kinds of light objects: point, directional, ambient, and spotlight. Each of these is a node that should be attached somewhere within the scene graph. Like anything you put into the scene, lights have a position and orientation, which is determined by the basic scene graph operations like ~.NodePath.set_pos(), ~.NodePath.set_hpr(), etc. The ~.NodePath.look_at() method is particularly useful for pointing spotlights and directional lights at a particular object.\n\ncpp\n\nNote that you will need to include the following headers according to the type of lights you are going to use:\n\n#include \"ambientLight.h\"\n#include \"directionalLight.h\"\n#include \"pointLight.h\"\n#include \"spotlight.h\"\n\nThe following code inserts a directional light into the scene:\n\npython\n\ndlight = DirectionalLight('my dlight')\ndlnp = render.attachNewNode(dlight)\n\ncpp\n\nPT(DirectionalLight) d_light;\nd_light = new DirectionalLight(\"my d_light\");\nNodePath dlnp = window->get_render().attach_new_node(d_light);\n\nNote that, unlike a real, physical light bulb, the light objects are not themselves directly visible. Although you can't see a Panda light itself, you can see the effect it has on the geometry around it. If you want to make a light visible, one simple trick is to load a simple model (like a sphere) and parent it directly to the light itself.\n\nCreating the light and putting it in the scene graph doesn't, by itself, have any visible effect. Your next step is to tell some object to be illuminated by the light. To do this, use the .NodePath.set_light() method, which turns on the light for the indicated NodePath and everything below it in the scene graph.\n\nIn the simplest case, you want all of your lights to illuminate everything they can, so you turn them on at render, the top of the scene graph:\n\npython\n\nrender.setLight(plnp)\n\ncpp\n\nwindow->get_render().set_light(pnlp);\n\nYou can remove the light setting from render:\n\npython\n\nrender.clearLight(plnp)\n\ncpp\n\nwindow->get_render().clear_light(pnlp);\n\nYou could also apply the ~.NodePath.set_light() call to a sub-node in the scene graph, so that a given light only affects a particular object or group of objects:\n\npython\n\nsofa.setLight(plnp)\n\ncpp\n\nsofa.set_light(plnp)\n\nNote that there are two (or more) different NodePaths involved here: the NodePath of the light itself, which defines the position and/or orientation of the light, and the NodePath(s) on which you call ~.NodePath.set_light(), which determines what subset of the scene graph the light illuminates. There's no requirement for these two NodePaths to be related in any way.\n\nLots of Lights: Performance Implications\n\nEach light slows down rendering a little. Using a half-dozen lights to illuminate an object is no problem at all. However, if you were to use a hundred lights to illuminate an object, that object would render slowly.\n\nBecause of this, when you create a big virtual world, you need to pick and choose which lights affect which objects. For example, if you had a dungeon containing a hundred torches, it would not be practical to tell every object to be illuminated by every torch. Instead, for each object in the dungeon, you would want to search for the three or four nearest torches, and tell the object to be illuminated only by those three or four torches.\n\nWhen per-pixel lighting is enabled, lights are considerably more costly.\n\nColored Lights\n\npython\n\nAll lights have a color, which is specified by light.color = (r, g, b, a) <.Light.color>. The default color is full white: light.color = (1, 1, 1, 1) <.Light.color>. The alpha component is largely irrelevant.\n\ncpp\n\nAll lights have a color, which is specified by light.set_color(LColor(r, g, b, a)) <.Light.set_color>. The default color is full white: light.set_color(LColor(1, 1, 1, 1)) <.Light.set_color>. The alpha component is largely irrelevant.\n\nIf you are trying to simulate a natural light, it may be easier to set the color temperature instead, by calling .Light.set_color_temperature() with a value in Kelvin. Use a value of 6500 for pure white, a lower value to get a warmer white color and a higher value to get a cooler white.\n\npython\n\nThe color of the specular highlight can be set individually using light.setSpecularColor((r, g, b, a)) <.Light.set_specular_color>, however, this should not be done as this will produce an unnatural effect. This method is deprecated and may be removed in a future version of Panda3D. By default, the specular color of a light is automatically set from its regular color.\n\ncpp\n\nThe color of the specular highlight can be set individually using light.set_specular_color(LColor(r, g, b, a)) <.Light.set_specular_color>, however, this should not be done as this will produce an unnatural effect. This method is deprecated and may be removed in a future version of Panda3D. By default, the specular color of a light is automatically set from its regular color.\n\nNote\n\nThe R, G, B values can be larger than 1, if you want brighter lights! In fact, to achieve a realistic look, you may need to set your light colors many orders of magnitude higher than \"full white\", and use HDR rendering techniques (described in common-image-filters) to make sure that the full dynamic range of your lights can be adequately represented and compressed down to the range that the user's monitor can display.\n\nPoint Lights\n\nPoint lights are the easiest kind of light to understand: a point light simulates a light originating from a single point in space and shining in all directions, like a very tiny light bulb. A point light's position is important, but its orientation doesn't matter.\n\npython\n\nplight = PointLight('plight')\nplight.setColor((0.2, 0.2, 0.2, 1))\nplnp = render.attachNewNode(plight)\nplnp.setPos(10, 20, 0)\nrender.setLight(plnp)\n\ncpp\n\nPT(PointLight) plight = new PointLight(\"sun\");\nplight->set_color(LColor(.7, .7, .7, 1));\nNodePath plnp = render.attach_new_node(plight);\nplnp.set_pos(500, 500, 500);\nrender.set_light(plnp);\n\nAttenuation\n\nYou can set the attenuation coefficients, which causes the light to drop off gradually with distance. There are three attenuation coefficients: constant, linear, and quadratic.\n\npython\n\nplight.attenuation = (c, l, q)\n\ncpp\n\nplight->set_attenuation(LVecBase3(c, l, q));\n\nThe default values for these constants are (1, 0, 0), respectively. This means that the intensity of a light is by default not dependent on the distance to the light source.\n\nIn real-life, lighting conforms to what is known as the inverse-square law. This means that the light falls off proportional to the inverse of the square of the distance. To achieve this effect, you need to set the quadratic coefficient to 1:\n\npython\n\nplight.attenuation = (0, 0, 1)\n\ncpp\n\nplight->set_attenuation(LVecBase3(0, 0, 1));\n\nOne disadvantage of this is that the light intensity will approach infinity as the distance approaches zero. A common way to avoid this in real-time rendering is to set the constant coefficient to 1.\n\npython\n\nplight.attenuation = (1, 0, 1)\n\ncpp\n\nplight->set_attenuation(LVecBase3(1, 0, 1));\n\nThis will make the light intensity smoothly reach 1 as the distance to the light source approaches zero.\n\nDirectional Lights\n\nA directional light is an infinite wave of light, always in the same direction, like sunlight. A directional light's position doesn't matter, but its orientation is important. The default directional light is shining down the forward (+Y) axis; you can use .NodePath.set_hpr() or ~.NodePath.set_light() to rotate it to face in a different direction.\n\npython\n\ndlight = DirectionalLight('dlight')\ndlight.setColor((0.8, 0.8, 0.5, 1))\ndlnp = render.attachNewNode(dlight)\ndlnp.setHpr(0, -60, 0)\nrender.setLight(dlnp)\n\ncpp\n\nPT(DirectionalLight) d_light;\nd_light = new DirectionalLight(\"my d_light\");\nd_light->set_color(LColor(0.8, 0.8, 0.5, 1));\nNodePath dlnp = window->get_render().attach_new_node(d_light);\ndlnp.set_hpr(-30, -60, 0);\nwindow->get_render().set_light(dlnp);\n\nAmbient Lights\n\nAn ambient light is used to fill in the shadows on the dark side of an object, so it doesn't look completely black. The light from an ambient light is uniformly distributed everywhere in the world, so the ambient light's position and orientation are irrelevant.\n\nUsually you don't want to create an ambient light without also creating one of the other kinds of lights, since an object illuminated solely by ambient light will be completely flat shaded and you won't be able to see any of its details. Typically, ambient lights are given a fairly dark gray color, so they don't overpower the other lights in the scene.\n\nalight = AmbientLight('alight')\nalight.setColor((0.2, 0.2, 0.2, 1))\nalnp = render.attachNewNode(alight)\nrender.setLight(alnp)\n\nSpotlights\n\nSpotlights represent the most sophisticated kind of light. A spotlight has both a point and a direction, and a field-of-view. In fact, a spotlight contains a lens, just like a camera does; the lens should be a PerspectiveLens and is used to define the area of effect of the light (the light illuminates everything within the field of view of the lens).\n\nNote that the English word \"spotlight\" is one word, as opposed to the other kinds of lights, which are two words. Thus, the class name is correctly spelled \"Spotlight\", not \"SpotLight\".\n\nslight = Spotlight('slight')\nslight.setColor((1, 1, 1, 1))\nlens = PerspectiveLens()\nslight.setLens(lens)\nslnp = render.attachNewNode(slight)\nslnp.setPos(10, 20, 0)\nslnp.lookAt(myObject)\nrender.setLight(slnp)\n\nPutting it all Together\n\nHere is an example of lighting. There are an ambient light and two directional lights lighting the scene, and a green ambient light that only affects one of the pandas.\n\nimport direct.directbase.DirectStart\nfrom panda3d.core import *\n\n# Put two pandas in the scene, panda x and panda y.\nx = loader.loadModel('panda')\nx.reparentTo(render)\nx.setPos(10,0,-6)\n\ny = loader.loadModel('panda')\ny.reparentTo(render)\ny.setPos(-10,0,-6)\n\n# Position the camera to view the two pandas.\nbase.trackball.node().setPos(0, 60, 0)\n\n# Now create some lights to apply to everything in the scene.\n\n# Create Ambient Light\nambientLight = AmbientLight('ambientLight')\nambientLight.setColor((0.1, 0.1, 0.1, 1))\nambientLightNP = render.attachNewNode(ambientLight)\nrender.setLight(ambientLightNP)\n\n# Directional light 01\ndirectionalLight = DirectionalLight('directionalLight')\ndirectionalLight.setColor((0.8, 0.2, 0.2, 1))\ndirectionalLightNP = render.attachNewNode(directionalLight)\n# This light is facing backwards, towards the camera.\ndirectionalLightNP.setHpr(180, -20, 0)\nrender.setLight(directionalLightNP)\n\n# Directional light 02\ndirectionalLight = DirectionalLight('directionalLight')\ndirectionalLight.setColor((0.2, 0.2, 0.8, 1))\ndirectionalLightNP = render.attachNewNode(directionalLight)\n# This light is facing forwards, away from the camera.\ndirectionalLightNP.setHpr(0, -20, 0)\nrender.setLight(directionalLightNP)\n\n# Now attach a green light only to object x.\nambient = AmbientLight('ambient')\nambient.setColor((0.5, 1, 0.5, 1))\nambientNP = x.attachNewNode(ambient)\n\n# If we did not call setLightOff() first, the green light would add to\n# the total set of lights on this object. Since we do call\n# setLightOff(), we are turning off all the other lights on this\n# object first, and then turning on only the green light.\nx.setLightOff()\nx.setLight(ambientNP)\n\nbase.run()\n\nShadow Mapping\n\nPanda3D offers fully automatic shadow mapping support for spotlights, directional lights and point lights. You can enable shadows by calling ~.LightLensNode.set_shadow_caster(). The nodes that receive shadows will need to have the Shader Generator <the-shader-generator> enabled, otherwise no shadows will appear.\n\npython\n\n# Use a 512x512 resolution shadow map\nlight.setShadowCaster(True, 512, 512)\n# Enable the shader generator for the receiving nodes\nrender.setShaderAuto()\n\ncpp\n\n// Use a 512x512 resolution shadow map\nlight->set_shadow_caster(true, 512, 512);\n// Enable the shader generator for the receiving nodes\nwindow->get_render().set_shader_auto();\n\nNote that, even though in general shadowing is easy to set-up, you will want to tweak the light's lens settings to get the best depth buffer precision. Use the ~.Lens.set_near_far() method on the Lens to get a perfect fit of what is being rendered. Also, for directional lights, you will need to call ~.Lens.set_film_size() on the Lens and position the light properly so that the light camera will get an optimal view of the scene.\n\nAlso note that every Light is in fact also a Camera, so you can easily exclude objects from being shadowed (e.g. for performance reasons) by use of camera masks.\n\nIf you have very thin objects, you may run into self-shadowing issues if the backside of the object casts shadows on its frontside. You can easily fix this by applying a depth offset to the object in question. A depth offset of 1 means to use an offset as small as possible, but big enough to make a difference. This should generally be enough. You can call ~.NodePath.set_depth_offset() on the NodePath or use the depth-offset scalar in the .egg file.\n\npython\n\nleaves.setDepthOffset(1)\n\ncpp\n\nleaves.set_depth_offset(1);",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/293663ad_lighting.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/2104fbbc_293663ad_lighting.json",
    "doc_id": "doc_365"
  }
}