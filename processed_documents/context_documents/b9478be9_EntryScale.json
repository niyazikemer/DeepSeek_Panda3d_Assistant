{
  "content": "\"\"\"\nEntryScale Class: Scale with a label, and a linked and validated entry\n\"\"\"\n\n__all__ = ['EntryScale', 'EntryScaleGroup']\n\nfrom panda3d.core import Vec4\nimport Pmw\nimport tkinter as tk\nfrom tkinter.simpledialog import askfloat, askstring\nfrom tkinter.colorchooser import askcolor\n\n\nclass EntryScale(Pmw.MegaWidget):\n    \"Scale with linked and validated entry\"\n\n    def __init__(self, parent = None, **kw):\n\n        # Define the megawidget options.\n        optiondefs = (\n            ('state',        None,          None),\n            ('value',        0.0,           Pmw.INITOPT),\n            ('resolution',   0.001,         None),\n            ('command',      None,          None),\n            ('preCallback',  None,          None),\n            ('postCallback', None,          None),\n            ('callbackData', [],            None),\n            ('min',          0.0,           self._updateValidate),\n            ('max',          100.0,         self._updateValidate),\n            ('text',         'EntryScale',  self._updateLabelText),\n            ('numDigits',    2,             self._setSigDigits),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Initialise superclass\n        Pmw.MegaWidget.__init__(self, parent)\n\n        # Initialize some class variables\n        self.value = self['value']\n        self.entryFormat = '%.2f'\n        self.fScaleCommand = 0\n\n        # Create the components.\n\n        # Setup up container\n        interior = self.interior()\n        interior.configure(relief = tk.GROOVE, borderwidth = 2)\n\n        # Create a label and an entry\n        self.labelFrame = self.createcomponent('frame', (), None,\n                                               tk.Frame, interior)\n        # Create an entry field to display and validate the entryScale's value\n        self.entryValue = tk.StringVar()\n        self.entryValue.set(self['value'])\n        self.entry = self.createcomponent('entryField',\n                                          # Access widget's entry using \"entry\"\n                                          (('entry', 'entryField_entry'),),\n                                          None,\n                                          Pmw.EntryField, self.labelFrame,\n                                          entry_width=10,\n                                          validate={'validator': 'real',\n                                                    'min': self['min'],\n                                                    'max': self['max'],\n                                                    'minstrict': 0,\n                                                    'maxstrict': 0},\n                                          entry_justify='right',\n                                          entry_textvar=self.entryValue,\n                                          command=self._entryCommand)\n        self.entry.pack(side='left', padx=4)\n\n        # Create the EntryScale's label\n        self.label = self.createcomponent('label', (), None,\n                                          tk.Label, self.labelFrame,\n                                          text = self['text'],\n                                          width = 12,\n                                          anchor = 'center',\n                                          font = \"Arial 12 bold\")\n        self.label.pack(side='left', expand = 1, fill = 'x')\n        self.label.bind('<Button-3>', self.askForLabel)\n\n        # Now pack the frame\n        self.labelFrame.pack(expand = 1, fill = 'both')\n\n        # Create a label and an entry\n        self.minMaxFrame = self.createcomponent('mmFrame', (), None,\n                                                tk.Frame, interior)\n        # Create the EntryScale's min max labels\n        self.minLabel = self.createcomponent('minLabel', (), None,\n                                             tk.Label, self.minMaxFrame,\n                                             text = repr(self['min']),\n                                             relief = tk.FLAT,\n                                             width = 5,\n                                             anchor = tk.W,\n                                             font = \"Arial 8\")\n        self.minLabel.pack(side='left', fill = 'x')\n        self.minLabel.bind('<Button-3>', self.askForMin)\n\n        # Create the scale component.\n        self.scale = self.createcomponent('scale', (), None,\n                                          tk.Scale, self.minMaxFrame,\n                                          command = self._scaleCommand,\n                                          orient = 'horizontal',\n                                          length = 150,\n                                          from_ = self['min'],\n                                          to = self['max'],\n                                          resolution = self['resolution'],\n                                          showvalue = 0)\n        self.scale.pack(side = 'left', expand = 1, fill = 'x')\n        # Set scale to the middle of its range\n        self.scale.set(self['value'])\n        self.scale.bind('<Button-1>', self.__onPress)\n        self.scale.bind('<ButtonRelease-1>', self.__onRelease)\n        self.scale.bind('<Button-3>', self.askForResolution)\n\n        self.maxLabel = self.createcomponent('maxLabel', (), None,\n                                             tk.Label, self.minMaxFrame,\n                                             text = repr(self['max']),\n                                             relief = tk.FLAT,\n                                             width = 5,\n                                             anchor = tk.E,\n                                             font = \"Arial 8\")\n        self.maxLabel.bind('<Button-3>', self.askForMax)\n        self.maxLabel.pack(side='left', fill = 'x')\n        self.minMaxFrame.pack(expand = 1, fill = 'both')\n\n        # Check keywords and initialise options based on input values.\n        self.initialiseoptions(EntryScale)\n\n    def askForLabel(self, event = None):\n        newLabel = askstring(title = self['text'],\n                             prompt = 'New label:',\n                             initialvalue = repr(self['text']),\n                             parent = self.interior())\n        if newLabel:\n            self['text'] = newLabel\n\n    def askForMin(self, event = None):\n        newMin = askfloat(title = self['text'],\n                          prompt = 'New min val:',\n                          initialvalue = repr(self['min']),\n                          parent = self.interior())\n        if newMin:\n            self.setMin(newMin)\n\n    def setMin(self, newMin):\n        self['min'] = newMin\n        self.scale['from_'] = newMin\n        self.minLabel['text'] = newMin\n        self.entry.checkentry()\n\n    def askForMax(self, event = None):\n        newMax = askfloat(title = self['text'],\n                          parent = self.interior(),\n                          initialvalue = self['max'],\n                          prompt = 'New max val:')\n        if newMax:\n            self.setMax(newMax)\n\n    def setMax(self, newMax):\n        self['max'] = newMax\n        self.scale['to'] = newMax\n        self.maxLabel['text'] = newMax\n        self.entry.checkentry()\n\n    def askForResolution(self, event = None):\n        newResolution = askfloat(title = self['text'],\n                                 parent = self.interior(),\n                                 initialvalue = self['resolution'],\n                                 prompt = 'New resolution:')\n        if newResolution:\n            self.setResolution(newResolution)\n\n    def setResolution(self, newResolution):\n        self['resolution'] = newResolution\n        self.scale['resolution'] = newResolution\n        self.entry.checkentry()\n\n    def _updateLabelText(self):\n        self.label['text'] = self['text']\n\n    def _updateValidate(self):\n        self.configure(entryField_validate = {\n            'validator': 'real',\n            'min': self['min'],\n            'max': self['max'],\n            'minstrict': 0,\n            'maxstrict': 0})\n        self.minLabel['text'] = self['min']\n        self.scale['from_'] = self['min']\n        self.scale['to'] = self['max']\n        self.maxLabel['text'] = self['max']\n\n    def _scaleCommand(self, strVal):\n        if not self.fScaleCommand:\n            return\n        # convert scale val to float\n        self.set(float(strVal))\n\n        # Update entry to reflect formatted value\n        #self.entryValue.set(self.entryFormat % self.value)\n        #self.entry.checkentry()\n        #if self['command']:\n        #    self['command'](self.value)\n\n    def _entryCommand(self, event = None):\n        try:\n            val = float(self.entryValue.get())\n            self.onReturn(*self['callbackData'])\n            self.set(val)\n            self.onReturnRelease(*self['callbackData'])\n        except ValueError:\n            pass\n\n    def _setSigDigits(self):\n        sd = self['numDigits']\n        self.entryFormat = '%.' + '%d' % sd + 'f'\n        # And reset value to reflect change\n        self.entryValue.set(self.entryFormat % self.value)\n\n    def get(self):\n        return self.value\n\n    def set(self, newVal, fCommand = 1):\n        # Clamp value\n        if self['min'] is not None:\n            if newVal < self['min']:\n                newVal = self['min']\n        if self['max'] is not None:\n            if newVal > self['max']:\n                newVal = self['max']\n        # Round by resolution\n        if self['resolution'] is not None:\n            newVal = round(newVal / self['resolution']) * self['resolution']\n\n        # Record updated value\n        self.value = newVal\n        # Update scale's position\n        self.scale.set(newVal)\n        # Update entry to reflect formatted value\n        self.entryValue.set(self.entryFormat % self.value)\n        self.entry.checkentry()\n\n        # execute command\n        if fCommand and (self['command'] is not None):\n            self['command'](newVal)\n\n    def onReturn(self, *args):\n        \"\"\" User redefinable callback executed on <Return> in entry \"\"\"\n\n    def onReturnRelease(self, *args):\n        \"\"\" User redefinable callback executed on <Return> release in entry \"\"\"\n\n    def __onPress(self, event):\n        # First execute onpress callback\n        if self['preCallback']:\n            self['preCallback'](*self['callbackData'])\n        # Now enable slider command\n        self.fScaleCommand = 1\n\n    def onPress(self, *args):\n        \"\"\" User redefinable callback executed on button press \"\"\"\n\n    def __onRelease(self, event):\n        # Now disable slider command\n        self.fScaleCommand = 0\n        # First execute onpress callback\n        if self['postCallback']:\n            self['postCallback'](*self['callbackData'])\n\n    def onRelease(self, *args):\n        \"\"\" User redefinable callback executed on button release \"\"\"\n\n\nclass EntryScaleGroup(Pmw.MegaToplevel):\n    def __init__(self, parent = None, **kw):\n\n        # Default group size\n        DEFAULT_DIM = 1\n        # Default value depends on *actual* group size, test for user input\n        DEFAULT_VALUE = [0.0] * kw.get('dim', DEFAULT_DIM)\n        DEFAULT_LABELS = ['v[%d]' % x for x in range(kw.get('dim', DEFAULT_DIM))]\n\n        #define the megawidget options\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            ('dim',             DEFAULT_DIM,            INITOPT),\n            ('side',            tk.TOP,                 INITOPT),\n            ('title',           'Group',                None),\n            # A tuple of initial values, one for each entryScale\n            ('value',    DEFAULT_VALUE,          INITOPT),\n            # The command to be executed any time one of the entryScales is updated\n            ('command',         None,                   None),\n            ('preCallback',     None,                   None),\n            ('postCallback',    None,                   None),\n            # A tuple of labels, one for each entryScale\n            ('labels',          DEFAULT_LABELS,         self._updateLabels),\n            # Destroy or withdraw\n            ('fDestroy',        0,                      INITOPT)\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Initialize the toplevel widget\n        Pmw.MegaToplevel.__init__(self, parent)\n\n        # Create the components\n        interior = self.interior()\n        # Get a copy of the initial value (making sure its a list)\n        self._value = list(self['value'])\n\n        # The Menu Bar\n        self.balloon = Pmw.Balloon()\n        menubar = self.createcomponent('menubar', (), None,\n                                       Pmw.MenuBar, (interior,),\n                                       balloon = self.balloon)\n        menubar.pack(fill=tk.X)\n\n        # EntryScaleGroup Menu\n        menubar.addmenu('EntryScale Group', 'EntryScale Group Operations')\n        menubar.addmenuitem(\n            'EntryScale Group', 'command', 'Reset the EntryScale Group panel',\n            label = 'Reset',\n            command = lambda s = self: s.reset())\n        if self['fDestroy']:\n            dismissCommand = self.destroy\n        else:\n            dismissCommand = self.withdraw\n        menubar.addmenuitem(\n            'EntryScale Group', 'command', 'Dismiss EntryScale Group panel',\n            label = 'Dismiss', command = dismissCommand)\n\n        menubar.addmenu('Help', 'EntryScale Group Help Operations')\n        self.toggleBalloonVar = tk.IntVar()\n        self.toggleBalloonVar.set(0)\n        menubar.addmenuitem('Help', 'checkbutton',\n                            'Toggle balloon help',\n                            label = 'Balloon Help',\n                            variable = self.toggleBalloonVar,\n                            command = self.toggleBalloon)\n\n        self.entryScaleList = []\n        for index in range(self['dim']):\n            # Add a group alias so you can configure the entryScales via:\n            #   fg.configure(Valuator_XXX = YYY)\n            f = self.createcomponent(\n                'entryScale%d' % index, (), 'Valuator', EntryScale,\n                (interior,), value = self._value[index],\n                text = self['labels'][index])\n            # Do this separately so command doesn't get executed during construction\n            f['command'] = lambda val, s=self, i=index: s._entryScaleSetAt(i, val)\n            f['callbackData'] = [self]\n            # Callbacks\n            f.onReturn = self.__onReturn\n            f.onReturnRelease = self.__onReturnRelease\n            f['preCallback'] = self.__onPress\n            f['postCallback'] = self.__onRelease\n            f.pack(side = self['side'], expand = 1, fill = tk.X)\n            self.entryScaleList.append(f)\n\n        # Make sure entryScales are initialized\n        self.set(self['value'])\n\n        # Make sure input variables processed\n        self.initialiseoptions(EntryScaleGroup)\n\n    def _updateLabels(self):\n        if self['labels']:\n            for index in range(self['dim']):\n                self.entryScaleList[index]['text'] = self['labels'][index]\n\n    def toggleBalloon(self):\n        if self.toggleBalloonVar.get():\n            self.balloon.configure(state = 'balloon')\n        else:\n            self.balloon.configure(state = 'none')\n\n    def get(self):\n        return self._value\n\n    def getAt(self, index):\n        return self._value[index]\n\n    # This is the command is used to set the groups value\n    def set(self, value, fCommand = 1):\n        for i in range(self['dim']):\n            self._value[i] = value[i]\n            # Update entryScale, but don't execute its command\n            self.entryScaleList[i].set(value[i], 0)\n        if fCommand and (self['command'] is not None):\n            self['command'](self._value)\n\n    def setAt(self, index, value):\n        # Update entryScale and execute its command\n        self.entryScaleList[index].set(value)\n\n    # This is the command used by the entryScale\n    def _entryScaleSetAt(self, index, value):\n        self._value[index] = value\n        if self['command']:\n            self['command'](self._value)\n\n    def reset(self):\n        self.set(self['value'])\n\n    def __onReturn(self, esg):\n        # Execute onReturn callback\n        self.onReturn(*esg.get())\n\n    def onReturn(self, *args):\n        \"\"\" User redefinable callback executed on button press \"\"\"\n\n    def __onReturnRelease(self, esg):\n        # Execute onReturnRelease callback\n        self.onReturnRelease(*esg.get())\n\n    def onReturnRelease(self, *args):\n        \"\"\" User redefinable callback executed on button press \"\"\"\n\n    def __onPress(self, esg):\n        # Execute onPress callback\n        if self['preCallback']:\n            self['preCallback'](*esg.get())\n\n    def onPress(self, *args):\n        \"\"\" User redefinable callback executed on button press \"\"\"\n\n    def __onRelease(self, esg):\n        # Execute onRelease callback\n        if self['postCallback']:\n            self['postCallback'](*esg.get())\n\n    def onRelease(self, *args):\n        \"\"\" User redefinable callback executed on button release \"\"\"\n\n\ndef rgbPanel(nodePath, callback = None):\n    from direct.showbase.MessengerGlobal import messenger\n\n    def setNodePathColor(color, np = nodePath, cb = callback):\n        np.setColor(color[0]/255.0, color[1]/255.0,\n                    color[2]/255.0, color[3]/255.0)\n        # Execute callback to pass along color info\n        if cb:\n            cb(color)\n    # Check init color\n    if nodePath.hasColor():\n        initColor = nodePath.getColor() * 255.0\n    else:\n        initColor = Vec4(255)\n    # Create entry scale group\n    esg = EntryScaleGroup(title = 'RGBA Panel: ' + nodePath.getName(),\n                          dim = 4,\n                          labels = ['R','G','B','A'],\n                          value = [int(initColor[0]),\n                                   int(initColor[1]),\n                                   int(initColor[2]),\n                                   int(initColor[3])],\n                          Valuator_max = 255,\n                          Valuator_resolution = 1,\n                          # Destroy not withdraw panel on dismiss\n                          fDestroy = 1,\n                          command = setNodePathColor)\n    # Update menu button\n    esg.component('menubar').component('EntryScale Group-button')['text'] = (\n        'RGBA Panel')\n    # Update menu\n    menubar = esg.component('menubar')\n    menubar.deletemenuitems('EntryScale Group', 1, 1)\n\n    # Some helper functions\n    # Clear color\n    menubar.addmenuitem(\n        'EntryScale Group', 'command',\n        label='Clear Color', command=lambda np=nodePath: np.clearColor())\n\n    # Set/Clear Transparency\n    menubar.addmenuitem(\n        'EntryScale Group', 'command',\n        label='Set Transparency', command=lambda np=nodePath: np.setTransparency(1))\n    menubar.addmenuitem(\n        'EntryScale Group', 'command',\n        label='Clear Transparency',\n        command=lambda np=nodePath: np.clearTransparency())\n\n    # System color picker\n    def popupColorPicker(esg = esg):\n        # Can pass in current color with: color = (255, 0, 0)\n        color = askcolor(\n            parent = esg.interior(),\n            # Initialize it to current color\n            initialcolor = tuple(esg.get()[:3]))[0]\n        if color:\n            esg.set((color[0], color[1], color[2], esg.getAt(3)))\n\n    menubar.addmenuitem(\n        'EntryScale Group', 'command',\n        label='Popup Color Picker', command=popupColorPicker)\n\n    def printToLog(nodePath=nodePath):\n        c = nodePath.getColor()\n        print(\"Vec4(%.3f, %.3f, %.3f, %.3f)\" % (c[0], c[1], c[2], c[3]))\n\n    menubar.addmenuitem(\n        'EntryScale Group', 'command',\n        label='Print to log', command=printToLog)\n\n    # Add back the Dismiss item we removed.\n    if esg['fDestroy']:\n        dismissCommand = esg.destroy\n    else:\n        dismissCommand = esg.withdraw\n    menubar.addmenuitem(\n        'EntryScale Group', 'command', 'Dismiss EntryScale Group panel',\n        label='Dismiss', command=dismissCommand)\n\n    # Set callback\n    def onRelease(r, g, b, a, nodePath = nodePath):\n        messenger.send('RGBPanel_setColor', [nodePath, r, g, b, a])\n    esg['postCallback'] = onRelease\n    return esg\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/tkwidgets/EntryScale.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/b9478be9_EntryScale.json",
    "doc_id": "doc_192"
  }
}