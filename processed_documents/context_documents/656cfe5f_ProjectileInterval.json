{
  "content": "\"\"\"ProjectileInterval module: contains the ProjectileInterval class\"\"\"\n\n__all__ = ['ProjectileInterval']\n\nfrom panda3d.core import CollisionParabola, LParabola, NodePath, Point3, VBase3\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom .Interval import Interval\nfrom direct.showbase import PythonUtil\n\n\nclass ProjectileInterval(Interval):\n    \"\"\"ProjectileInterval class: moves a nodepath through the trajectory\n    of a projectile under the influence of gravity\"\"\"\n\n    # create ProjectileInterval DirectNotify category\n    notify = directNotify.newCategory('ProjectileInterval')\n\n    # serial num for unnamed intervals\n    projectileIntervalNum = 1\n\n    # g ~ 9.8 m/s^2 ~ 32 ft/s^2\n    gravity = 32.\n\n    # the projectile's velocity is constant in the X and Y directions.\n    # the projectile's motion in the Z (up) direction is parabolic\n    # due to the constant force of gravity, which acts in the -Z direction\n\n    def __init__(self, node, startPos = None,\n                 endPos = None, duration = None,\n                 startVel = None, endZ = None,\n                 wayPoint = None, timeToWayPoint = None,\n                 gravityMult = None, name = None,\n                 collNode = None):\n        \"\"\"\n        You may specify several different sets of input parameters.\n        (If startPos is not provided, it will be obtained from the node's\n        position at the time that the interval is first started. Note that\n        in this case you must provide a duration of some kind.)\n\n        # go from startPos to endPos in duration seconds\n        startPos, endPos, duration\n        # given a starting velocity, go for a specific time period\n        startPos, startVel, duration\n        # given a starting velocity, go until you hit a given Z plane\n        startPos, startVel, endZ\n        # pass through wayPoint at time 'timeToWayPoint'. Go until\n        # you hit a given Z plane\n        startPos, wayPoint, timeToWayPoint, endZ\n\n        You may alter gravity by providing a multiplier in 'gravityMult'.\n        '2.' will make gravity twice as strong, '.5' half as strong.\n        '-1.' will reverse gravity\n\n        If collNode is not None, it should be an empty CollisionNode\n        which will be filled with an appropriate CollisionParabola\n        when the interval starts.  This CollisionParabola will be set\n        to match the interval's parabola, and its t1, t2 values will\n        be updated automatically as the interval plays.  It will *not*\n        be automatically removed from the node when the interval\n        finishes.\n\n        \"\"\"\n        self.node = node\n        self.collNode = collNode\n        if self.collNode:\n            if isinstance(self.collNode, NodePath):\n                self.collNode = self.collNode.node()\n            assert self.collNode.getNumSolids() == 0\n\n        if name is None:\n            name = '%s-%s' % (self.__class__.__name__,\n                              self.projectileIntervalNum)\n            ProjectileInterval.projectileIntervalNum += 1\n\n        args = (startPos, endPos, duration, startVel, endZ,\n                wayPoint, timeToWayPoint, gravityMult)\n        self.implicitStartPos = 0\n        if startPos is None:\n            if duration is None:\n                self.notify.error('must provide either startPos or duration')\n            self.duration = duration\n            # we can't calc the trajectory until we know our starting\n            # position; delay until the interval is actually started\n            self.trajectoryArgs = args\n            self.implicitStartPos = 1\n        else:\n            self.trajectoryArgs = args\n            self.__calcTrajectory(*args)\n\n        Interval.__init__(self, name, self.duration)\n\n    def __calcTrajectory(self, startPos = None,\n                         endPos = None, duration = None,\n                         startVel = None, endZ = None,\n                         wayPoint = None, timeToWayPoint = None,\n                         gravityMult = None):\n        if startPos is None:\n            startPos = self.node.getPos()\n\n        def doIndirections(*items):\n            result = []\n            for item in items:\n                if callable(item):\n                    item = item()\n                result.append(item)\n            return result\n\n        startPos, endPos, startVel, endZ, gravityMult, wayPoint, \\\n                  timeToWayPoint = \\\n                  doIndirections(startPos, endPos, startVel, endZ, gravityMult,\n                                 wayPoint, timeToWayPoint)\n\n        # we're guaranteed to know the starting position at this point\n        self.startPos = startPos\n\n        # gravity is applied in the -Z direction\n        self.zAcc = -self.gravity\n        if gravityMult:\n            self.zAcc *= gravityMult\n\n        def calcStartVel(startPos, endPos, duration, zAccel):\n            # p(t) = p_0 + t*v_0 + .5*a*t^2\n            # v_0 = [p(t) - p_0 - .5*a*t^2] / t\n            if duration == 0:\n                return Point3(0, 0, 0)\n            else:\n                return Point3((endPos[0] - startPos[0]) / duration,\n                          (endPos[1] - startPos[1]) / duration,\n                          (endPos[2] - startPos[2] - (.5*zAccel*duration*duration)) / duration)\n\n        def calcTimeOfImpactOnPlane(startHeight, endHeight, startVel, accel):\n            return PythonUtil.solveQuadratic(accel * .5, startVel,\n                                             startHeight-endHeight)\n\n        def calcTimeOfLastImpactOnPlane(startHeight, endHeight,\n                                        startVel, accel):\n            time = calcTimeOfImpactOnPlane(startHeight, endHeight,\n                                           startVel, accel)\n            if not time:\n                return None\n            if isinstance(time, list):\n                # projectile hits plane once going up, once going down\n                # assume they want the one on the way down\n                assert self.notify.debug('projectile hits plane twice at times: %s' %\n                                  time)\n                time = max(*time)\n            else:\n                assert self.notify.debug('projectile hits plane once at time: %s' %\n                                  time)\n            return time\n\n        # now all we need is startVel, duration, and endPos.\n\n        # which set of input parameters do we have?\n        if None not in (endPos, duration):\n            assert not startVel\n            assert not endZ\n            assert not wayPoint\n            assert not timeToWayPoint\n            self.duration = duration\n            self.endPos = endPos\n            self.startVel = calcStartVel(self.startPos, self.endPos,\n                                         self.duration, self.zAcc)\n        elif None not in (startVel, duration):\n            assert not endPos\n            assert not endZ\n            assert not wayPoint\n            assert not timeToWayPoint\n            self.duration = duration\n            self.startVel = startVel\n            self.endPos = None\n        elif None not in (startVel, endZ):\n            assert not endPos\n            assert not duration\n            assert not wayPoint\n            assert not timeToWayPoint\n            self.startVel = startVel\n            time = calcTimeOfLastImpactOnPlane(self.startPos[2], endZ,\n                                               self.startVel[2], self.zAcc)\n            if time is None:\n                self.notify.error(\n                    'projectile never reaches plane Z=%s' % endZ)\n            self.duration = time\n            self.endPos = None\n        elif None not in (wayPoint, timeToWayPoint, endZ):\n            assert not endPos\n            assert not duration\n            assert not startVel\n            # we pass through wayPoint at time 'timeToWayPoint', and we\n            # stop when we reach endZ\n            self.startVel = calcStartVel(self.startPos, wayPoint,\n                                         timeToWayPoint, self.zAcc)\n            time = calcTimeOfLastImpactOnPlane(\n                self.startPos[2], endZ, self.startVel[2], self.zAcc)\n            if time is None:\n                self.notify.error(\n                    'projectile never reaches plane Z=%s' % endZ)\n            self.duration = time\n            self.endPos = None\n        else:\n            self.notify.error('invalid set of inputs to ProjectileInterval')\n\n        self.parabola = LParabola(VBase3(0, 0, 0.5 * self.zAcc),\n                                  self.startVel,\n                                  self.startPos)\n\n        if not self.endPos:\n            self.endPos = self.__calcPos(self.duration)\n\n        # these are the parameters that we need to know:\n        assert self.notify.debug('startPos: %s' % repr(self.startPos))\n        assert self.notify.debug('endPos:   %s' % repr(self.endPos))\n        assert self.notify.debug('duration: %s' % self.duration)\n        assert self.notify.debug('startVel: %s' % repr(self.startVel))\n        assert self.notify.debug('z-accel:  %s' % self.zAcc)\n\n    def __initialize(self):\n        if self.implicitStartPos:\n            self.__calcTrajectory(*self.trajectoryArgs)\n\n    def testTrajectory(self):\n        try:\n            self.__calcTrajectory(*self.trajectoryArgs)\n        except Exception:\n            assert self.notify.error('invalid projectile parameters')\n            return False\n        return True\n\n    def privInitialize(self, t):\n        self.__initialize()\n        if self.collNode:\n            self.collNode.clearSolids()\n            csolid = CollisionParabola(self.parabola, 0, 0)\n            self.collNode.addSolid(csolid)\n\n        Interval.privInitialize(self, t)\n\n    def privInstant(self):\n        self.__initialize()\n        Interval.privInstant(self)\n        if self.collNode:\n            self.collNode.clearSolids()\n            csolid = CollisionParabola(self.parabola, 0, self.duration)\n            self.collNode.addSolid(csolid)\n\n    def __calcPos(self, t):\n        return self.parabola.calcPoint(t)\n\n    def privStep(self, t):\n        self.node.setFluidPos(self.__calcPos(t))\n        Interval.privStep(self, t)\n        if self.collNode and self.collNode.getNumSolids() > 0:\n            csolid = self.collNode.modifySolid(0)\n            csolid.setT1(csolid.getT2())\n            csolid.setT2(t)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/interval/ProjectileInterval.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/656cfe5f_ProjectileInterval.json",
    "doc_id": "doc_168"
  }
}