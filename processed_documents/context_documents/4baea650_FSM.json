{
  "content": "\"\"\"The new Finite State Machine module. This replaces the module\npreviously called FSM (now called :mod:`.ClassicFSM`).\n\nFor more information on FSMs, consult the :ref:`finite-state-machines` section\nof the programming manual.\n\"\"\"\n\n__all__ = ['FSMException', 'FSM']\n\n\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.showbase import PythonUtil\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.stdpy.threading import RLock\nfrom panda3d.core import AsyncTaskManager, AsyncFuture, PythonTask\nimport types\n\n\nclass FSMException(Exception):\n    pass\n\n\nclass AlreadyInTransition(FSMException):\n    pass\n\n\nclass RequestDenied(FSMException):\n    pass\n\n\nclass Transition(tuple):\n    \"\"\"Used for the return value of fsm.request().  Behaves like a tuple, for\n    historical reasons.\"\"\"\n\n    _future = None\n\n    def __await__(self):\n        if self._future:\n            yield self._future\n\n        return tuple(self)\n\n\nclass FSM(DirectObject):\n    \"\"\"\n    A Finite State Machine.  This is intended to be the base class\n    of any number of specific machines, which consist of a collection\n    of states and transitions, and rules to switch between states\n    according to arbitrary input data.\n\n    The states of an FSM are defined implicitly.  Each state is\n    identified by a string, which by convention begins with a capital\n    letter.  (Also by convention, strings passed to request that are\n    not state names should begin with a lowercase letter.)\n\n    To define specialized behavior when entering or exiting a\n    particular state, define a method named enterState() and/or\n    exitState(), where \"State\" is the name of the state, e.g.::\n\n        def enterRed(self):\n            ... do stuff ...\n\n        def exitRed(self):\n            ... cleanup stuff ...\n\n        def enterYellow(self):\n            ... do stuff ...\n\n        def exitYellow(self):\n            ... cleanup stuff ...\n\n        def enterGreen(self):\n            ... do stuff ...\n\n        def exitGreen(self):\n            ... cleanup stuff ...\n\n    Both functions can access the previous state name as\n    self.oldState, and the new state name we are transitioning to as\n    self.newState.  (Of course, in enterRed(), self.newState will\n    always be \"Red\", and the in exitRed(), self.oldState will always\n    be \"Red\".)\n\n    Both functions are optional.  If either function is omitted, the\n    state is still defined, but nothing is done when transitioning\n    into (or out of) the state.\n\n    Additionally, you may define a filterState() function for each\n    state.  The purpose of this function is to decide what state to\n    transition to next, if any, on receipt of a particular input.  The\n    input is always a string and a tuple of optional parameters (which\n    is often empty), and the return value should either be None to do\n    nothing, or the name of the state to transition into.  For\n    example::\n\n        def filterRed(self, request, args):\n            if request in ['Green']:\n                return (request,) + args\n            return None\n\n        def filterYellow(self, request, args):\n            if request in ['Red']:\n                return (request,) + args\n            return None\n\n        def filterGreen(self, request, args):\n            if request in ['Yellow']:\n                return (request,) + args\n            return None\n\n    As above, the filterState() functions are optional.  If any is\n    omitted, the defaultFilter() method is called instead.  A standard\n    implementation of defaultFilter() is provided, which may be\n    overridden in a derived class to change the behavior on an\n    unexpected transition.\n\n    If self.defaultTransitions is left unassigned, then the standard\n    implementation of defaultFilter() will return None for any\n    lowercase transition name and allow any uppercase transition name\n    (this assumes that an uppercase name is a request to go directly\n    to a particular state by name).\n\n    self.state may be queried at any time other than during the\n    handling of the enter() and exit() functions.  During these\n    functions, self.state contains the value None (you are not really\n    in any state during the transition).  However, during a transition\n    you *can* query the outgoing and incoming states, respectively,\n    via self.oldState and self.newState.  At other times, self.state\n    contains the name of the current state.\n\n    Initially, the FSM is in state 'Off'.  It does not call enterOff()\n    at construction time; it is simply in Off already by convention.\n    If you need to call code in enterOff() to initialize your FSM\n    properly, call it explicitly in the constructor.  Similarly, when\n    `cleanup()` is called or the FSM is destructed, the FSM transitions\n    back to 'Off' by convention.  (It does call enterOff() at this\n    point, but does not call exitOff().)\n\n    To implement nested hierarchical FSM's, simply create a nested FSM\n    and store it on the class within the appropriate enterState()\n    function, and clean it up within the corresponding exitState()\n    function.\n\n    There is a way to define specialized transition behavior between\n    two particular states.  This is done by defining a from<X>To<Y>()\n    function, where X is the old state and Y is the new state.  If this\n    is defined, it will be run in place of the exit<X> and enter<Y>\n    functions, so if you want that behavior, you'll have to call them\n    specifically.  Otherwise, you can completely replace that transition's\n    behavior.\n\n    See the code in SampleFSM.py for further examples.\n    \"\"\"\n\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"FSM\")\n\n    SerialNum = 0\n\n    # This member lists the default transitions that are accepted\n    # without question by the defaultFilter.  It's a map of state\n    # names to a list of legal target state names from that state.\n    # Define it only if you want to use the classic FSM model of\n    # defining all (or most) of your transitions up front.  If\n    # this is set to None (the default), all named-state\n    # transitions (that is, those requests whose name begins with\n    # a capital letter) are allowed.  If it is set to an empty\n    # map, no transitions are implicitly allowed--all transitions\n    # must be approved by some filter function.\n    defaultTransitions = None\n\n    __doneFuture = AsyncFuture()\n    __doneFuture.set_result(None)\n\n    # An enum class for special states like the DEFAULT or ANY state,\n    # that should be treatened by the FSM in a special way\n    class EnumStates():\n        ANY = 1\n        DEFAULT = 2\n\n    def __init__(self, name):\n        self.fsmLock = RLock()\n        self._name = name\n        self.stateArray = []\n        self._serialNum = FSM.SerialNum\n        FSM.SerialNum += 1\n        self._broadcastStateChanges = False\n        # Initially, we are in the Off state by convention.\n        self.state = 'Off'\n\n        # This member records transition requests made by demand() or\n        # forceTransition() while the FSM is in transition between\n        # states.\n        self.__requestQueue = []\n\n        if __debug__:\n            from direct.fsm.ClassicFSM import _debugFsms\n            import weakref\n            _debugFsms[name]=weakref.ref(self)\n\n    def cleanup(self):\n        # A convenience function to force the FSM to clean itself up\n        # by transitioning to the \"Off\" state.\n        self.fsmLock.acquire()\n        try:\n            assert self.state\n            if self.state != 'Off':\n                self.__setState('Off')\n        finally:\n            self.fsmLock.release()\n\n    def setBroadcastStateChanges(self, doBroadcast):\n        self._broadcastStateChanges = doBroadcast\n    def getStateChangeEvent(self):\n        # if setBroadcastStateChanges(True), this event will be sent through\n        # the messenger on every state change. The new and old states are\n        # accessible as self.oldState and self.newState, and the transition\n        # functions will already have been called.\n        return 'FSM-%s-%s-stateChange' % (self._serialNum, self._name)\n\n    def getCurrentFilter(self):\n        if not self.state:\n            error = \"FSM cannot determine current filter while in transition (%s -> %s).\" % (self.oldState, self.newState)\n            raise AlreadyInTransition(error)\n\n        filter = getattr(self, \"filter\" + self.state, None)\n        if not filter:\n            # If there's no matching filterState() function, call\n            # defaultFilter() instead.\n            filter = self.defaultFilter\n\n        return filter\n\n    def getCurrentOrNextState(self):\n        # Returns the current state if we are in a state now, or the\n        # state we are transitioning into if we are currently within\n        # the enter or exit function for a state.\n        self.fsmLock.acquire()\n        try:\n            if self.state:\n                return self.state\n            return self.newState\n        finally:\n            self.fsmLock.release()\n\n    def getCurrentStateOrTransition(self):\n        # Returns the current state if we are in a state now, or the\n        # transition we are performing if we are currently within\n        # the enter or exit function for a state.\n        self.fsmLock.acquire()\n        try:\n            if self.state:\n                return self.state\n            return '%s -> %s' % (self.oldState, self.newState)\n        finally:\n            self.fsmLock.release()\n\n    def isInTransition(self):\n        self.fsmLock.acquire()\n        try:\n            return self.state is None\n        finally:\n            self.fsmLock.release()\n\n    def forceTransition(self, request, *args):\n        \"\"\"Changes unconditionally to the indicated state.  This\n        bypasses the filterState() function, and just calls\n        exitState() followed by enterState().\n\n        If the FSM is currently undergoing a transition, this will\n        queue up the new transition.\n\n        Returns a future, which can be used to await the transition.\n        \"\"\"\n\n        self.fsmLock.acquire()\n        try:\n            assert isinstance(request, str)\n            self.notify.debug(\"%s.forceTransition(%s, %s\" % (\n                self._name, request, str(args)[1:]))\n\n            if not self.state:\n                # Queue up the request.\n                fut = AsyncFuture()\n                self.__requestQueue.append((PythonUtil.Functor(\n                    self.forceTransition, request, *args), fut))\n                return fut\n\n            result = self.__setState(request, *args)\n            return result._future or self.__doneFuture\n        finally:\n            self.fsmLock.release()\n\n    def demand(self, request, *args):\n        \"\"\"Requests a state transition, by code that does not expect\n        the request to be denied.  If the request is denied, raises a\n        `RequestDenied` exception.\n\n        Unlike `request()`, this method allows a new request to be made\n        while the FSM is currently in transition.  In this case, the\n        request is queued up and will be executed when the current\n        transition finishes.  Multiple requests will queue up in\n        sequence.\n\n        The return value of this function can be used in an `await`\n        expression to suspend the current coroutine until the\n        transition is done.\n        \"\"\"\n\n        self.fsmLock.acquire()\n        try:\n            assert isinstance(request, str)\n            self.notify.debug(\"%s.demand(%s, %s\" % (\n                self._name, request, str(args)[1:]))\n            if not self.state:\n                # Queue up the request.\n                fut = AsyncFuture()\n                self.__requestQueue.append((PythonUtil.Functor(\n                    self.demand, request, *args), fut))\n                return fut\n\n            result = self.request(request, *args)\n            if not result:\n                raise RequestDenied(\"%s (from state: %s)\" % (request, self.state))\n            return result._future or self.__doneFuture\n        finally:\n            self.fsmLock.release()\n\n    def request(self, request, *args):\n        \"\"\"Requests a state transition (or other behavior).  The\n        request may be denied by the FSM's filter function.  If it is\n        denied, the filter function may either raise an exception\n        (`RequestDenied`), or it may simply return None, without\n        changing the FSM's state.\n\n        The request parameter should be a string.  The request, along\n        with any additional arguments, is passed to the current\n        filterState() function.  If filterState() returns a string,\n        the FSM transitions to that state.\n\n        The return value is the same as the return value of\n        filterState() (that is, None if the request does not provoke a\n        state transition, otherwise it is a tuple containing the name\n        of the state followed by any optional args.)\n\n        If the FSM is currently in transition (i.e. in the middle of\n        executing an enterState or exitState function), an\n        `AlreadyInTransition` exception is raised (but see `demand()`,\n        which will queue these requests up and apply when the\n        transition is complete).\n\n        If the previous state's exitFunc or the new state's enterFunc\n        is a coroutine, the state change may not have been applied by\n        the time request() returns, but you can use `await` on the\n        return value to await the transition.\"\"\"\n\n        self.fsmLock.acquire()\n        try:\n            assert isinstance(request, str)\n            self.notify.debug(\"%s.request(%s, %s\" % (\n                self._name, request, str(args)[1:]))\n\n            filter = self.getCurrentFilter()\n            result = filter(request, args)\n            if result:\n                if isinstance(result, str):\n                    # If the return value is a string, it's just the name\n                    # of the state.  Wrap it in a tuple for consistency.\n                    result = (result,) + args\n\n                # Otherwise, assume it's a (name, *args) tuple\n                return self.__setState(*result)\n\n            return result\n        finally:\n            self.fsmLock.release()\n\n    def defaultEnter(self, *args):\n        \"\"\" This is the default function that is called if there is no\n        enterState() method for a particular state name. \"\"\"\n\n    def defaultExit(self):\n        \"\"\" This is the default function that is called if there is no\n        exitState() method for a particular state name. \"\"\"\n\n    def defaultFilter(self, request, args):\n        \"\"\"This is the function that is called if there is no\n        filterState() method for a particular state name.\n\n        This default filter function behaves in one of two modes:\n\n        (1) if self.defaultTransitions is None, allow any request\n        whose name begins with a capital letter, which is assumed to\n        be a direct request to a particular state.  This is similar to\n        the old ClassicFSM onUndefTransition=ALLOW, with no explicit\n        state transitions listed.\n\n        (2) if self.defaultTransitions is not None, allow only those\n        requests explicitly identified in this map.  This is similar\n        to the old ClassicFSM onUndefTransition=DISALLOW, with an\n        explicit list of allowed state transitions.\n\n        Specialized FSM's may wish to redefine this default filter\n        (for instance, to always return the request itself, thus\n        allowing any transition.).\"\"\"\n\n        if request == 'Off':\n            # We can always go to the \"Off\" state.\n            return (request,) + args\n\n        if self.defaultTransitions is None:\n            # If self.defaultTransitions is None, it means to accept\n            # all requests whose name begins with a capital letter.\n            # These are direct requests to a particular state.\n            if request[0].isupper():\n                return (request,) + args\n        else:\n            # If self.defaultTransitions is not None, it is a map of\n            # allowed transitions from each state.  That is, each key\n            # of the map is the current state name; for that key, the\n            # value is a list of allowed transitions from the\n            # indicated state.\n            if request in self.defaultTransitions.get(self.state, []):\n                # This transition is listed in the defaultTransitions map;\n                # accept it.\n                return (request,) + args\n\n            elif FSM.EnumStates.ANY in self.defaultTransitions.get(self.state, []):\n                # Whenever we have a '*' as our to transition, we allow\n                # to transit to any other state\n                return (request,) + args\n\n            elif request in self.defaultTransitions.get(FSM.EnumStates.ANY, []):\n                # If the requested state is in the default transitions\n                # from any state list, we also alow to transit to the\n                # new state\n                return (request,) + args\n\n            elif FSM.EnumStates.ANY in self.defaultTransitions.get(FSM.EnumStates.ANY, []):\n                # This is like we had set the defaultTransitions to None.\n                # Any state can transit to any other state\n                return (request,) + args\n\n            elif request in self.defaultTransitions.get(FSM.EnumStates.DEFAULT, []):\n                # This is the fallback state that we use whenever no\n                # other trnasition was possible\n                return (request,) + args\n\n            # If self.defaultTransitions is not None, it is an error\n            # to request a direct state transition (capital letter\n            # request) not listed in defaultTransitions and not\n            # handled by an earlier filter.\n            if request[0].isupper():\n                raise RequestDenied(\"%s (from state: %s)\" % (request, self.state))\n\n        # In either case, we quietly ignore unhandled command\n        # (lowercase) requests.\n        assert self.notify.debug(\"%s ignoring request %s from state %s.\" % (self._name, request, self.state))\n        return None\n\n    def filterOff(self, request, args):\n        \"\"\"From the off state, we can always go directly to any other\n        state.\"\"\"\n        if request[0].isupper():\n            return (request,) + args\n        return self.defaultFilter(request, args)\n\n    def setStateArray(self, stateArray):\n        \"\"\"array of unique states to iterate through\"\"\"\n        self.fsmLock.acquire()\n        try:\n            self.stateArray = stateArray\n        finally:\n            self.fsmLock.release()\n\n    def requestNext(self, *args):\n        \"\"\"Request the 'next' state in the predefined state array.\"\"\"\n        self.fsmLock.acquire()\n        try:\n            if self.stateArray:\n                if not self.state in self.stateArray:\n                    return self.request(self.stateArray[0])\n                else:\n                    cur_index = self.stateArray.index(self.state)\n                    new_index = (cur_index + 1) % len(self.stateArray)\n                    return self.request(self.stateArray[new_index], args)\n            else:\n                assert self.notify.debug(\n                                    \"stateArray empty. Can't switch to next.\")\n        finally:\n            self.fsmLock.release()\n\n    def requestPrev(self, *args):\n        \"\"\"Request the 'previous' state in the predefined state array.\"\"\"\n        self.fsmLock.acquire()\n        try:\n            if self.stateArray:\n                if not self.state in self.stateArray:\n                    return self.request(self.stateArray[0])\n                else:\n                    cur_index = self.stateArray.index(self.state)\n                    new_index = (cur_index - 1) % len(self.stateArray)\n                    return self.request(self.stateArray[new_index], args)\n            else:\n                assert self.notify.debug(\n                                    \"stateArray empty. Can't switch to next.\")\n        finally:\n            self.fsmLock.release()\n\n    def __setState(self, newState, *args):\n        # Internal function to change unconditionally to the indicated state.\n\n        transition = Transition((newState,) + args)\n\n        # See if we can transition immediately by polling the coroutine.\n        coro = self.__transition(newState, *args)\n        try:\n            coro.send(None)\n        except StopIteration:\n            # We managed to apply this straight away.\n            return transition\n\n        # Continue the state transition in a task.\n        task = PythonTask(coro)\n        mgr = AsyncTaskManager.get_global_ptr()\n        mgr.add(task)\n        transition._future = task\n        return transition\n\n    async def __transition(self, newState, *args):\n        assert self.state\n        assert self.notify.debug(\"%s to state %s.\" % (self._name, newState))\n\n        self.oldState = self.state\n        self.newState = newState\n        self.state = None\n\n        try:\n            if not self.__callFromToFunc(self.oldState, self.newState, *args):\n                result = self.__callExitFunc(self.oldState)\n                if isinstance(result, types.CoroutineType):\n                    await result\n\n                result = self.__callEnterFunc(self.newState, *args)\n                if isinstance(result, types.CoroutineType):\n                    await result\n        except:\n            # If we got an exception during the enter or exit methods,\n            # go directly to state \"InternalError\" and raise up the\n            # exception.  This might leave things a little unclean\n            # since we've partially transitioned, but what can you do?\n\n            self.state = 'InternalError'\n            del self.oldState\n            del self.newState\n            raise\n\n        if self._broadcastStateChanges:\n            messenger.send(self.getStateChangeEvent())\n\n        self.state = newState\n        del self.oldState\n        del self.newState\n\n        if self.__requestQueue:\n            request, fut = self.__requestQueue.pop(0)\n            assert self.notify.debug(\"%s continued queued request.\" % (self._name))\n            await request()\n            fut.set_result(None)\n\n    def __callEnterFunc(self, name, *args):\n        # Calls the appropriate enter function when transitioning into\n        # a new state, if it exists.\n        assert self.state is None and self.newState == name\n\n        func = getattr(self, \"enter\" + name, None)\n        if not func:\n            # If there's no matching enterFoo() function, call\n            # defaultEnter() instead.\n            func = self.defaultEnter\n        return func(*args)\n\n    def __callFromToFunc(self, oldState, newState, *args):\n        # Calls the appropriate fromTo function when transitioning into\n        # a new state, if it exists.\n        assert self.state is None and self.oldState == oldState and self.newState == newState\n\n        func = getattr(self, \"from%sTo%s\" % (oldState,newState), None)\n        if func:\n            func(*args)\n            return True\n        return False\n\n    def __callExitFunc(self, name):\n        # Calls the appropriate exit function when leaving a\n        # state, if it exists.\n        assert self.state is None and self.oldState == name\n\n        func = getattr(self, \"exit\" + name, None)\n        if not func:\n            # If there's no matching exitFoo() function, call\n            # defaultExit() instead.\n            func = self.defaultExit\n        return func()\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        \"\"\"\n        Print out something useful about the fsm\n        \"\"\"\n        self.fsmLock.acquire()\n        try:\n            className = self.__class__.__name__\n            if self.state:\n                return f'{className} FSM:{self._name} in state \"{self.state}\"'\n            else:\n                return f'{className} FSM:{self._name} in transition from \\'{self.oldState}\\' to \\'{self.newState}\\''\n        finally:\n            self.fsmLock.release()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/fsm/FSM.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/4baea650_FSM.json",
    "doc_id": "doc_144"
  }
}