{
  "content": "\"\"\"\nDefines AnimMgrBase\n\"\"\"\n\nimport os\nimport math\n\nfrom direct.interval.ActorInterval import ActorInterval\nfrom direct.interval.LerpInterval import LerpFunc, LerpPosHprInterval\nfrom direct.interval.MetaInterval import Parallel, Sequence\nfrom panda3d.core import VBase3\nfrom . import ObjectGlobals as OG\nfrom . import AnimGlobals as AG\n\n\nclass AnimMgrBase:\n    \"\"\" AnimMgr will create, manage, update animations in the scene \"\"\"\n\n    def __init__(self, editor):\n        self.editor = editor\n        self.graphEditorCounter = 0\n\n        self.keyFramesInfo = {}\n        self.curveAnimation = {}\n\n        #normal properties\n        self.lerpFuncs = {\n            'H': self.lerpFuncH,\n            'P': self.lerpFuncP,\n            'R': self.lerpFuncR,\n            'SX': self.lerpFuncSX,\n            'SY': self.lerpFuncSY,\n            'SZ': self.lerpFuncSZ,\n            'CR': self.lerpFuncCR,\n            'CG': self.lerpFuncCG,\n            'CB': self.lerpFuncCB,\n            'CA': self.lerpFuncCA\n        }\n\n        #Properties which has animation curves\n        self.curveLerpFuncs = {\n            'X': [self.lerpFuncX, self.lerpCurveFuncX],\n            'Y': [self.lerpFuncY, self.lerpCurveFuncY],\n            'Z': [self.lerpFuncZ, self.lerpCurveFuncZ]\n        }\n\n    def reset(self):\n        self.keyFramesInfo = {}\n        self.curveAnimation = {}\n\n    def generateKeyFrames(self):\n        #generate keyFrame list\n        self.keyFrames = []\n        for property in list(self.keyFramesInfo.keys()):\n            for frameInfo in self.keyFramesInfo[property]:\n                frame = frameInfo[AG.FRAME]\n                exist = False\n                for keyFrame in self.keyFrames:\n                    if frame == keyFrame:\n                        exist = True\n                        break\n                if not exist:\n                    self.keyFrames.append(frame)\n\n    def generateSlope(self, list):\n        #generate handler slope of every keyframe for animation curve\n        listLen = len(list)\n        if listLen == 2:\n            slope =[float(list[1][AG.FRAME]-list[0][AG.FRAME]),(float(list[1][AG.VALUE])-float(list[0][AG.VALUE]))]\n            list[0][AG.INSLOPE] = slope\n            list[1][AG.INSLOPE] = slope\n            list[0][AG.OUTSLOPE] = list[0][AG.INSLOPE]\n            list[1][AG.OUTSLOPE] = list[1][AG.INSLOPE]\n            return\n\n        if listLen >= 3:\n            list[0][AG.INSLOPE] = [float(list[1][AG.FRAME] - list[0][AG.FRAME]),(float(list[1][AG.VALUE]) - float(list[0][AG.VALUE]))]\n            list[0][AG.OUTSLOPE] = list[0][AG.INSLOPE]\n            for i in range(1, listLen-1):\n                list[i][AG.INSLOPE] = [float(list[i+1][AG.FRAME] - list[i-1][AG.FRAME]),(float(list[i+1][AG.VALUE]) - float(list[i-1][AG.VALUE]))]\n                list[i][AG.OUTSLOPE] = list[i][AG.INSLOPE]\n            list[listLen-1][AG.INSLOPE] = [float(list[listLen-1][AG.FRAME] - list[listLen-2][AG.FRAME]),(float(list[listLen-1][AG.VALUE]) - float(list[listLen-2][AG.VALUE]))]\n            list[listLen-1][AG.OUTSLOPE] = list[listLen-1][AG.INSLOPE]\n            return\n\n    def removeAnimInfo(self, uid):\n        for property in list(self.keyFramesInfo.keys()):\n            if property[AG.UID] == uid:\n                del self.keyFramesInfo[property]\n        self.generateKeyFrames()\n        if self.editor.mode == self.editor.ANIM_MODE:\n            self.editor.ui.animUI.OnPropKey()\n\n    def singleCurveAnimation(self, nodePath, curve, time):\n        rope = curve[OG.OBJ_NP]\n        self.points = rope.getPoints(time)\n        self.hprs = []\n        temp = render.attachNewNode(\"temp\")\n        temp.setHpr(0,0,0)\n        for i in range(len(self.points)-1):\n            temp.setPos(self.points[i])\n            temp.lookAt(self.points[i+1])\n            hpr = temp.getHpr()\n            ## self.hprs.append(hpr)\n            self.hprs.append(VBase3(hpr[0]+180,hpr[1],hpr[2]))\n        self.hprs.append(self.hprs[len(self.points)-2])\n\n        curveSequenceName = str(nodePath[OG.OBJ_UID])+' '+str(curve[OG.OBJ_UID])+' '+str(time)\n        self.curveSequence = Sequence(name = curveSequenceName)\n\n        for i in range(len(self.points)-1):\n            myLerp = LerpPosHprInterval(nodePath[OG.OBJ_NP], float(1)/float(24), self.points[i+1], self.hprs[i+1], self.points[i], self.hprs[i])\n            self.curveSequence.append(myLerp)\n\n        return self.curveSequence\n\n    def createParallel(self, startFrame, endFrame):\n        self.parallel = []\n        self.parallel = Parallel(name=\"Current Parallel\")\n\n        self.createCurveAnimation(self.parallel)\n        self.createActorAnimation(self.parallel, startFrame, endFrame)\n        self.createKeyFrameAnimation(self.parallel, startFrame, endFrame)\n        self.createCurveKeyFrameAnimation(self.parallel, startFrame, endFrame)\n\n        return self.parallel\n\n    def createCurveAnimation(self, parallel):\n        for key in self.curveAnimation:\n            curveInfo = self.curveAnimation[key]\n            nodePath = self.editor.objectMgr.findObjectById(curveInfo[AG.NODE])\n            curve = self.editor.objectMgr.findObjectById(curveInfo[AG.CURVE])\n            time = curveInfo[AG.TIME]\n            sequence = self.singleCurveAnimation(nodePath, curve, time)\n            parallel.append(sequence)\n\n    def createActorAnimation(self, parallel, startFrame, endFrame):\n        self.editor.objectMgr.findActors(render)\n        for actor in self.editor.objectMgr.Actor:\n            actorAnim = os.path.basename(actor[OG.OBJ_ANIM])\n            myInterval = ActorInterval(actor[OG.OBJ_NP], actorAnim, loop=1, duration = float(endFrame-startFrame+1)/float(24))\n            parallel.append(myInterval)\n\n    def createKeyFrameAnimation(self, parallel, startFrame, endFrame):\n        #generate key frame animation for normal property\n        self.editor.objectMgr.findNodes(render)\n        for node in self.editor.objectMgr.Nodes:\n            for property in list(self.keyFramesInfo.keys()):\n                if property[AG.UID] == node[OG.OBJ_UID] and property[AG.PROP_NAME] != 'X' and property[AG.PROP_NAME] != 'Y' and property[AG.PROP_NAME] != 'Z':\n                    mysequence = Sequence(name = node[OG.OBJ_UID])\n                    keyFramesInfo = self.keyFramesInfo[property]\n                    if len(keyFramesInfo) == 1:\n                        myLerp = LerpFunc(self.lerpFuncs[property[AG.PROP_NAME]],fromData=float(keyFramesInfo[0][AG.VALUE]),toData=float(keyFramesInfo[0][AG.VALUE]),duration = float(endFrame-startFrame)/float(24),blendType = 'noBlend',extraArgs = [node[OG.OBJ_NP]])\n                        mysequence.append(myLerp)\n                        parallel.append(mysequence)\n\n                    if len(keyFramesInfo) != 1:\n                        myLerp = LerpFunc(self.lerpFuncs[property[AG.PROP_NAME]],fromData=float(keyFramesInfo[0][AG.VALUE]),toData=float(keyFramesInfo[0][AG.VALUE]),duration = float(keyFramesInfo[0][AG.FRAME]-startFrame)/float(24),blendType = 'noBlend',extraArgs = [node[OG.OBJ_NP]])\n                        mysequence.append(myLerp)\n\n                        for key in range(0,len(keyFramesInfo)-1):\n                            myLerp = LerpFunc(self.lerpFuncs[property[AG.PROP_NAME]],fromData=float(keyFramesInfo[key][AG.VALUE]),toData=float(keyFramesInfo[key+1][AG.VALUE]),duration = float(keyFramesInfo[key+1][AG.FRAME]-keyFramesInfo[key][AG.FRAME])/float(24),blendType = 'noBlend',extraArgs = [node[OG.OBJ_NP]])\n                            mysequence.append(myLerp)\n\n                        myLerp = LerpFunc(self.lerpFuncs[property[AG.PROP_NAME]],fromData=float(keyFramesInfo[len(keyFramesInfo)-1][AG.VALUE]),toData=float(keyFramesInfo[len(keyFramesInfo)-1][AG.VALUE]),duration = float(endFrame-keyFramesInfo[len(keyFramesInfo)-1][AG.FRAME])/float(24),blendType = 'noBlend',extraArgs = [node[OG.OBJ_NP]])\n                        mysequence.append(myLerp)\n                        parallel.append(mysequence)\n\n    def createCurveKeyFrameAnimation(self, parallel, startFrame, endFrame):\n        #generate key frame animation for the property which is controled by animation curve\n        self.editor.objectMgr.findNodes(render)\n        for node in self.editor.objectMgr.Nodes:\n            for property in list(self.keyFramesInfo.keys()):\n                if property[AG.UID] == node[OG.OBJ_UID]:\n                    if property[AG.PROP_NAME] == 'X' or property[AG.PROP_NAME] == 'Y' or property[AG.PROP_NAME] == 'Z':\n                        mysequence = Sequence(name = node[OG.OBJ_UID])\n                        keyFramesInfo = self.keyFramesInfo[property]\n                        if len(keyFramesInfo) == 1:\n                            myLerp = LerpFunc(self.curveLerpFuncs[property[AG.PROP_NAME]][0],fromData=float(keyFramesInfo[0][AG.VALUE]),toData=float(keyFramesInfo[0][AG.VALUE]),duration = float(endFrame-startFrame)/float(24),blendType = 'noBlend',extraArgs = [node[OG.OBJ_NP]])\n                            mysequence.append(myLerp)\n                            parallel.append(mysequence)\n\n                        if len(keyFramesInfo) == 2:\n                            myLerp = LerpFunc(self.curveLerpFuncs[property[AG.PROP_NAME]][0],fromData=float(keyFramesInfo[0][AG.VALUE]),toData=float(keyFramesInfo[0][AG.VALUE]),duration = float(keyFramesInfo[0][AG.FRAME]-startFrame)/float(24),blendType = 'noBlend',extraArgs = [node[OG.OBJ_NP]])\n                            mysequence.append(myLerp)\n\n                            for key in range(0,len(keyFramesInfo)-1):\n                                self.keyFrameInfoForSingleLerp = keyFramesInfo\n                                self.keyInfoForSingleLerp = key\n                                myLerp = LerpFunc(self.curveLerpFuncs[property[AG.PROP_NAME]][0],fromData=float(keyFramesInfo[key][AG.VALUE]),toData=float(keyFramesInfo[key+1][AG.VALUE]),duration = float(keyFramesInfo[key+1][AG.FRAME]-keyFramesInfo[key][AG.FRAME])/float(24),blendType = 'noBlend',extraArgs = [node[OG.OBJ_NP]])\n                                mysequence.append(myLerp)\n\n                            myLerp = LerpFunc(self.curveLerpFuncs[property[AG.PROP_NAME]][0],fromData=float(keyFramesInfo[len(keyFramesInfo)-1][AG.VALUE]),toData=float(keyFramesInfo[len(keyFramesInfo)-1][AG.VALUE]),duration = float(endFrame-keyFramesInfo[len(keyFramesInfo)-1][AG.FRAME])/float(24),blendType = 'noBlend',extraArgs = [node[OG.OBJ_NP]])\n                            mysequence.append(myLerp)\n                            parallel.append(mysequence)\n\n                        if len(keyFramesInfo) > 2:\n                            myLerp = LerpFunc(self.curveLerpFuncs[property[AG.PROP_NAME]][0],fromData=float(keyFramesInfo[0][AG.VALUE]),toData=float(keyFramesInfo[0][1]),duration = float(keyFramesInfo[0][AG.FRAME]-startFrame)/float(24),blendType = 'noBlend',extraArgs = [node[OG.OBJ_NP]])\n                            mysequence.append(myLerp)\n\n                            for key in range(0,len(keyFramesInfo)-1):\n                                myLerp = LerpFunc(self.curveLerpFuncs[property[AG.PROP_NAME]][1],fromData=float(keyFramesInfo[key][AG.FRAME]),toData=float(keyFramesInfo[key+1][AG.FRAME]),duration = float(keyFramesInfo[key+1][AG.FRAME]-keyFramesInfo[key][AG.FRAME])/float(24),blendType = 'noBlend',extraArgs = [[node[OG.OBJ_NP], keyFramesInfo, key]])\n                                mysequence.append(myLerp)\n\n                            myLerp = LerpFunc(self.curveLerpFuncs[property[AG.PROP_NAME]][0],fromData=float(keyFramesInfo[len(keyFramesInfo)-1][AG.VALUE]),toData=float(keyFramesInfo[len(keyFramesInfo)-1][AG.VALUE]),duration = float(endFrame-keyFramesInfo[len(keyFramesInfo)-1][AG.FRAME])/float(24),blendType = 'noBlend',extraArgs = [node[OG.OBJ_NP]])\n                            mysequence.append(myLerp)\n                            parallel.append(mysequence)\n\n    def getPos(self, x, list, i):\n        #get the value from animation curve\n        x1 = float(list[i][AG.FRAME])\n        y1 = float(list[i][AG.VALUE])\n\n        x4 = float(list[i+1][AG.FRAME])\n        y4 = float(list[i+1][AG.VALUE])\n\n        t1x = list[i][AG.OUTSLOPE][0]\n        t1y = list[i][AG.OUTSLOPE][1]\n\n        t2x = list[i+1][AG.INSLOPE][0]\n        t2y = list[i+1][AG.INSLOPE][1]\n\n        x2 = x1 + (x4 - x1) / float(3)\n        scale1 = (x2 - x1) / t1x\n        y2 = y1 + t1y * scale1\n\n        x3 = x4 - (x4 - x1) / float(3)\n        scale2 = (x4 - x3) / t2x\n        y3 = y4 - t2y * scale2\n\n        ax = - float(1) * x1 + float(3) * x2 - float(3) * x3 + float(1) * x4\n        bx =   float(3) * x1 - float(6) * x2 + float(3) * x3 + float(0) * x4\n        cx = - float(3) * x1 + float(3) * x2 + float(0) * x3 + float(0) * x4\n        dx =   float(1) * x1 + float(0) * x2 - float(0) * x3 + float(0) * x4\n\n        ay = - float(1) * y1 + float(3) * y2 - float(3) * y3 + float(1) * y4\n        by =   float(3) * y1 - float(6) * y2 + float(3) * y3 + float(0) * y4\n        cy = - float(3) * y1 + float(3) * y2 + float(0) * y3 + float(0) * y4\n        dy =   float(1) * y1 + float(0) * y2 - float(0) * y3 + float(0) * y4\n\n        if ax == 0 and bx == 0 and cx == 0:\n            return 0\n\n        if ax == 0 and bx == 0 and cx != 0:\n            a = cx\n            b = dx-x\n            t = -b/a\n            y = ay * t*t*t + by * t*t + cy * t + dy\n            return y\n\n        if ax == 0 and bx!= 0:\n            a=bx\n            b=cx\n            c=dx-x\n            t=(-b+math.sqrt(b**2-4.0*a*c))/2*a\n            if t>=0 and t<=1:\n                y = ay * t*t*t + by * t*t + cy * t + dy\n                return y\n            else:\n                t=(-b-math.sqrt(b**2-4.0*a*c))/2*a\n                y = ay * t*t*t + by * t*t + cy * t + dy\n                return y\n\n        if ax != 0:\n            a = ax\n            b = bx\n            c = cx\n            d = dx - float(x)\n            t = self.calculateT(a, b, c, d, x)\n            y = ay * t*t*t + by * t*t + cy * t + dy\n            return y\n\n    def calculateT(self, a, b, c, d, x):\n        #Newton EQUATION\n        t = float(1)\n        t2 = t\n        t -= (a*t*t*t+b*t*t+c*t+d)/(float(3)*a*t*t+float(2)*b*t+c)\n        if abs(t-t2) <= 0.000001:\n            return t\n        else:\n            while abs(t - t2) > 0.000001:\n                t2 = t\n                t -= (a*t*t*t+b*t*t+c*t+d)/(float(3)*a*t*t+float(2)*b*t+c)\n            return t\n\n    def lerpFuncX(self,pos,np):\n        np.setX(pos)\n\n    def lerpFuncY(self,pos,np):\n        np.setY(pos)\n\n    def lerpFuncZ(self,pos,np):\n        np.setZ(pos)\n\n    def lerpCurveFuncX(self,t,extraArgs):\n        np = extraArgs[0]\n        pos = self.getPos(t, extraArgs[1], extraArgs[2])\n        np.setX(pos)\n\n    def lerpCurveFuncY(self,t,extraArgs):\n        np = extraArgs[0]\n        pos = self.getPos(t, extraArgs[1], extraArgs[2])\n        np.setY(pos)\n\n    def lerpCurveFuncZ(self,t,extraArgs):\n        np = extraArgs[0]\n        pos = self.getPos(t, extraArgs[1], extraArgs[2])\n        np.setZ(pos)\n\n    def lerpFuncH(self,angle,np):\n        np.setH(angle)\n\n    def lerpFuncP(self,angle,np):\n        np.setP(angle)\n\n    def lerpFuncR(self,angle,np):\n        np.setR(angle)\n\n    def lerpFuncSX(self,scale,np):\n        np.setSx(scale)\n\n    def lerpFuncSY(self,scale,np):\n        np.setSy(scale)\n\n    def lerpFuncSZ(self,scale,np):\n        np.setSz(scale)\n\n    def lerpFuncCR(self,R,np):\n        obj = self.editor.objectMgr.findObjectByNodePath(np)\n        r = obj[OG.OBJ_RGBA][0]\n        g = obj[OG.OBJ_RGBA][1]\n        b = obj[OG.OBJ_RGBA][2]\n        a = obj[OG.OBJ_RGBA][3]\n        self.colorUpdate(R,g,b,a,np)\n\n    def lerpFuncCG(self,G,np):\n        obj = self.editor.objectMgr.findObjectByNodePath(np)\n        r = obj[OG.OBJ_RGBA][0]\n        g = obj[OG.OBJ_RGBA][1]\n        b = obj[OG.OBJ_RGBA][2]\n        a = obj[OG.OBJ_RGBA][3]\n        self.colorUpdate(r,G,b,a,np)\n\n    def lerpFuncCB(self,B,np):\n        obj = self.editor.objectMgr.findObjectByNodePath(np)\n        r = obj[OG.OBJ_RGBA][0]\n        g = obj[OG.OBJ_RGBA][1]\n        b = obj[OG.OBJ_RGBA][2]\n        a = obj[OG.OBJ_RGBA][3]\n        self.colorUpdate(r,g,B,a,np)\n\n    def lerpFuncCA(self,A,np):\n        obj = self.editor.objectMgr.findObjectByNodePath(np)\n        r = obj[OG.OBJ_RGBA][0]\n        g = obj[OG.OBJ_RGBA][1]\n        b = obj[OG.OBJ_RGBA][2]\n        a = obj[OG.OBJ_RGBA][3]\n        self.colorUpdate(r,g,b,A,np)\n\n    def colorUpdate(self, r, g, b, a, np):\n        if base.direct.selected.last is None:\n            self.editor.objectMgr.updateObjectColor(r, g, b, a, np)\n        elif self.editor.objectMgr.findObjectByNodePath(np) == self.editor.objectMgr.findObjectByNodePath(base.direct.selected.last):\n            self.editor.ui.objectPropertyUI.propCR.setValue(r)\n            self.editor.ui.objectPropertyUI.propCG.setValue(g)\n            self.editor.ui.objectPropertyUI.propCB.setValue(b)\n            self.editor.ui.objectPropertyUI.propCA.setValue(a)\n            self.editor.objectMgr.updateObjectColor(r, g, b, a, np)\n        else:\n            self.editor.objectMgr.updateObjectColor(r, g, b, a, np)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/leveleditor/AnimMgrBase.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/c3433415_AnimMgrBase.json",
    "doc_id": "doc_26"
  }
}