{
  "content": "\"\"\" Mopath Recorder Panel Module \"\"\"\n\n__all__ = ['MopathRecorder']\n\n# Import Tkinter, Pmw, and the dial code from this directory tree.\nfrom panda3d.core import (\n    Camera,\n    ClockObject,\n    CurveFitter,\n    Filename,\n    NodePath,\n    ParametricCurveCollection,\n    PerspectiveLens,\n    Point3,\n    Quat,\n    VBase3,\n    VBase4,\n    Vec3,\n    Vec4,\n    getModelPath,\n)\nfrom direct.showbase import ShowBaseGlobal\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.tkwidgets.AppShell import AppShell\nfrom direct.directtools.DirectUtil import CLAMP, useDirectRenderStyle\nfrom direct.directtools.DirectGeometry import LineNodePath, qSlerp\nfrom direct.directtools.DirectSelection import SelectionRay\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.tkwidgets import Dial\nfrom direct.tkwidgets import Floater\nfrom direct.tkwidgets import Slider\nfrom direct.tkwidgets import EntryScale\nfrom direct.tkwidgets import VectorWidgets\nfrom tkinter.filedialog import askopenfilename, asksaveasfilename\nimport Pmw\nimport math\nimport os\nimport tkinter as tk\n\n\nPRF_UTILITIES = [\n    'lambda: base.direct.camera.lookAt(render)',\n    'lambda: base.direct.camera.setZ(render, 0.0)',\n    'lambda s = self: s.playbackMarker.lookAt(render)',\n    'lambda s = self: s.playbackMarker.setZ(render, 0.0)',\n    'lambda s = self: s.followTerrain(10.0)']\n\n\nclass MopathRecorder(AppShell, DirectObject):\n    # Override class variables here\n    appname = 'Mopath Recorder Panel'\n    frameWidth      = 450\n    frameHeight     = 550\n    usecommandarea = 0\n    usestatusarea  = 0\n    count = 0\n\n    def __init__(self, parent = None, **kw):\n        INITOPT = Pmw.INITOPT\n        name = 'recorder-%d' % MopathRecorder.count\n        MopathRecorder.count += 1\n        optiondefs = (\n            ('title',       self.appname,         None),\n            ('nodePath',    None,                 None),\n            ('name',        name,                 None)\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Call superclass initialization function\n        AppShell.__init__(self)\n\n        self.initialiseoptions(MopathRecorder)\n\n        self.selectNodePathNamed('camera')\n\n    def appInit(self):\n        self.name = self['name']\n        # Dictionary of widgets\n        self.widgetDict = {}\n        self.variableDict = {}\n        # Initialize state\n        # The active node path\n        self.nodePath = self['nodePath']\n        self.playbackNodePath = self.nodePath\n        # The active node path's parent\n        self.nodePathParent = render\n        # Top level node path\n        self.recorderNodePath = base.direct.group.attachNewNode(self.name)\n        # Temp CS for use in refinement/path extension\n        self.tempCS = self.recorderNodePath.attachNewNode(\n            'mopathRecorderTempCS')\n        # Marker for use in playback\n        self.playbackMarker = base.loader.loadModel('models/misc/smiley')\n        self.playbackMarker.setName('Playback Marker')\n        self.playbackMarker.reparentTo(self.recorderNodePath)\n        self.playbackMarkerIds = self.getChildIds(\n            self.playbackMarker.getChild(0))\n        self.playbackMarker.hide()\n        # Tangent marker\n        self.tangentGroup = self.playbackMarker.attachNewNode('Tangent Group')\n        self.tangentGroup.hide()\n        self.tangentMarker = base.loader.loadModel('models/misc/sphere')\n        self.tangentMarker.reparentTo(self.tangentGroup)\n        self.tangentMarker.setScale(0.5)\n        self.tangentMarker.setColor(1, 0, 1, 1)\n        self.tangentMarker.setName('Tangent Marker')\n        self.tangentMarkerIds = self.getChildIds(\n            self.tangentMarker.getChild(0))\n        self.tangentLines = LineNodePath(self.tangentGroup)\n        self.tangentLines.setColor(VBase4(1, 0, 1, 1))\n        self.tangentLines.setThickness(1)\n        self.tangentLines.moveTo(0, 0, 0)\n        self.tangentLines.drawTo(0, 0, 0)\n        self.tangentLines.create()\n        # Active node path dictionary\n        self.nodePathDict = {}\n        self.nodePathDict['marker'] = self.playbackMarker\n        self.nodePathDict['camera'] = base.direct.camera\n        self.nodePathDict['widget'] = base.direct.widget\n        self.nodePathDict['mopathRecorderTempCS'] = self.tempCS\n        self.nodePathNames = ['marker', 'camera', 'selected']\n        # ID of selected object\n        self.manipulandumId = None\n        self.trace = LineNodePath(self.recorderNodePath)\n        self.oldPlaybackNodePath = None\n        # Count of point sets recorded\n        self.pointSet = []\n        self.prePoints = []\n        self.postPoints = []\n        self.pointSetDict = {}\n        self.pointSetCount = 0\n        self.pointSetName = self.name + '-ps-' + repr(self.pointSetCount)\n        # User callback to call before recording point\n        self.samplingMode = 'Continuous'\n        self.preRecordFunc = None\n        # Hook to start/stop recording\n        self.startStopHook = 'f6'\n        self.keyframeHook = 'f10'\n        # Curve fitter object\n        self.lastPos = Point3(0)\n        self.curveFitter = CurveFitter()\n        # Curve variables\n        # Number of ticks per parametric unit\n        self.numTicks = 1\n        # Number of segments to represent each parametric unit\n        # This just affects the visual appearance of the curve\n        self.numSegs = 40\n        # The nurbs curves\n        self.curveCollection = None\n        # Curve drawers\n        self.nurbsCurveDrawer = NurbsCurveDrawer()\n        self.nurbsCurveDrawer.setCurves(ParametricCurveCollection())\n        self.nurbsCurveDrawer.setNumSegs(self.numSegs)\n        self.nurbsCurveDrawer.setShowHull(0)\n        self.nurbsCurveDrawer.setShowCvs(0)\n        self.nurbsCurveDrawer.setNumTicks(0)\n        self.nurbsCurveDrawer.setTickScale(5.0)\n        self.curveNodePath = self.recorderNodePath.attachNewNode(\n            self.nurbsCurveDrawer.getGeomNode())\n        useDirectRenderStyle(self.curveNodePath)\n        # Playback variables\n        self.maxT = 0.0\n        self.playbackTime = 0.0\n        self.loopPlayback = 1\n        self.playbackSF = 1.0\n        # Sample variables\n        self.desampleFrequency = 1\n        self.numSamples = 100\n        self.recordStart = 0.0\n        self.deltaTime = 0.0\n        self.controlStart = 0.0\n        self.controlStop = 0.0\n        self.recordStop = 0.0\n        self.cropFrom = 0.0\n        self.cropTo = 0.0\n        self.fAdjustingValues = 0\n        # For terrain following\n        self.iRayCS = self.recorderNodePath.attachNewNode(\n            'mopathRecorderIRayCS')\n        self.iRay = SelectionRay(self.iRayCS)\n        # Set up event hooks\n        self.actionEvents = [\n            ('DIRECT_undo', self.undoHook),\n            ('DIRECT_pushUndo', self.pushUndoHook),\n            ('DIRECT_undoListEmpty', self.undoListEmptyHook),\n            ('DIRECT_redo', self.redoHook),\n            ('DIRECT_pushRedo', self.pushRedoHook),\n            ('DIRECT_redoListEmpty', self.redoListEmptyHook),\n            ('DIRECT_selectedNodePath', self.selectedNodePathHook),\n            ('DIRECT_deselectedNodePath', self.deselectedNodePathHook),\n            ('DIRECT_manipulateObjectStart', self.manipulateObjectStartHook),\n            ('DIRECT_manipulateObjectCleanup',\n             self.manipulateObjectCleanupHook),\n        ]\n        for event, method in self.actionEvents:\n            self.accept(event, method)\n\n    def createInterface(self):\n        interior = self.interior()\n        # FILE MENU\n        # Get a handle on the file menu so commands can be inserted\n        # before quit item\n        fileMenu = self.menuBar.component('File-menu')\n        fileMenu.insert_command(\n            fileMenu.index('Quit'),\n            label = 'Load Curve',\n            command = self.loadCurveFromFile)\n        fileMenu.insert_command(\n            fileMenu.index('Quit'),\n            label = 'Save Curve',\n            command = self.saveCurveToFile)\n\n        # Add mopath recorder commands to menubar\n        self.menuBar.addmenu('Recorder', 'Mopath Recorder Panel Operations')\n        self.menuBar.addmenuitem(\n            'Recorder', 'command',\n            'Save current curve as a new point set',\n            label = 'Save Point Set',\n            command = self.extractPointSetFromCurveCollection)\n        self.menuBar.addmenuitem(\n            'Recorder', 'command',\n            'Toggle widget visability',\n            label = 'Toggle Widget Vis',\n            command = base.direct.toggleWidgetVis)\n        self.menuBar.addmenuitem(\n            'Recorder', 'command',\n            'Toggle widget manipulation mode',\n            label = 'Toggle Widget Mode',\n            command = base.direct.manipulationControl.toggleObjectHandlesMode)\n\n        self.createComboBox(self.menuFrame, 'Mopath', 'History',\n                            'Select input points to fit curve to', '',\n                            self.selectPointSetNamed, expand = 1)\n\n        self.undoButton = tk.Button(self.menuFrame, text = 'Undo',\n                                    command = base.direct.undo)\n        if base.direct.undoList:\n            self.undoButton['state'] = 'normal'\n        else:\n            self.undoButton['state'] = 'disabled'\n        self.undoButton.pack(side = tk.LEFT, expand = 0)\n        self.bind(self.undoButton, 'Undo last operation')\n\n        self.redoButton = tk.Button(self.menuFrame, text = 'Redo',\n                                    command = base.direct.redo)\n        if base.direct.redoList:\n            self.redoButton['state'] = 'normal'\n        else:\n            self.redoButton['state'] = 'disabled'\n        self.redoButton.pack(side = tk.LEFT, expand = 0)\n        self.bind(self.redoButton, 'Redo last operation')\n\n        # Record button\n        mainFrame = tk.Frame(interior, relief = tk.SUNKEN, borderwidth = 2)\n        frame = tk.Frame(mainFrame)\n        # Active node path\n        # Button to select active node path\n        widget = self.createButton(frame, 'Recording', 'Node Path:',\n                                   'Select Active Mopath Node Path',\n                                   lambda s = self: base.direct.select(s.nodePath),\n                                   side = tk.LEFT, expand = 0)\n        widget['relief'] = tk.FLAT\n        self.nodePathMenu = Pmw.ComboBox(\n            frame, entry_width = 20,\n            selectioncommand = self.selectNodePathNamed,\n            scrolledlist_items = self.nodePathNames)\n        self.nodePathMenu.selectitem('camera')\n        self.nodePathMenuEntry = (\n            self.nodePathMenu.component('entryfield_entry'))\n        self.nodePathMenuBG = (\n            self.nodePathMenuEntry.configure('background')[3])\n        self.nodePathMenu.pack(side = tk.LEFT, fill = tk.X, expand = 1)\n        self.bind(self.nodePathMenu,\n                  'Select active node path used for recording and playback')\n        # Recording type\n        self.recordingType = tk.StringVar()\n        self.recordingType.set('New Curve')\n        widget = self.createRadiobutton(\n            frame, 'left',\n            'Recording', 'New Curve',\n            ('Next record session records a new path'),\n            self.recordingType, 'New Curve', expand = 0)\n        widget = self.createRadiobutton(\n            frame, 'left',\n            'Recording', 'Refine',\n            ('Next record session refines existing path'),\n            self.recordingType, 'Refine', expand = 0)\n        widget = self.createRadiobutton(\n            frame, 'left',\n            'Recording', 'Extend',\n            ('Next record session extends existing path'),\n            self.recordingType, 'Extend', expand = 0)\n        frame.pack(fill = tk.X, expand = 1)\n\n        frame = tk.Frame(mainFrame)\n        widget = self.createCheckbutton(\n            frame, 'Recording', 'Record',\n            'On: path is being recorded', self.toggleRecord, 0,\n            side = tk.LEFT, fill = tk.BOTH, expand = 1)\n        widget.configure(foreground = 'Red', relief = tk.RAISED, borderwidth = 2,\n                         anchor = tk.CENTER, width = 16)\n        widget = self.createButton(frame, 'Recording', 'Add Keyframe',\n                                   'Add Keyframe To Current Path',\n                                   self.addKeyframe,\n                                   side = tk.LEFT, expand = 1)\n        frame.pack(fill = tk.X, expand = 1)\n\n        mainFrame.pack(expand = 1, fill = tk.X, pady = 3)\n\n        # Playback controls\n        playbackFrame = tk.Frame(interior, relief = tk.SUNKEN,\n                                 borderwidth = 2)\n        tk.Label(playbackFrame, text = 'PLAYBACK CONTROLS',\n                 font=('MSSansSerif', 12, 'bold')).pack(fill = tk.X)\n        # Main playback control slider\n        widget = self.createEntryScale(\n            playbackFrame, 'Playback', 'Time', 'Set current playback time',\n            resolution = 0.01, command = self.playbackGoTo, side = tk.TOP)\n        widget.component('hull')['relief'] = tk.RIDGE\n        # Kill playback task if drag slider\n        widget['preCallback'] = self.stopPlayback\n        # Jam duration entry into entry scale\n        self.createLabeledEntry(widget.labelFrame, 'Resample', 'Path Duration',\n                                'Set total curve duration',\n                                command = self.setPathDuration,\n                                side = tk.LEFT, expand = 0)\n        # Start stop buttons\n        frame = tk.Frame(playbackFrame)\n        widget = self.createButton(frame, 'Playback', '<<',\n                                   'Jump to start of playback',\n                                   self.jumpToStartOfPlayback,\n                                   side = tk.LEFT, expand = 1)\n        widget['font'] = (('MSSansSerif', 12, 'bold'))\n        widget = self.createCheckbutton(frame, 'Playback', 'Play',\n                                        'Start/Stop playback',\n                                        self.startStopPlayback, 0,\n                                        side = tk.LEFT, fill = tk.BOTH, expand = 1)\n        widget.configure(anchor = 'center', justify = 'center',\n                         relief = tk.RAISED, font = ('MSSansSerif', 12, 'bold'))\n        widget = self.createButton(frame, 'Playback', '>>',\n                                   'Jump to end of playback',\n                                   self.jumpToEndOfPlayback,\n                                   side = tk.LEFT, expand = 1)\n        widget['font'] = (('MSSansSerif', 12, 'bold'))\n        self.createCheckbutton(frame, 'Playback', 'Loop',\n                               'On: loop playback',\n                               self.setLoopPlayback, self.loopPlayback,\n                               side = tk.LEFT, fill = tk.BOTH, expand = 0)\n        frame.pack(fill = tk.X, expand = 1)\n\n        # Speed control\n        frame = tk.Frame(playbackFrame)\n        widget = tk.Button(frame, text = 'PB Speed Vernier', relief = tk.FLAT,\n                           command = lambda s = self: s.setSpeedScale(1.0))\n        widget.pack(side = tk.LEFT, expand = 0)\n        self.speedScale = tk.Scale(frame, from_ = -1, to = 1,\n                                   resolution = 0.01, showvalue = 0,\n                                   width = 10, orient = 'horizontal',\n                                   command = self.setPlaybackSF)\n        self.speedScale.pack(side = tk.LEFT, fill = tk.X, expand = 1)\n        self.speedVar = tk.StringVar()\n        self.speedVar.set(\"0.00\")\n        self.speedEntry = tk.Entry(frame, textvariable = self.speedVar,\n                                width = 8)\n        self.speedEntry.bind(\n            '<Return>',\n            lambda e = None, s = self: s.setSpeedScale(\n            float(s.speedVar.get())))\n        self.speedEntry.pack(side = tk.LEFT, expand = 0)\n        frame.pack(fill = tk.X, expand = 1)\n\n        playbackFrame.pack(fill = tk.X, pady = 2)\n\n        # Create notebook pages\n        self.mainNotebook = Pmw.NoteBook(interior)\n        self.mainNotebook.pack(fill = tk.BOTH, expand = 1)\n        self.resamplePage = self.mainNotebook.add('Resample')\n        self.refinePage = self.mainNotebook.add('Refine')\n        self.extendPage = self.mainNotebook.add('Extend')\n        self.cropPage = self.mainNotebook.add('Crop')\n        self.drawPage = self.mainNotebook.add('Draw')\n        self.optionsPage = self.mainNotebook.add('Options')\n\n        ## RESAMPLE PAGE\n        label = tk.Label(self.resamplePage, text = 'RESAMPLE CURVE',\n                         font=('MSSansSerif', 12, 'bold'))\n        label.pack(fill = tk.X)\n\n        # Resample\n        resampleFrame = tk.Frame(\n            self.resamplePage, relief = tk.SUNKEN, borderwidth = 2)\n        label = tk.Label(resampleFrame, text = 'RESAMPLE CURVE',\n                         font=('MSSansSerif', 12, 'bold')).pack()\n        widget = self.createSlider(\n            resampleFrame, 'Resample', 'Num. Samples',\n            'Number of samples in resampled curve',\n            resolution = 1, min = 2, max = 1000, command = self.setNumSamples)\n        widget.component('hull')['relief'] = tk.RIDGE\n        widget['postCallback'] = self.sampleCurve\n\n        frame = tk.Frame(resampleFrame)\n        self.createButton(\n            frame, 'Resample', 'Make Even',\n            'Apply timewarp so resulting path has constant velocity',\n            self.makeEven, side = tk.LEFT, fill = tk.X, expand = 1)\n        self.createButton(\n            frame, 'Resample', 'Face Forward',\n            'Compute HPR so resulting hpr curve faces along xyz tangent',\n            self.faceForward, side = tk.LEFT, fill = tk.X, expand = 1)\n        frame.pack(fill = tk.X, expand = 0)\n        resampleFrame.pack(fill = tk.X, expand = 0, pady = 2)\n\n        # Desample\n        desampleFrame = tk.Frame(\n            self.resamplePage, relief = tk.SUNKEN, borderwidth = 2)\n        tk.Label(desampleFrame, text = 'DESAMPLE CURVE',\n              font=('MSSansSerif', 12, 'bold')).pack()\n        widget = self.createSlider(\n            desampleFrame, 'Resample', 'Points Between Samples',\n            'Specify number of points to skip between samples',\n            min = 1, max = 100, resolution = 1,\n            command = self.setDesampleFrequency)\n        widget.component('hull')['relief'] = tk.RIDGE\n        widget['postCallback'] = self.desampleCurve\n        desampleFrame.pack(fill = tk.X, expand = 0, pady = 2)\n\n        ## REFINE PAGE ##\n        refineFrame = tk.Frame(self.refinePage, relief = tk.SUNKEN,\n                               borderwidth = 2)\n        label = tk.Label(refineFrame, text = 'REFINE CURVE',\n                         font=('MSSansSerif', 12, 'bold'))\n        label.pack(fill = tk.X)\n\n        widget = self.createSlider(refineFrame,\n                                       'Refine Page', 'Refine From',\n                                       'Begin time of refine pass',\n                                       resolution = 0.01,\n                                       command = self.setRecordStart)\n        widget['preCallback'] = self.setRefineMode\n        widget['postCallback'] = lambda s = self: s.getPrePoints('Refine')\n        widget = self.createSlider(\n            refineFrame, 'Refine Page',\n            'Control Start',\n            'Time when full control of node path is given during refine pass',\n            resolution = 0.01,\n            command = self.setControlStart)\n        widget['preCallback'] = self.setRefineMode\n        widget = self.createSlider(\n            refineFrame, 'Refine Page',\n            'Control Stop',\n            'Time when node path begins transition back to original curve',\n            resolution = 0.01,\n            command = self.setControlStop)\n        widget['preCallback'] = self.setRefineMode\n        widget = self.createSlider(refineFrame, 'Refine Page', 'Refine To',\n                                       'Stop time of refine pass',\n                                       resolution = 0.01,\n                                       command = self.setRefineStop)\n        widget['preCallback'] = self.setRefineMode\n        widget['postCallback'] = self.getPostPoints\n        refineFrame.pack(fill = tk.X)\n\n        ## EXTEND PAGE ##\n        extendFrame = tk.Frame(self.extendPage, relief = tk.SUNKEN,\n                               borderwidth = 2)\n        label = tk.Label(extendFrame, text = 'EXTEND CURVE',\n                         font=('MSSansSerif', 12, 'bold'))\n        label.pack(fill = tk.X)\n\n        widget = self.createSlider(extendFrame,\n                                       'Extend Page', 'Extend From',\n                                       'Begin time of extend pass',\n                                       resolution = 0.01,\n                                       command = self.setRecordStart)\n        widget['preCallback'] = self.setExtendMode\n        widget['postCallback'] = lambda s = self: s.getPrePoints('Extend')\n        widget = self.createSlider(\n            extendFrame, 'Extend Page',\n            'Control Start',\n            'Time when full control of node path is given during extend pass',\n            resolution = 0.01,\n            command = self.setControlStart)\n        widget['preCallback'] = self.setExtendMode\n        extendFrame.pack(fill = tk.X)\n\n        ## CROP PAGE ##\n        cropFrame = tk.Frame(self.cropPage, relief = tk.SUNKEN,\n                             borderwidth = 2)\n        label = tk.Label(cropFrame, text = 'CROP CURVE',\n                         font=('MSSansSerif', 12, 'bold'))\n        label.pack(fill = tk.X)\n\n        widget = self.createSlider(\n            cropFrame,\n            'Crop Page', 'Crop From',\n            'Delete all curve points before this time',\n            resolution = 0.01,\n            command = self.setCropFrom)\n\n        widget = self.createSlider(\n            cropFrame,\n            'Crop Page', 'Crop To',\n            'Delete all curve points after this time',\n            resolution = 0.01,\n            command = self.setCropTo)\n\n        self.createButton(cropFrame, 'Crop Page', 'Crop Curve',\n                          'Crop curve to specified from to times',\n                          self.cropCurve, fill = tk.NONE)\n        cropFrame.pack(fill = tk.X)\n\n        ## DRAW PAGE ##\n        drawFrame = tk.Frame(self.drawPage, relief = tk.SUNKEN,\n                             borderwidth = 2)\n\n        self.sf = Pmw.ScrolledFrame(self.drawPage, horizflex = 'elastic')\n        self.sf.pack(fill = 'both', expand = 1)\n        sfFrame = self.sf.interior()\n\n        label = tk.Label(sfFrame, text = 'CURVE RENDERING STYLE',\n                         font=('MSSansSerif', 12, 'bold'))\n        label.pack(fill = tk.X)\n\n        frame = tk.Frame(sfFrame)\n        tk.Label(frame, text = 'SHOW:').pack(side = tk.LEFT, expand = 0)\n        widget = self.createCheckbutton(\n            frame, 'Style', 'Path',\n            'On: path is visible', self.setPathVis, 1,\n            side = tk.LEFT, fill = tk.X, expand = 1)\n        widget = self.createCheckbutton(\n            frame, 'Style', 'Knots',\n            'On: path knots are visible', self.setKnotVis, 1,\n            side = tk.LEFT, fill = tk.X, expand = 1)\n        widget = self.createCheckbutton(\n            frame, 'Style', 'CVs',\n            'On: path CVs are visible', self.setCvVis, 0,\n            side = tk.LEFT, fill = tk.X, expand = 1)\n        widget = self.createCheckbutton(\n            frame, 'Style', 'Hull',\n            'On: path hull is visible', self.setHullVis, 0,\n            side = tk.LEFT, fill = tk.X, expand = 1)\n        widget = self.createCheckbutton(\n            frame, 'Style', 'Trace',\n            'On: record is visible', self.setTraceVis, 0,\n            side = tk.LEFT, fill = tk.X, expand = 1)\n        widget = self.createCheckbutton(\n            frame, 'Style', 'Marker',\n            'On: playback marker is visible', self.setMarkerVis, 0,\n            side = tk.LEFT, fill = tk.X, expand = 1)\n        frame.pack(fill = tk.X, expand = 1)\n        # Sliders\n        widget = self.createSlider(\n            sfFrame, 'Style', 'Num Segs',\n            'Set number of segments used to approximate each parametric unit',\n            min = 1.0, max = 400, resolution = 1.0,\n            value = 40,\n            command = self.setNumSegs, side = tk.TOP)\n        widget.component('hull')['relief'] = tk.RIDGE\n        widget = self.createSlider(\n            sfFrame, 'Style', 'Num Ticks',\n            'Set number of tick marks drawn for each unit of time',\n            min = 0.0, max = 10.0, resolution = 1.0,\n            value = 0.0,\n            command = self.setNumTicks, side = tk.TOP)\n        widget.component('hull')['relief'] = tk.RIDGE\n        widget = self.createSlider(\n            sfFrame, 'Style', 'Tick Scale',\n            'Set visible size of time tick marks',\n            min = 0.01, max = 100.0, resolution = 0.01,\n            value = 5.0,\n            command = self.setTickScale, side = tk.TOP)\n        widget.component('hull')['relief'] = tk.RIDGE\n        self.createColorEntry(\n            sfFrame, 'Style', 'Path Color',\n            'Color of curve',\n            command = self.setPathColor,\n            value = [255.0, 255.0, 255.0, 255.0])\n        self.createColorEntry(\n            sfFrame, 'Style', 'Knot Color',\n            'Color of knots',\n            command = self.setKnotColor,\n            value = [0, 0, 255.0, 255.0])\n        self.createColorEntry(\n            sfFrame, 'Style', 'CV Color',\n            'Color of CVs',\n            command = self.setCvColor,\n            value = [255.0, 0, 0, 255.0])\n        self.createColorEntry(\n            sfFrame, 'Style', 'Tick Color',\n            'Color of Ticks',\n            command = self.setTickColor,\n            value = [255.0, 0, 0, 255.0])\n        self.createColorEntry(\n            sfFrame, 'Style', 'Hull Color',\n            'Color of Hull',\n            command = self.setHullColor,\n            value = [255.0, 128.0, 128.0, 255.0])\n\n        #drawFrame.pack(fill = tk.X)\n\n        ## OPTIONS PAGE ##\n        optionsFrame = tk.Frame(self.optionsPage, relief = tk.SUNKEN,\n                                borderwidth = 2)\n        label = tk.Label(optionsFrame, text = 'RECORDING OPTIONS',\n                         font=('MSSansSerif', 12, 'bold'))\n        label.pack(fill = tk.X)\n        # Hooks\n        frame = tk.Frame(optionsFrame)\n        widget = self.createLabeledEntry(\n            frame, 'Recording', 'Record Hook',\n            'Hook used to start/stop recording',\n            value = self.startStopHook,\n            command = self.setStartStopHook)[0]\n        label = self.getWidget('Recording', 'Record Hook-Label')\n        label.configure(width = 16, anchor = tk.W)\n        self.setStartStopHook()\n        widget = self.createLabeledEntry(\n            frame, 'Recording', 'Keyframe Hook',\n            'Hook used to add a new keyframe',\n            value = self.keyframeHook,\n            command = self.setKeyframeHook)[0]\n        label = self.getWidget('Recording', 'Keyframe Hook-Label')\n        label.configure(width = 16, anchor = tk.W)\n        self.setKeyframeHook()\n        frame.pack(expand = 1, fill = tk.X)\n        # PreRecordFunc\n        frame = tk.Frame(optionsFrame)\n        widget = self.createComboBox(\n            frame, 'Recording', 'Pre-Record Func',\n            'Function called before sampling each point',\n            PRF_UTILITIES, self.setPreRecordFunc,\n            history = 1, expand = 1)\n        widget.configure(label_width = 16, label_anchor = tk.W)\n        widget.configure(entryfield_entry_state = 'normal')\n        # Initialize preRecordFunc\n        self.preRecordFunc = eval(PRF_UTILITIES[0])\n        self.createCheckbutton(frame, 'Recording', 'PRF Active',\n                               'On: Pre Record Func enabled',\n                               None, 0,\n                               side = tk.LEFT, fill = tk.BOTH, expand = 0)\n        frame.pack(expand = 1, fill = tk.X)\n        # Pack record frame\n        optionsFrame.pack(fill = tk.X, pady = 2)\n\n        self.mainNotebook.setnaturalsize()\n\n    def pushUndo(self, fResetRedo = 1):\n        base.direct.pushUndo([self.nodePath])\n\n    def undoHook(self, nodePathList = []):\n        # Reflect new changes\n        pass\n\n    def pushUndoHook(self):\n        # Make sure button is reactivated\n        self.undoButton.configure(state = 'normal')\n\n    def undoListEmptyHook(self):\n        # Make sure button is deactivated\n        self.undoButton.configure(state = 'disabled')\n\n    def pushRedo(self):\n        base.direct.pushRedo([self.nodePath])\n\n    def redoHook(self, nodePathList = []):\n        # Reflect new changes\n        pass\n\n    def pushRedoHook(self):\n        # Make sure button is reactivated\n        self.redoButton.configure(state = 'normal')\n\n    def redoListEmptyHook(self):\n        # Make sure button is deactivated\n        self.redoButton.configure(state = 'disabled')\n\n    def selectedNodePathHook(self, nodePath):\n        \"\"\"\n        Hook called upon selection of a node path used to select playback\n        marker if subnode selected\n        \"\"\"\n        taskMgr.remove(self.name + '-curveEditTask')\n        print(nodePath.getKey())\n        if nodePath.id() in self.playbackMarkerIds:\n            base.direct.select(self.playbackMarker)\n        elif nodePath.id() in self.tangentMarkerIds:\n            base.direct.select(self.tangentMarker)\n        elif nodePath.id() == self.playbackMarker.id():\n            self.tangentGroup.show()\n            taskMgr.add(self.curveEditTask,\n                                     self.name + '-curveEditTask')\n        elif nodePath.id() == self.tangentMarker.id():\n            self.tangentGroup.show()\n            taskMgr.add(self.curveEditTask,\n                                     self.name + '-curveEditTask')\n        else:\n            self.tangentGroup.hide()\n\n    def getChildIds(self, nodePath):\n        ids = [nodePath.id()]\n        kids = nodePath.getChildren()\n        for kid in kids:\n            ids += self.getChildIds(kid)\n        return ids\n\n    def deselectedNodePathHook(self, nodePath):\n        \"\"\"\n        Hook called upon deselection of a node path used to select playback\n        marker if subnode selected\n        \"\"\"\n        if nodePath.id() == self.playbackMarker.id() or \\\n           nodePath.id() == self.tangentMarker.id():\n            self.tangentGroup.hide()\n\n    def curveEditTask(self, state):\n        if self.curveCollection is not None:\n            # Update curve position\n            if self.manipulandumId == self.playbackMarker.id():\n                # Show playback marker\n                self.playbackMarker.getChild(0).show()\n                pos = Point3(0)\n                hpr = Point3(0)\n                pos = self.playbackMarker.getPos(self.nodePathParent)\n                hpr = self.playbackMarker.getHpr(self.nodePathParent)\n                self.curveCollection.adjustXyz(\n                    self.playbackTime, VBase3(pos[0], pos[1], pos[2]))\n                self.curveCollection.adjustHpr(\n                    self.playbackTime, VBase3(hpr[0], hpr[1], hpr[2]))\n                # Note: this calls recompute on the curves\n                self.nurbsCurveDrawer.draw()\n            # Update tangent\n            if self.manipulandumId == self.tangentMarker.id():\n                # If manipulating marker, update tangent\n                # Hide playback marker\n                self.playbackMarker.getChild(0).hide()\n                # Where is tangent marker relative to playback marker\n                tan = self.tangentMarker.getPos()\n                # Transform this vector to curve space\n                tan2Curve = Vec3(\n                    self.playbackMarker.getMat(\n                    self.nodePathParent).xformVec(tan))\n                # Update nurbs curve\n                self.curveCollection.getXyzCurve().adjustTangent(\n                    self.playbackTime,\n                    tan2Curve[0], tan2Curve[1], tan2Curve[2])\n                # Note: this calls recompute on the curves\n                self.nurbsCurveDrawer.draw()\n            else:\n                # Show playback marker\n                self.playbackMarker.getChild(0).show()\n                # Update tangent marker line\n                tan = Point3(0)\n                self.curveCollection.getXyzCurve().getTangent(\n                    self.playbackTime, tan)\n                # Transform this point to playback marker space\n                tan.assign(\n                    self.nodePathParent.getMat(\n                    self.playbackMarker).xformVec(tan))\n                self.tangentMarker.setPos(tan)\n            # In either case update tangent line\n            self.tangentLines.setVertex(1, tan[0], tan[1], tan[2])\n        return Task.cont\n\n    def manipulateObjectStartHook(self):\n        self.manipulandumId = None\n        if base.direct.selected.last:\n            if base.direct.selected.last.id() == self.playbackMarker.id():\n                self.manipulandumId = self.playbackMarker.id()\n            elif base.direct.selected.last.id() == self.tangentMarker.id():\n                self.manipulandumId = self.tangentMarker.id()\n\n    def manipulateObjectCleanupHook(self, nodePathList = []):\n        # Clear flag\n        self.manipulandumId = None\n\n    def onDestroy(self, event):\n        # Remove hooks\n        for event, method in self.actionEvents:\n            self.ignore(event)\n        # remove start stop hook\n        self.ignore(self.startStopHook)\n        self.ignore(self.keyframeHook)\n        self.curveNodePath.reparentTo(self.recorderNodePath)\n        self.trace.reparentTo(self.recorderNodePath)\n        self.recorderNodePath.removeNode()\n        # Make sure markers are deselected\n        base.direct.deselect(self.playbackMarker)\n        base.direct.deselect(self.tangentMarker)\n        # Remove tasks\n        taskMgr.remove(self.name + '-recordTask')\n        taskMgr.remove(self.name + '-playbackTask')\n        taskMgr.remove(self.name + '-curveEditTask')\n\n    def createNewPointSet(self):\n        self.pointSetName = self.name + '-ps-' + repr(self.pointSetCount)\n        # Update dictionary and record pointer to new point set\n        self.pointSet = self.pointSetDict[self.pointSetName] = []\n        # Update combo box\n        comboBox = self.getWidget('Mopath', 'History')\n        scrolledList = comboBox.component('scrolledlist')\n        listbox = scrolledList.component('listbox')\n        names = list(listbox.get(0,'end'))\n        names.append(self.pointSetName)\n        scrolledList.setlist(names)\n        comboBox.selectitem(self.pointSetName)\n        # Update count\n        self.pointSetCount += 1\n\n    def extractPointSetFromCurveFitter(self):\n        # Get new point set based on newly created curve\n        self.createNewPointSet()\n        for i in range(self.curveFitter.getNumSamples()):\n            time = self.curveFitter.getSampleT(i)\n            pos = Point3(self.curveFitter.getSampleXyz(i))\n            hpr = Point3(self.curveFitter.getSampleHpr(i))\n            self.pointSet.append([time, pos, hpr])\n\n    def extractPointSetFromCurveCollection(self):\n        # Use curve to compute new point set\n        # Record maxT\n        self.maxT = self.curveCollection.getMaxT()\n        # Determine num samples\n        # Limit point set to 1000 points and samples per second to 30\n        samplesPerSegment = min(30.0, 1000.0/self.curveCollection.getMaxT())\n        self.setNumSamples(self.maxT * samplesPerSegment)\n        # Sample the curve but don't create a new curve collection\n        self.sampleCurve(fCompute = 0)\n        # Update widgets based on new data\n        self.updateWidgets()\n\n    def selectPointSetNamed(self, name):\n        self.pointSet = self.pointSetDict.get(name, None)\n        # Reload points into curve fitter\n        # Reset curve fitters\n        self.curveFitter.reset()\n        for time, pos, hpr in self.pointSet:\n            # Add it to the curve fitters\n            self.curveFitter.addXyzHpr(time, pos, hpr)\n        # Compute curve\n        self.computeCurves()\n\n    def setPathVis(self):\n        if self.getVariable('Style', 'Path').get():\n            self.curveNodePath.show()\n        else:\n            self.curveNodePath.hide()\n\n    def setKnotVis(self):\n        self.nurbsCurveDrawer.setShowKnots(\n            self.getVariable('Style', 'Knots').get())\n\n    def setCvVis(self):\n        self.nurbsCurveDrawer.setShowCvs(\n            self.getVariable('Style', 'CVs').get())\n\n    def setHullVis(self):\n        self.nurbsCurveDrawer.setShowHull(\n            self.getVariable('Style', 'Hull').get())\n\n    def setTraceVis(self):\n        if self.getVariable('Style', 'Trace').get():\n            self.trace.show()\n        else:\n            self.trace.hide()\n\n    def setMarkerVis(self):\n        if self.getVariable('Style', 'Marker').get():\n            self.playbackMarker.reparentTo(self.recorderNodePath)\n        else:\n            self.playbackMarker.reparentTo(ShowBaseGlobal.hidden)\n\n    def setNumSegs(self, value):\n        self.numSegs = int(value)\n        self.nurbsCurveDrawer.setNumSegs(self.numSegs)\n\n    def setNumTicks(self, value):\n        self.nurbsCurveDrawer.setNumTicks(float(value))\n\n    def setTickScale(self, value):\n        self.nurbsCurveDrawer.setTickScale(float(value))\n\n    def setPathColor(self, color):\n        self.nurbsCurveDrawer.setColor(\n            color[0]/255.0, color[1]/255.0, color[2]/255.0)\n        self.nurbsCurveDrawer.draw()\n\n    def setKnotColor(self, color):\n        self.nurbsCurveDrawer.setKnotColor(\n            color[0]/255.0, color[1]/255.0, color[2]/255.0)\n\n    def setCvColor(self, color):\n        self.nurbsCurveDrawer.setCvColor(\n            color[0]/255.0, color[1]/255.0, color[2]/255.0)\n\n    def setTickColor(self, color):\n        self.nurbsCurveDrawer.setTickColor(\n            color[0]/255.0, color[1]/255.0, color[2]/255.0)\n\n    def setHullColor(self, color):\n        self.nurbsCurveDrawer.setHullColor(\n            color[0]/255.0, color[1]/255.0, color[2]/255.0)\n\n    def setStartStopHook(self, event = None):\n        # Clear out old hook\n        self.ignore(self.startStopHook)\n        # Record new one\n        hook = self.getVariable('Recording', 'Record Hook').get()\n        self.startStopHook = hook\n        # Add new one\n        self.accept(self.startStopHook, self.toggleRecordVar)\n\n    def setKeyframeHook(self, event = None):\n        # Clear out old hook\n        self.ignore(self.keyframeHook)\n        # Record new one\n        hook = self.getVariable('Recording', 'Keyframe Hook').get()\n        self.keyframeHook = hook\n        # Add new one\n        self.accept(self.keyframeHook, self.addKeyframe)\n\n    def reset(self):\n        self.pointSet = []\n        self.hasPoints = 0\n        self.curveCollection = None\n        self.curveFitter.reset()\n        self.nurbsCurveDrawer.hide()\n\n    def setSamplingMode(self, mode):\n        self.samplingMode = mode\n\n    def disableKeyframeButton(self):\n        self.getWidget('Recording', 'Add Keyframe')['state'] = 'disabled'\n\n    def enableKeyframeButton(self):\n        self.getWidget('Recording', 'Add Keyframe')['state'] = 'normal'\n\n    def setRecordingType(self, type):\n        self.recordingType.set(type)\n\n    def setNewCurveMode(self):\n        self.setRecordingType('New Curve')\n\n    def setRefineMode(self):\n        self.setRecordingType('Refine')\n\n    def setExtendMode(self):\n        self.setRecordingType('Extend')\n\n    def toggleRecordVar(self):\n        # Get recording variable\n        v = self.getVariable('Recording', 'Record')\n        # Toggle it\n        v.set(1 - v.get())\n        # Call the command\n        self.toggleRecord()\n\n    def toggleRecord(self):\n        if self.getVariable('Recording', 'Record').get():\n            # Kill old tasks\n            taskMgr.remove(self.name + '-recordTask')\n            taskMgr.remove(self.name + '-curveEditTask')\n            # Remove old curve\n            self.nurbsCurveDrawer.hide()\n            # Reset curve fitters\n            self.curveFitter.reset()\n            # Update sampling mode button if necessary\n            if self.samplingMode == 'Continuous':\n                self.disableKeyframeButton()\n            # Create a new point set to hold raw data\n            self.createNewPointSet()\n            # Clear out old trace, get ready to draw new\n            self.initTrace()\n            # Keyframe mode?\n            if self.samplingMode == 'Keyframe':\n                # Record first point\n                self.lastPos.assign(Point3(\n                    self.nodePath.getPos(self.nodePathParent)))\n                # Init delta time\n                self.deltaTime = 0.0\n                # Record first point\n                self.recordPoint(self.recordStart)\n            # Everything else\n            else:\n                if self.recordingType.get() == 'Refine' or \\\n                   self.recordingType.get() == 'Extend':\n                    # Turn off looping playback\n                    self.loopPlayback = 0\n                    # Update widget to reflect new value\n                    self.getVariable('Playback', 'Loop').set(0)\n                    # Select tempCS as playback nodepath\n                    self.oldPlaybackNodePath = self.playbackNodePath\n                    self.setPlaybackNodePath(self.tempCS)\n                    # Parent record node path to temp\n                    self.nodePath.reparentTo(self.playbackNodePath)\n                    # Align with temp\n                    self.nodePath.setPosHpr(0, 0, 0, 0, 0, 0)\n                    # Set playback start to self.recordStart\n                    self.playbackGoTo(self.recordStart)\n                    # start flying nodePath along path\n                    self.startPlayback()\n                # Start new task\n                t = taskMgr.add(\n                    self.recordTask, self.name + '-recordTask')\n                t.startTime = ClockObject.getGlobalClock().getFrameTime()\n        else:\n            if self.samplingMode == 'Continuous':\n                # Kill old task\n                taskMgr.remove(self.name + '-recordTask')\n                if self.recordingType.get() == 'Refine' or \\\n                   self.recordingType.get() == 'Extend':\n                    # Reparent node path back to parent\n                    self.nodePath.wrtReparentTo(self.nodePathParent)\n                    # Restore playback Node Path\n                    self.setPlaybackNodePath(self.oldPlaybackNodePath)\n            else:\n                # Add last point\n                self.addKeyframe(0)\n            # Reset sampling mode\n            self.setSamplingMode('Continuous')\n            self.enableKeyframeButton()\n            # Clean up after refine or extend\n            if self.recordingType.get() == 'Refine' or \\\n               self.recordingType.get() == 'Extend':\n                # Merge prePoints, pointSet, postPoints\n                self.mergePoints()\n                # Clear out pre and post list\n                self.prePoints = []\n                self.postPoints = []\n                # Reset recording mode\n                self.setNewCurveMode()\n            # Compute curve\n            self.computeCurves()\n\n    def recordTask(self, state):\n        # Record raw data point\n        time = self.recordStart + (\n            ClockObject.getGlobalClock().getFrameTime() - state.startTime)\n        self.recordPoint(time)\n        return Task.cont\n\n    def addKeyframe(self, fToggleRecord = 1):\n        # Make sure we're in a recording mode!\n        if fToggleRecord and not self.getVariable('Recording', 'Record').get():\n            # Set sampling mode\n            self.setSamplingMode('Keyframe')\n            # This will automatically add the first point\n            self.toggleRecordVar()\n        else:\n            # Use distance as a time\n            pos = self.nodePath.getPos(self.nodePathParent)\n            deltaPos = Vec3(pos - self.lastPos).length()\n            if deltaPos != 0:\n                # If we've moved at all, use delta Pos as time\n                self.deltaTime = self.deltaTime + deltaPos\n            else:\n                # Otherwise add one second\n                self.deltaTime = self.deltaTime + 1.0\n            # Record point at new time\n            self.recordPoint(self.recordStart + self.deltaTime)\n            # Update last pos\n            self.lastPos.assign(pos)\n\n    def easeInOut(self, t):\n        x = t * t\n        return (3 * x) - (2 * t * x)\n\n    def setPreRecordFunc(self, func):\n        # Note: If func is one defined at command prompt, need to set\n        # __builtins__.func = func at command line\n        self.preRecordFunc = eval(func)\n        # Update widget to reflect new value\n        self.getVariable('Recording', 'PRF Active').set(1)\n\n    def recordPoint(self, time):\n        # Call user define callback before recording point\n        if self.getVariable('Recording', 'PRF Active').get() and \\\n           self.preRecordFunc is not None:\n            self.preRecordFunc()\n        # Get point\n        pos = self.nodePath.getPos(self.nodePathParent)\n        hpr = self.nodePath.getHpr(self.nodePathParent)\n        qNP = Quat()\n        qNP.setHpr(hpr)\n        # Blend between recordNodePath and self.nodePath\n        if self.recordingType.get() == 'Refine' or \\\n           self.recordingType.get() == 'Extend':\n            if time < self.controlStart and \\\n               self.controlStart - self.recordStart != 0.0:\n                rPos = self.playbackNodePath.getPos(self.nodePathParent)\n                rHpr = self.playbackNodePath.getHpr(self.nodePathParent)\n                qR = Quat()\n                qR.setHpr(rHpr)\n                t = self.easeInOut(((time - self.recordStart)/\n                                    (self.controlStart - self.recordStart)))\n                # Transition between the recorded node path and the driven one\n                pos = (rPos * (1 - t)) + (pos * t)\n                q = qSlerp(qR, qNP, t)\n                hpr.assign(q.getHpr())\n            elif self.recordingType.get() == 'Refine' and \\\n                 time > self.controlStop and \\\n                 self.recordStop - self.controlStop != 0.0:\n                rPos = self.playbackNodePath.getPos(self.nodePathParent)\n                rHpr = self.playbackNodePath.getHpr(self.nodePathParent)\n                qR = Quat()\n                qR.setHpr(rHpr)\n                t = self.easeInOut(((time - self.controlStop)/\n                                    (self.recordStop - self.controlStop)))\n                # Transition between the recorded node path and the driven one\n                pos = (pos * (1 - t)) + (rPos * t)\n                q = qSlerp(qNP, qR, t)\n                hpr.assign(q.getHpr())\n        # Add it to the point set\n        self.pointSet.append([time, pos, hpr])\n        # Add it to the curve fitters\n        self.curveFitter.addXyzHpr(time, pos, hpr)\n        # Update trace now if recording keyframes\n        if self.samplingMode == 'Keyframe':\n            self.trace.reset()\n            for t, p, h in self.pointSet:\n                self.trace.drawTo(p[0], p[1], p[2])\n            self.trace.create()\n\n    def computeCurves(self):\n        # Check to make sure curve fitters have points\n        if self.curveFitter.getNumSamples() == 0:\n            print('MopathRecorder.computeCurves: Must define curve first')\n            return\n        # Create curves\n        # XYZ\n        self.curveFitter.sortPoints()\n        self.curveFitter.wrapHpr()\n        self.curveFitter.computeTangents(1)\n        # This is really a collection\n        self.curveCollection = self.curveFitter.makeNurbs()\n        self.nurbsCurveDrawer.setCurves(self.curveCollection)\n        self.nurbsCurveDrawer.draw()\n        # Update widget based on new curve\n        self.updateWidgets()\n\n    def initTrace(self):\n        self.trace.reset()\n        # Put trace line segs under node path's parent\n        self.trace.reparentTo(self.nodePathParent)\n        # Show it\n        self.trace.show()\n\n    def updateWidgets(self):\n        if not self.curveCollection:\n            return\n        self.fAdjustingValues = 1\n        # Widgets depending on max T\n        maxT = self.curveCollection.getMaxT()\n        maxT_text = '%0.2f' % maxT\n        # Playback controls\n        self.getWidget('Playback', 'Time').configure(max = maxT_text)\n        self.getVariable('Resample', 'Path Duration').set(maxT_text)\n        # Refine widgets\n        widget = self.getWidget('Refine Page', 'Refine From')\n        widget.configure(max = maxT)\n        widget.set(0.0)\n        widget = self.getWidget('Refine Page', 'Control Start')\n        widget.configure(max = maxT)\n        widget.set(0.0)\n        widget = self.getWidget('Refine Page', 'Control Stop')\n        widget.configure(max = maxT)\n        widget.set(float(maxT))\n        widget = self.getWidget('Refine Page', 'Refine To')\n        widget.configure(max = maxT)\n        widget.set(float(maxT))\n        # Extend widgets\n        widget = self.getWidget('Extend Page', 'Extend From')\n        widget.configure(max = maxT)\n        widget.set(float(0.0))\n        widget = self.getWidget('Extend Page', 'Control Start')\n        widget.configure(max = maxT)\n        widget.set(float(0.0))\n        # Crop widgets\n        widget = self.getWidget('Crop Page', 'Crop From')\n        widget.configure(max = maxT)\n        widget.set(float(0.0))\n        widget = self.getWidget('Crop Page', 'Crop To')\n        widget.configure(max = maxT)\n        widget.set(float(maxT))\n        self.maxT = float(maxT)\n        # Widgets depending on number of samples\n        numSamples = self.curveFitter.getNumSamples()\n        widget = self.getWidget('Resample', 'Points Between Samples')\n        widget.configure(max=numSamples)\n        widget = self.getWidget('Resample', 'Num. Samples')\n        widget.configure(max = 4 * numSamples)\n        widget.set(numSamples, 0)\n        self.fAdjustingValues = 0\n\n    def selectNodePathNamed(self, name):\n        nodePath = None\n        if name == 'init':\n            nodePath = self.nodePath\n            # Add Combo box entry for the initial node path\n            self.addNodePath(nodePath)\n        elif name == 'selected':\n            nodePath = base.direct.selected.last\n            # Add Combo box entry for this selected object\n            self.addNodePath(nodePath)\n        else:\n            nodePath = self.nodePathDict.get(name, None)\n            if nodePath is None:\n                # See if this evaluates into a node path\n                try:\n                    nodePath = eval(name)\n                    if isinstance(nodePath, NodePath):\n                        self.addNodePath(nodePath)\n                    else:\n                        # Good eval but not a node path, give up\n                        nodePath = None\n                except Exception:\n                    # Bogus eval\n                    nodePath = None\n                    # Clear bogus entry from listbox\n                    listbox = self.nodePathMenu.component('scrolledlist')\n                    listbox.setlist(self.nodePathNames)\n            else:\n                if name == 'widget':\n                    # Record relationship between selected nodes and widget\n                    base.direct.selected.getWrtAll()\n                if name == 'marker':\n                    self.playbackMarker.show()\n                    # Initialize tangent marker position\n                    tan = Point3(0)\n                    if self.curveCollection is not None:\n                        self.curveCollection.getXyzCurve().getTangent(\n                            self.playbackTime, tan)\n                    self.tangentMarker.setPos(tan)\n                else:\n                    self.playbackMarker.hide()\n        # Update active node path\n        self.setNodePath(nodePath)\n\n    def setNodePath(self, nodePath):\n        self.playbackNodePath = self.nodePath = nodePath\n        if self.nodePath:\n            # Record nopath's parent\n            self.nodePathParent = self.nodePath.getParent()\n            # Put curve drawer under record node path's parent\n            self.curveNodePath.reparentTo(self.nodePathParent)\n            # Set entry color\n            self.nodePathMenuEntry.configure(\n                background = self.nodePathMenuBG)\n        else:\n            # Flash entry\n            self.nodePathMenuEntry.configure(background = 'Pink')\n\n    def setPlaybackNodePath(self, nodePath):\n        self.playbackNodePath = nodePath\n\n    def addNodePath(self, nodePath):\n        self.addNodePathToDict(nodePath, self.nodePathNames,\n                               self.nodePathMenu, self.nodePathDict)\n\n    def addNodePathToDict(self, nodePath, names, menu, dict):\n        if not nodePath:\n            return\n        # Get node path's name\n        name = nodePath.getName()\n        if name in ['mopathRecorderTempCS', 'widget', 'camera', 'marker']:\n            dictName = name\n        else:\n            # Generate a unique name for the dict\n            dictName = name + '-' + repr(nodePath.id())\n        if dictName not in dict:\n            # Update combo box to include new item\n            names.append(dictName)\n            listbox = menu.component('scrolledlist')\n            listbox.setlist(names)\n            # Add new item to dictionary\n            dict[dictName] = nodePath\n        menu.selectitem(dictName)\n\n    def setLoopPlayback(self):\n        self.loopPlayback = self.getVariable('Playback', 'Loop').get()\n\n    def playbackGoTo(self, time):\n        if self.curveCollection is None:\n            return\n        self.playbackTime = CLAMP(time, 0.0, self.maxT)\n        if self.curveCollection is not None:\n            pos = Point3(0)\n            hpr = Point3(0)\n            self.curveCollection.evaluate(self.playbackTime, pos, hpr)\n            self.playbackNodePath.setPosHpr(self.nodePathParent, pos, hpr)\n\n    def startPlayback(self):\n        if self.curveCollection is None:\n            return\n        # Kill any existing tasks\n        self.stopPlayback()\n        # Make sure checkbutton is set\n        self.getVariable('Playback', 'Play').set(1)\n        # Start new playback task\n        t = taskMgr.add(\n            self.playbackTask, self.name + '-playbackTask')\n        t.currentTime = self.playbackTime\n        t.lastTime = ClockObject.getGlobalClock().getFrameTime()\n\n    def setSpeedScale(self, value):\n        self.speedScale.set(math.log10(value))\n\n    def setPlaybackSF(self, value):\n        self.playbackSF = pow(10.0, float(value))\n        self.speedVar.set('%0.2f' % self.playbackSF)\n\n    def playbackTask(self, state):\n        time = ClockObject.getGlobalClock().getFrameTime()\n        dTime = self.playbackSF * (time - state.lastTime)\n        state.lastTime = time\n        if self.loopPlayback:\n            cTime = (state.currentTime + dTime) % self.maxT\n        else:\n            cTime = state.currentTime + dTime\n        # Stop task if not looping and at end of curve\n        # Or if refining curve and past recordStop\n        if self.recordingType.get() == 'Refine' and cTime > self.recordStop:\n            # Go to recordStop\n            self.getWidget('Playback', 'Time').set(self.recordStop)\n            # Then stop playback\n            self.stopPlayback()\n            # Also kill record task\n            self.toggleRecordVar()\n            return Task.done\n        elif self.loopPlayback == 0 and cTime > self.maxT:\n            # Go to maxT\n            self.getWidget('Playback', 'Time').set(self.maxT)\n            # Then stop playback\n            self.stopPlayback()\n            return Task.done\n        elif self.recordingType.get() == 'Extend' and cTime > self.controlStart:\n            # Go to final point\n            self.getWidget('Playback', 'Time').set(self.controlStart)\n            # Stop playback\n            self.stopPlayback()\n            return Task.done\n        # Otherwise go to specified time and continue\n        self.getWidget('Playback', 'Time').set(cTime)\n        state.currentTime = cTime\n        return Task.cont\n\n    def stopPlayback(self):\n        self.getVariable('Playback', 'Play').set(0)\n        taskMgr.remove(self.name + '-playbackTask')\n\n    def jumpToStartOfPlayback(self):\n        self.stopPlayback()\n        self.getWidget('Playback', 'Time').set(0.0)\n\n    def jumpToEndOfPlayback(self):\n        self.stopPlayback()\n        if self.curveCollection is not None:\n            self.getWidget('Playback', 'Time').set(self.maxT)\n\n    def startStopPlayback(self):\n        if self.getVariable('Playback', 'Play').get():\n            self.startPlayback()\n        else:\n            self.stopPlayback()\n\n    def setDesampleFrequency(self, frequency):\n        self.desampleFrequency = frequency\n\n    def desampleCurve(self):\n        if self.curveFitter.getNumSamples() == 0:\n            print('MopathRecorder.desampleCurve: Must define curve first')\n            return\n        # NOTE: This is destructive, points will be deleted from curve fitter\n        self.curveFitter.desample(self.desampleFrequency)\n        # Compute new curve based on desampled data\n        self.computeCurves()\n        # Get point set from the curve fitter\n        self.extractPointSetFromCurveFitter()\n\n    def setNumSamples(self, numSamples):\n        self.numSamples = int(numSamples)\n\n    def sampleCurve(self, fCompute = 1):\n        if self.curveCollection is None:\n            print('MopathRecorder.sampleCurve: Must define curve first')\n            return\n        # Reset curve fitters\n        self.curveFitter.reset()\n        # Sample curve using specified number of samples\n        self.curveFitter.sample(self.curveCollection, self.numSamples)\n        if fCompute:\n            # Now recompute curves\n            self.computeCurves()\n        # Get point set from the curve fitter\n        self.extractPointSetFromCurveFitter()\n\n    def makeEven(self):\n        # Note: segments_per_unit = 2 seems to give a good fit\n        self.curveCollection.makeEven(self.maxT, 2)\n        # Get point set from curve\n        self.extractPointSetFromCurveCollection()\n\n    def faceForward(self):\n        # Note: segments_per_unit = 2 seems to give a good fit\n        self.curveCollection.faceForward(2)\n        # Get point set from curve\n        self.extractPointSetFromCurveCollection()\n\n    def setPathDuration(self, event):\n        newMaxT = float(self.getWidget('Resample', 'Path Duration').get())\n        self.setPathDurationTo(newMaxT)\n\n    def setPathDurationTo(self, newMaxT):\n        # Compute scale factor\n        sf = newMaxT/self.maxT\n        # Scale curve collection\n        self.curveCollection.resetMaxT(newMaxT)\n        # Scale point set\n        # Save handle to old point set\n        oldPointSet = self.pointSet\n        # Create new point set\n        self.createNewPointSet()\n        # Reset curve fitters\n        self.curveFitter.reset()\n        # Now scale values\n        for time, pos, hpr in oldPointSet:\n            newTime = time * sf\n            # Update point set\n            self.pointSet.append([newTime, Point3(pos), Point3(hpr)])\n            # Add it to the curve fitters\n            self.curveFitter.addXyzHpr(newTime, pos, hpr)\n        # Update widgets\n        self.updateWidgets()\n        # Compute curve\n        #self.computeCurves()\n\n    def setRecordStart(self, value):\n        self.recordStart = value\n        # Someone else is adjusting values, let them take care of it\n        if self.fAdjustingValues:\n            return\n        self.fAdjustingValues = 1\n        # Adjust refine widgets\n        # Make sure we're in sync\n        self.getWidget('Refine Page', 'Refine From').set(\n            self.recordStart)\n        self.getWidget('Extend Page', 'Extend From').set(\n            self.recordStart)\n        # Check bounds\n        if self.recordStart > self.controlStart:\n            self.getWidget('Refine Page', 'Control Start').set(\n                self.recordStart)\n            self.getWidget('Extend Page', 'Control Start').set(\n                self.recordStart)\n        if self.recordStart > self.controlStop:\n            self.getWidget('Refine Page', 'Control Stop').set(\n                self.recordStart)\n        if self.recordStart > self.recordStop:\n            self.getWidget('Refine Page', 'Refine To').set(self.recordStart)\n        # Move playback node path to specified time\n        self.getWidget('Playback', 'Time').set(value)\n        self.fAdjustingValues = 0\n\n    def getPrePoints(self, type = 'Refine'):\n        # Switch to appropriate recording type\n        self.setRecordingType(type)\n        # Reset prePoints\n        self.prePoints = []\n        # See if we need to save any points before recordStart\n        for i in range(len(self.pointSet)):\n            # Have we passed recordStart?\n            if self.recordStart < self.pointSet[i][0]:\n                # Get a copy of the points prior to recordStart\n                self.prePoints = self.pointSet[:i-1]\n                break\n\n    def setControlStart(self, value):\n        self.controlStart = value\n        # Someone else is adjusting values, let them take care of it\n        if self.fAdjustingValues:\n            return\n        self.fAdjustingValues = 1\n        # Adjust refine widgets\n        # Make sure both pages are in sync\n        self.getWidget('Refine Page', 'Control Start').set(\n            self.controlStart)\n        self.getWidget('Extend Page', 'Control Start').set(\n            self.controlStart)\n        # Check bounds on other widgets\n        if self.controlStart < self.recordStart:\n            self.getWidget('Refine Page', 'Refine From').set(\n                self.controlStart)\n            self.getWidget('Extend Page', 'Extend From').set(\n                self.controlStart)\n        if self.controlStart > self.controlStop:\n            self.getWidget('Refine Page', 'Control Stop').set(\n                self.controlStart)\n        if self.controlStart > self.recordStop:\n            self.getWidget('Refine Page', 'Refine To').set(\n                self.controlStart)\n        # Move playback node path to specified time\n        self.getWidget('Playback', 'Time').set(value)\n        self.fAdjustingValues = 0\n\n    def setControlStop(self, value):\n        self.controlStop = value\n        # Someone else is adjusting values, let them take care of it\n        if self.fAdjustingValues:\n            return\n        self.fAdjustingValues = 1\n        if self.controlStop < self.recordStart:\n            self.getWidget('Refine Page', 'Refine From').set(\n                self.controlStop)\n        if self.controlStop < self.controlStart:\n            self.getWidget('Refine Page', 'Control Start').set(\n                self.controlStop)\n        if self.controlStop > self.recordStop:\n            self.getWidget('Refine Page', 'Refine To').set(\n                self.controlStop)\n        # Move playback node path to specified time\n        self.getWidget('Playback', 'Time').set(value)\n        self.fAdjustingValues = 0\n\n    def setRefineStop(self, value):\n        self.recordStop = value\n        # Someone else is adjusting values, let them take care of it\n        if self.fAdjustingValues:\n            return\n        self.fAdjustingValues = 1\n        if self.recordStop < self.recordStart:\n            self.getWidget('Refine Page', 'Refine From').set(\n                self.recordStop)\n        if self.recordStop < self.controlStart:\n            self.getWidget('Refine Page', 'Control Start').set(\n                self.recordStop)\n        if self.recordStop < self.controlStop:\n            self.getWidget('Refine Page', 'Control Stop').set(\n                self.recordStop)\n        # Move playback node path to specified time\n        self.getWidget('Playback', 'Time').set(value)\n        self.fAdjustingValues = 0\n\n    def getPostPoints(self):\n        # Set flag so we know to do a refine pass\n        self.setRefineMode()\n        # Reset postPoints\n        self.postPoints = []\n        # See if we need to save any points after recordStop\n        for i in range(len(self.pointSet)):\n            # Have we reached recordStop?\n            if self.recordStop < self.pointSet[i][0]:\n                # Get a copy of the points after recordStop\n                self.postPoints = self.pointSet[i:]\n                break\n\n    def mergePoints(self):\n        # prepend pre points\n        self.pointSet[0:0] = self.prePoints\n        for time, pos, hpr in self.prePoints:\n            # Add it to the curve fitters\n            self.curveFitter.addXyzHpr(time, pos, hpr)\n        # And post points\n        # What is end time of pointSet?\n        endTime = self.pointSet[-1][0]\n        for time, pos, hpr in self.postPoints:\n            adjustedTime = endTime + (time - self.recordStop)\n            # Add it to point set\n            self.pointSet.append([adjustedTime, pos, hpr])\n            # Add it to the curve fitters\n            self.curveFitter.addXyzHpr(adjustedTime, pos, hpr)\n\n    def setCropFrom(self, value):\n        self.cropFrom = value\n        # Someone else is adjusting values, let them take care of it\n        if self.fAdjustingValues:\n            return\n        self.fAdjustingValues = 1\n        if self.cropFrom > self.cropTo:\n            self.getWidget('Crop Page', 'Crop To').set(\n                self.cropFrom)\n        # Move playback node path to specified time\n        self.getWidget('Playback', 'Time').set(value)\n        self.fAdjustingValues = 0\n\n    def setCropTo(self, value):\n        self.cropTo = value\n        # Someone else is adjusting values, let them take care of it\n        if self.fAdjustingValues:\n            return\n        self.fAdjustingValues = 1\n        if self.cropTo < self.cropFrom:\n            self.getWidget('Crop Page', 'Crop From').set(\n                self.cropTo)\n        # Move playback node path to specified time\n        self.getWidget('Playback', 'Time').set(value)\n        self.fAdjustingValues = 0\n\n    def cropCurve(self):\n        if self.pointSet is None:\n            print('Empty Point Set')\n            return\n        # Keep handle on old points\n        oldPoints = self.pointSet\n        # Create new point set\n        self.createNewPointSet()\n        # Copy over points between from/to\n        # Reset curve fitters\n        self.curveFitter.reset()\n        # Add start point\n        pos = Point3(0)\n        hpr = Point3(0)\n        self.curveCollection.evaluate(self.cropFrom, pos, hpr)\n        self.curveFitter.addXyzHpr(0.0, pos, hpr)\n        # Get points within bounds\n        for time, pos, hpr in oldPoints:\n            # Is it within the time?\n            if time > self.cropFrom and time < self.cropTo:\n                # Add it to the curve fitters\n                t = time - self.cropFrom\n                self.curveFitter.addXyzHpr(t, pos, hpr)\n                # And the point set\n                self.pointSet.append([t, pos, hpr])\n        # Add last point\n        pos = Vec3(0)\n        hpr = Vec3(0)\n        self.curveCollection.evaluate(self.cropTo, pos, hpr)\n        self.curveFitter.addXyzHpr(self.cropTo - self.cropFrom, pos, hpr)\n        # Compute curve\n        self.computeCurves()\n\n    def loadCurveFromFile(self):\n        # Use first directory in model path\n        mPath = getModelPath()\n        if mPath.getNumDirectories() > 0:\n            if repr(mPath.getDirectory(0)) == '.':\n                path = '.'\n            else:\n                path = mPath.getDirectory(0).toOsSpecific()\n        else:\n            path = '.'\n        if not os.path.isdir(path):\n            print('MopathRecorder Info: Empty Model Path!')\n            print('Using current directory')\n            path = '.'\n        mopathFilename = askopenfilename(\n            defaultextension = '.egg',\n            filetypes = (('Egg Files', '*.egg'),\n                         ('Bam Files', '*.bam'),\n                         ('All files', '*')),\n            initialdir = path,\n            title = 'Load Nurbs Curve',\n            parent = self.parent)\n        if mopathFilename and mopathFilename != 'None':\n            self.reset()\n            nodePath = base.loader.loadModel(\n                Filename.fromOsSpecific(mopathFilename))\n            self.curveCollection = ParametricCurveCollection()\n            # MRM: Add error check\n            self.curveCollection.addCurves(nodePath.node())\n            nodePath.removeNode()\n            if self.curveCollection:\n                # Draw the curve\n                self.nurbsCurveDrawer.setCurves(self.curveCollection)\n                self.nurbsCurveDrawer.draw()\n                # Save a pointset for this curve\n                self.extractPointSetFromCurveCollection()\n            else:\n                self.reset()\n\n    def saveCurveToFile(self):\n        # Use first directory in model path\n        mPath = getModelPath()\n        if mPath.getNumDirectories() > 0:\n            if repr(mPath.getDirectory(0)) == '.':\n                path = '.'\n            else:\n                path = mPath.getDirectory(0).toOsSpecific()\n        else:\n            path = '.'\n        if not os.path.isdir(path):\n            print('MopathRecorder Info: Empty Model Path!')\n            print('Using current directory')\n            path = '.'\n        mopathFilename = asksaveasfilename(\n            defaultextension = '.egg',\n            filetypes = (('Egg Files', '*.egg'),\n                         ('Bam Files', '*.bam'),\n                         ('All files', '*')),\n            initialdir = path,\n            title = 'Save Nurbs Curve as',\n            parent = self.parent)\n        if mopathFilename:\n            self.curveCollection.writeEgg(Filename(mopathFilename))\n\n    def followTerrain(self, height = 1.0):\n        self.iRay.rayCollisionNodePath.reparentTo(self.nodePath)\n        entry = self.iRay.pickGeom3D()\n        if entry:\n            hitPtDist = Vec3(entry.getFromIntersectionPoint()).length()\n            self.nodePath.setZ(self.nodePath, height - hitPtDist)\n        self.iRay.rayCollisionNodePath.reparentTo(self.recorderNodePath)\n\n    ## WIDGET UTILITY FUNCTIONS ##\n    def addWidget(self, widget, category, text):\n        self.widgetDict[category + '-' + text] = widget\n\n    def getWidget(self, category, text):\n        return self.widgetDict[category + '-' + text]\n\n    def getVariable(self, category, text):\n        return self.variableDict[category + '-' + text]\n\n    def createLabeledEntry(self, parent, category, text, balloonHelp,\n                           value = '', command = None,\n                           relief = 'sunken', side = tk.LEFT,\n                           expand = 1, width = 12):\n        frame = tk.Frame(parent)\n        variable = tk.StringVar()\n        variable.set(value)\n        label = tk.Label(frame, text = text)\n        label.pack(side = tk.LEFT, fill = tk.X)\n        self.bind(label, balloonHelp)\n        self.widgetDict[category + '-' + text + '-Label'] = label\n        entry = tk.Entry(frame, width = width, relief = relief,\n                         textvariable = variable)\n        entry.pack(side = tk.LEFT, fill = tk.X, expand = expand)\n        self.bind(entry, balloonHelp)\n        self.widgetDict[category + '-' + text] = entry\n        self.variableDict[category + '-' + text] = variable\n        if command:\n            entry.bind('<Return>', command)\n        frame.pack(side = side, fill = tk.X, expand = expand)\n        return (frame, label, entry)\n\n    def createButton(self, parent, category, text, balloonHelp, command,\n                     side = 'top', expand = 0, fill = tk.X):\n        widget = tk.Button(parent, text = text)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(side = side, fill = fill, expand = expand)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createCheckbutton(self, parent, category, text,\n                          balloonHelp, command, initialState,\n                          side = 'top', fill = tk.X, expand = 0):\n        bool = tk.BooleanVar()\n        bool.set(initialState)\n        widget = tk.Checkbutton(parent, text = text, anchor = tk.W,\n                                variable = bool)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(side = side, fill = fill, expand = expand)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        self.variableDict[category + '-' + text] = bool\n        return widget\n\n    def createRadiobutton(self, parent, side, category, text,\n                          balloonHelp, variable, value,\n                          command = None, fill = tk.X, expand = 0):\n        widget = tk.Radiobutton(parent, text = text, anchor = tk.W,\n                                variable = variable, value = value)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(side = side, fill = fill, expand = expand)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createFloater(self, parent, category, text, balloonHelp,\n                      command = None, min = 0.0, resolution = None,\n                      maxVelocity = 10.0, **kw):\n        kw['text'] = text\n        kw['min'] = min\n        kw['maxVelocity'] = maxVelocity\n        kw['resolution'] = resolution\n        widget = Floater.Floater(parent, **kw)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createAngleDial(self, parent, category, text, balloonHelp,\n                        command = None, **kw):\n        kw['text'] = text\n        widget = Dial.AngleDial(parent, **kw)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createSlider(self, parent, category, text, balloonHelp,\n                         command = None, min = 0.0, max = 1.0,\n                         resolution = None,\n                         side = tk.TOP, fill = tk.X, expand = 1, **kw):\n        kw['text'] = text\n        kw['min'] = min\n        kw['max'] = max\n        kw['resolution'] = resolution\n        #widget = apply(EntryScale.EntryScale, (parent,), kw)\n        from direct.tkwidgets import Slider\n        widget = Slider.Slider(parent, **kw)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(side = side, fill = fill, expand = expand)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createEntryScale(self, parent, category, text, balloonHelp,\n                         command = None, min = 0.0, max = 1.0,\n                         resolution = None,\n                         side = tk.TOP, fill = tk.X, expand = 1, **kw):\n        kw['text'] = text\n        kw['min'] = min\n        kw['max'] = max\n        kw['resolution'] = resolution\n        widget = EntryScale.EntryScale(parent, **kw)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(side = side, fill = fill, expand = expand)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createVector2Entry(self, parent, category, text, balloonHelp,\n                           command = None, **kw):\n        # Set label's text\n        kw['text'] = text\n        widget = VectorWidgets.Vector2Entry(parent, **kw)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createVector3Entry(self, parent, category, text, balloonHelp,\n                           command = None, **kw):\n        # Set label's text\n        kw['text'] = text\n        widget = VectorWidgets.Vector3Entry(parent, **kw)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createColorEntry(self, parent, category, text, balloonHelp,\n                         command = None, **kw):\n        # Set label's text\n        kw['text'] = text\n        widget = VectorWidgets.ColorEntry(parent, **kw)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createOptionMenu(self, parent, category, text, balloonHelp,\n                         items, command):\n        optionVar = tk.StringVar()\n        if len(items) > 0:\n            optionVar.set(items[0])\n        widget = Pmw.OptionMenu(parent, labelpos = tk.W, label_text = text,\n                                label_width = 12, menu_tearoff = 1,\n                                menubutton_textvariable = optionVar,\n                                items = items)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X)\n        self.bind(widget.component('menubutton'), balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        self.variableDict[category + '-' + text] = optionVar\n        return optionVar\n\n    def createComboBox(self, parent, category, text, balloonHelp,\n                       items, command, history = 0,\n                       side = tk.LEFT, expand = 0, fill = tk.X):\n        widget = Pmw.ComboBox(parent,\n                              labelpos = tk.W,\n                              label_text = text,\n                              label_anchor = 'e',\n                              label_width = 12,\n                              entry_width = 16,\n                              history = history,\n                              scrolledlist_items = items)\n        # Don't allow user to edit entryfield\n        widget.configure(entryfield_entry_state = 'disabled')\n        # Select first item if it exists\n        if len(items) > 0:\n            widget.selectitem(items[0])\n        # Bind selection command\n        widget['selectioncommand'] = command\n        widget.pack(side = side, fill = fill, expand = expand)\n        # Bind help\n        self.bind(widget, balloonHelp)\n        # Record widget\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def makeCameraWindow(self):\n        # First, we need to make a new layer on the window.\n        chan = base.win.getChannel(0)\n        self.cLayer = chan.makeLayer(1)\n        self.layerIndex = 1\n        self.cDr = self.cLayer.makeDisplayRegion(0.6, 1.0, 0, 0.4)\n        self.cDr.setClearDepthActive(1)\n        self.cDr.setClearColorActive(1)\n        self.cDr.setClearColor(Vec4(0))\n\n        # It gets its own camera\n        self.cCamera = render.attachNewNode('cCamera')\n        self.cCamNode = Camera('cCam')\n        self.cLens = PerspectiveLens()\n        self.cLens.setFov(40, 40)\n        self.cLens.setNear(0.1)\n        self.cLens.setFar(100.0)\n        self.cCamNode.setLens(self.cLens)\n        self.cCamNode.setScene(render)\n        self.cCam = self.cCamera.attachNewNode(self.cCamNode)\n\n        self.cDr.setCamera(self.cCam)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/tkpanels/MopathRecorder.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/78026bc9_MopathRecorder.json",
    "doc_id": "doc_65"
  }
}