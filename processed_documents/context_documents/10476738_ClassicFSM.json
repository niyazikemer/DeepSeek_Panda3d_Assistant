{
  "content": "\"\"\"Finite State Machine module: contains the ClassicFSM class.\n\nNote:\n    This module and class exist only for backward compatibility with\n    existing code.  New code should use the :mod:`.FSM` module instead.\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = ['ClassicFSM']\n\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.showbase.MessengerGlobal import messenger\nimport weakref\n\nif __debug__:\n    _debugFsms: dict[str, weakref.ref] = {}\n\n    def printDebugFsmList():\n        for k in sorted(_debugFsms.keys()):\n            print(\"%s %s\" % (k, _debugFsms[k]()))\n    __builtins__['debugFsmList'] = printDebugFsmList\n\n\nclass ClassicFSM(DirectObject):\n    \"\"\"\n    Finite State Machine class.\n\n    This module and class exist only for backward compatibility with\n    existing code.  New code should use the FSM class instead.\n    \"\"\"\n\n    # create ClassicFSM DirectNotify category\n    notify = directNotify.newCategory(\"ClassicFSM\")\n\n    # special methods\n\n    # these are flags that tell the ClassicFSM what to do when an\n    # undefined transition is requested:\n    ALLOW = 0            # print a warning, and do the transition\n    DISALLOW = 1         # silently ignore the request (don't do the transition)\n    DISALLOW_VERBOSE = 2 # print a warning, and don't do the transition\n    ERROR = 3            # print an error message and raise an exception\n\n    def __init__(self, name, states=[], initialStateName=None,\n                 finalStateName=None, onUndefTransition=DISALLOW_VERBOSE):\n        \"\"\"__init__(self, string, State[], string, string, int)\n\n        ClassicFSM constructor: takes name, list of states, initial state and\n        final state as::\n\n            fsm = ClassicFSM.ClassicFSM('stopLight',\n              [State.State('red', enterRed, exitRed, ['green']),\n                State.State('yellow', enterYellow, exitYellow, ['red']),\n                State.State('green', enterGreen, exitGreen, ['yellow'])],\n              'red',\n              'red')\n\n        each state's last argument, a list of allowed state transitions,\n        is optional; if left out (or explicitly specified to be\n        State.State.Any) then any transition from the state is 'defined'\n        and allowed\n\n        'onUndefTransition' flag determines behavior when undefined\n        transition is requested; see flag definitions above\n        \"\"\"\n        self.setName(name)\n        self.setStates(states)\n        self.setInitialState(initialStateName)\n        self.setFinalState(finalStateName)\n\n        self.onUndefTransition = onUndefTransition\n\n        # Flag to see if we are inspecting\n        self.inspecting = 0\n\n        # We do not enter the initial state to separate\n        # construction from activation\n        self.__currentState = None\n\n        # We set this while we are modifying the state.  No one else\n        # should recursively attempt to modify the state while we are\n        # doing this.\n        self.__internalStateInFlux = 0\n        if __debug__:\n            _debugFsms[name] = weakref.ref(self)\n\n    # I know this isn't how __repr__ is supposed to be used, but it\n    # is nice and convenient.\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        \"\"\"\n        Print out something useful about the fsm\n        \"\"\"\n        name = self.getName()\n        currentState = self.getCurrentState()\n        if currentState:\n            str = f'ClassicFSM {name} in state \"{currentState.getName()}\"'\n        else:\n            str = f'ClassicFSM {name} not in any state'\n        return str\n\n    def enterInitialState(self, argList=[]):\n        assert not self.__internalStateInFlux\n        if self.__currentState == self.__initialState:\n            return\n\n        assert self.__currentState is None\n        self.__internalStateInFlux = 1\n        self.__enter(self.__initialState, argList)\n        assert not self.__internalStateInFlux\n\n    # setters and getters\n\n    def getName(self):\n        return self.__name\n\n    def setName(self, name):\n        self.__name = name\n\n    def getStates(self):\n        return list(self.__states.values())\n\n    def setStates(self, states):\n        \"\"\"setStates(self, State[])\"\"\"\n        # Make a dictionary from stateName -> state\n        self.__states = {}\n        for state in states:\n            self.__states[state.getName()] = state\n\n    def addState(self, state):\n        self.__states[state.getName()] = state\n\n    def getInitialState(self):\n        return self.__initialState\n\n    def setInitialState(self, initialStateName):\n        self.__initialState = self.getStateNamed(initialStateName)\n\n    def getFinalState(self):\n        return self.__finalState\n\n    def setFinalState(self, finalStateName):\n        self.__finalState = self.getStateNamed(finalStateName)\n\n    def requestFinalState(self):\n        self.request(self.getFinalState().getName())\n\n    def getCurrentState(self):\n        return self.__currentState\n\n    # lookup funcs\n\n    def getStateNamed(self, stateName):\n        \"\"\"\n        Return the state with given name if found, issue warning otherwise\n        \"\"\"\n        state = self.__states.get(stateName)\n        if state:\n            return state\n        else:\n            ClassicFSM.notify.warning(\"[%s]: getStateNamed: %s, no such state\" %\n                                      (self.__name, stateName))\n\n    def hasStateNamed(self, stateName):\n        \"\"\"\n        Return True if stateName is a valid state, False otherwise.\n        \"\"\"\n        result = False\n        state = self.__states.get(stateName)\n        if state:\n            result = True\n        return result\n\n    # basic ClassicFSM functionality\n\n    def __exitCurrent(self, argList):\n        \"\"\"\n        Exit the current state\n        \"\"\"\n        assert self.__internalStateInFlux\n        assert ClassicFSM.notify.debug(\"[%s]: exiting %s\" % (self.__name, self.__currentState.getName()))\n        self.__currentState.exit(argList)\n        # Only send the state change event if we are inspecting it\n        # If this event turns out to be generally useful, we can\n        # turn it on all the time, but for now nobody else is using it\n        if self.inspecting:\n            messenger.send(self.getName() + '_' +\n                           self.__currentState.getName() + '_exited')\n        self.__currentState = None\n\n    def __enter(self, aState, argList=[]):\n        \"\"\"\n        Enter a given state, if it exists\n        \"\"\"\n        assert self.__internalStateInFlux\n        stateName = aState.getName()\n        if stateName in self.__states:\n            assert ClassicFSM.notify.debug(\"[%s]: entering %s\" % (self.__name, stateName))\n            self.__currentState = aState\n            # Only send the state change event if we are inspecting it\n            # If this event turns out to be generally useful, we can\n            # turn it on all the time, but for now nobody else is using it\n            if self.inspecting:\n                messenger.send(self.getName() + '_' + stateName + '_entered')\n\n            # Once we begin entering the new state, we're allow to\n            # recursively request a transition to another state.\n            # Indicate this by marking our internal state no longer in\n            # flux.\n            self.__internalStateInFlux = 0\n            aState.enter(argList)\n        else:\n            # notify.error is going to raise an exception; reset the\n            # flux flag first\n            self.__internalStateInFlux = 0\n            ClassicFSM.notify.error(\"[%s]: enter: no such state\" % (self.__name))\n\n    def __transition(self, aState, enterArgList=[], exitArgList=[]):\n        \"\"\"\n        Exit currentState and enter given one\n        \"\"\"\n        assert not self.__internalStateInFlux\n        self.__internalStateInFlux = 1\n        self.__exitCurrent(exitArgList)\n        self.__enter(aState, enterArgList)\n        assert not self.__internalStateInFlux\n\n    def request(self, aStateName, enterArgList=[], exitArgList=[],\n                force=0):\n        \"\"\"\n        Attempt transition from currentState to given one.\n        Return true is transition exists to given state,\n        false otherwise.\n        \"\"\"\n        # If you trigger this assertion failure, you must have\n        # recursively requested a state transition from within the\n        # exitState() function for the previous state.  This is not\n        # supported because we're not fully transitioned into the new\n        # state yet.\n        assert not self.__internalStateInFlux\n\n        if not self.__currentState:\n            # Make this a warning for now\n            ClassicFSM.notify.warning(\"[%s]: request: never entered initial state\" %\n                               (self.__name))\n            self.__currentState = self.__initialState\n\n        if isinstance(aStateName, str):\n            aState = self.getStateNamed(aStateName)\n        else:\n            # Allow the caller to pass in a state in itself, not just\n            # the name of a state.\n            aState = aStateName\n            aStateName = aState.getName()\n\n        if aState is None:\n            ClassicFSM.notify.error(\"[%s]: request: %s, no such state\" %\n                             (self.__name, aStateName))\n\n        # is the transition defined? if it isn't, should we allow it?\n        transitionDefined = self.__currentState.isTransitionDefined(aStateName)\n        transitionAllowed = transitionDefined\n\n        if self.onUndefTransition == ClassicFSM.ALLOW:\n            transitionAllowed = 1\n            if not transitionDefined:\n                # the transition is not defined, but we're going to do it\n                # anyway. print a warning.\n                ClassicFSM.notify.warning(\n                    \"[%s]: performing undefined transition from %s to %s\" %\n                    (self.__name,\n                     self.__currentState.getName(),\n                     aStateName))\n\n        if transitionAllowed or force:\n            self.__transition(aState,\n                              enterArgList,\n                              exitArgList)\n            return 1\n        # We can implicitly always transition to our final state.\n        elif aStateName == self.__finalState.getName():\n            if self.__currentState == self.__finalState:\n                # Do not do the transition if we are already in the\n                # final state\n                assert ClassicFSM.notify.debug(\n                    \"[%s]: already in final state: %s\" %\n                    (self.__name, aStateName))\n                return 1\n            else:\n                # Force a transition to allow for cleanup\n                assert ClassicFSM.notify.debug(\n                    \"[%s]: implicit transition to final state: %s\" %\n                    (self.__name, aStateName))\n                self.__transition(aState,\n                                  enterArgList,\n                                  exitArgList)\n                return 1\n        # are we already in this state?\n        elif aStateName == self.__currentState.getName():\n            assert ClassicFSM.notify.debug(\n                \"[%s]: already in state %s and no self transition\" %\n                (self.__name, aStateName))\n            return 0\n        else:\n            msg = (\"[%s]: no transition exists from %s to %s\" %\n                   (self.__name,\n                    self.__currentState.getName(),\n                    aStateName))\n            if self.onUndefTransition == ClassicFSM.ERROR:\n                ClassicFSM.notify.error(msg)\n            elif self.onUndefTransition == ClassicFSM.DISALLOW_VERBOSE:\n                ClassicFSM.notify.warning(msg)\n            return 0\n\n    def forceTransition(self, aStateName, enterArgList=[], exitArgList=[]):\n        \"\"\"\n        force a transition -- for debugging ONLY\n        \"\"\"\n        self.request(aStateName, enterArgList, exitArgList, force=1)\n\n    def conditional_request(self, aStateName, enterArgList=[], exitArgList=[]):\n        \"\"\"\n        'if this transition is defined, do it'\n        Attempt transition from currentState to given one, if it exists.\n        Return true if transition exists to given state, false otherwise.\n        It is NOT an error/warning to attempt a cond_request if the\n        transition doesn't exist.  This lets people be sloppy about\n        ClassicFSM transitions, letting the same fn be used for different\n        states that may not have the same out transitions.\n        \"\"\"\n        assert not self.__internalStateInFlux\n        if not self.__currentState:\n            # Make this a warning for now\n            ClassicFSM.notify.warning(\"[%s]: request: never entered initial state\" %\n                               (self.__name))\n            self.__currentState = self.__initialState\n\n        if isinstance(aStateName, str):\n            aState = self.getStateNamed(aStateName)\n        else:\n            # Allow the caller to pass in a state in itself, not just\n            # the name of a state.\n            aState = aStateName\n            aStateName = aState.getName()\n\n        if aState is None:\n            ClassicFSM.notify.error(\"[%s]: request: %s, no such state\" %\n                                (self.__name, aStateName))\n\n        transitionDefined = (\n            self.__currentState.isTransitionDefined(aStateName) or\n            aStateName in [self.__currentState.getName(),\n                           self.__finalState.getName()]\n        )\n\n        if transitionDefined:\n            return self.request(aStateName, enterArgList, exitArgList)\n        else:\n            assert ClassicFSM.notify.debug(\n                \"[%s]: condition_request: %s, transition doesnt exist\" %\n                (self.__name, aStateName))\n            return 0\n\n    def view(self):\n        # Don't use a regular import, to prevent ModuleFinder from picking\n        # it up as a dependency when building a .p3d package.\n        import importlib\n        FSMInspector = importlib.import_module('direct.tkpanels.FSMInspector')\n        FSMInspector.FSMInspector(self)\n\n    def isInternalStateInFlux(self):\n        return self.__internalStateInFlux\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/fsm/ClassicFSM.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/10476738_ClassicFSM.json",
    "doc_id": "doc_143"
  }
}