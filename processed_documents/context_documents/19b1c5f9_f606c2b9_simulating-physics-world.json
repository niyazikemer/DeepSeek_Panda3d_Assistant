{
  "content": "Simulating the Physics World\n\nSimulating the physics scene\n\nNow, we've only had some theory so far, but haven't seen any simulation yet. To simulate, we will need to keep calling the quickStep(stepSize) function on the OdeWorld instance. stepSize is how much time should be simulated in one step. To get the most stable simulation, it is recommended that the stepSize be kept constant.\n\nThe problem with using the delta time of a task to step the simulation is that the time between tasks might not be consistent. To get around this, a deltaTime accumulator is used to figure out how many steps must be taken. When a step is performed, the world is iterated a few times, you can specify how much times the world is being iterated by calling the setQuickStepNumIterations(num) function on the OdeWorld instance.\n\nHere's a small example showing a simple simulation showing an iron ball falling from a ridge:\n\npython\n\nfrom direct.directbase import DirectStart\nfrom panda3d.ode import OdeWorld, OdeBody, OdeMass\nfrom panda3d.core import Quat\n\n# Load the cube where the ball will fall from\ncube = loader.loadModel(\"box.egg\")\ncube.reparentTo(render)\ncube.setColor(0.2, 0, 0.7)\ncube.setScale(20)\n\n# Load the smiley model which will act as our iron ball\nsphere = loader.loadModel(\"smiley.egg\")\nsphere.reparentTo(render)\nsphere.setPos(10, 1, 21)\nsphere.setColor(0.7, 0.4, 0.4)\n\n# Setup our physics world and the body\nworld = OdeWorld()\nworld.setGravity(0, 0, -9.81)\nbody = OdeBody(world)\nM = OdeMass()\nM.setSphere(7874, 1.0)\nbody.setMass(M)\nbody.setPosition(sphere.getPos(render))\nbody.setQuaternion(sphere.getQuat(render))\n\n# Set the camera position\nbase.disableMouse()\nbase.camera.setPos(80, -20, 40)\nbase.camera.lookAt(0, 0, 10)\n\n# Create an accumulator to track the time since the sim\n# has been running\ndeltaTimeAccumulator = 0.0\n# This stepSize makes the simulation run at 90 frames per second\nstepSize = 1.0 / 90.0\n\n# The task for our simulation\ndef simulationTask(task):\n    global deltaTimeAccumulator\n    # Set the force on the body to push it off the ridge\n    body.setForce(0, min(task.time**4 * 500000 - 500000, 0), 0)\n    # Add the deltaTime for the task to the accumulator\n    deltaTimeAccumulator += globalClock.getDt()\n    while deltaTimeAccumulator > stepSize:\n        # Remove a stepSize from the accumulator until\n        # the accumulated time is less than the stepsize\n        deltaTimeAccumulator -= stepSize\n        # Step the simulation\n        world.quickStep(stepSize)\n    # set the new positions\n    sphere.setPosQuat(render, body.getPosition(), Quat(body.getQuaternion()))\n    return task.cont\n\ntaskMgr.doMethodLater(1.0, simulationTask, \"Physics Simulation\")\n\nbase.run()\n\ncpp\n\n// To keep the C++ samples short, we assume a running Panda environment,\n// with \"framework\", \"window\", \"camera\" and \"taskMgr\" variables in the\n// global scope. Likewise, only the includes relevant to this chapter\n// are shown. Check the beginning of the manual for a tutorial on making\n// a full Panda3D C++ app.\n// Sample entry point: simulation()\n\n#include \"odeWorld.h\"\n#include \"odeBody.h\"\n#include \"odeMass.h\"\n\nOdeBody *body;\nOdeWorld world;\nNodePath sphere;\nPT(ClockObject) globalClock = ClockObject::get_global_clock();\n\n// Create an accumulator to track the time since the sim\n// has been running\nfloat deltaTimeAccumulator = 0.0f;\n\n// This stepSize makes the simulation run at 90 frames per second\nfloat stepSize = 1.0f / 90.0f;\n\nAsyncTask::DoneStatus simulationTask(GenericAsyncTask *task, void *data);\n\nvoid simulation() {\n  // Load the cube where the ball will fall from\n  NodePath cube window->load_model(framework.get_models(), \"models/box\");\n  cube.reparent_to(window->get_render());\n  cube.set_scale(0.25, 0.25, 0.25);\n  cube.set_pos(0, 0, 0);\n\n  // Load the smiley model which will act as our iron ball\n  sphere = window->load_model(framework.get_models(), \"models/smiley\");\n  sphere.reparent_to(window->get_render());\n  sphere.set_scale(0.25, 0.25, 0.25);\n  sphere.set_pos(0, 0, 1);\n\n  // Setup our physics world and the body\n  world.set_gravity(0, 0, -9.81);\n  body = new OdeBody(world);\n  OdeMass M;\n  M.set_sphere(7874, 1.0);\n  body->set_mass(M);\n  body->set_position(sphere.get_pos(window->get_render()));\n  body->set_quaternion(sphere.get_quat(window->get_render()));\n\n  // Set the camera position\n  camera.set_pos(80, -20, 40);\n  camera.look_at(0, 0, 0);\n\n  PT(GenericAsyncTask) simulationTaskObject =\n    new GenericAsyncTask(\"startup task\", &simulationTask, nullptr);\n  simulationTaskObject->set_delay(2);\n  taskMgr->add(simulationTaskObject);\n}\n\n// The task for our simulation\nAsyncTask::DoneStatus simulationTask (GenericAsyncTask *task, void *data) {\n  // Set the force on the body to push it off the ridge\n  body->set_force(0, min(pow(task->get_elapsed_time(),4) * 500000 - 500000, 0), 0);\n  // Add the deltaTime for the task to the accumulator\n  deltaTimeAccumulator += globalClock->get_dt();\n  while (deltaTimeAccumulator > stepSize ) {\n    // Remove a stepSize from the accumulator until\n    // the accumulated time is less than the stepsize\n    deltaTimeAccumulator -= stepSize;\n    // Step the simulation\n    world.quick_step(stepSize);\n  }\n  // set the new positions\n  sphere.set_pos_quat(window->get_render(),\n    body->get_position(), body->get_quaternion());\n  return AsyncTask::DS_cont;\n}",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/f606c2b9_simulating-physics-world.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/19b1c5f9_f606c2b9_simulating-physics-world.json",
    "doc_id": "doc_691"
  }
}