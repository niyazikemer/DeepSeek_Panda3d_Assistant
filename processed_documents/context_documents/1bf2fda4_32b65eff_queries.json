{
  "content": "Bullet Queries\n\nBullet offers a bunch of different queries for retrieving information about collision objects. A common usecase is sensors needed by game logic components. For example to find out if the space in front of an NPC object is blocked by a solid obstacle, or to find out if an NPC can see some other object.\n\nRay Test\n\nRaycasting is to shoot a ray from one position (the from-position) to another position (the to-position). Both the from-position and the to-position have to be specified in global coordinates. The ray test methods will then return a result object which contains information about which objects the ray has hit.\n\nThere are two different ray test method: The first method (rayTestAll) returns all collision objects hit by the ray. But sometimes we are only interested in the first collision object hit by the ray. Then we can use the second ray test method (rayTestClosest).\n\nExample for closest hit:\n\npython\n\npFrom = Point3(0, 0, 0)\npTo = Point3(10, 0, 0)\n\nresult = world.rayTestClosest(pFrom, pTo)\n\nprint(result.hasHit())\nprint(result.getHitPos())\nprint(result.getHitNormal())\nprint(result.getHitFraction())\nprint(result.getNode())\n\ncpp\n\nLPoint3 pFrom(0, 0, 0);\nLPoint3 pTo(10, 0, 0);\nBulletAllHitsRayResult result = world->ray_test_closest(pFrom, pTo);\n\nExample for all hits:\n\npython\n\npFrom = Point3(0, 0, 0)\npTo = pFrom + Vec3(1, 0, 0) * 99999\n\nresult = world.rayTestAll(pFrom, pTo)\n\nprint(result.hasHits())\nprint(result.getClosestHitFraction())\nprint(result.getNumHits())\n\nfor hit in result.getHits():\n    print(hit.getHitPos())\n    print(hit.getHitNormal())\n    print(hit.getHitFraction())\n    print(hit.getNode())\n\ncpp\n\nLPoint3 pFrom = LPoint3(0, 0, 0);\nLPoint3 pTo = pFrom + LVector3d(1, 0, 0) * 99999;\nBulletAllHitsRayResult result = world->ray_test_all(pFrom, pTo);\n\nOften users want to pick or select an object by clicking on it with the mouse. We can use the rayTestClosest to find the collision object which is \"under\" the mouse pointer, but we have to convert the coordinates in camera space to global coordinates world space. The following example shows how this can be done.\n\npython\n\n# Get to and from pos in camera coordinates\npMouse = base.mouseWatcherNode.getMouse()\npFrom = Point3()\npTo = Point3()\nbase.camLens.extrude(pMouse, pFrom, pTo)\n\n# Transform to global coordinates\npFrom = render.getRelativePoint(base.cam, pFrom)\npTo = render.getRelativePoint(base.cam, pTo)\n\ncpp\n\nTODO\n\nSweep Test\n\nThe sweep test is similar to the ray test. There are two differences: (1) The sweep test does not use an infinite thin ray, like the ray test, but checks for collisions with a convex shape which is \"moved\" along the from from-position to to-position. (2) The sweep test wants to have \"from\" and \"to\" specified as TransformState. The sweep test can for example be used to predict if an object would collide with something else if it was moving from it's current position to some other position.\n\nThe sweep test can only be used with shapes that are convex, otherwise the call will fail. Many primitive shapes (sphere, box, etc.) are convex, but a triangle mesh is not. (If you have geometry that is convex, use a BulletConvexHullShape instead of a BulletTriangleMeshShape.)\n\npython\n\nExample for sweep testing:\n\ntsFrom = TransformState.makePos(Point3(0, 0, 0))\ntsTo = TransformState.makePos(Point3(10, 0, 0))\n\nshape = BulletSphereShape(0.5)\npenetration = 0.0\n\nresult = world.sweepTestClosest(shape, tsFrom, tsTo, penetration)\n\nprint(result.hasHit())\nprint(result.getHitPos())\nprint(result.getHitNormal())\nprint(result.getHitFraction())\nprint(result.getNode())\n\nContact Test\n\nThere are two contact tests. One which checks if a collision objects is in contact with other collision objects, and another which checks for a pair of collision objects if they are in contact.\n\npython\n\nExample for contact testing:\n\nbody1 = BulletRigidBodyNode(\"body1\")\n...\n\nbody2 = BulletRigidBodyNode(\"body2\")\n...\n\nresult = world.contactTest(node1)\nresult = world.contactTestPair(node1, node2)\n\nprint(result.getNumContacts())\n\nfor contact in result.getContacts():\n  print(contact.getNode0())\n  print(contact.getNode1())\n\n  mpoint = contact.getManifoldPoint()\n  print(mpoint.getDistance())\n  print(mpoint.getAppliedImpulse())\n  print(mpoint.getPositionWorldOnA())\n  print(mpoint.getPositionWorldOnB())\n  print(mpoint.getLocalPointA())\n  print(mpoint.getLocalPointB())\n\nFiltering\n\nThe test methods on BulletWorld also take an optional mask argument that can be used to limit which groups are matched against (see collision-filtering for information about collision groups). The default is BitMask32.allOn(), which indicates that bodies in all groups are considered for the test.\n\nFor example, the following query will consider object A and C, but ignore object B:\n\n# These three bodies are in different groups\nobjA.setCollideMask(BitMask32.bit(0))\nobjB.setCollideMask(BitMask32.bit(1))\nobjC.setCollideMask(BitMask32.bit(2))\n\nfro = (0, 0, 0)\nto = (1, 0, 0)\nmask = BitMask32.bit(0) | BitMask32.bit(2)\nresult = world.rayTestClosest(fro, to, mask)\n\nOf particular note if you are using the groups-mask filter algorithm is that the mask matches directly against the collide mask of the bodies, ignoring the group matrix entirely. For example, if you specify BitMask32.bit(1), it will consider all bodies that have a collide mask with this bit enabled (ie. all bodies that are in group 1). It does not behave as though the ray itself were a body in group 1.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/32b65eff_queries.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/1bf2fda4_32b65eff_queries.json",
    "doc_id": "doc_444"
  }
}