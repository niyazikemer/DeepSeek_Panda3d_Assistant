{
  "content": "\"\"\" Showutil Effects module: contains code for useful showcode effects. \"\"\"\n\nfrom panda3d.core import Vec3\nfrom direct.interval.IntervalGlobal import (\n    LerpHprInterval,\n    LerpPosInterval,\n    LerpScaleInterval,\n    Sequence,\n)\n\n# bounce types\nSX_BOUNCE = 0\nSY_BOUNCE = 1\nSZ_BOUNCE = 2\nTX_BOUNCE = 3\nTY_BOUNCE = 4\nTZ_BOUNCE = 5\nH_BOUNCE = 6\nP_BOUNCE = 7\nR_BOUNCE = 8\n\n\n# convenience funcs\n#\ndef createScaleXBounce(nodeObj, numBounces, startValues, totalTime, amplitude):\n    return createBounce(nodeObj, numBounces, startValues, totalTime,\n                        amplitude, SX_BOUNCE)\n\ndef createScaleYBounce(nodeObj, numBounces, startValues, totalTime, amplitude):\n    return createBounce(nodeObj, numBounces, startValues, totalTime,\n                        amplitude, SY_BOUNCE)\n\ndef createScaleZBounce(nodeObj, numBounces, startValue, totalTime, amplitude):\n    return createBounce(nodeObj, numBounces, startValue, totalTime,\n                        amplitude, SZ_BOUNCE)\n\ndef createXBounce(nodeObj, numBounces, startValues, totalTime, amplitude):\n    return createBounce(nodeObj, numBounces, startValues, totalTime,\n                        amplitude, TX_BOUNCE)\n\ndef createYBounce(nodeObj, numBounces, startValues, totalTime, amplitude):\n    return createBounce(nodeObj, numBounces, startValues, totalTime,\n                        amplitude, TY_BOUNCE)\n\ndef createZBounce(nodeObj, numBounces, startValues, totalTime, amplitude):\n    return createBounce(nodeObj, numBounces, startValues, totalTime,\n                        amplitude, TZ_BOUNCE)\n\ndef createHBounce(nodeObj, numBounces, startValues, totalTime, amplitude):\n    return createBounce(nodeObj, numBounces, startValues, totalTime,\n                        amplitude, H_BOUNCE)\n\ndef createPBounce(nodeObj, numBounces, startValues, totalTime, amplitude):\n    return createBounce(nodeObj, numBounces, startValues, totalTime,\n                        amplitude, P_BOUNCE)\n\ndef createRBounce(nodeObj, numBounces, startValues, totalTime, amplitude):\n    return createBounce(nodeObj, numBounces, startValues, totalTime,\n                        amplitude, R_BOUNCE)\n\ndef createBounce(nodeObj, numBounces, startValues, totalTime, amplitude,\n                 bounceType=SZ_BOUNCE):\n    \"\"\"\n    createBounce: create and return a list of intervals to make a\n    given nodePath bounce a given number of times over a give total time.\n    \"\"\"\n    if not nodeObj or numBounces < 1 or totalTime == 0:\n        raise ValueError(\"createBounce called with invalid parameter\")\n\n    result = Sequence()\n\n    # calculate how long, in seconds, each bounce should last\n    bounceTime = totalTime / numBounces\n    currTime = bounceTime\n    currAmplitude = amplitude\n\n    # determine the how much of a change in value the first bounce\n    # will produce based on the given start value and amplitude\n    #\n    index = bounceType % 3\n    currBounceVal = startValues[index]\n\n    # create a lerp interval for each bounce, making sure to\n    # figure out the new value, which progressively gets closer\n    # to our start value\n    #\n    for bounceNum in range(numBounces * 2):\n        # determine the direction that this value should go,\n        # alternating for each lerp interval to simulate\n        # a spring effect\n        #\n        if bounceNum % 2:\n            # bounce down\n            currBounceVal = startValues[index]\n            blend = 'easeIn'\n        else:\n            # bounce up\n            currBounceVal = startValues[index] + currAmplitude\n            blend = 'easeOut'\n\n        newVec3 = Vec3(startValues)\n        newVec3.setCell(index, currBounceVal)\n\n        # create the right type of lerp\n        if bounceType >= SX_BOUNCE and bounceType <= SZ_BOUNCE:\n            result.append(LerpScaleInterval(\n                nodeObj, currTime, newVec3, blendType=blend))\n        elif bounceType >= TX_BOUNCE and bounceType <= TZ_BOUNCE:\n            result.append(LerpPosInterval(\n                nodeObj, currTime, newVec3, blendType=blend))\n        elif bounceType >= H_BOUNCE and bounceType <= R_BOUNCE:\n            result.append(LerpHprInterval(\n                nodeObj, currTime, newVec3, blendType=blend))\n\n        # the value diff from the base gets smaller for each\n        # consecutive bounce, and make sure to update for\n        # possibly a new amount of time the next bounce will\n        # take\n        #\n        currAmplitude *= 0.5\n        currTime = bounceTime\n\n    return result\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showutil/Effects.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/c94c3f02_Effects.json",
    "doc_id": "doc_170"
  }
}