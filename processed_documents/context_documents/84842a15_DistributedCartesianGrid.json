{
  "content": "from panda3d.core import ConfigVariableBool, TextNode, VBase4, Vec3\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\n\nfrom direct.distributed.DistributedNode import DistributedNode\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.gui import DirectGuiGlobals\nfrom direct.showbase.EventGroup import EventGroup\nfrom direct.showbase.PythonUtil import report\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.distributed.GridParent import GridParent\n\nif __debug__:\n    # For grid drawing\n    from direct.directtools.DirectGeometry import LineNodePath\n    from direct.showbase.PythonUtil import randFloat\n\nfrom .CartesianGridBase import CartesianGridBase\n\n# increase this number if you want to visualize the grid lines\n# above water level\nGRID_Z_OFFSET = 0.0\n\nclass DistributedCartesianGrid(DistributedNode, CartesianGridBase):\n    notify = directNotify.newCategory(\"DistributedCartesianGrid\")\n    notify.setDebug(False)\n\n    VisualizeGrid = ConfigVariableBool(\"visualize-cartesian-grid\", False)\n\n    RuleSeparator = \":\"\n\n    def __init__(self, cr):\n        DistributedNode.__init__(self, cr)\n        # Let the derived classes instantiate the NodePath\n        self.visAvatar = None\n        self.gridVisContext = None\n        # Do we have grid lines visualized?\n        self._onOffState = False\n        if __debug__:\n            self.haveGridLines = 0\n\n    def generate(self):\n        DistributedNode.generate(self)\n\n    def disable(self):\n        DistributedNode.disable(self)\n        self.stopProcessVisibility()\n\n    def delete(self):\n        DistributedNode.delete(self)\n        # TODO: when teleporting off an island...\n        taskMgr.remove(self.taskName(\"processVisibility\"))\n\n    def isGridParent(self):\n        # If this distributed object is a DistributedGrid return 1.  0 by default\n        return 1\n\n    def setCellWidth(self, width):\n        self.cellWidth = width\n\n    def setParentingRules(self, style, rule):\n        assert self.notify.debug(\"setParentingRules: style: %s, rule: %s\" % (style, rule))\n        rules = rule.split(self.RuleSeparator)\n        assert len(rules) == 3\n        self.style = style\n        self.startingZone = int(rules[0])\n        self.gridSize = int(rules[1])\n        self.viewingRadius = int(rules[2])\n\n        # Store the center of the grid\n        cx = self.cellWidth * self.gridSize/2.0\n        self.centerPos = Vec3(cx, cx, 0)\n\n        if __debug__:\n            if self.VisualizeGrid:\n                self.visualizeGrid()\n\n    def getCenterPos(self):\n        return self.centerPos\n\n    def handleChildArrive(self, child, zoneId):\n        DistributedNode.handleChildArrive(self, child, zoneId)\n        if zoneId >= self.startingZone:\n            if not child.gridParent:\n                child.gridParent = GridParent(child)\n            child.gridParent.setGridParent(self, zoneId)\n        elif child.gridParent:\n            child.gridParent.delete()\n            child.gridParent = None\n\n    def handleChildArriveZone(self, child, zoneId):\n        DistributedNode.handleChildArrive(self, child, zoneId)\n        if zoneId >= self.startingZone:\n            if not child.gridParent:\n                child.gridParent = GridParent(child)\n            child.gridParent.setGridParent(self, zoneId)\n        elif child.gridParent:\n            child.gridParent.delete()\n            child.gridParent = None\n\n    def handleChildLeave(self, child, zoneId):\n        if child.gridParent:\n            child.gridParent.delete()\n            child.gridParent = None\n\n    @report(types = ['deltaStamp', 'avLocation', 'args'], dConfigParam = ['connector','shipboard'])\n    def startProcessVisibility(self, avatar):\n        if not self._onOffState:\n            # if we've been told that we're OFF, don't try\n            # to process visibilty\n            return\n\n        assert not self.cr._noNewInterests\n        if self.cr.noNewInterests():\n            self.notify.warning(\n                'startProcessVisibility(%s): tried to open a new interest during logout'\n                % self.doId)\n            return\n        taskMgr.remove(self.taskName(\"processVisibility\"))\n        self.acceptOnce(self.cr.StopVisibilityEvent, self.stopProcessVisibility)\n        self.visAvatar = avatar\n        self.visZone = None\n        self.visDirty = True\n        taskMgr.add(\n            self.processVisibility, self.taskName(\"processVisibility\"))\n        self.processVisibility(0)\n\n    @report(types = ['deltaStamp', 'avLocation', 'args'], dConfigParam = ['connector','shipboard'])\n    def stopProcessVisibility(self, clearAll=False, event=None):\n        self.ignore(self.cr.StopVisibilityEvent)\n        taskMgr.remove(self.taskName(\"processVisibility\"))\n        if event is not None:\n            eventGroup = EventGroup('DistCartesianGrid.stopProcessVis',\n                                    doneEvent=event)\n        if self.gridVisContext is not None:\n            if event is not None:\n                removeEvent = eventGroup.newEvent('%s.removeInterest' % self.doId)\n            else:\n                removeEvent = None\n            self.cr.removeInterest(self.gridVisContext, removeEvent)\n            self.gridVisContext = None\n        else:\n            # if we were given an event but we have not interest open,\n            # just send the event right away\n            if event is not None:\n                messenger.send(event)\n        self.visAvatar = None\n        self.visZone = None\n\n        # sometimes we also need to remove vis avatar from\n        # my parent if it is also a grid\n        if clearAll:\n            if event is not None:\n                parentEvent = eventGroup.newEvent('%s.parent.removeInterest' % self.doId)\n            else:\n                parentEvent = None\n\n            ##HACK BANDAID FOR PVP INSTANCES\n            if hasattr(self.cr.doId2do[self.parentId], \"worldGrid\"):\n                self.cr.doId2do[self.parentId].worldGrid.stopProcessVisibility(event=parentEvent)\n\n    def processVisibility(self, task):\n        if self.visAvatar is None:\n            # no avatar to process visibility for\n            return Task.done\n        if self.visAvatar.isDisabled():\n            self.visAvatar = None\n            return Task.done\n        if self.visAvatar.gameFSM.state == 'Cutscene':\n            return Task.cont\n\n        pos = self.visAvatar.getPos(self)\n        # Check to make sure our x and y are positive\n        dx = self.cellWidth * self.gridSize * .5\n        x = pos[0] + dx\n        y = pos[1] + dx\n        col = x // self.cellWidth\n        row = y // self.cellWidth\n        assert self.notify.debug(\n            \"processVisibility: %s: avatar pos: %s %s\" % (self.doId, x, y))\n        if (row < 0) or (col < 0) or (row > self.gridSize) or (col > self.gridSize):\n            assert self.notify.debug(\"processVisibility: %s: not on the grid\" % (self.doId))\n            # If we are viewingRadius away from this entire grid,\n            # remove interest in any current visZone we may have\n            if self.gridVisContext:\n                self.cr.removeInterest(self.gridVisContext)\n                self.visZone = None\n                self.gridVisContext = None\n            return Task.cont\n        # Compute which zone we are in\n        zoneId = int(self.startingZone + ((row * self.gridSize) + col))\n        assert self.notify.debug(\"processVisibility: %s: row: %s col: %s zoneId: %s\" %\n                                 (self.doId, row, col, zoneId))\n        if zoneId == self.visZone:\n            assert self.notify.debug(\n                \"processVisibility: %s: interest did not change\" % (self.doId))\n            if self.visDirty:\n                messenger.send(self.uniqueName(\"visibility\"))\n                self.visDirty = False\n            return Task.cont\n        else:\n            assert self.notify.debug(\n                \"processVisibility: %s: new interest\" % (self.doId))\n            self.visZone = zoneId\n            if not self.gridVisContext:\n                self.gridVisContext = self.cr.addInterest(\n                    self.getDoId(), self.visZone,\n                    self.uniqueName(\"visibility\"),\n                    event = self.uniqueName(\"visibility\"))\n            else:\n                assert self.notify.debug(\n                    \"processVisibility: %s: altering interest to zoneId: %s\" %\n                    (self.doId, zoneId))\n\n                event = None\n                if self.visDirty:\n                    event = self.uniqueName(\"visibility\")\n                self.cr.alterInterest(\n                    self.gridVisContext, self.getDoId(), self.visZone,\n                    event = event)\n\n                # If the visAvatar is parented to this grid, also do a\n                # setLocation\n                parentId = self.visAvatar.parentId\n                oldZoneId = self.visAvatar.zoneId\n                assert self.notify.debug(\n                    \"processVisibility: %s: parentId: %s oldZoneId: %s\" %\n                    (self.doId, parentId, oldZoneId))\n                if parentId == self.doId:\n                    assert self.notify.debug(\n                        \"processVisibility: %s: changing location\" %\n                        (self.doId))\n                    messenger.send(\"avatarZoneChanged\", [self.visAvatar, self.doId, zoneId])\n                    #self.handleAvatarZoneChange(self.visAvatar, zoneId)\n            self.visDirty = False\n            return Task.cont\n\n    # Update our location based on our avatar's position on the grid\n    # Assumes our position is correct, relative to the grid\n    def addObjectToGrid(self, av):\n        assert self.notify.debug(\"addObjectToGrid %s\" % av)\n        # Get our pos relative to the island grid\n        pos = av.getPos(self)\n        # Figure out what zone in that island grid\n        zoneId = self.getZoneFromXYZ(pos)\n        # Do the wrtReparenting to the grid node\n        messenger.send(\"avatarZoneChanged\", [av, self.doId, zoneId])\n        #self.handleAvatarZoneChange(av, zoneId)\n\n    def removeObjectFromGrid(self, av):\n        assert self.notify.debug(\"removeObjectFromGrid %s\" % av)\n        # TODO: WHAT LOCATION SHOULD WE SET THIS TO?\n        #av.reparentTo(hidden)\n        if av.getParent() == self:\n            # only detach if object is directly parented\n            av.detachNode()\n        #av.b_setLocation(0, 0)\n\n\n    def handleAvatarZoneChange(self, av, zoneId):\n        assert self.notify.debug(\"handleAvatarZoneChange(%s, %s)\" % (av.doId, zoneId))\n        # This method can be overridden by derived classes that\n        # want to do some special management when the avatar changes\n        # zones.\n        # Make sure this is a valid zone\n        if not self.isValidZone(zoneId):\n            assert self.notify.warning(\"handleAvatarZoneChange: not a valid zone (%s)\" % zoneId)\n            return\n\n        # Set the location on the server\n        av.b_setLocation(self.doId, zoneId)\n\n    def turnOff(self):\n        self._onOffState = False\n        self.stopProcessVisibility()\n\n    def turnOn(self, av = None):\n        self._onOffState = True\n        if av:\n            self.startProcessVisibility(av)\n\n    ##################################################\n    # Visualization Tools\n    ##################################################\n\n    if __debug__:\n\n        def initializeGridLines(self):\n            # Grid Lines\n            self.gridColor = VBase4(0.4 + randFloat(0.4),\n                                    0.4 + randFloat(0.4),\n                                    0.4 + randFloat(0.4),\n                                    1)\n            # A Dark version of the grid color\n            color = self.gridColor * 0.5\n            color.setW(1)\n\n            self.lines = self.attachNewNode('gridLines')\n            self.minorLines = LineNodePath(self.lines)\n            self.minorLines.lineNode.setName('minorLines')\n            self.minorLines.setColor(color)\n            self.minorLines.setThickness(1)\n\n            self.majorLines = LineNodePath(self.lines)\n            self.majorLines.lineNode.setName('majorLines')\n            self.majorLines.setColor(color)\n            self.majorLines.setThickness(5)\n\n            self.centerLines = LineNodePath(self.lines)\n            self.centerLines.lineNode.setName('centerLines')\n            self.centerLines.setColor(VBase4(1, 0, 0, 0))\n            self.centerLines.setThickness(3)\n\n            # Load up grid parts to initialize grid object\n            # Polygon used to mark grid plane\n            # self.gridBack = base.loader.loadModel('models/misc/gridBack')\n            # self.gridBack.reparentTo(self)\n            # self.gridBack.setColor(0.2, 0.2, 0.2, 0.5)\n\n            self.cellLabelParent = None\n            self.markerParent = None\n            self.haveGridLines = 1\n\n        def updateGrid(self):\n            # Update grid lines based upon current grid spacing and grid size\n            # First reset existing grid lines\n            self.minorLines.reset()\n            self.majorLines.reset()\n            self.centerLines.reset()\n            # Now redraw lines\n            numLines = self.gridSize\n            scaledSize = numLines * self.cellWidth / 2.0\n            center = self.centerLines\n            minor = self.minorLines\n            major = self.majorLines\n            cw = self.cellWidth\n            dx = cw * self.gridSize * .5\n            for i in range(numLines+1):\n                icw = i * cw - dx\n                if i == numLines/2:\n                    center.moveTo(icw, -scaledSize, GRID_Z_OFFSET)\n                    center.drawTo(icw, scaledSize, GRID_Z_OFFSET)\n                    center.moveTo(-scaledSize, icw, GRID_Z_OFFSET)\n                    center.drawTo(scaledSize, icw, GRID_Z_OFFSET)\n                else:\n                    if (i % 5) == 0:\n                        major.moveTo(icw, -scaledSize, GRID_Z_OFFSET)\n                        major.drawTo(icw, scaledSize, GRID_Z_OFFSET)\n                        major.moveTo(-scaledSize, icw, GRID_Z_OFFSET)\n                        major.drawTo(scaledSize, icw, GRID_Z_OFFSET)\n                    else:\n                        minor.moveTo(icw, -scaledSize, GRID_Z_OFFSET)\n                        minor.drawTo(icw, scaledSize, GRID_Z_OFFSET)\n                        minor.moveTo(-scaledSize, icw, GRID_Z_OFFSET)\n                        minor.drawTo(scaledSize, icw, GRID_Z_OFFSET)\n            center.create()\n            minor.create()\n            major.create()\n            # self.gridBack.setScale(scaledSize)\n            self.labelCells()\n\n        def labelCells(self):\n            if self.cellLabelParent:\n                self.cellLabelParent.removeNode()\n            self.cellLabelParent = self.attachNewNode('cellLabels')\n            cw = self.cellWidth\n            scale = cw / 10.0\n            dx = cw * self.gridSize * .5\n            font = DirectGuiGlobals.getDefaultFont()\n            color = self.gridColor\n            for i in range(self.gridSize):\n                for j in range(self.gridSize):\n                    zoneId = self.startingZone + ((j * self.gridSize) + i)\n                    zoneStr = str(zoneId)\n                    textNode = TextNode(zoneStr)\n                    textNode.setText(zoneStr)\n                    textNode.setFont(font)\n                    textNode.setTextColor(color)\n                    textNode.setAlign(TextNode.ACenter)\n                    genTextNode = textNode.generate()\n                    textNodePath = self.cellLabelParent.attachNewNode(genTextNode)\n                    # Place the text node in the center of the cell\n                    textNodePath.setPosHprScale((i * cw - dx) + (cw * 0.5), # x\n                                                (j * cw - dx) + (cw * 0.5), # y\n                                                GRID_Z_OFFSET+3.0, # z\n                                                # Lay them down flat\n                                                0, -90, 0, # hpr\n                                                scale, scale, scale)\n            self.cellLabelParent.flattenLight()\n\n        def markCells(self):\n            if self.markerParent:\n                self.markerParent.removeNode()\n            self.markerParent = self.attachNewNode('markers')\n            self.cellMarkers = []\n            dx = self.cellWidth * self.gridSize * .5\n            for i in range(self.gridSize):\n                for j in range(self.gridSize):\n                    marker = base.loader.loadModel(\"models/misc/smiley\")\n                    marker.reparentTo(self.markerParent)\n                    marker.setPos(i * self.cellWidth - dx,\n                                  j * self.cellWidth - dx,\n                                  GRID_Z_OFFSET + 1.0)\n                    marker.setScale(5)\n                    self.cellMarkers.append(marker)\n\n        def unmarkCells(self):\n            if self.markerParent:\n                self.markerParent.removeNode()\n            self.markerParent = None\n\n        def visualizeGrid(self):\n            if not self.haveGridLines:\n                self.initializeGridLines()\n            self.updateGrid()\n\n    def setWorldContext(self, worldContext):\n        pass\n\n    def clearWorldContext(self, event = None):\n        pass\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/DistributedCartesianGrid.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/84842a15_DistributedCartesianGrid.json",
    "doc_id": "doc_302"
  }
}