{
  "content": "Geometrical MipMapping\n\nThe GeoMipTerrain generates terrain geometry from a heightfield image, but it does more than any bruteforce terrain generator: the GeoMipTerrain divides the terrain into multiple chunks, where each of them can have a different level of detail. The advantage of this approach is that, when the focal point (the place where the terrain has the highest quality, probably the camera) moves, not the entire terrain has to be regenerated to match the correct detail level, like the HeightfieldTesselator <heightfield-tesselator>, but only the chunks that have a different LOD can be regenerated. Also, it improves culling and collision detection.\n\nBasic Usage\n\nUsing the GeoMipTerrain is quite easy, it does not require to write many complicated calculations:\n\npython\n\nterrain = GeoMipTerrain(\"mySimpleTerrain\")\nterrain.setHeightfield(\"yourHeightField.png\")\n#terrain.setBruteforce(True)\nterrain.getRoot().reparentTo(render)\nterrain.generate()\n\ncpp\n\nGeoMipTerrain terrain(\"mySimpleTerrain\");\nterrain.set_heightfield(Filename(\"maps/yourHeightField.png\"));\nterrain.set_bruteforce(true);\nterrain.get_root().reparent_to(window->get_render());\nterrain.generate();\n\nFirst, the code creates a GeoMipTerrain instance. The ~.GeoMipTerrain.set_heightfield() call loads in a heightfield image. Preferably this is a size of a power of two plus one (like 129, 257, 513, 1025, etc.), but if it is not, the GeoMipTerrain will automatically scale it up to the nearest correct size (which is quite slow). ~.GeoMipTerrain.set_heightfield() can take a PNMImage <creating-new-textures-from-scratch>, Texture or a path according to the filename-syntax.\n\nThe set_bruteforce(True) <.GeoMipTerrain.set_bruteforce> call sets the terrain to bruteforce rendering -- this means that the terrain is created at the highest quality (the lowest detail level), and LOD is not applied. In the next section we will explain how to set a LOD level and a Focal Point. The ~.GeoMipTerrain.get_root() call returns the NodePath of the terrain. It is then reparented to render to be a part of the scene graph. You can apply common-state-changes to this NodePath. Finally, the ~.GeoMipTerrain.generate() call generates the terrain geometry. Note that if the terrain is still quite flat, you will have to scale the terrain NodePath in the Z direction, because by default, the Z positions are between 0 and 1. To fix this, scale the terrain up in the Z direction (before generating it, otherwise it might require you to regenerate it):\n\npython\n\nterrain.getRoot().setSz(100)\n\ncpp\n\nterrain.get_root().set_sz(100);\n\nDynamic Terrains\n\nThis code shows a dynamically updated terrain with LOD:\n\npython\n\n# Set up the GeoMipTerrain\nterrain = GeoMipTerrain(\"myDynamicTerrain\")\nterrain.setHeightfield(\"yourHeightField.png\")\n\n# Set terrain properties\nterrain.setBlockSize(32)\nterrain.setNear(40)\nterrain.setFar(100)\nterrain.setFocalPoint(base.camera)\n\n# Store the root NodePath for convenience\nroot = terrain.getRoot()\nroot.reparentTo(render)\nroot.setSz(100)\n\n# Generate it.\nterrain.generate()\n\n# Add a task to keep updating the terrain\ndef updateTask(task):\n    terrain.update()\n    return task.cont\n\ntaskMgr.add(updateTask, \"update\")\n\ncpp\n\n// Set up the GeoMipTerrain\nGeoMipTerrain terrain(\"myDynamicTerrain\");\nterrain.set_heightfield(Filename(\"maps/yourHeightField.png\"));\n\n// Set terrain properties\nterrain.set_block_size(32);\nterrain.set_near(40);\nterrain.set_far(100);\nterrain.set_focal_point(camera);\n\n// Store the root NodePath for convenience\nNodePath root = terrain.get_root();\nroot.reparent_to(window->get_render());\nroot.set_sz(100);\n\n// Generate it.\nterrain.generate();\n\n// Add a task to keep updating the terrain\ntaskMgr->add(new GenericAsyncTask(\"Updates terrain\", &UpdateTerrain, nullptr));\n\n// And the task, outside main:\nAsyncTask::DoneStatus UpdateTerrain(GenericAsyncTask *task, void *data) {\n  terrain.update();\n  return AsyncTask::DS_cont;\n}\n\nThis code shows a dynamically updated terrain, which is updated every frame with the camera as focal point. You see that a few functions are called: The blocksize is set to 32. This means that GeoMipTerrain has to divide the terrain in chunks of 32x32 quads. Then, the near and far distances are set. The Near distance is the distance from the focal point to where the terrain starts to decrease in quality. The far clip is the distance where the terrain is lowest quality. Also, the focal point is set to the Camera's NodePath; you can specify any NodePath you want, but also a Point2 or Point3. If you specify the latter, please note that only the X and Y positions are used to calculate the distance; the Z position is disregarded. Note that you need to experiment with those values to get a good quality terrain while still maintaining a good performance.\n\nNext, for convenience, the terrain root is stored in a separate variable, which is scaled and placed in the scene graph. The terrain is then initially generated, and a task is created which calls terrain.update() <.GeoMipTerrain.update> every frame. This function calculates the new LOD levels based on the movement of the focal point and updates the chunks which have got a new LOD level.\n\nAdvanced Control\n\nThe GeoMipTerrain provides some advanced features over the terrain:\n\nMinimum Level\n\nYou can specify a minimum LOD level to GeoMipTerrain. You can do this if you find the terrain a bit too high quality near the focal point, and this could waste your performance. If you set a minimum LOD level, you can prevent this and force the chunks to have a minimum level of detail:\n\npython\n\nterrain.setMinLevel(2)\n\ncpp\n\nterrain.set_min_level(2);\n\nIf you make the value higher, it will decrease the quality level near the focal point.\n\nAutomatic Flattening\n\nSince flattening the terrain root might interfere with the updating system, GeoMipTerrain provides an auto-flattening function, which can be really useful if you have too many meshes <too-many-meshes> in your scene. This function calls one of NodePath's flattening functions every time the terrain is regenerated, and each time before the chunks are modified the terrain is restored from a backup node:\n\npython\n\nterrain.setAutoFlatten(GeoMipTerrain.AFMStrong)\n\ncpp\n\nterrain.set_auto_flatten(GeoMipTerrain::AFM_strong);\n\nThere are multiple options: AFM_strong for ~.NodePath.flatten_strong(), AFM_medium for ~.NodePath.flatten_medium(), AFM_light for ~.NodePath.flatten_light(), and AFM_off for no flattening at all. After setting the AutoFlattenMode, GeoMipTerrain will automatically take care of it at the next ~.GeoMipTerrain.update() call.\n\nNotes\n\nFor a full function overview, see the ~panda3d.core.GeoMipTerrain page in the API Reference.\n\nThe GeoMipTerrain generates texture coordinates between 0 and 1, making the texture stretched over the entire terrain. If you are using a shader, please do not directly base the coordinates on the vtx_position, because since the terrain can have multiple chunks the vertex position is relative to the chunk. Instead, base your shader calculations on the vtx_texcoord0 generated by the GeoMipTerrain.\n\nThe GeoMipTerrain class implements part of the GeoMipMapping algorithm, described in this paper by Willem H. de Boer.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/34a01633_geometrical-mipmapping.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/6da47c38_34a01633_geometrical-mipmapping.json",
    "doc_id": "doc_707"
  }
}