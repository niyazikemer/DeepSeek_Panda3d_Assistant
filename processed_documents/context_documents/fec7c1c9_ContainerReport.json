{
  "content": "from __future__ import annotations\n\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.showbase.PythonUtil import Queue, invertDictLossless\nfrom direct.showbase.PythonUtil import safeRepr\nfrom direct.showbase.Job import Job\nfrom direct.showbase.JobManagerGlobal import jobMgr\nfrom direct.showbase.ContainerLeakDetector import deadEndTypes\nimport types\nimport io\n\n\nclass ContainerReport(Job):\n    notify = directNotify.newCategory(\"ContainerReport\")\n    # set of containers that should not be included in the report\n    PrivateIds: set[int] = set()\n\n    def __init__(self, name, log=False, limit=None, threaded=False):\n        Job.__init__(self, name)\n        self._log = log\n        self._limit = limit\n        # set up our data structures\n        self._visitedIds = set()\n        self._id2pathStr = {}\n        self._id2container = {}\n        self._type2id2len = {}\n        self._instanceDictIds = set()\n        # for breadth-first searching\n        self._queue = Queue()\n        jobMgr.add(self)\n        if not threaded:\n            jobMgr.finish(self)\n\n    def destroy(self):\n        del self._queue\n        del self._instanceDictIds\n        del self._type2id2len\n        del self._id2container\n        del self._id2pathStr\n        del self._visitedIds\n        del self._limit\n        del self._log\n\n    def finished(self):\n        if self._log:\n            self.destroy()\n\n    def run(self):\n        ContainerReport.PrivateIds.update(set([\n            id(ContainerReport.PrivateIds),\n            id(self._visitedIds),\n            id(self._id2pathStr),\n            id(self._id2container),\n            id(self._type2id2len),\n            id(self._queue),\n            id(self._instanceDictIds),\n        ]))\n        # push on a few things that we want to give priority\n        # for the sake of the variable-name printouts\n        try:\n            base\n        except NameError:\n            pass\n        else:\n            self._enqueueContainer(base.__dict__,\n                                   'base')\n        try:\n            simbase\n        except NameError:\n            pass\n        else:\n            self._enqueueContainer(simbase.__dict__,\n                                   'simbase')\n        self._queue.push(__builtins__)\n        self._id2pathStr[id(__builtins__)] = ''\n\n        while len(self._queue) > 0:\n            # yield up here instead of at the end, since we skip back to the\n            # top of the while loop from various points\n            yield None\n            parentObj = self._queue.pop()\n            #print '%s: %s, %s' % (id(parentObj), type(parentObj), self._id2pathStr[id(parentObj)])\n            isInstanceDict = False\n            if id(parentObj) in self._instanceDictIds:\n                isInstanceDict = True\n\n            try:\n                if parentObj.__class__.__name__ == 'method-wrapper':\n                    continue\n            except Exception:\n                pass\n\n            if isinstance(parentObj, (str, bytes)):\n                continue\n\n            if isinstance(parentObj, dict):\n                key = None\n                attr = None\n                keys = list(parentObj.keys())\n                try:\n                    keys.sort()\n                except TypeError as e:\n                    self.notify.warning('non-sortable dict keys: %s: %s' % (self._id2pathStr[id(parentObj)], repr(e)))\n                for key in keys:\n                    try:\n                        attr = parentObj[key]\n                    except KeyError as e:\n                        self.notify.warning('could not index into %s with key %s' % (self._id2pathStr[id(parentObj)],\n                                                                                     key))\n                    if id(attr) not in self._visitedIds:\n                        self._visitedIds.add(id(attr))\n                        if self._examine(attr):\n                            assert self._queue.back() is attr\n                            if parentObj is __builtins__:\n                                self._id2pathStr[id(attr)] = key\n                            else:\n                                if isInstanceDict:\n                                    self._id2pathStr[id(attr)] = self._id2pathStr[id(parentObj)] + '.%s' % key\n                                else:\n                                    self._id2pathStr[id(attr)] = self._id2pathStr[id(parentObj)] + '[%s]' % safeRepr(key)\n                del key\n                del attr\n                continue\n\n            # types.CellType was added in Python 3.8\n            if type(parentObj) is types.CellType:\n                child = parentObj.cell_contents\n                if self._examine(child):\n                    assert (self._queue.back() is child)\n                    self._instanceDictIds.add(id(child))\n                    self._id2pathStr[id(child)] = str(self._id2pathStr[id(parentObj)]) + '.cell_contents'\n                continue\n\n            if hasattr(parentObj, '__dict__'):\n                # Instance of a class\n                child = parentObj.__dict__\n                if self._examine(child):\n                    assert (self._queue.back() is child)\n                    self._instanceDictIds.add(id(child))\n                    self._id2pathStr[id(child)] = str(self._id2pathStr[id(parentObj)])\n                continue\n\n            if not isinstance(parentObj, io.TextIOWrapper):\n                try:\n                    itr = iter(parentObj)\n                except Exception:\n                    pass\n                else:\n                    try:\n                        index = 0\n                        while 1:\n                            try:\n                                attr = next(itr)\n                            except Exception:\n                                # some custom classes don't do well when iterated\n                                attr = None\n                                break\n                            if id(attr) not in self._visitedIds:\n                                self._visitedIds.add(id(attr))\n                                if self._examine(attr):\n                                    assert self._queue.back() is attr\n                                    self._id2pathStr[id(attr)] = self._id2pathStr[id(parentObj)] + '[%s]' % index\n                            index += 1\n                        del attr\n                    except StopIteration as e:\n                        pass\n                    del itr\n                    continue\n\n            try:\n                childNames = dir(parentObj)\n            except Exception:\n                pass\n            else:\n                childName = None\n                child = None\n                for childName in childNames:\n                    try:\n                        child = getattr(parentObj, childName)\n                    except Exception:\n                        continue\n                    if id(child) not in self._visitedIds:\n                        self._visitedIds.add(id(child))\n                        if self._examine(child):\n                            assert self._queue.back() is child\n                            self._id2pathStr[id(child)] = self._id2pathStr[id(parentObj)] + '.%s' % childName\n                del childName\n                del child\n                continue\n\n        if self._log:\n            self.printingBegin()\n            for i in self._output(limit=self._limit):\n                yield None\n            self.printingEnd()\n\n        yield Job.Done\n\n    def _enqueueContainer(self, obj, pathStr=None):\n        # call this to add a container that should be examined before any (other) direct\n        # children of __builtins__\n        # this is mostly to fix up the names of variables\n        self._queue.push(obj)\n        objId = id(obj)\n        if pathStr is not None:\n            self._id2pathStr[objId] = pathStr\n        # if it's a container, put it in the tables\n        try:\n            length = len(obj)\n        except Exception:\n            length = None\n        if length is not None and length > 0:\n            self._id2container[objId] = obj\n            self._type2id2len.setdefault(type(obj), {})\n            self._type2id2len[type(obj)][objId] = length\n\n    def _examine(self, obj):\n        # return False if it's an object that can't contain or lead to other objects\n        if type(obj) in deadEndTypes:\n            return False\n        # if it's an internal object, ignore it\n        if id(obj) in ContainerReport.PrivateIds:\n            return False\n        # this object might lead to more objects. put it on the queue\n        self._enqueueContainer(obj)\n        return True\n\n    def _outputType(self, type, limit=None):\n        if type not in self._type2id2len:\n            return\n        len2ids = invertDictLossless(self._type2id2len[type])\n        print('=====')\n        print('===== %s' % type)\n        count = 0\n        stop = False\n        for l in sorted(len2ids, reverse=True):\n            #len2ids[l].sort()\n            pathStrList = list()\n            for id in len2ids[l]:\n                obj = self._id2container[id]\n                #print '%s: %s' % (l, self._id2pathStr[id])\n                pathStrList.append(self._id2pathStr[id])\n                count += 1\n                if (count & 0x7f) == 0:\n                    yield None\n            pathStrList.sort()\n            for pathstr in pathStrList:\n                print('%s: %s' % (l, pathstr))\n            if limit is not None and count >= limit:\n                return\n\n    def _output(self, **kArgs):\n        print(\"===== ContainerReport: \\'%s\\' =====\" % (self._name,))\n        initialTypes = (dict, list, tuple)\n        for type in initialTypes:\n            for i in self._outputType(type, **kArgs):\n                yield None\n        otherTypes = set(self._type2id2len).difference(initialTypes)\n        for type in sorted(otherTypes, key=lambda obj: obj.__name__):\n            for i in self._outputType(type, **kArgs):\n                yield None\n\n    def log(self, **kArgs):\n        self._output(**kArgs)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/ContainerReport.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/fec7c1c9_ContainerReport.json",
    "doc_id": "doc_247"
  }
}