{
  "content": "Generalized Image Filters\n\ncpp\n\nNote\n\nSorry, but the CommonFilters and FilterManager classes are implemented in Python and will not be of much use to C++ users.\n\nThe Filter Manager\n\nClass FilterManager is designed to make it easier to apply filters to your scene. Of course, the easiest way to apply filters to your scene is to use class CommonFilters <common-image-filters>. But if that utility does not contain the filters you need, then the FilterManager is your next best choice. The main function of the FilterManager is to help you set up the offscreen buffers, the quads, and the textures.\n\nImport the class like this:\n\nfrom direct.filter.FilterManager import FilterManager\n\nThe Simplest Filter\n\nThe simplest possible code that uses the FilterManager looks like this:\n\nmanager = FilterManager(base.win, base.cam)\ntex = Texture()\nquad = manager.renderSceneInto(colortex=tex)\nquad.setShader(Shader.load(\"myfilter.sha\"))\nquad.setShaderInput(\"tex\", tex)\n\nThe first line creates an object of class FilterManager. We have told it that we want to apply filtering to the contents of the main window. We have also told it that we want to filter the stuff that's being rendered by the main camera, and not, for instance, the 2D camera.\n\nThe second line creates a texture - this is the texture that we're going to render the scene into.\n\nThe third line does most of the work. This removes the scene from the window, and instead, directs the rendering of the scene into 'tex'. It puts a quad into the window in place of the scene. The quad is returned.\n\nFinally, we apply a shader to the quad, and pass the scene texture to the shader. Presumably, the shader is rendering the scene onto the quad, which covers the window. Presto, filtered scene.\n\nThere's one tricky aspect of all this. Usually, the window is usually not a power of two. The texture will end up being bigger than the window: for instance, if the window is 800x600, then the texture will be 1024x1024. The scene will be rendered into the lower-left 800x600 pixels of the texture. The shader needs to compensate for this. If you forget this, you will see an empty band above and to the right of the texture.\n\nHere is a basic shader code example, it applies a simple black and white effect:\n\n//Cg\n\nvoid vshader(\n    float4 vtx_position : POSITION,\n    float2 vtx_texcoord0 : TEXCOORD0,\n    out float4 l_position : POSITION,\n    out float2 l_texcoord0 : TEXCOORD0,\n    uniform float4 texpad_tex,\n    uniform float4x4 mat_modelproj)\n{\n    l_position=mul(mat_modelproj, vtx_position);\n    l_texcoord0 = vtx_position.xz * texpad_tex.xy + texpad_tex.xy;\n}\n\nvoid fshader(float2 l_texcoord0 : TEXCOORD0,\n             out float4 o_color : COLOR,\n             uniform sampler2D k_tex : TEXUNIT0)\n{\n    float4 c = tex2D(k_tex, l_texcoord0);\n\n    // To have a useless filter that outputs the original view\n    // without changing anything, just use :\n    //o_color  = c;\n\n    // basic black and white effet\n    float moyenne = (c.x + c.y + c.z)/3;\n    o_color = float4(moyenne, moyenne, moyenne, 1);\n}\n\nExtracting More Information from the Scene\n\nIn addition to fetching the color buffer of the scene, you can also fetch the depth buffer:\n\nmanager = FilterManager(base.win, base.cam)\ntex = Texture()\ndtex = Texture()\nquad = manager.renderSceneInto(colortex=tex, depthtex=dtex)\n\nThe depth buffer is particularly useful for filters like depth-of-field. You can pass the depth-texture to the shader too.\n\nSometimes, scene rendering may generate not just a color buffer and a depth buffer, but also an auxiliary buffer. If so, you can fetch that too:\n\nmanager = FilterManager(base.win, base.cam)\ntex = Texture()\natex = Texture()\nquad = manager.renderSceneInto(colortex=tex, auxtex=atex)\n\nDoing this would really only make sense if you've asked the renderer to put something of interest into the auxiliary buffer. To do this, see AuxBitplaneAttrib.\n\nUsing Intermediate Stages\n\nThe setup shown above works for any filter that can be computed in one stage. However, for certain filters, you want to perform intermediate computations before putting the output into the window.\n\nThe method renderQuadInto creates a quad, and then causes that quad to be rendered into a texture. This is the classic intermediate processing step for image postprocessing. Using renderQuadInto, we can create a simple two-stage filter:\n\nmanager = FilterManager(base.win, base.cam)\ntex1 = Texture()\ntex2 = Texture()\nfinalquad = manager.renderSceneInto(colortex=tex1)\ninterquad = manager.renderQuadInto(colortex=tex2)\ninterquad.setShader(Shader.load(\"stage1.sha\"))\ninterquad.setShaderInput(\"tex1\", tex1)\nfinalquad.setShader(Shader.load(\"stage2.sha\"))\nfinalquad.setShaderInput(\"tex2\", tex2)\n\nSo tex1 will contain the raw, unfitered scene. Tex2 will contain a scene that has been filtered through stage1.sha. The window will contain a scene that has been filtered through both stage1.sha and stage2.sha.\n\nThe function 'renderQuadInto' accepts the keywords 'colortex', 'auxtex0', and 'auxtex1'. It does not accept 'depthtex,' since no depth buffer is used when rendering a quad.\n\nResolution Management\n\nUnless you specify otherwise, all textures will be the same resolution as the window. The FilterManager will preserve this condition - it will automatically resize the offscreen textures if the window gets resized.\n\nThe intermediate stages created by renderQuadInto can be the same size as the window, but they can also be larger or smaller by a constant factor. The function takes the following keyword arguments:\n\nmul - The 'mul' option multiplies the size by an integer constant.\n\ndiv - The 'div' option divides the size by an integer constant.\n\nalign - Relevant only when using the 'div' option - the window size is aligned to a specified alignment before dividing. This is useful to minimize resampling artifacts.\n\nCleaning Up\n\nThis function will cause the FilterManager to put everything back the way it started:\n\nmanager.cleanup()",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/b80495da_generalized-image-filters.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/abbc8ed0_b80495da_generalized-image-filters.json",
    "doc_id": "doc_392"
  }
}