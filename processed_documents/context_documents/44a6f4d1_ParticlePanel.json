{
  "content": "\"\"\"PANDA3D Particle Panel\"\"\"\n\n__all__ = ['ParticlePanel']\n\n# Import Tkinter, Pmw, and the floater code from this directory tree.\nfrom panda3d.core import ColorBlendAttrib, Filename, Point2, Point3, Vec3, Vec4, getModelPath\nfrom panda3d.physics import (\n    BaseParticleEmitter,\n    BaseParticleRenderer,\n    BoxEmitter,\n    ColorInterpolationFunctionConstant,\n    ColorInterpolationFunctionLinear,\n    ColorInterpolationFunctionSinusoid,\n    ColorInterpolationFunctionStepwave,\n    DiscEmitter,\n    GeomParticleRenderer,\n    LinearCylinderVortexForce,\n    LinearDistanceForce,\n    LinearFrictionForce,\n    LinearJitterForce,\n    LinearNoiseForce,\n    LinearSinkForce,\n    LinearSourceForce,\n    LinearUserDefinedForce,\n    LinearVectorForce,\n    LineEmitter,\n    LineParticleRenderer,\n    PointEmitter,\n    PointParticleRenderer,\n    RectangleEmitter,\n    RingEmitter,\n    SparkleParticleRenderer,\n    SphereSurfaceEmitter,\n    SphereVolumeEmitter,\n    SpriteAnim,\n    SpriteParticleRenderer,\n    TangentRingEmitter,\n)\nfrom panda3d.direct import getParticlePath\nfrom direct.tkwidgets.AppShell import AppShell\nfrom direct.tkwidgets import Dial\nfrom direct.tkwidgets import Floater\nfrom direct.tkwidgets import Slider\nfrom direct.tkwidgets import VectorWidgets\nfrom direct.tkpanels import Placer\nfrom direct.particles import ForceGroup\nfrom direct.particles import Particles\nfrom direct.particles import ParticleEffect\nfrom tkinter.filedialog import askopenfilename, asksaveasfilename\nfrom tkinter.simpledialog import askstring\nimport Pmw\nimport os\nimport tkinter as tk\n\n\nclass ParticlePanel(AppShell):\n    # Override class variables\n    appname = 'Particle Panel'\n    frameWidth  = 375\n    frameHeight = 675\n    usecommandarea = 0\n    usestatusarea  = 0\n    balloonState = 'both'\n\n    def __init__(self, particleEffect = None, **kw):\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            ('title',     self.appname,       None),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Record particle effect\n        if particleEffect is not None:\n            self.particleEffect = particleEffect\n        else:\n            # Make sure particles are enabled\n            base.enableParticles()\n\n            # Or create a new one if none given\n            particles = Particles.Particles()\n            particles.setBirthRate(0.02)\n            particles.setLitterSize(10)\n            particles.setLitterSpread(0)\n            particles.setFactory(\"PointParticleFactory\")\n            particles.setRenderer(\"PointParticleRenderer\")\n            particles.setEmitter(\"SphereVolumeEmitter\")\n            particles.enable()\n            pe = ParticleEffect.ParticleEffect('effect-1', particles)\n            self.particleEffect = pe\n            pe.reparentTo(render)\n            pe.enable()\n\n        # Initialize application specific info\n        AppShell.__init__(self)\n\n        # Initialize panel Pmw options\n        self.initialiseoptions(ParticlePanel)\n\n        # Update panel values to reflect particle effect's state\n        self.selectEffectNamed(next(iter(self.effectsDict)))\n        # Make sure labels/menus reflect current state\n        self.updateMenusAndLabels()\n        # Make sure there is a page for each forceGroup objects\n        for forceGroup in self.particleEffect.getForceGroupList():\n            self.addForceGroupNotebookPage(self.particleEffect, forceGroup)\n\n    def appInit(self):\n        # Create dictionaries to keep track of panel objects\n        self.widgetDict = {}\n        self.variableDict = {}\n        self.effectsDict = {}\n        self.effectsDict[self.particleEffect.getName()] = (\n            self.particleEffect)\n        self.forcePagesDict = {}\n\n    def createInterface(self):\n        # Handle to the toplevels hull\n        interior = self.interior()\n\n        # Create particle panel menu items\n\n        ## MENUBAR ENTRIES ##\n        # FILE MENU\n        # Get a handle on the file menu, and delete the Quit item that AppShell\n        # created so we can add it back after adding the other items.\n        self.menuBar.deletemenuitems('File', 0, 0)\n        self.menuBar.addmenuitem('File', 'command',\n                                 label='Load Params',\n                                 command=self.loadParticleEffectFromFile)\n        self.menuBar.addmenuitem('File', 'command',\n                                 label='Save Params',\n                                 command=self.saveParticleEffectToFile)\n        self.menuBar.addmenuitem('File', 'command',\n                                 label='Print Params',\n                                 command=lambda s=self:s.particles.printParams())\n        self.menuBar.addmenuitem('File', 'command', 'Quit this application',\n                                 label='Quit',\n                                 command=self.quit)\n\n        # PARTICLE MANAGER MENU\n        self.menuBar.addmenu('ParticleMgr', 'ParticleMgr Operations')\n        self.particleMgrActive = tk.IntVar()\n        self.particleMgrActive.set(base.isParticleMgrEnabled())\n        self.menuBar.addmenuitem(\n            'ParticleMgr', 'checkbutton',\n            'Enable/Disable ParticleMgr',\n            label = 'Active',\n            variable = self.particleMgrActive,\n            command = self.toggleParticleMgr)\n\n        ## MENUBUTTON LABELS ##\n        # Menubutton/label to identify the current objects being configured\n        labelFrame = tk.Frame(interior)\n        # Current effect\n        self.effectsLabel = tk.Menubutton(labelFrame, width = 10,\n                                          relief = tk.RAISED,\n                                          borderwidth = 2,\n                                          font=('MSSansSerif', 12, 'bold'),\n                                          activebackground = '#909090')\n        self.effectsLabelMenu = tk.Menu(self.effectsLabel, tearoff = 0)\n        self.effectsLabel['menu'] = self.effectsLabelMenu\n        self.effectsLabel.pack(side = tk.LEFT, fill = 'x', expand = 1)\n        self.bind(self.effectsLabel,\n                  'Select effect to configure or create new effect')\n        self.effectsLabelMenu.add_command(label = 'Create New Effect',\n                                          command = self.createNewEffect)\n        self.effectsLabelMenu.add_command(\n            label = 'Select Particle Effect',\n            command = lambda s = self: base.direct.select(s.particleEffect))\n        self.effectsLabelMenu.add_command(\n            label = 'Place Particle Effect',\n            command = lambda s = self: Placer.place(s.particleEffect))\n\n        def togglePEVis(s = self):\n            if s.particleEffect.isHidden():\n                s.particleEffect.show()\n            else:\n                s.particleEffect.hide()\n        self.effectsLabelMenu.add_command(\n            label = 'Toggle Effect Vis',\n            command = togglePEVis)\n        self.effectsEnableMenu = tk.Menu(self.effectsLabelMenu, tearoff = 0)\n        self.effectsLabelMenu.add_cascade(label = 'Enable/Disable',\n                                          menu = self.effectsEnableMenu)\n        self.effectsLabelMenu.add_separator()\n        # Current particles\n        self.particlesLabel = tk.Menubutton(labelFrame, width = 10,\n                                            relief = tk.RAISED,\n                                            borderwidth = 2,\n                                            font=('MSSansSerif', 12, 'bold'),\n                                            activebackground = '#909090')\n        self.particlesLabelMenu = tk.Menu(self.particlesLabel, tearoff = 0)\n        self.particlesLabel['menu'] = self.particlesLabelMenu\n        self.particlesLabel.pack(side = tk.LEFT, fill = 'x', expand = 1)\n        self.bind(self.particlesLabel,\n                  ('Select particles object to configure ' +\n                   'or add new particles object to current effect'))\n        self.particlesLabelMenu.add_command(label = 'Create New Particles',\n                                            command = self.createNewParticles)\n        self.particlesEnableMenu = tk.Menu(self.particlesLabelMenu, tearoff = 0)\n        self.particlesLabelMenu.add_cascade(label = 'Enable/Disable',\n                                            menu = self.particlesEnableMenu)\n        self.particlesLabelMenu.add_separator()\n        # Current force\n        self.forceGroupLabel = tk.Menubutton(labelFrame, width = 10,\n                                             relief = tk.RAISED,\n                                             borderwidth = 2,\n                                             font=('MSSansSerif', 12, 'bold'),\n                                             activebackground = '#909090')\n        self.forceGroupLabelMenu = tk.Menu(self.forceGroupLabel, tearoff = 0)\n        self.forceGroupLabel['menu'] = self.forceGroupLabelMenu\n        self.forceGroupLabel.pack(side = tk.LEFT, fill = 'x', expand = 1)\n        self.bind(self.forceGroupLabel,\n                  ('Select force group to configure ' +\n                   'or add a new force group to current effect'))\n        self.forceGroupLabelMenu.add_command(\n            label = 'Create New ForceGroup',\n            command = self.createNewForceGroup)\n        self.forceGroupEnableMenu = tk.Menu(self.forceGroupLabelMenu, tearoff = 0)\n        self.forceGroupLabelMenu.add_cascade(label = 'Enable/Disable',\n                                             menu = self.forceGroupEnableMenu)\n        self.forceGroupLabelMenu.add_separator()\n        # Pack labels\n        labelFrame.pack(fill = 'x', expand = 0)\n\n        # Create the toplevel notebook pages\n        self.mainNotebook = Pmw.NoteBook(interior)\n        self.mainNotebook.pack(fill = tk.BOTH, expand = 1)\n        systemPage = self.mainNotebook.add('System')\n        factoryPage = self.mainNotebook.add('Factory')\n        emitterPage = self.mainNotebook.add('Emitter')\n        rendererPage = self.mainNotebook.add('Renderer')\n        forcePage = self.mainNotebook.add('Force')\n        # Put this here so it isn't called right away\n        self.mainNotebook['raisecommand'] = self.updateInfo\n\n        ## SYSTEM PAGE WIDGETS ##\n        # Create system floaters\n        systemFloaterDefs = (\n            ('System', 'Pool Size',\n             'Max number of simultaneous particles',\n             self.setSystemPoolSize,\n             1.0, 2000000, 1.0),\n            ('System', 'Birth Rate',\n             'Seconds between particle births',\n             self.setSystemBirthRate,\n             0.0, None, None),\n            ('System', 'Litter Size',\n             'Number of particle created at each birth',\n             self.setSystemLitterSize,\n             1.0, 0x7fffffff, 1.0),\n            ('System', 'Litter Spread',\n             'Variation in litter size',\n             self.setSystemLitterSpread,\n             0.0, 0x7fffffff, 1.0),\n            ('System', 'Lifespan',\n             'Age in seconds at which the system (vs. particles) should die',\n             self.setSystemLifespan,\n             0.0, None, None)\n        )\n        self.createFloaters(systemPage, systemFloaterDefs)\n\n        # Checkboxes\n        self.createCheckbutton(\n            systemPage, 'System', 'Render Space Velocities',\n            ('On: velocities are in render space; ' +\n             'Off: velocities are in particle local space'),\n            self.toggleSystemLocalVelocity, 0)\n        self.createCheckbutton(\n            systemPage, 'System', 'System Grows Older',\n            'On: system has a lifespan',\n            self.toggleSystemGrowsOlder, 0)\n\n        # Vector widgets\n        pos = self.createVector3Entry(systemPage, 'System', 'Pos',\n                                      'Particle system position',\n                                      command = self.setSystemPos)\n        pos.addMenuItem('Popup Placer Panel', Placer.Placer)\n        hpr = self.createVector3Entry(systemPage, 'System', 'Hpr',\n                                     'Particle system orientation',\n                                      fGroup_labels = ('H', 'P', 'R'),\n                                      command = self.setSystemHpr)\n        hpr.addMenuItem('Popup Placer Panel', Placer.Placer)\n\n        ## FACTORY PAGE WIDGETS ##\n        self.createOptionMenu(\n            factoryPage,\n            'Factory', 'Factory Type',\n            'Select type of particle factory',\n            ('PointParticleFactory', 'ZSpinParticleFactory',\n             #'OrientedParticleFactory'\n             ),\n            self.selectFactoryType)\n        factoryWidgets = (\n            ('Factory', 'Life Span',\n             'Average particle lifespan in seconds',\n             self.setFactoryLifeSpan,\n             0.0, None, None),\n            ('Factory', 'Life Span Spread',\n             'Variation in lifespan',\n             self.setFactoryLifeSpanSpread,\n             0.0, None, None),\n            ('Factory', 'Mass',\n             'Average particle mass',\n             self.setFactoryParticleMass,\n             0.001, None, None),\n            ('Factory', 'Mass Spread',\n             'Variation in particle mass',\n             self.setFactoryParticleMassSpread,\n             0.0, None, None),\n            ('Factory', 'Terminal Velocity',\n             'Cap on average particle velocity',\n             self.setFactoryTerminalVelocity,\n             0.0, None, None),\n            ('Factory', 'Terminal Vel. Spread',\n             'Variation in terminal velocity',\n             self.setFactoryTerminalVelocitySpread,\n             0.0, None, None),\n        )\n        self.createFloaters(factoryPage, factoryWidgets)\n\n        self.factoryNotebook = Pmw.NoteBook(factoryPage, tabpos = None)\n        # Point page #\n        factoryPointPage = self.factoryNotebook.add('PointParticleFactory')\n        # Z spin page #\n        zSpinPage = self.factoryNotebook.add('ZSpinParticleFactory')\n\n        self.createCheckbutton(\n            zSpinPage, 'Z Spin Factory', 'Enable Angular Velocity',\n            'On: angular velocity is used; Off: final angle is used',\n            self.toggleAngularVelocity, 0, side = tk.TOP)\n\n        self.createFloater(\n            zSpinPage, 'Z Spin Factory', 'Angular Velocity',\n            'How fast sprites rotate',\n            command = self.setFactoryZSpinAngularVelocity)\n\n        self.createFloater(\n            zSpinPage, 'Z Spin Factory', 'Angular Velocity Spread',\n            'Variation in how fast sprites rotate',\n            command = self.setFactoryZSpinAngularVelocitySpread)\n\n        self.createAngleDial(zSpinPage, 'Z Spin Factory', 'Initial Angle',\n                             'Starting angle in degrees',\n                             fRollover = 1,\n                             command = self.setFactoryZSpinInitialAngle)\n        self.createAngleDial(\n            zSpinPage, 'Z Spin Factory',\n            'Initial Angle Spread',\n            'Spread of the initial angle',\n            fRollover = 1,\n            command = self.setFactoryZSpinInitialAngleSpread)\n        self.createAngleDial(zSpinPage, 'Z Spin Factory', 'Final Angle',\n                             'Final angle in degrees',\n                             fRollover = 1,\n                             command = self.setFactoryZSpinFinalAngle)\n        self.createAngleDial(\n            zSpinPage, 'Z Spin Factory',\n            'Final Angle Spread',\n            'Spread of the final angle',\n            fRollover = 1,\n            command = self.setFactoryZSpinFinalAngleSpread)\n        # Oriented page #\n        orientedPage = self.factoryNotebook.add('OrientedParticleFactory')\n        tk.Label(orientedPage, text = 'Not implemented').pack(expand = 1,\n                                                              fill = tk.BOTH)\n        self.factoryNotebook.pack(expand = 1, fill = tk.BOTH)\n\n        ## EMITTER PAGE WIDGETS ##\n        self.createOptionMenu(\n            emitterPage, 'Emitter',\n            'Emitter Type',\n            'Select type of particle emitter',\n            ('BoxEmitter', 'DiscEmitter', 'LineEmitter', 'PointEmitter',\n             'RectangleEmitter', 'RingEmitter', 'SphereVolumeEmitter',\n             'SphereSurfaceEmitter', 'TangentRingEmitter'),\n            self.selectEmitterType)\n\n        # Emitter modes\n        self.emissionType = tk.IntVar()\n        self.emissionType.set(BaseParticleEmitter.ETRADIATE)\n        emissionFrame = tk.Frame(emitterPage)\n        self.createRadiobutton(\n            emissionFrame, 'left',\n            'Emitter', 'Explicit Emission',\n            ('particles are all emitted in parallel, direction is based ' +\n             'on explicit velocity vector'),\n            self.emissionType, BaseParticleEmitter.ETEXPLICIT,\n            self.setEmissionType)\n        self.createRadiobutton(\n            emissionFrame, 'left',\n            'Emitter', 'Radiate Emission',\n            'particles are emitted away from a specific point',\n            self.emissionType, BaseParticleEmitter.ETRADIATE,\n            self.setEmissionType)\n        self.createRadiobutton(\n            emissionFrame, 'left',\n            'Emitter', 'Custom Emission',\n            ('particles are emitted with a velocity that ' +\n             'is determined by the particular emitter'),\n            self.emissionType, BaseParticleEmitter.ETCUSTOM,\n            self.setEmissionType)\n        emissionFrame.pack(fill = 'x', expand = 0)\n\n        self.createFloater(\n            emitterPage, 'Emitter', 'Velocity Multiplier',\n            'launch velocity multiplier (all emission modes)',\n            command = self.setEmitterAmplitude,\n            min = None)\n\n        self.createFloater(\n            emitterPage, 'Emitter', 'Velocity Multiplier Spread',\n            'spread for launch velocity multiplier (all emission modes)',\n            command = self.setEmitterAmplitudeSpread)\n\n        self.createVector3Entry(\n            emitterPage, 'Emitter', 'Offset Velocity',\n            'Velocity vector applied to all particles',\n            command = self.setEmitterOffsetForce)\n\n        self.createVector3Entry(\n            emitterPage, 'Emitter', 'Explicit Velocity',\n            'all particles launch with this velocity in Explicit mode',\n            command = self.setEmitterExplicitLaunchVector)\n\n        self.createVector3Entry(\n            emitterPage, 'Emitter', 'Radiate Origin',\n            'particles launch away from this point in Radiate mode',\n            command = self.setEmitterRadiateOrigin)\n\n        self.emitterNotebook = Pmw.NoteBook(emitterPage, tabpos = None)\n        # Box page #\n        boxPage = self.emitterNotebook.add('BoxEmitter')\n        self.createVector3Entry(boxPage, 'Box Emitter', 'Min',\n                                'Min point defining emitter box',\n                                command = self.setEmitterBoxPoint1)\n        self.createVector3Entry(boxPage, 'Box Emitter', 'Max',\n                                'Max point defining emitter box',\n                                command = self.setEmitterBoxPoint2,\n                                value = (1.0, 1.0, 1.0))\n        # Disc page #\n        discPage = self.emitterNotebook.add('DiscEmitter')\n        self.createFloater(discPage, 'Disc Emitter', 'Radius',\n                           'Radius of disc',\n                           command = self.setEmitterDiscRadius,\n                           min = 0.01)\n        customPage = self.discCustomFrame = tk.Frame(discPage)\n        self.createAngleDial(customPage, 'Disc Emitter', 'Inner Angle',\n                             'Particle launch angle at center of disc',\n                             command = self.setEmitterDiscInnerAngle)\n        self.createFloater(customPage, 'Disc Emitter', 'Inner Velocity',\n                           'Launch velocity multiplier at center of disc',\n                           command = self.setEmitterDiscInnerVelocity)\n        self.createAngleDial(customPage, 'Disc Emitter', 'Outer Angle',\n                             'Particle launch angle at outer edge of disc',\n                             command = self.setEmitterDiscOuterAngle)\n        self.createFloater(customPage, 'Disc Emitter', 'Outer Velocity',\n                           'Launch velocity multiplier at edge of disc',\n                           command = self.setEmitterDiscOuterVelocity)\n        self.createCheckbutton(\n            customPage, 'Disc Emitter', 'Cubic Lerping',\n            'On: magnitude/angle interpolation from center',\n            self.toggleEmitterDiscCubicLerping, 0)\n        customPage.pack(fill = tk.BOTH, expand = 1)\n\n        # Line page #\n        linePage = self.emitterNotebook.add('LineEmitter')\n        self.createVector3Entry(linePage, 'Line Emitter', 'Min',\n                                'Min point defining emitter line',\n                                command = self.setEmitterLinePoint1)\n        self.createVector3Entry(linePage, 'Line Emitter', 'Max',\n                                'Max point defining emitter line',\n                                command = self.setEmitterLinePoint2,\n                                value = (1.0, 0.0, 0.0))\n        # Point page #\n        emitterPointPage = self.emitterNotebook.add('PointEmitter')\n        self.createVector3Entry(emitterPointPage, 'Point Emitter', 'Position',\n                               'Position of emitter point',\n                                command = self.setEmitterPointPosition)\n        # Rectangle #\n        rectanglePage = self.emitterNotebook.add('RectangleEmitter')\n        self.createVector2Entry(rectanglePage,\n                                'Rectangle Emitter', 'Min',\n                               'Point defining rectangle',\n                                command = self.setEmitterRectanglePoint1)\n        self.createVector2Entry(rectanglePage,\n                                'Rectangle Emitter', 'Max',\n                               'Point defining rectangle',\n                                command = self.setEmitterRectanglePoint2)\n        # Ring #\n        ringPage = self.emitterNotebook.add('RingEmitter')\n        self.createFloater(ringPage, 'Ring Emitter', 'Radius',\n                           'Radius of ring',\n                           command = self.setEmitterRingRadius,\n                           min = 0.01)\n        self.createFloater(ringPage, 'Ring Emitter', 'Radius Spread',\n                           'Variation in radius of ring',\n                           command = self.setEmitterRingRadiusSpread,\n                           min = 0.0)\n        self.ringCustomFrame = tk.Frame(ringPage)\n        self.createAngleDial(self.ringCustomFrame, 'Ring Emitter', 'Angle',\n                             'Particle launch angle',\n                             command = self.setEmitterRingLaunchAngle)\n        self.ringCustomFrame.pack(fill = tk.BOTH, expand = 1)\n\n        # Sphere volume #\n        sphereVolumePage = self.emitterNotebook.add('SphereVolumeEmitter')\n        self.createFloater(sphereVolumePage, 'Sphere Volume Emitter', 'Radius',\n                           'Radius of sphere',\n                           command = self.setEmitterSphereVolumeRadius,\n                           min = 0.01)\n        # Sphere surface #\n        sphereSurfacePage = self.emitterNotebook.add('SphereSurfaceEmitter')\n        self.createFloater(sphereSurfacePage, 'Sphere Surface Emitter',\n                           'Radius',\n                           'Radius of sphere',\n                           command = self.setEmitterSphereSurfaceRadius,\n                           min = 0.01)\n        # Tangent ring #\n        tangentRingPage = self.emitterNotebook.add('TangentRingEmitter')\n        self.createFloater(tangentRingPage, 'Tangent Ring Emitter', 'Radius',\n                           'Radius of ring',\n                           command = self.setEmitterTangentRingRadius,\n                           min = 0.01)\n        self.createFloater(tangentRingPage, 'Tangent Ring Emitter',\n                           'Radius Spread',\n                           'Variation in radius of ring',\n                           command = self.setEmitterTangentRingRadiusSpread)\n        self.emitterNotebook.pack(fill = tk.X)\n\n        ## RENDERER PAGE WIDGETS ##\n        self.createOptionMenu(\n            rendererPage, 'Renderer', 'Renderer Type',\n            'Select type of particle renderer',\n            ('LineParticleRenderer', 'GeomParticleRenderer',\n             'PointParticleRenderer', 'SparkleParticleRenderer',\n             'SpriteParticleRenderer'),\n            self.selectRendererType)\n\n        self.createOptionMenu(rendererPage,\n                              'Renderer', 'Alpha Mode',\n                              \"alpha setting over particles' lifetime\",\n                              ('NO_ALPHA','ALPHA_IN','ALPHA_OUT',\n                               'ALPHA_IN_OUT', 'ALPHA_USER'),\n                              self.setRendererAlphaMode)\n\n        self.createSlider(\n            rendererPage, 'Renderer', 'User Alpha',\n            'alpha value for ALPHA_USER alpha mode',\n            command = self.setRendererUserAlpha)\n\n        self.rendererNotebook = Pmw.NoteBook(rendererPage, tabpos = None)\n        self.rendererNotebook.pack(fill = tk.BOTH, expand = 1)\n\n        # Line page #\n        linePage = self.rendererNotebook.add('LineParticleRenderer')\n        self.createColorEntry(linePage, 'Line Renderer', 'Head Color',\n                                'Head color of line',\n                                command = self.setRendererLineHeadColor)\n        self.createColorEntry(linePage, 'Line Renderer', 'Tail Color',\n                                'Tail color of line',\n                                command = self.setRendererLineTailColor)\n        self.createFloater(linePage, 'Line Renderer', 'Line Scale Factor',\n                           'Scale Factor applied to length of line',\n                           command = self.setRendererLineScaleFactor)\n\n        ############################################################################\n        # GEOM PARTICLE RENDERER PAGE #\n        ############################################################################\n        geomPage = self.rendererNotebook.add('GeomParticleRenderer')\n        f = tk.Frame(geomPage)\n        f.pack(fill = tk.X)\n\n        # Geom Node input field\n        tk.Label(f, width = 12, text = 'Geom Node', pady = 3).pack(side = tk.LEFT)\n        self.rendererGeomNode = tk.StringVar()\n        self.rendererGeomNodeEntry = tk.Entry(f, width = 12,\n                                              textvariable = self.rendererGeomNode)\n        self.rendererGeomNodeEntry.bind('<Return>', self.setRendererGeomNode)\n        self.rendererGeomNodeEntry.pack(side = tk.LEFT, expand = 1, fill = tk.X)\n\n        # Setup frames\n        f = tk.Frame(geomPage)\n        f.pack(fill = tk.BOTH, expand = 1)\n        rendererGeomNotebook = Pmw.NoteBook(f)\n        rendererGeomNotebook.pack(fill = tk.BOTH, expand = 1)\n\n        rendererGeomBlendPage = rendererGeomNotebook.add('Blend')\n        rendererGeomScalePage = rendererGeomNotebook.add('Scale')\n        rendererGeomInterpolationPage = rendererGeomNotebook.add('Interpolate')\n\n        ############################################################################\n        # Blend tab\n        p = tk.Frame(rendererGeomBlendPage)\n        p.pack(fill = tk.X)\n        self.createOptionMenu(p, 'Geom Renderer',\n                              'Color Blend',\n                              'How to render semi-transparent colors',\n                              ('MNone','MAdd','MSubtract','MInvSubtract','MMin','MMax'),\n                              self.setRendererGeomColorBlendMethod)\n        self.createOptionMenu(p, 'Geom Renderer',\n                              'Incoming Op.',\n                              'See ColorBlendAttrib.h for explanation',\n                              ('OOne','OIncomingColor','OOneMinusIncomingColor','OFbufferColor',\n                               'OOneMinusFbufferColor','OIncomingAlpha','OOneMinusIncomingAlpha',\n                               'OFbufferAlpha','OOneMinusFbufferAlpha','OConstantColor',\n                               'OOneMinusConstantColor','OConstantAlpha','OOneMinusConstantAlpha',\n                               'OIncomingColorSaturate','OZero'),\n                              self.setRendererGeomColorBlendIncomingOperand)\n        self.getVariable('Geom Renderer','Incoming Op.').set('OIncomingAlpha')\n        self.createOptionMenu(p, 'Geom Renderer',\n                              'Fbuffer Op.',\n                              'See ColorBlendAttrib.h for explanation',\n                              ('OOne','OIncomingColor','OOneMinusIncomingColor','OFbufferColor',\n                               'OOneMinusFbufferColor','OIncomingAlpha','OOneMinusIncomingAlpha',\n                               'OFbufferAlpha','OOneMinusFbufferAlpha','OConstantColor',\n                               'OOneMinusConstantColor','OConstantAlpha','OOneMinusConstantAlpha',\n                               'OZero'),\n                              self.setRendererGeomColorBlendFbufferOperand)\n        self.getVariable('Geom Renderer','Fbuffer Op.').set('OOneMinusIncomingAlpha')\n\n        ############################################################################\n        # Scale tab\n        p = tk.Frame(rendererGeomScalePage)\n        p.pack(fill = tk.X)\n\n        self.createCheckbutton(\n            p, 'Geom Renderer', 'X Scale',\n            (\"On: x scale is interpolated over particle's life; \" +\n             \"Off: stays as start_X_Scale\"),\n            self.toggleRendererGeomXScale, 0, side = tk.LEFT)\n        self.createCheckbutton(\n            p, 'Geom Renderer', 'Y Scale',\n            (\"On: y scale is interpolated over particle's life; \" +\n             \"Off: stays as start_Y_Scale\"),\n            self.toggleRendererGeomYScale, 0, side = tk.LEFT)\n        self.createCheckbutton(\n            p, 'Geom Renderer', 'Z Scale',\n            (\"On: z scale is interpolated over particle's life; \" +\n             \"Off: stays as start_Z_Scale\"),\n            self.toggleRendererGeomZScale, 0, side = tk.LEFT)\n\n        p = tk.Frame(rendererGeomScalePage)\n        p.pack(fill = tk.X)\n\n        self.createFloater(p, 'Geom Renderer',\n                           'Initial X Scale',\n                           'Initial X scaling factor',\n                           command = self.setRendererGeomInitialXScale)\n        self.createFloater(p, 'Geom Renderer',\n                           'Final X Scale',\n                           'Final X scaling factor, if xScale enabled',\n                           command = self.setRendererGeomFinalXScale)\n        self.createFloater(p, 'Geom Renderer',\n                           'Initial Y Scale',\n                           'Initial Y scaling factor',\n                           command = self.setRendererGeomInitialYScale)\n        self.createFloater(p, 'Geom Renderer',\n                           'Final Y Scale',\n                           'Final Y scaling factor, if yScale enabled',\n                           command = self.setRendererGeomFinalYScale)\n        self.createFloater(p, 'Geom Renderer',\n                           'Initial Z Scale',\n                           'Initial Z scaling factor',\n                           command = self.setRendererGeomInitialZScale)\n        self.createFloater(p, 'Geom Renderer',\n                           'Final Z Scale',\n                           'Final Z scaling factor, if zScale enabled',\n                           command = self.setRendererGeomFinalZScale)\n\n        ############################################################################\n        # Interpolate tab\n        p = tk.Frame(rendererGeomInterpolationPage)\n        p.pack(fill = tk.X)\n        addSegmentButton = tk.Menubutton(p, text = 'Add Segment',\n                                         relief = tk.RAISED,\n                                         borderwidth = 2,\n                                         font=('MSSansSerif', 14, 'bold'),\n                                         activebackground = '#909090')\n        segmentMenu = tk.Menu(addSegmentButton)\n        addSegmentButton['menu'] = segmentMenu\n        segmentMenu.add_command(label = 'Add Constant segment',\n                                command = self.addConstantInterpolationSegment)\n        segmentMenu.add_command(label = 'Add Linear segment',\n                                command = self.addLinearInterpolationSegment)\n        segmentMenu.add_command(label = 'Add Stepwave segment',\n                                command = self.addStepwaveInterpolationSegment)\n        segmentMenu.add_command(label = 'Add Sinusoid segment',\n                                command = self.addSinusoidInterpolationSegment)\n        addSegmentButton.pack(expand = 0)\n\n        sf = Pmw.ScrolledFrame(p, horizflex = 'elastic')\n        sf.pack(fill = tk.BOTH, expand = 1)\n\n        self.rendererGeomSegmentFrame = sf.interior()\n        self.rendererGeomSegmentFrame.pack(fill = tk.BOTH, expand = 1)\n        self.rendererSegmentWidgetList = []\n\n        rendererGeomNotebook.setnaturalsize()\n\n        ############################################################################\n        # POINT PARTICLE RENDERER PAGE #\n        ############################################################################\n        rendererPointPage = self.rendererNotebook.add('PointParticleRenderer')\n        self.createFloater(rendererPointPage, 'Point Renderer', 'Point Size',\n                           'Width and height of points in pixels',\n                           command = self.setRendererPointSize)\n        self.createColorEntry(rendererPointPage, 'Point Renderer',\n                              'Start Color',\n                               'Starting color of point',\n                              command = self.setRendererPointStartColor)\n        self.createColorEntry(rendererPointPage, 'Point Renderer',\n                              'End Color',\n                               'Ending color of point',\n                              command = self.setRendererPointEndColor)\n        self.createOptionMenu(rendererPointPage, 'Point Renderer',\n                              'Blend Type',\n                              'Type of color blending used for particle',\n                              ('PP_ONE_COLOR', 'PP_BLEND_LIFE',\n                               'PP_BLEND_VEL'),\n                              self.rendererPointSelectBlendType)\n        self.createOptionMenu(rendererPointPage, 'Point Renderer',\n                              'Blend Method',\n                              'Interpolation method between colors',\n                              ('PP_NO_BLEND', 'PP_BLEND_LINEAR',\n                               'PP_BLEND_CUBIC'),\n                              self.rendererPointSelectBlendMethod)\n        # Sparkle #\n        sparklePage = self.rendererNotebook.add('SparkleParticleRenderer')\n        self.createColorEntry(sparklePage, 'Sparkle Renderer',\n                              'Center Color',\n                              'Color of sparkle center',\n                              command = self.setRendererSparkleCenterColor)\n        self.createColorEntry(sparklePage, 'Sparkle Renderer',\n                              'Edge Color',\n                              'Color of sparkle line endpoints',\n                              command = self.setRendererSparkleEdgeColor)\n        self.createFloater(sparklePage, 'Sparkle Renderer',\n                           'Birth Radius',\n                           'Initial sparkle radius',\n                           command = self.setRendererSparkleBirthRadius)\n        self.createFloater(sparklePage, 'Sparkle Renderer',\n                           'Death Radius',\n                           'Final sparkle radius',\n                           command = self.setRendererSparkleDeathRadius)\n        self.createOptionMenu(sparklePage,\n                              'Sparkle Renderer', 'Life Scale',\n                              'Does particle scale over its lifetime?',\n                              ('SP_NO_SCALE', 'SP_SCALE'),\n                              self.setRendererSparkleLifeScale)\n        # Sprite #\n        spritePage = self.rendererNotebook.add('SpriteParticleRenderer')\n        f = tk.Frame(spritePage)\n        f.pack(fill = tk.BOTH, expand = 1)\n\n        rendererSpriteNotebook = Pmw.NoteBook(f)\n        rendererSpriteNotebook.pack(fill = tk.BOTH, expand = 1)\n\n        rendererSpriteTexturePage = rendererSpriteNotebook.add('Texture')\n        rendererSpriteScalePage = rendererSpriteNotebook.add('Scale')\n        rendererSpriteBlendPage = rendererSpriteNotebook.add('Blend')\n        rendererSpriteInterpolationPage = rendererSpriteNotebook.add('Interpolate')\n##################################################################################\n\n        p = tk.Frame(rendererSpriteTexturePage)\n        p.pack(fill = tk.BOTH, expand = 1)\n\n        bp = tk.Frame(p)\n        bp.pack(expand = 0, side = tk.TOP)\n\n        bbp = tk.Frame(bp)\n        bbp.pack()\n        self.createCheckbutton(\n            bbp, 'Sprite Renderer', 'Enable Animation',\n            (\"On: Multitexture node will be animated; \" +\n             \"Off: Only the first frame of a node is rendered\"),\n            self.setRendererSpriteAnimationEnable, 0, side = tk.LEFT)\n        self.createFloater(bbp, 'Sprite Renderer', 'Frame Rate', 'Animation frame rate',\n                           command = self.setRendererSpriteAnimationFrameRate).pack(side = tk.LEFT)\n\n        bbp = tk.Frame(bp)\n        bbp.pack(pady=3)\n        tk.Button(bbp, text = 'Add Texture',\n                  command = self.addRendererSpriteAnimationTexture).pack(pady = 3, padx = 15, side = tk.LEFT)\n        tk.Button(bbp, text = 'Add Animation',\n                  command = self.addRendererSpriteAnimationFromNode).pack(pady = 3, padx = 15, side = tk.LEFT)\n\n        pp = tk.Frame(p)\n        pp.pack(fill = tk.BOTH, expand = 1, pady = 3)\n        sf = Pmw.ScrolledFrame(pp, horizflex = 'elastic')\n        sf.pack(fill = tk.BOTH, expand = 1)\n\n        self.rendererSpriteAnimationFrame = sf.interior()\n        self.rendererSpriteAnimationFrame.pack(fill = tk.BOTH, expand = 1)\n        self.rendererSpriteAnimationWidgetList = []\n\n        self.rendererSpriteTexture = tk.StringVar()\n        self.rendererSpriteFile = tk.StringVar()\n        self.rendererSpriteNode = tk.StringVar()\n\n##################################################################################\n        p = tk.Frame(rendererSpriteScalePage)\n        p.pack(fill = tk.X)\n\n        self.createCheckbutton(\n            p, 'Sprite Renderer', 'X Scale',\n            (\"On: x scale is interpolated over particle's life; \" +\n             \"Off: stays as start_X_Scale\"),\n            self.toggleRendererSpriteXScale, 0, side = tk.LEFT)\n        self.createCheckbutton(\n            p, 'Sprite Renderer', 'Y Scale',\n            (\"On: y scale is interpolated over particle's life; \" +\n             \"Off: stays as start_Y_Scale\"),\n            self.toggleRendererSpriteYScale, 0, side = tk.LEFT)\n        self.createCheckbutton(\n            p, 'Sprite Renderer', 'Anim Angle',\n            (\"On: particles that are set to spin on the Z axis will \" +\n             \"spin appropriately\"),\n            self.toggleRendererSpriteAnimAngle, 0, side = tk.LEFT)\n        p = tk.Frame(rendererSpriteScalePage)\n        p.pack(fill = tk.X)\n        self.createFloater(p, 'Sprite Renderer',\n                           'Initial X Scale',\n                           'Initial X scaling factor',\n                           command = self.setRendererSpriteInitialXScale)\n        self.createFloater(p, 'Sprite Renderer',\n                           'Final X Scale',\n                           'Final X scaling factor, if xScale enabled',\n                           command = self.setRendererSpriteFinalXScale)\n        self.createFloater(p, 'Sprite Renderer',\n                           'Initial Y Scale',\n                           'Initial Y scaling factor',\n                           command = self.setRendererSpriteInitialYScale)\n        self.createFloater(p, 'Sprite Renderer',\n                           'Final Y Scale',\n                           'Final Y scaling factor, if yScale enabled',\n                           command = self.setRendererSpriteFinalYScale)\n        self.createAngleDial(p, 'Sprite Renderer',\n                             'Non Animated Theta',\n                             ('If animAngle is false: counter clockwise ' +\n                              'Z rotation of all sprites'),\n                             command = self.setRendererSpriteNonAnimatedTheta)\n        p = tk.Frame(rendererSpriteBlendPage)\n        p.pack(fill = tk.X)\n        self.createOptionMenu(p, 'Sprite Renderer',\n                              'Blend Type',\n                              'Interpolation blend type for X and Y scaling',\n                              ('PP_NO_BLEND', 'PP_LINEAR', 'PP_CUBIC'),\n                              self.setRendererSpriteBlendMethod)\n        self.createCheckbutton(\n            p, 'Sprite Renderer', 'Alpha Disable',\n            'On: alpha blending is disabled',\n            self.toggleRendererSpriteAlphaDisable, 0)\n        self.createOptionMenu(p, 'Sprite Renderer',\n                              'Color Blend',\n                              'How to render semi-transparent colors',\n                              ('MNone','MAdd','MSubtract','MInvSubtract','MMin','MMax'),\n                              self.setRendererSpriteColorBlendMethod)\n        self.createOptionMenu(p, 'Sprite Renderer',\n                              'Incoming Op.',\n                              'See ColorBlendAttrib.h for explanation',\n                              ('OOne','OIncomingColor','OOneMinusIncomingColor','OFbufferColor',\n                               'OOneMinusFbufferColor','OIncomingAlpha','OOneMinusIncomingAlpha',\n                               'OFbufferAlpha','OOneMinusFbufferAlpha','OConstantColor',\n                               'OOneMinusConstantColor','OConstantAlpha','OOneMinusConstantAlpha',\n                               'OIncomingColorSaturate','OZero'),\n                              self.setRendererSpriteColorBlendIncomingOperand)\n        self.getVariable('Sprite Renderer','Incoming Op.').set('OIncomingAlpha')\n        self.createOptionMenu(p, 'Sprite Renderer',\n                              'Fbuffer Op.',\n                              'See ColorBlendAttrib.h for explanation',\n                              ('OOne','OIncomingColor','OOneMinusIncomingColor','OFbufferColor',\n                               'OOneMinusFbufferColor','OIncomingAlpha','OOneMinusIncomingAlpha',\n                               'OFbufferAlpha','OOneMinusFbufferAlpha','OConstantColor',\n                               'OOneMinusConstantColor','OConstantAlpha','OOneMinusConstantAlpha',\n                               'OZero'),\n                              self.setRendererSpriteColorBlendFbufferOperand)\n        self.getVariable('Sprite Renderer','Fbuffer Op.').set('OOneMinusIncomingAlpha')\n        p = tk.Frame(rendererSpriteInterpolationPage)\n        p.pack(fill = tk.BOTH, expand = 1)\n        addSegmentButton = tk.Menubutton(p, text = 'Add Segment',\n                                         relief = tk.RAISED,\n                                         borderwidth = 2,\n                                         font=('MSSansSerif', 14, 'bold'),\n                                         activebackground = '#909090')\n        segmentMenu = tk.Menu(addSegmentButton)\n        addSegmentButton['menu'] = segmentMenu\n        segmentMenu.add_command(label = 'Add Constant segment',\n                                command = self.addConstantInterpolationSegment)\n        segmentMenu.add_command(label = 'Add Linear segment',\n                                command = self.addLinearInterpolationSegment)\n        segmentMenu.add_command(label = 'Add Stepwave segment',\n                                command = self.addStepwaveInterpolationSegment)\n        segmentMenu.add_command(label = 'Add Sinusoid segment',\n                                command = self.addSinusoidInterpolationSegment)\n        addSegmentButton.pack(expand = 0)\n\n        pp = tk.Frame(p)\n        pp.pack(fill = tk.BOTH, expand = 1, pady = 3)\n        sf = Pmw.ScrolledFrame(pp, horizflex = 'elastic')\n        sf.pack(fill = tk.BOTH, expand = 1)\n\n        self.rendererSpriteSegmentFrame = sf.interior()\n        self.rendererSpriteSegmentFrame.pack(fill = tk.BOTH, expand = 1)\n        self.rendererSegmentWidgetList = []\n\n        rendererSpriteNotebook.setnaturalsize()\n        ##########################################################\n        ## FORCE PAGE WIDGETS ##\n        self.addForceButton = tk.Menubutton(forcePage, text = 'Add Force',\n                                             relief = tk.RAISED,\n                                             borderwidth = 2,\n                                             font=('MSSansSerif', 14, 'bold'),\n                                             activebackground = '#909090')\n        forceMenu = tk.Menu(self.addForceButton)\n        self.addForceButton['menu'] = forceMenu\n        # DERIVED FROM LINEAR FORCE\n        # This also has: setVector\n        forceMenu.add_command(label = 'Add Linear Vector Force',\n                            command = self.addLinearVectorForce)\n        # Parameters: setAmplitude, setMassDependent, setVectorMasks\n        forceMenu.add_command(label = 'Add Linear Noise Force',\n                            command = self.addLinearNoiseForce)\n        forceMenu.add_command(label = 'Add Linear Jitter Force',\n                            command = self.addLinearJitterForce)\n        # This also has setCoef\n        forceMenu.add_command(label = 'Add Linear Friction Force',\n                            command = self.addLinearFrictionForce)\n        # This also has: setCoef, setLength, setRadius,\n        forceMenu.add_command(label = 'Add Linear Cylinder Vortex Force',\n                            command = self.addLinearCylinderVortexForce)\n\n        # DERIVED FROM LINEAR DISTANCE FORCE\n        # Parameters: setFalloffType, setForceCenter, setRadius\n        forceMenu.add_command(label = 'Add Linear Sink Force',\n                            command = self.addLinearSinkForce)\n        forceMenu.add_command(label = 'Add Linear Source Force',\n                            command = self.addLinearSourceForce)\n        \"\"\"\n        # Avoid for now\n        forceMenu.add_command(label = 'Add Linear User Defined Force',\n                            command = self.addLinearUserDefinedForce)\n        \"\"\"\n\n        self.addForceButton.pack(expand = 0)\n\n        # Scrolled frame to hold force widgets\n        self.sf = Pmw.ScrolledFrame(forcePage, horizflex = 'elastic')\n        self.sf.pack(fill = 'both', expand = 1)\n        self.forceFrame = self.sf.interior()\n        # Notebook to hold force widgets as the are added\n        self.forceGroupNotebook = Pmw.NoteBook(self.forceFrame, tabpos = None)\n        self.forceGroupNotebook.pack(fill = tk.X)\n\n        ########################################################################\n        self.factoryNotebook.setnaturalsize()\n        self.emitterNotebook.setnaturalsize()\n        self.rendererNotebook.setnaturalsize()\n        self.forceGroupNotebook.setnaturalsize()\n        self.mainNotebook.setnaturalsize()\n\n        # Make sure input variables processed\n        self.initialiseoptions(ParticlePanel)\n\n    ### WIDGET UTILITY FUNCTIONS ###\n    def createCheckbutton(self, parent, category, text,\n                          balloonHelp, command, initialState, side = 'top'):\n        bool = tk.BooleanVar()\n        bool.set(initialState)\n        widget = tk.Checkbutton(parent, text = text, anchor = tk.W,\n                                variable = bool)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X, side = side)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        self.variableDict[category + '-' + text] = bool\n        return widget\n\n    def createRadiobutton(self, parent, side, category, text,\n                          balloonHelp, variable, value,\n                          command):\n        widget = tk.Radiobutton(parent, text = text, anchor = tk.W,\n                                variable = variable, value = value)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(side = side, fill = tk.X)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createFloaters(self, parent, widgetDefinitions):\n        widgets = []\n        for category, label, balloonHelp, command, min, max, resolution in widgetDefinitions:\n            widgets.append(\n                self.createFloater(parent, category, label, balloonHelp,\n                                   command, min, max, resolution)\n            )\n        return widgets\n\n    def createFloater(self, parent, category, text, balloonHelp,\n                      command = None, min = 0.0, max = None, resolution = None,\n                      numDigits = None, **kw):\n        kw['text'] = text\n        kw['min'] = min\n        if max is not None:\n            kw['max'] = max\n        kw['resolution'] = resolution\n        if numDigits is None:\n            # If this is apparently an integer setting, show no decimals.\n            if resolution is not None and int(resolution) == resolution and \\\n                (min is None or int(min) == min) and \\\n                (max is None or int(max) == max):\n                numDigits = 0\n            else:\n                numDigits = 3\n        kw['numDigits'] = numDigits\n        widget = Floater.Floater(parent, **kw)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createAngleDial(self, parent, category, text, balloonHelp,\n                        command = None, **kw):\n        kw['text'] = text\n        kw['style'] = 'mini'\n        widget = Dial.AngleDial(parent, **kw)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createSlider(self, parent, category, text, balloonHelp,\n                     command = None, min = 0.0, max = 1.0,\n                     resolution = 0.001, **kw):\n        kw['text'] = text\n        kw['min'] = min\n        kw['max'] = max\n        kw['resolution'] = resolution\n        widget = Slider.Slider(parent, **kw)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createVector2Entry(self, parent, category, text, balloonHelp,\n                           command = None, **kw):\n        # Set label's text\n        kw['text'] = text\n        widget = VectorWidgets.Vector2Entry(parent, **kw)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createVector3Entry(self, parent, category, text, balloonHelp,\n                           command = None, **kw):\n        # Set label's text\n        kw['text'] = text\n        widget = VectorWidgets.Vector3Entry(parent, **kw)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createColorEntry(self, parent, category, text, balloonHelp,\n                         command = None, **kw):\n        # Set label's text\n        kw['text'] = text\n        widget = VectorWidgets.ColorEntry(parent, **kw)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X)\n        self.bind(widget, balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def createOptionMenu(self, parent, category, text, balloonHelp,\n                         items, command):\n        optionVar = tk.StringVar()\n        if len(items) > 0:\n            optionVar.set(items[0])\n        widget = Pmw.OptionMenu(parent, labelpos = tk.W, label_text = text,\n                                label_width = 12, menu_tearoff = 1,\n                                menubutton_textvariable = optionVar,\n                                items = items)\n        # Do this after the widget so command isn't called on creation\n        widget['command'] = command\n        widget.pack(fill = tk.X)\n        self.bind(widget.component('menubutton'), balloonHelp)\n        self.widgetDict[category + '-' + text] = widget\n        self.variableDict[category + '-' + text] = optionVar\n        return optionVar\n\n    def createComboBox(self, parent, category, text, balloonHelp,\n                         items, command, history = 0):\n        widget = Pmw.ComboBox(parent,\n                              labelpos = tk.W,\n                              label_text = text,\n                              label_anchor = 'w',\n                              label_width = 12,\n                              entry_width = 16,\n                              history = history,\n                              scrolledlist_items = items)\n        # Don't allow user to edit entryfield\n        widget.configure(entryfield_entry_state = 'disabled')\n        # Select first item if it exists\n        if len(items) > 0:\n            widget.selectitem(items[0])\n        # Bind selection command\n        widget['selectioncommand'] = command\n        widget.pack(side = 'left', expand = 0)\n        # Bind help\n        self.bind(widget, balloonHelp)\n        # Record widget\n        self.widgetDict[category + '-' + text] = widget\n        return widget\n\n    def updateMenusAndLabels(self):\n        self.updateMenus()\n        self.updateLabels()\n\n    def updateLabels(self):\n        self.effectsLabel['text'] = self.particleEffect.getName()\n        self.particlesLabel['text'] = self.particles.getName()\n        if self.forceGroup is not None:\n            self.forceGroupLabel['text'] = self.forceGroup.getName()\n        else:\n            self.forceGroupLabel['text'] = 'Force Group'\n\n    def updateMenus(self):\n        self.updateEffectsMenus()\n        self.updateParticlesMenus()\n        self.updateForceGroupMenus()\n\n    def updateEffectsMenus(self):\n        # Get rid of old effects entries if any\n        self.effectsEnableMenu.delete(0, 'end')\n        self.effectsLabelMenu.delete(5, 'end')\n        self.effectsLabelMenu.add_separator()\n        # Add in a checkbutton for each effect (to toggle on/off)\n        keys = sorted(self.effectsDict.keys())\n        for name in keys:\n            effect = self.effectsDict[name]\n            self.effectsLabelMenu.add_command(\n                label = effect.getName(),\n                command = (lambda s = self,\n                           e = effect: s.selectEffectNamed(e.getName()))\n            )\n            effectActive = tk.IntVar()\n            effectActive.set(effect.isEnabled())\n            self.effectsEnableMenu.add_checkbutton(\n                label = effect.getName(),\n                variable = effectActive,\n                command = (lambda s = self,\n                           e = effect,\n                           v = effectActive: s.toggleEffect(e, v)))\n\n    def updateParticlesMenus(self):\n        # Get rid of old particles entries if any\n        self.particlesEnableMenu.delete(0, 'end')\n        self.particlesLabelMenu.delete(2, 'end')\n        self.particlesLabelMenu.add_separator()\n        # Add in a checkbutton for each effect (to toggle on/off)\n        particles = self.particleEffect.getParticlesList()\n        for name in sorted(x.getName() for x in particles):\n            particle = self.particleEffect.getParticlesNamed(name)\n            self.particlesLabelMenu.add_command(\n                label = name,\n                command = (lambda s = self,\n                           n = name: s.selectParticlesNamed(n))\n            )\n            particleActive = tk.IntVar()\n            particleActive.set(particle.isEnabled())\n            self.particlesEnableMenu.add_checkbutton(\n                label = name,\n                variable = particleActive,\n                command = (lambda s = self,\n                           p = particle,\n                           v = particleActive: s.toggleParticles(p, v)))\n\n    def updateForceGroupMenus(self):\n        # Get rid of old forceGroup entries if any\n        self.forceGroupEnableMenu.delete(0, 'end')\n        self.forceGroupLabelMenu.delete(2, 'end')\n        self.forceGroupLabelMenu.add_separator()\n        # Add in a checkbutton for each effect (to toggle on/off)\n        forceGroupList = self.particleEffect.getForceGroupList()\n        for name in sorted(x.getName() for x in forceGroupList):\n            force = self.particleEffect.getForceGroupNamed(name)\n            self.forceGroupLabelMenu.add_command(\n                label = name,\n                command = (lambda s = self,\n                           n = name: s.selectForceGroupNamed(n))\n            )\n            forceActive = tk.IntVar()\n            forceActive.set(force.isEnabled())\n            self.forceGroupEnableMenu.add_checkbutton(\n                label = name,\n                variable = forceActive,\n                command = (lambda s = self,\n                           f = force,\n                           v = forceActive: s.toggleForceGroup(f, v)))\n\n    def selectEffectNamed(self, name):\n        effect = self.effectsDict.get(name, None)\n        if effect is not None:\n            self.particleEffect = effect\n            # Default to first particle in particlesDict\n            self.particles = self.particleEffect.getParticlesList()[0]\n            # See if particle effect has any forceGroup\n            forceGroupList = self.particleEffect.getForceGroupList()\n            if len(forceGroupList) > 0:\n                self.forceGroup = forceGroupList[0]\n            else:\n                self.forceGroup = None\n            self.mainNotebook.selectpage('System')\n            self.updateInfo('System')\n        else:\n            print('ParticlePanel: No effect named ' + name)\n\n    def toggleEffect(self, effect, var):\n        if var.get():\n            effect.enable()\n        else:\n            effect.disable()\n\n    def selectParticlesNamed(self, name):\n        particles = self.particleEffect.getParticlesNamed(name)\n        if particles is not None:\n            self.particles = particles\n            self.updateInfo()\n\n    def toggleParticles(self, particles, var):\n        if var.get():\n            particles.enable()\n        else:\n            particles.disable()\n\n    def selectForceGroupNamed(self, name):\n        forceGroup = self.particleEffect.getForceGroupNamed(name)\n        if forceGroup is not None:\n            self.forceGroup = forceGroup\n            self.updateInfo('Force')\n\n    def toggleForceGroup(self, forceGroup, var):\n        if var.get():\n            forceGroup.enable()\n        else:\n            forceGroup.disable()\n\n    def toggleForce(self, force, pageName, variableName):\n        v = self.getVariable(pageName, variableName)\n        if v.get():\n            force.setActive(1)\n        else:\n            force.setActive(0)\n\n    def getWidget(self, category, text):\n        return self.widgetDict[category + '-' + text]\n\n    def getVariable(self, category, text):\n        return self.variableDict[category + '-' + text]\n\n    def loadParticleEffectFromFile(self):\n        # Find path to particle directory\n        pPath = getParticlePath()\n        if pPath.getNumDirectories() > 0:\n            if repr(pPath.getDirectory(0)) == '.':\n                path = '.'\n            else:\n                path = pPath.getDirectory(0).toOsSpecific()\n        else:\n            path = '.'\n        if not os.path.isdir(path):\n            print('ParticlePanel Warning: Invalid default DNA directory!')\n            print('Using current directory')\n            path = '.'\n        particleFilename = askopenfilename(\n            defaultextension = '.ptf',\n            filetypes = (('Particle Files', '*.ptf'), ('All files', '*')),\n            initialdir = path,\n            title = 'Load Particle Effect',\n            parent = self.parent)\n        if particleFilename and particleFilename != 'None':\n            # Delete existing particles and forces\n            self.particleEffect.loadConfig(\n                Filename.fromOsSpecific(particleFilename))\n            self.selectEffectNamed(self.particleEffect.getName())\n            # Enable effect\n            self.particleEffect.enable()\n\n    def saveParticleEffectToFile(self):\n        # Find path to particle directory\n        pPath = getParticlePath()\n        if pPath.getNumDirectories() > 0:\n            if repr(pPath.getDirectory(0)) == '.':\n                path = '.'\n            else:\n                path = pPath.getDirectory(0).toOsSpecific()\n        else:\n            path = '.'\n        if not os.path.isdir(path):\n            print('ParticlePanel Warning: Invalid default DNA directory!')\n            print('Using current directory')\n            path = '.'\n        particleFilename = asksaveasfilename(\n            defaultextension = '.ptf',\n            filetypes = (('Particle Files', '*.ptf'), ('All files', '*')),\n            initialdir = path,\n            title = 'Save Particle Effect as',\n            parent = self.parent)\n        if particleFilename:\n            self.particleEffect.saveConfig(Filename(particleFilename))\n\n    ### PARTICLE EFFECTS COMMANDS ###\n    def toggleParticleMgr(self):\n        if self.particleMgrActive.get():\n            base.enableParticles()\n        else:\n            base.disableParticles()\n\n    ### PARTICLE SYSTEM COMMANDS ###\n    def updateInfo(self, page = 'System'):\n        self.updateMenusAndLabels()\n        if page == 'System':\n            self.updateSystemWidgets()\n        elif page == 'Factory':\n            self.selectFactoryPage()\n            self.updateFactoryWidgets()\n        elif page == 'Emitter':\n            self.selectEmitterPage()\n            self.updateEmitterWidgets()\n        elif page == 'Renderer':\n            self.selectRendererPage()\n            self.updateRendererWidgets()\n        elif page == 'Force':\n            self.updateForceWidgets()\n\n    def toggleParticleEffect(self):\n        if self.getVariable('Effect', 'Active').get():\n            self.particleEffect.enable()\n        else:\n            self.particleEffect.disable()\n\n    ## SYSTEM PAGE ##\n    def updateSystemWidgets(self):\n        poolSize = self.particles.getPoolSize()\n        self.getWidget('System', 'Pool Size').set(int(poolSize), 0)\n        birthRate = self.particles.getBirthRate()\n        self.getWidget('System', 'Birth Rate').set(birthRate, 0)\n        litterSize = self.particles.getLitterSize()\n        self.getWidget('System', 'Litter Size').set(int(litterSize), 0)\n        litterSpread = self.particles.getLitterSpread()\n        self.getWidget('System', 'Litter Spread').set(litterSpread, 0)\n        systemLifespan = self.particles.getSystemLifespan()\n        self.getWidget('System', 'Lifespan').set(systemLifespan, 0)\n        pos = self.particles.nodePath.getPos()\n        self.getWidget('System', 'Pos').set([pos[0], pos[1], pos[2]], 0)\n        hpr = self.particles.nodePath.getHpr()\n        self.getWidget('System', 'Hpr').set([hpr[0], hpr[1], hpr[2]], 0)\n        self.getVariable('System', 'Render Space Velocities').set(\n            self.particles.getLocalVelocityFlag())\n        self.getVariable('System', 'System Grows Older').set(\n            self.particles.getSystemGrowsOlderFlag())\n\n    def setSystemPoolSize(self, value):\n        self.particles.setPoolSize(int(value))\n\n    def setSystemBirthRate(self, value):\n        self.particles.setBirthRate(value)\n\n    def setSystemLitterSize(self, value):\n        self.particles.setLitterSize(int(value))\n\n    def setSystemLitterSpread(self, value):\n        self.particles.setLitterSpread(int(value))\n\n    def setSystemLifespan(self, value):\n        self.particles.setSystemLifespan(value)\n\n    def toggleSystemLocalVelocity(self):\n        self.particles.setLocalVelocityFlag(\n            self.getVariable('System', 'Render Space Velocities').get())\n\n    def toggleSystemGrowsOlder(self):\n        self.particles.setSystemGrowsOlderFlag(\n            self.getVariable('System', 'System Grows Older').get())\n\n    def setSystemPos(self, pos):\n        self.particles.nodePath.setPos(Vec3(pos[0], pos[1], pos[2]))\n\n    def setSystemHpr(self, pos):\n        self.particles.nodePath.setHpr(Vec3(pos[0], pos[1], pos[2]))\n\n    ## FACTORY PAGE ##\n    def selectFactoryType(self, type):\n        self.factoryNotebook.selectpage(type)\n        self.particles.setFactory(type)\n        self.updateFactoryWidgets()\n\n    def selectFactoryPage(self):\n        pass\n\n    def updateFactoryWidgets(self):\n        factory = self.particles.factory\n        lifespan = factory.getLifespanBase()\n        self.getWidget('Factory', 'Life Span').set(lifespan, 0)\n        lifespanSpread = factory.getLifespanSpread()\n        self.getWidget('Factory', 'Life Span Spread').set(lifespanSpread, 0)\n        mass = factory.getMassBase()\n        self.getWidget('Factory', 'Mass').set(mass, 0)\n        massSpread = factory.getMassSpread()\n        self.getWidget('Factory', 'Mass Spread').set(massSpread, 0)\n        terminalVelocity = factory.getTerminalVelocityBase()\n        self.getWidget('Factory', 'Terminal Velocity').set(terminalVelocity, 0)\n        terminalVelocitySpread = factory.getTerminalVelocitySpread()\n        self.getWidget('Factory', 'Terminal Vel. Spread').set(\n            terminalVelocitySpread, 0)\n\n    def setFactoryLifeSpan(self, value):\n        self.particles.factory.setLifespanBase(value)\n\n    def setFactoryLifeSpanSpread(self, value):\n        self.particles.factory.setLifespanSpread(value)\n\n    def setFactoryParticleMass(self, value):\n        self.particles.factory.setMassBase(value)\n\n    def setFactoryParticleMassSpread(self, value):\n        self.particles.factory.setMassSpread(value)\n\n    def setFactoryTerminalVelocity(self, value):\n        self.particles.factory.setTerminalVelocityBase(value)\n\n    def setFactoryTerminalVelocitySpread(self, value):\n        self.particles.factory.setTerminalVelocitySpread(value)\n    # Point Page #\n    # Z Spin Page #\n\n    def setFactoryZSpinInitialAngle(self, angle):\n        self.particles.factory.setInitialAngle(angle)\n\n    def setFactoryZSpinInitialAngleSpread(self, spread):\n        self.particles.factory.setInitialAngleSpread(spread)\n\n    def setFactoryZSpinFinalAngle(self, angle):\n        self.particles.factory.setFinalAngle(angle)\n\n    def setFactoryZSpinFinalAngleSpread(self, spread):\n        self.particles.factory.setFinalAngleSpread(spread)\n\n    def setFactoryZSpinAngularVelocity(self, vel):\n        self.particles.factory.setAngularVelocity(vel)\n\n    def setFactoryZSpinAngularVelocitySpread(self, spread):\n        self.particles.factory.setAngularVelocitySpread(spread)\n\n    ## EMITTER PAGE ##\n    def selectEmitterType(self, type):\n        self.emitterNotebook.selectpage(type)\n        self.particles.setEmitter(type)\n        self.updateEmitterWidgets()\n\n    def selectEmitterPage(self):\n        type = self.particles.emitter.__class__.__name__\n        self.emitterNotebook.selectpage(type)\n        self.getVariable('Emitter', 'Emitter Type').set(type)\n\n    def updateEmitterWidgets(self):\n        emitter = self.particles.emitter\n        self.setEmissionType(self.particles.emitter.getEmissionType())\n        amp = emitter.getAmplitude()\n        self.getWidget('Emitter', 'Velocity Multiplier').set(amp)\n        spread = emitter.getAmplitudeSpread()\n        self.getWidget('Emitter', 'Velocity Multiplier Spread').set(spread)\n        vec = emitter.getOffsetForce()\n        self.getWidget('Emitter', 'Offset Velocity').set(\n            [vec[0], vec[1], vec[2]], 0)\n        vec = emitter.getRadiateOrigin()\n        self.getWidget('Emitter', 'Radiate Origin').set(\n            [vec[0], vec[1], vec[2]], 0)\n        vec = emitter.getExplicitLaunchVector()\n        self.getWidget('Emitter', 'Explicit Velocity').set(\n            [vec[0], vec[1], vec[2]], 0)\n        if isinstance(emitter, BoxEmitter):\n            min = emitter.getMinBound()\n            self.getWidget('Box Emitter', 'Min').set(\n                [min[0], min[1], min[2]], 0)\n            max = emitter.getMaxBound()\n            self.getWidget('Box Emitter', 'Max').set(\n                [max[0], max[1], max[2]], 0)\n        elif isinstance(emitter, DiscEmitter):\n            radius = emitter.getRadius()\n            self.getWidget('Disc Emitter', 'Radius').set(radius, 0)\n            innerAngle = emitter.getInnerAngle()\n            self.getWidget('Disc Emitter', 'Inner Angle').set(innerAngle, 0)\n            innerMagnitude = emitter.getInnerMagnitude()\n            self.getWidget('Disc Emitter', 'Inner Velocity').set(\n                innerMagnitude, 0)\n            outerAngle = emitter.getOuterAngle()\n            self.getWidget('Disc Emitter', 'Outer Angle').set(outerAngle, 0)\n            outerMagnitude = emitter.getOuterMagnitude()\n            self.getWidget('Disc Emitter', 'Inner Velocity').set(\n                outerMagnitude, 0)\n            cubicLerping = emitter.getCubicLerping()\n            self.getVariable('Disc Emitter', 'Cubic Lerping').set(cubicLerping)\n        elif isinstance(emitter, LineEmitter):\n            min = emitter.getEndpoint1()\n            self.getWidget('Line Emitter', 'Min').set(\n                [min[0], min[1], min[2]], 0)\n            max = emitter.getEndpoint2()\n            self.getWidget('Line Emitter', 'Max').set(\n                [max[0], max[1], max[2]], 0)\n        elif isinstance(emitter, PointEmitter):\n            location = emitter.getLocation()\n            self.getWidget('Point Emitter', 'Position').set(\n                [location[0], location[1], location[2]], 0)\n        elif isinstance(emitter, RectangleEmitter):\n            min = emitter.getMinBound()\n            self.getWidget('Rectangle Emitter', 'Min').set(\n                [min[0], min[1]], 0)\n            max = emitter.getMaxBound()\n            self.getWidget('Rectangle Emitter', 'Max').set(\n                [max[0], max[1]], 0)\n        elif isinstance(emitter, RingEmitter):\n            radius = emitter.getRadius()\n            self.getWidget('Ring Emitter', 'Radius').set(radius, 0)\n            radiusSpread = emitter.getRadiusSpread()\n            self.getWidget('Ring Emitter', 'Radius Spread').set(radiusSpread, 0)\n            angle = emitter.getAngle()\n            self.getWidget('Ring Emitter', 'Angle').set(angle, 0)\n        elif isinstance(emitter, SphereVolumeEmitter):\n            radius = emitter.getRadius()\n            self.getWidget('Sphere Volume Emitter', 'Radius').set(radius, 0)\n        elif isinstance(emitter, SphereSurfaceEmitter):\n            radius = emitter.getRadius()\n            self.getWidget('Sphere Surface Emitter', 'Radius').set(radius, 0)\n        elif isinstance(emitter, TangentRingEmitter):\n            radius = emitter.getRadius()\n            self.getWidget('Tangent Ring Emitter', 'Radius').set(radius, 0)\n            radiusSpread = emitter.getRadiusSpread()\n            self.getWidget('Tangent Ring Emitter', 'Radius Spread').set(\n                radiusSpread, 0)\n    # All #\n\n    def setEmissionType(self, newType = None):\n        if newType:\n            type = newType\n            self.emissionType.set(type)\n        else:\n            type = self.emissionType.get()\n        self.particles.emitter.setEmissionType(type)\n        if type == BaseParticleEmitter.ETEXPLICIT:\n            self.getWidget(\n                'Emitter', 'Radiate Origin')['state'] = 'disabled'\n            self.getWidget(\n                'Emitter', 'Explicit Velocity')['state'] = 'normal'\n            # Hide custom widgets\n            if isinstance(self.particles.emitter, DiscEmitter):\n                self.discCustomFrame.pack_forget()\n            elif isinstance(self.particles.emitter, RingEmitter):\n                self.ringCustomFrame.pack_forget()\n        elif type == BaseParticleEmitter.ETRADIATE:\n            self.getWidget(\n                'Emitter', 'Radiate Origin')['state'] = 'normal'\n            self.getWidget(\n                'Emitter', 'Explicit Velocity')['state'] = 'disabled'\n\n            # Hide custom widgets\n            if isinstance(self.particles.emitter, DiscEmitter):\n                self.discCustomFrame.pack_forget()\n            elif isinstance(self.particles.emitter, RingEmitter):\n                self.ringCustomFrame.pack_forget()\n        elif type == BaseParticleEmitter.ETCUSTOM:\n            self.getWidget(\n                'Emitter', 'Radiate Origin')['state'] = 'disabled'\n            self.getWidget(\n                'Emitter', 'Explicit Velocity')['state'] = 'disabled'\n            # Show custom widgets\n            if isinstance(self.particles.emitter, DiscEmitter):\n                self.discCustomFrame.pack(fill = tk.BOTH, expand = 1)\n            elif isinstance(self.particles.emitter, RingEmitter):\n                self.ringCustomFrame.pack(fill = tk.BOTH, expand = 1)\n\n    def setEmitterAmplitude(self, value):\n        self.particles.emitter.setAmplitude(value)\n\n    def setEmitterAmplitudeSpread(self, value):\n        self.particles.emitter.setAmplitudeSpread(value)\n\n    def setEmitterOffsetForce(self, vec):\n        self.particles.emitter.setOffsetForce(\n            Vec3(vec[0], vec[1], vec[2]))\n\n    def setEmitterRadiateOrigin(self, origin):\n        self.particles.emitter.setRadiateOrigin(\n            Point3(origin[0], origin[1], origin[2]))\n\n    def setEmitterExplicitLaunchVector(self, vec):\n        self.particles.emitter.setExplicitLaunchVector(\n            Vec3(vec[0], vec[1], vec[2]))\n\n    # Box #\n    def setEmitterBoxPoint1(self, point):\n        self.particles.emitter.setMinBound(Point3(point[0],\n                                                  point[1],\n                                                  point[2]))\n\n    def setEmitterBoxPoint2(self, point):\n        self.particles.emitter.setMaxBound(Point3(point[0],\n                                                  point[1],\n                                                  point[2]))\n    # Disc #\n\n    def setEmitterDiscRadius(self, radius):\n        self.particles.emitter.setRadius(radius)\n\n    def setEmitterDiscInnerAngle(self, angle):\n        self.particles.emitter.setInnerAngle(angle)\n\n    def setEmitterDiscInnerVelocity(self, velocity):\n        self.particles.emitter.setInnerMagnitude(velocity)\n\n    def setEmitterDiscOuterAngle(self, angle):\n        self.particles.emitter.setOuterAngle(angle)\n\n    def setEmitterDiscOuterVelocity(self, velocity):\n        self.particles.emitter.setOuterMagnitude(velocity)\n\n    def toggleEmitterDiscCubicLerping(self):\n        self.particles.emitter.setCubicLerping(\n            self.getVariable('Disc Emitter', 'Cubic Lerping').get())\n    # Line #\n\n    def setEmitterLinePoint1(self, point):\n        self.particles.emitter.setEndpoint1(Point3(point[0],\n                                                   point[1],\n                                                   point[2]))\n\n    def setEmitterLinePoint2(self, point):\n        self.particles.emitter.setEndpoint2(Point3(point[0],\n                                                   point[1],\n                                                   point[2]))\n    # Point #\n\n    def setEmitterPointPosition(self, pos):\n        self.particles.emitter.setLocation(Point3(pos[0], pos[1], pos[2]))\n    # Rectangle #\n\n    def setEmitterRectanglePoint1(self, point):\n        self.particles.emitter.setMinBound(Point2(point[0], point[1]))\n\n    def setEmitterRectanglePoint2(self, point):\n        self.particles.emitter.setMaxBound(Point2(point[0], point[1]))\n    # Ring #\n\n    def setEmitterRingRadius(self, radius):\n        self.particles.emitter.setRadius(radius)\n\n    def setEmitterRingRadiusSpread(self, radiusSpread):\n        self.particles.emitter.setRadiusSpread(radiusSpread)\n\n    def setEmitterRingLaunchAngle(self, angle):\n        self.particles.emitter.setAngle(angle)\n    # Sphere surface #\n\n    def setEmitterSphereSurfaceRadius(self, radius):\n        self.particles.emitter.setRadius(radius)\n    # Sphere volume #\n\n    def setEmitterSphereVolumeRadius(self, radius):\n        self.particles.emitter.setRadius(radius)\n    # Tangent ring #\n\n    def setEmitterTangentRingRadius(self, radius):\n        self.particles.emitter.setRadius(radius)\n\n    def setEmitterTangentRingRadiusSpread(self, radiusSpread):\n        self.particles.emitter.setRadiusSpread(radiusSpread)\n\n    ## RENDERER PAGE ##\n    def selectRendererType(self, type):\n        self.rendererNotebook.selectpage(type)\n        self.particles.setRenderer(type)\n        self.updateRendererWidgets()\n\n    def updateRendererWidgets(self):\n        renderer = self.particles.renderer\n        alphaMode = renderer.getAlphaMode()\n        if alphaMode == BaseParticleRenderer.PRALPHANONE:\n            aMode = 'NO_ALPHA'\n        elif alphaMode == BaseParticleRenderer.PRALPHAOUT:\n            aMode = 'ALPHA_OUT'\n        elif alphaMode == BaseParticleRenderer.PRALPHAIN:\n            aMode = 'ALPHA_IN'\n        elif alphaMode == BaseParticleRenderer.PRALPHAINOUT:\n            aMode = 'ALPHA_IN_OUT'\n        elif alphaMode == BaseParticleRenderer.PRALPHAUSER:\n            aMode = 'ALPHA_USER'\n        self.getVariable('Renderer', 'Alpha Mode').set(aMode)\n        userAlpha = renderer.getUserAlpha()\n        self.getWidget('Renderer', 'User Alpha').set(userAlpha)\n\n        if isinstance(renderer, LineParticleRenderer):\n            headColor = renderer.getHeadColor() * 255.0\n            self.getWidget('Line Renderer', 'Head Color').set(\n                [headColor[0], headColor[1], headColor[2], headColor[3]])\n            tailColor = renderer.getTailColor() * 255.0\n            self.getWidget('Line Renderer', 'Tail Color').set(\n                [tailColor[0], tailColor[1], tailColor[2], tailColor[3]])\n            self.getWidget('Line Renderer', 'Line Scale Factor').set(\n                renderer.getLineScaleFactor())\n\n        elif isinstance(renderer, GeomParticleRenderer):\n            self.getVariable('Geom Renderer', 'X Scale').set(\n                renderer.getXScaleFlag())\n            self.getVariable('Geom Renderer', 'Y Scale').set(\n                renderer.getYScaleFlag())\n            self.getVariable('Geom Renderer', 'Z Scale').set(\n                renderer.getZScaleFlag())\n            initialXScale = renderer.getInitialXScale()\n            self.getWidget('Geom Renderer', 'Initial X Scale').set(\n                initialXScale)\n            initialYScale = renderer.getInitialYScale()\n            self.getWidget('Geom Renderer', 'Initial Y Scale').set(\n                initialYScale)\n            initialZScale = renderer.getInitialZScale()\n            self.getWidget('Geom Renderer', 'Initial Z Scale').set(\n                initialZScale)\n            finalXScale = renderer.getFinalXScale()\n            self.getWidget('Geom Renderer', 'Final X Scale').set(\n                finalXScale)\n            finalYScale = renderer.getFinalYScale()\n            self.getWidget('Geom Renderer', 'Final Y Scale').set(\n                finalYScale)\n            finalZScale = renderer.getFinalZScale()\n            self.getWidget('Geom Renderer', 'Final Z Scale').set(\n                finalZScale)\n            if self.getVariable('Geom Renderer','Color Blend').get() in ['MAdd','MSubtract','MInvSubtract']:\n                self.getWidget('Geom Renderer','Incoming Op.').pack(fill = tk.X)\n                self.getWidget('Geom Renderer','Fbuffer Op.').pack(fill = tk.X)\n            else:\n                self.getWidget('Geom Renderer','Incoming Op.').pack_forget()\n                self.getWidget('Geom Renderer','Fbuffer Op.').pack_forget()\n            for x in self.rendererSegmentWidgetList:\n                x.pack_forget()\n                x.destroy()\n            self.rendererSegmentWidgetList = []\n            for id in self.particles.renderer.getColorInterpolationManager().getSegmentIdList().split():\n                self.createWidgetForExistingInterpolationSegment(eval(id))\n\n        elif isinstance(renderer, PointParticleRenderer):\n            pointSize = renderer.getPointSize()\n            self.getWidget('Point Renderer', 'Point Size').set(pointSize)\n            startColor = renderer.getStartColor() * 255.0\n            self.getWidget('Point Renderer', 'Start Color').set(\n                [startColor[0], startColor[1], startColor[2], startColor[3]])\n            endColor = renderer.getEndColor() * 255.0\n            self.getWidget('Point Renderer', 'End Color').set(\n                [endColor[0], endColor[1], endColor[2], endColor[3]])\n            blendType = renderer.getBlendType()\n            if blendType == PointParticleRenderer.PPONECOLOR:\n                bType = \"PP_ONE_COLOR\"\n            elif blendType == PointParticleRenderer.PPBLENDLIFE:\n                bType = \"PP_BLEND_LIFE\"\n            elif blendType == PointParticleRenderer.PPBLENDVEL:\n                bType = \"PP_BLEND_VEL\"\n            self.getVariable('Point Renderer', 'Blend Type').set(bType)\n            blendMethod = renderer.getBlendMethod()\n            bMethod = \"PP_NO_BLEND\"\n            if blendMethod == BaseParticleRenderer.PPNOBLEND:\n                bMethod = \"PP_NO_BLEND\"\n            elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n                bMethod = \"PP_BLEND_LINEAR\"\n            elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n                bMethod = \"PP_BLEND_CUBIC\"\n            self.getVariable('Point Renderer', 'Blend Method').set(bMethod)\n\n        elif isinstance(renderer, SparkleParticleRenderer):\n            centerColor = renderer.getCenterColor() * 255.0\n            self.getWidget('Sparkle Renderer', 'Center Color').set(\n                [centerColor[0], centerColor[1],\n                 centerColor[2], centerColor[3]])\n            edgeColor = renderer.getEdgeColor() * 255.0\n            self.getWidget('Sparkle Renderer', 'Edge Color').set(\n                [edgeColor[0], edgeColor[1], edgeColor[2], edgeColor[3]])\n            birthRadius = renderer.getBirthRadius()\n            self.getWidget('Sparkle Renderer', 'Birth Radius').set(birthRadius)\n            deathRadius = renderer.getDeathRadius()\n            self.getWidget('Sparkle Renderer', 'Death Radius').set(deathRadius)\n            lifeScale = renderer.getLifeScale()\n            lScale = \"SP_NO_SCALE\"\n            if lifeScale == SparkleParticleRenderer.SPSCALE:\n                lScale = \"SP_SCALE\"\n            self.getVariable('Sparkle Renderer', 'Life Scale').set(lScale)\n\n        elif isinstance(renderer, SpriteParticleRenderer):\n            self.getWidget('Sprite Renderer','Frame Rate').set(renderer.getAnimateFramesRate(), 0)\n            self.getVariable('Sprite Renderer','Enable Animation').set(\n                renderer.getAnimateFramesEnable())\n            self.readSpriteRendererAnimations() # Updates widgets with renderer data.\n            self.getVariable('Sprite Renderer', 'X Scale').set(\n                renderer.getXScaleFlag())\n            self.getVariable('Sprite Renderer', 'Y Scale').set(\n                renderer.getYScaleFlag())\n            self.getVariable('Sprite Renderer', 'Anim Angle').set(\n                renderer.getAnimAngleFlag())\n            initialXScale = renderer.getInitialXScale()\n            self.getWidget('Sprite Renderer', 'Initial X Scale').set(\n                initialXScale)\n            initialYScale = renderer.getInitialYScale()\n            self.getWidget('Sprite Renderer', 'Initial Y Scale').set(\n                initialYScale)\n            finalXScale = renderer.getFinalXScale()\n            self.getWidget('Sprite Renderer', 'Final X Scale').set(\n                finalXScale)\n            finalYScale = renderer.getFinalYScale()\n            self.getWidget('Sprite Renderer', 'Final Y Scale').set(\n                finalYScale)\n            nonanimatedTheta = renderer.getNonanimatedTheta()\n            self.getWidget('Sprite Renderer', 'Non Animated Theta').set(\n                nonanimatedTheta)\n            blendMethod = renderer.getAlphaBlendMethod()\n            bMethod = \"PP_NO_BLEND\"\n            if blendMethod == BaseParticleRenderer.PPNOBLEND:\n                bMethod = \"PP_NO_BLEND\"\n            elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n                bMethod = \"PP_BLEND_LINEAR\"\n            elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n                bMethod = \"PP_BLEND_CUBIC\"\n            self.getVariable('Sprite Renderer', 'Alpha Disable').set(\n                renderer.getAlphaDisable())\n            if self.getVariable('Sprite Renderer','Color Blend').get() in ['MAdd','MSubtract','MInvSubtract']:\n                self.getWidget('Sprite Renderer','Incoming Op.').pack(fill = tk.X)\n                self.getWidget('Sprite Renderer','Fbuffer Op.').pack(fill = tk.X)\n            else:\n                self.getWidget('Sprite Renderer','Incoming Op.').pack_forget()\n                self.getWidget('Sprite Renderer','Fbuffer Op.').pack_forget()\n            for x in self.rendererSegmentWidgetList:\n                x.pack_forget()\n                x.destroy()\n            self.rendererSegmentWidgetList = []\n            for id in self.particles.renderer.getColorInterpolationManager().getSegmentIdList().split():\n                self.createWidgetForExistingInterpolationSegment(eval(id))\n\n    def selectRendererPage(self):\n        type = self.particles.renderer.__class__.__name__\n        if type == 'SpriteParticleRendererExt':\n            type = 'SpriteParticleRenderer'\n        self.rendererNotebook.selectpage(type)\n        self.getVariable('Renderer', 'Renderer Type').set(type)\n\n    # All #\n    def setRendererAlphaMode(self, alphaMode):\n        if alphaMode == 'NO_ALPHA':\n            aMode = BaseParticleRenderer.PRALPHANONE\n        elif alphaMode == 'ALPHA_OUT':\n            aMode = BaseParticleRenderer.PRALPHAOUT\n        elif alphaMode == 'ALPHA_IN':\n            aMode = BaseParticleRenderer.PRALPHAIN\n        elif alphaMode == 'ALPHA_IN_OUT':\n            aMode = BaseParticleRenderer.PRALPHAINOUT\n        elif alphaMode == 'ALPHA_USER':\n            aMode = BaseParticleRenderer.PRALPHAUSER\n        self.particles.renderer.setAlphaMode(aMode)\n\n    def setRendererUserAlpha(self, alpha):\n        self.particles.renderer.setUserAlpha(alpha)\n\n    # Line #\n    def setRendererLineHeadColor(self, color):\n        self.particles.renderer.setHeadColor(\n            Vec4(color[0]/255.0, color[1]/255.0,\n                 color[2]/255.0, color[3]/255.0))\n\n    def setRendererLineTailColor(self, color):\n        self.particles.renderer.setTailColor(\n            Vec4(color[0]/255.0, color[1]/255.0,\n                 color[2]/255.0, color[3]/255.0))\n\n    def setRendererLineScaleFactor(self, sf):\n        self.particles.renderer.setLineScaleFactor(sf)\n    # Geom #\n\n    def setRendererGeomNode(self, event):\n        node = None\n        nodePath = base.loader.loadModel(self.rendererGeomNode.get())\n        if nodePath is not None:\n            node = nodePath.node()\n        if node is not None:\n            self.particles.geomReference = self.rendererGeomNode.get()\n            self.particles.renderer.setGeomNode(node)\n    # Point #\n\n    def setRendererPointSize(self, size):\n        self.particles.renderer.setPointSize(size)\n\n    def setRendererPointStartColor(self, color):\n        self.particles.renderer.setStartColor(\n            Vec4(color[0]/255.0, color[1]/255.0,\n                 color[2]/255.0, color[3]/255.0))\n\n    def setRendererPointEndColor(self, color):\n        self.particles.renderer.setEndColor(\n            Vec4(color[0]/255.0, color[1]/255.0,\n                 color[2]/255.0, color[3]/255.0))\n\n    def rendererPointSelectBlendType(self, blendType):\n        if blendType == \"PP_ONE_COLOR\":\n            bType = PointParticleRenderer.PPONECOLOR\n        elif blendType == \"PP_BLEND_LIFE\":\n            bType = PointParticleRenderer.PPBLENDLIFE\n        elif blendType == \"PP_BLEND_VEL\":\n            bType = PointParticleRenderer.PPBLENDVEL\n        self.particles.renderer.setBlendType(bType)\n\n    def rendererPointSelectBlendMethod(self, blendMethod):\n        if blendMethod == \"PP_NO_BLEND\":\n            bMethod = BaseParticleRenderer.PPNOBLEND\n        elif blendMethod == \"PP_BLEND_LINEAR\":\n            bMethod = BaseParticleRenderer.PPBLENDLINEAR\n        elif blendMethod == \"PP_BLEND_CUBIC\":\n            bMethod = BaseParticleRenderer.PPBLENDCUBIC\n        self.particles.renderer.setBlendMethod(bMethod)\n    # Sparkle #\n\n    def setRendererSparkleCenterColor(self, color):\n        self.particles.renderer.setCenterColor(\n            Vec4(color[0]/255.0, color[1]/255.0,\n                 color[2]/255.0, color[3]/255.0))\n\n    def setRendererSparkleEdgeColor(self, color):\n        self.particles.renderer.setEdgeColor(\n            Vec4(color[0]/255.0, color[1]/255.0,\n                 color[2]/255.0, color[3]/255.0))\n\n    def setRendererSparkleBirthRadius(self, radius):\n        self.particles.renderer.setBirthRadius(radius)\n\n    def setRendererSparkleDeathRadius(self, radius):\n        self.particles.renderer.setDeathRadius(radius)\n\n    def setRendererSparkleLifeScale(self, lifeScaleMethod):\n        if lifeScaleMethod == 'SP_NO_SCALE':\n            lScale = SparkleParticleRenderer.SPNOSCALE\n        else:\n            lScale = SparkleParticleRenderer.SPSCALE\n        self.particles.renderer.setLifeScale(lScale)\n    # Sprite #\n\n    def setSpriteSourceType(self):\n        if self.rendererSpriteSourceType.get() == 0:\n            self.rendererSpriteTextureEntry['state'] = 'normal'\n            self.rendererSpriteFileEntry['state'] = 'disabled'\n            self.rendererSpriteNodeEntry['state'] = 'disabled'\n            self.rendererSpriteTextureEntry['background'] = '#FFFFFF'\n            self.rendererSpriteFileEntry['background'] = '#C0C0C0'\n            self.rendererSpriteNodeEntry['background'] = '#C0C0C0'\n        else:\n            self.rendererSpriteTextureEntry['state'] = 'disabled'\n            self.rendererSpriteFileEntry['state'] = 'normal'\n            self.rendererSpriteNodeEntry['state'] = 'normal'\n            self.rendererSpriteTextureEntry['background'] = '#C0C0C0'\n            self.rendererSpriteFileEntry['background'] = '#FFFFFF'\n            self.rendererSpriteNodeEntry['background'] = '#FFFFFF'\n\n    def setRendererSpriteAnimationFrameRate(self, rate):\n        self.particles.renderer.setAnimateFramesRate(rate)\n\n    def setRendererSpriteAnimationEnable(self):\n        self.particles.renderer.setAnimateFramesEnable(\n            self.getVariable('Sprite Renderer','Enable Animation').get())\n\n    def addRendererSpriteAnimationTexture(self):\n        ren = self.particles.getRenderer()\n        parent = self.rendererSpriteAnimationFrame\n\n        if ren.addTextureFromFile():\n            animId = len([x for x in self.rendererSpriteAnimationWidgetList if x and x.valid])\n            anim = ren.getAnim(animId)\n\n            frameNum = len([x for x in self.rendererSpriteAnimationWidgetList if x])\n\n            self.rendererSpriteAnimationWidgetList.append(\n                self.createSpriteAnimationTextureWidget(parent, anim, repr(frameNum)))\n        else:\n            animId = len([x for x in self.rendererSpriteAnimationWidgetList if x and x.valid])\n            anim = SpriteAnim.STTexture\n\n            frameNum = len([x for x in self.rendererSpriteAnimationWidgetList if x])\n\n            self.rendererSpriteAnimationWidgetList.append(\n                self.createSpriteAnimationTextureWidget(parent, anim, repr(frameNum)))\n        parent.pack(fill=tk.BOTH, expand=1)\n\n    def addRendererSpriteAnimationFromNode(self):\n        ren = self.particles.getRenderer()\n        parent = self.rendererSpriteAnimationFrame\n\n        if ren.addTextureFromNode():\n            animId = len([x for x in self.rendererSpriteAnimationWidgetList if x and x.valid])\n            anim = ren.getAnim(animId)\n\n            frameNum = len([x for x in self.rendererSpriteAnimationWidgetList if x])\n\n            self.rendererSpriteAnimationWidgetList.append(\n                self.createSpriteAnimationNodeWidget(parent, anim, repr(frameNum)))\n        else:\n            animId = len([x for x in self.rendererSpriteAnimationWidgetList if x and x.valid])\n            anim = SpriteAnim.STFromNode\n\n            frameNum = len([x for x in self.rendererSpriteAnimationWidgetList if x])\n\n            self.rendererSpriteAnimationWidgetList.append(\n                self.createSpriteAnimationNodeWidget(parent, anim, repr(frameNum)))\n        parent.pack(fill=tk.BOTH, expand=1)\n\n    def toggleRendererSpriteXScale(self):\n        self.particles.renderer.setXScaleFlag(\n            self.getVariable('Sprite Renderer', 'X Scale').get())\n\n    def toggleRendererSpriteYScale(self):\n        self.particles.renderer.setYScaleFlag(\n            self.getVariable('Sprite Renderer', 'Y Scale').get())\n\n    def toggleRendererSpriteAnimAngle(self):\n        self.particles.renderer.setAnimAngleFlag(\n            self.getVariable('Sprite Renderer', 'Anim Angle').get())\n\n    def toggleAngularVelocity(self):\n        self.particles.factory.enableAngularVelocity(\n            self.getVariable('Z Spin Factory', 'Enable Angular Velocity').get())\n\n    def setRendererSpriteInitialXScale(self, xScale):\n        self.particles.renderer.setInitialXScale(xScale)\n\n    def setRendererSpriteFinalXScale(self, xScale):\n        self.particles.renderer.setFinalXScale(xScale)\n\n    def setRendererSpriteInitialYScale(self, yScale):\n        self.particles.renderer.setInitialYScale(yScale)\n\n    def setRendererSpriteFinalYScale(self, yScale):\n        self.particles.renderer.setFinalYScale(yScale)\n\n    def setRendererSpriteNonAnimatedTheta(self, theta):\n        self.particles.renderer.setNonanimatedTheta(theta)\n\n    def setRendererSpriteBlendMethod(self, blendMethod):\n        if blendMethod == 'PP_NO_BLEND':\n            bMethod = BaseParticleRenderer.PPNOBLEND\n        elif blendMethod == 'PP_BLEND_LINEAR':\n            bMethod = BaseParticleRenderer.PPBLENDLINEAR\n        elif blendMethod == 'PP_BLEND_CUBIC':\n            bMethod = BaseParticleRenderer.PPBLENDCUBIC\n        else:\n            bMethod = BaseParticleRenderer.PPNOBLEND\n\n    def toggleRendererSpriteAlphaDisable(self):\n        self.particles.renderer.setAlphaDisable(\n            self.getVariable('Sprite Renderer', 'Alpha Disable').get())\n\n    def setRendererColorBlendAttrib(self, rendererName, blendMethodStr, incomingOperandStr, fbufferOperandStr):\n        self.particles.getRenderer().setColorBlendMode(getattr(ColorBlendAttrib, blendMethodStr),\n                                                       getattr(ColorBlendAttrib, incomingOperandStr),\n                                                       getattr(ColorBlendAttrib, fbufferOperandStr))\n\n        if blendMethodStr in ['MAdd','MSubtract','MInvSubtract']:\n            self.getWidget(rendererName,'Incoming Op.').pack(fill = tk.X)\n            self.getWidget(rendererName,'Fbuffer Op.').pack(fill = tk.X)\n        else:\n            self.getWidget(rendererName,'Incoming Op.').pack_forget()\n            self.getWidget(rendererName,'Fbuffer Op.').pack_forget()\n\n        self.updateRendererWidgets()\n\n    def setRendererSpriteColorBlendMethod(self, blendMethod):\n        blendMethodStr = blendMethod\n        incomingOperandStr = self.getVariable('Sprite Renderer','Incoming Op.').get()\n        fbufferOperandStr = self.getVariable('Sprite Renderer','Fbuffer Op.').get()\n\n        self.setRendererColorBlendAttrib('Sprite Renderer', blendMethodStr, incomingOperandStr, fbufferOperandStr)\n\n    def setRendererSpriteColorBlendIncomingOperand(self, operand):\n        blendMethodStr = self.getVariable('Sprite Renderer','Color Blend').get()\n        incomingOperandStr = operand\n        fbufferOperandStr = self.getVariable('Sprite Renderer','Fbuffer Op.').get()\n\n        self.setRendererColorBlendAttrib('Sprite Renderer', blendMethodStr, incomingOperandStr, fbufferOperandStr)\n\n    def setRendererSpriteColorBlendFbufferOperand(self, operand):\n        blendMethodStr = self.getVariable('Sprite Renderer','Color Blend').get()\n        incomingOperandStr = self.getVariable('Sprite Renderer','Incoming Op.').get()\n        fbufferOperandStr = operand\n        self.setRendererColorBlendAttrib('Sprite Renderer', blendMethodStr, incomingOperandStr, fbufferOperandStr)\n\n    # GeomParticleRenderer Functionality\n\n    def toggleRendererGeomXScale(self):\n        self.particles.renderer.setXScaleFlag(\n            self.getVariable('Geom Renderer', 'X Scale').get())\n\n    def toggleRendererGeomYScale(self):\n        self.particles.renderer.setYScaleFlag(\n            self.getVariable('Geom Renderer', 'Y Scale').get())\n\n    def toggleRendererGeomZScale(self):\n        self.particles.renderer.setZScaleFlag(\n            self.getVariable('Geom Renderer', 'Z Scale').get())\n\n    def setRendererGeomInitialXScale(self, xScale):\n        self.particles.renderer.setInitialXScale(xScale)\n\n    def setRendererGeomFinalXScale(self, xScale):\n        self.particles.renderer.setFinalXScale(xScale)\n\n    def setRendererGeomInitialYScale(self, yScale):\n        self.particles.renderer.setInitialYScale(yScale)\n\n    def setRendererGeomFinalYScale(self, yScale):\n        self.particles.renderer.setFinalYScale(yScale)\n\n    def setRendererGeomInitialZScale(self, zScale):\n        self.particles.renderer.setInitialZScale(zScale)\n\n    def setRendererGeomFinalZScale(self, zScale):\n        self.particles.renderer.setFinalZScale(zScale)\n\n    def setRendererGeomColorBlendMethod(self, blendMethod):\n        blendMethodStr = blendMethod\n        incomingOperandStr = self.getVariable('Geom Renderer','Incoming Op.').get()\n        fbufferOperandStr = self.getVariable('Geom Renderer','Fbuffer Op.').get()\n        self.setRendererColorBlendAttrib('Geom Renderer', blendMethodStr, incomingOperandStr, fbufferOperandStr)\n\n    def setRendererGeomColorBlendIncomingOperand(self, operand):\n        blendMethodStr = self.getVariable('Geom Renderer','Color Blend').get()\n        incomingOperandStr = operand\n        fbufferOperandStr = self.getVariable('Geom Renderer','Fbuffer Op.').get()\n        self.setRendererColorBlendAttrib('Geom Renderer', blendMethodStr, incomingOperandStr, fbufferOperandStr)\n\n    def setRendererGeomColorBlendFbufferOperand(self, operand):\n        blendMethodStr = self.getVariable('Geom Renderer','Color Blend').get()\n        incomingOperandStr = self.getVariable('Geom Renderer','Incoming Op.').get()\n        fbufferOperandStr = operand\n        self.setRendererColorBlendAttrib('Geom Renderer', blendMethodStr, incomingOperandStr, fbufferOperandStr)\n\n    def addConstantInterpolationSegment(self, id = None):\n        ren = self.particles.getRenderer()\n        cim = ren.getColorInterpolationManager()\n        if id is None:\n            seg = cim.getSegment(cim.addConstant())\n        else:\n            seg = cim.getSegment(id)\n\n        if ren.__class__.__name__ == 'SpriteParticleRendererExt':\n            parent = self.rendererSpriteSegmentFrame\n            segName = repr(len(self.rendererSegmentWidgetList))+':Constant'\n            self.rendererSegmentWidgetList.append(\n                self.createConstantInterpolationSegmentWidget(parent, segName, seg))\n        elif ren.__class__.__name__ == 'GeomParticleRenderer':\n            parent = self.rendererGeomSegmentFrame\n            segName = repr(len(self.rendererSegmentWidgetList))+':Constant'\n            self.rendererSegmentWidgetList.append(\n                self.createConstantInterpolationSegmentWidget(parent, segName, seg))\n        parent.pack(fill=tk.BOTH, expand=1)\n\n    def addLinearInterpolationSegment(self, id = None):\n        ren = self.particles.getRenderer()\n        cim = ren.getColorInterpolationManager()\n        if id is None:\n            seg = cim.getSegment(cim.addLinear())\n        else:\n            seg = cim.getSegment(id)\n\n        if ren.__class__.__name__ == 'SpriteParticleRendererExt':\n            parent = self.rendererSpriteSegmentFrame\n            segName = repr(len(self.rendererSegmentWidgetList))+':Linear'\n            self.rendererSegmentWidgetList.append(\n                self.createLinearInterpolationSegmentWidget(parent, segName, seg))\n        elif ren.__class__.__name__ == 'GeomParticleRenderer':\n            parent = self.rendererGeomSegmentFrame\n            segName = repr(len(self.rendererSegmentWidgetList))+':Linear'\n            self.rendererSegmentWidgetList.append(\n                self.createLinearInterpolationSegmentWidget(parent, segName, seg))\n        parent.pack(fill=tk.BOTH, expand=1)\n\n    def addStepwaveInterpolationSegment(self, id = None):\n        ren = self.particles.getRenderer()\n        cim = ren.getColorInterpolationManager()\n        if id is None:\n            seg = cim.getSegment(cim.addStepwave())\n        else:\n            seg = cim.getSegment(id)\n\n        if ren.__class__.__name__ == 'SpriteParticleRendererExt':\n            parent = self.rendererSpriteSegmentFrame\n            segName = repr(len(self.rendererSegmentWidgetList))+':Stepwave'\n            self.rendererSegmentWidgetList.append(\n                self.createStepwaveInterpolationSegmentWidget(parent, segName, seg))\n        elif ren.__class__.__name__ == 'GeomParticleRenderer':\n            parent = self.rendererGeomSegmentFrame\n            segName = repr(len(self.rendererSegmentWidgetList))+':Stepwave'\n            self.rendererSegmentWidgetList.append(\n                self.createStepwaveInterpolationSegmentWidget(parent, segName, seg))\n        parent.pack(fill=tk.BOTH, expand=1)\n\n    def addSinusoidInterpolationSegment(self, id = None):\n        ren = self.particles.getRenderer()\n        cim = ren.getColorInterpolationManager()\n        if id is None:\n            seg = cim.getSegment(cim.addSinusoid())\n        else:\n            seg = cim.getSegment(id)\n\n        if ren.__class__.__name__ == 'SpriteParticleRendererExt':\n            parent = self.rendererSpriteSegmentFrame\n            segName = repr(len(self.rendererSegmentWidgetList))+':Sinusoid'\n            self.rendererSegmentWidgetList.append(\n                self.createSinusoidInterpolationSegmentWidget(parent, segName, seg))\n        elif ren.__class__.__name__ == 'GeomParticleRenderer':\n            parent = self.rendererGeomSegmentFrame\n            segName = repr(len(self.rendererSegmentWidgetList))+':Sinusoid'\n            self.rendererSegmentWidgetList.append(\n                self.createSinusoidInterpolationSegmentWidget(parent, segName, seg))\n        parent.pack(fill=tk.BOTH, expand=1)\n\n    def createWidgetForExistingInterpolationSegment(self, id):\n        ren = self.particles.getRenderer()\n        cim = ren.getColorInterpolationManager()\n        seg = cim.getSegment(id)\n        assert seg\n\n        fun = seg.getFunction()\n        if isinstance(fun,ColorInterpolationFunctionSinusoid):\n            self.addSinusoidInterpolationSegment(id)\n        elif isinstance(fun,ColorInterpolationFunctionStepwave):\n            self.addStepwaveInterpolationSegment(id)\n        elif isinstance(fun,ColorInterpolationFunctionLinear):\n            self.addLinearInterpolationSegment(id)\n        elif isinstance(fun,ColorInterpolationFunctionConstant):\n            self.addConstantInterpolationSegment(id)\n\n    def createInterpolationSegmentFrame(self, parent, segName, seg):\n        frame = tk.Frame(parent, relief = tk.RAISED, borderwidth = 2)\n        lFrame = tk.Frame(frame, relief = tk.FLAT)\n\n        def removeInterpolationSegmentFrame(s = self, seg = seg, fr = frame):\n            s.particles.getRenderer().getColorInterpolationManager().clearSegment(seg.getId())\n            fr.pack_forget()\n\n        def setSegEnabled(s=self, n=segName):\n            enabled = s.getVariable('Sprite Renderer', n+' Enabled')\n            seg.setEnabled(enabled.get())\n\n        def setIsModulated(s=self, n=segName):\n            modulated = s.getVariable('Sprite Renderer', n+' isModulated')\n            seg.setIsModulated(modulated.get())\n\n        def setSegBegin(time):\n            seg.setTimeBegin(time)\n\n        def setSegEnd(time):\n            seg.setTimeEnd(time)\n        tk.Button(lFrame, text = 'X',\n                  command = removeInterpolationSegmentFrame).pack(side = tk.RIGHT, expand = 0)\n        tk.Label(lFrame, text = segName,\n                 foreground = 'Blue',\n                 font = ('MSSansSerif', 12, 'bold'),\n                 ).pack(fill = tk.X, expand = 1)\n        lFrame.pack(fill = tk.X, expand = 1)\n        lFrame = tk.Frame(frame, relief = tk.FLAT)\n        self.createCheckbutton(\n            lFrame, 'Sprite Renderer', segName + ' Enabled',\n            ('On: Enabled\\n' +\n             'Off: Disabled'),\n            command = setSegEnabled, initialState = seg.isEnabled())\n        self.createCheckbutton(\n            lFrame, 'Sprite Renderer', segName + ' isModulated',\n            ('On: Modulate\\n' +\n             'Off: Add'),\n            command = setIsModulated, initialState = seg.isModulated())\n        lFrame.pack(fill = tk.X, expand = 1)\n\n        f = tk.Frame(frame)\n        self.createSlider(f,\n                          'Sprite Renderer', segName + ' Begin',\n                          '',\n                          command = setSegBegin,\n                          value = seg.getTimeBegin())\n        self.createSlider(f,'Sprite Renderer', segName + ' End',\n                          '',\n                          command = setSegEnd,\n                          value = seg.getTimeEnd())\n        f.pack(fill = tk.X, expand = 0)\n        frame.pack(pady = 3, fill = tk.X, expand = 0)\n        return frame\n\n    def createConstantInterpolationSegmentWidget(self, parent, segName, segment):\n        fun = segment.getFunction()\n\n        def setSegColorA(color):\n            fun.setColorA(\n                Vec4(color[0]/255.0, color[1]/255.0,\n                     color[2]/255.0, color[3]/255.0))\n\n        frame = self.createInterpolationSegmentFrame(parent, segName, segment)\n        f = tk.Frame(frame)\n\n        c = fun.getColorA()\n        c = [c[0]*255.0, c[1]*255.0, c[2]*255.0, c[3]*255.0]\n        self.createColorEntry(f,'Sprite Renderer', segName + ' Color A',\n                              '',\n                              command = setSegColorA,\n                              value = c)\n        f.pack(fill = tk.X)\n        return frame\n\n    def createLinearInterpolationSegmentWidget(self, parent, segName, segment):\n        fun = segment.getFunction()\n\n        def setSegColorA(color):\n            fun.setColorA(\n                Vec4(color[0]/255.0, color[1]/255.0,\n                     color[2]/255.0, color[3]/255.0))\n\n        def setSegColorB(color):\n            fun.setColorB(\n                Vec4(color[0]/255.0, color[1]/255.0,\n                     color[2]/255.0, color[3]/255.0))\n\n        frame = self.createInterpolationSegmentFrame(parent, segName, segment)\n        f = tk.Frame(frame)\n\n        c = fun.getColorA()\n        c = [c[0]*255.0, c[1]*255.0, c[2]*255.0, c[3]*255.0]\n        self.createColorEntry(f,'Sprite Renderer', segName + ' Color A',\n                              '',\n                              command = setSegColorA,\n                              value = c)\n        c = fun.getColorB()\n        c = [c[0]*255.0, c[1]*255.0, c[2]*255.0, c[3]*255.0]\n        self.createColorEntry(f,'Sprite Renderer', segName + ' Color B',\n                              '',\n                              command = setSegColorB,\n                              value = c)\n        f.pack(fill = tk.X)\n        return frame\n\n    def createStepwaveInterpolationSegmentWidget(self, parent, segName, segment):\n        fun = segment.getFunction()\n\n        def setColorA(color):\n            fun.setColorA(\n                Vec4(color[0]/255.0, color[1]/255.0,\n                     color[2]/255.0, color[3]/255.0))\n\n        def setColorB(color):\n            fun.setColorB(\n                Vec4(color[0]/255.0, color[1]/255.0,\n                     color[2]/255.0, color[3]/255.0))\n\n        def setWidthA(width):\n            fun.setWidthA(width)\n\n        def setWidthB(width):\n            fun.setWidthB(width)\n\n        frame = self.createInterpolationSegmentFrame(parent, segName, segment)\n        f = tk.Frame(frame)\n\n        c = fun.getColorA()\n        c = [c[0]*255.0, c[1]*255.0, c[2]*255.0, c[3]*255.0]\n        self.createColorEntry(f,'Sprite Renderer', segName + ' Color A',\n                              '',\n                              command = setColorA,\n                              value = c)\n        c = fun.getColorB()\n        c = [c[0]*255.0, c[1]*255.0, c[2]*255.0, c[3]*255.0]\n        self.createColorEntry(f,'Sprite Renderer', segName + ' Color B',\n                              '',\n                              command = setColorB,\n                              value = c)\n        w = fun.getWidthA()\n        self.createSlider(f,'Sprite Renderer', segName + ' Width A',\n                          '',\n                          command = setWidthA,\n                          value = w)\n        w = fun.getWidthB()\n        self.createSlider(f,'Sprite Renderer', segName + ' Width B',\n                          '',\n                          command = setWidthB,\n                          value = w)\n        f.pack(fill = tk.X)\n        return frame\n\n    def createSinusoidInterpolationSegmentWidget(self, parent, segName, segment):\n        fun = segment.getFunction()\n\n        def setColorA(color):\n            fun.setColorA(\n                Vec4(color[0]/255.0, color[1]/255.0,\n                     color[2]/255.0, color[3]/255.0))\n\n        def setColorB(color):\n            fun.setColorB(\n                Vec4(color[0]/255.0, color[1]/255.0,\n                     color[2]/255.0, color[3]/255.0))\n\n        def setPeriod(period):\n            fun.setPeriod(period)\n\n        frame = self.createInterpolationSegmentFrame(parent, segName, segment)\n        f = tk.Frame(frame)\n\n        c = fun.getColorA()\n        c = [c[0]*255.0, c[1]*255.0, c[2]*255.0, c[3]*255.0]\n        self.createColorEntry(f,'Sprite Renderer', segName + ' Color A',\n                              '',\n                              command = setColorA,\n                              value = c)\n        c = fun.getColorB()\n        c = [c[0]*255.0, c[1]*255.0, c[2]*255.0, c[3]*255.0]\n        self.createColorEntry(f,'Sprite Renderer', segName + ' Color B',\n                              '',\n                              command = setColorB,\n                              value = c)\n        p = fun.getPeriod()\n        self.createFloater(f,'Sprite Renderer', segName + ' Period',\n                          '',\n                          command = setPeriod,\n                          value = p)\n        f.pack(fill = tk.X)\n        return frame\n\n    def createSpriteAnimationFrame(self, parent, anim, animName):\n        ren = self.particles.getRenderer()\n        frame = tk.Frame(parent, relief = tk.RAISED, borderwidth = 2)\n        frame.pack(pady = 1, fill = tk.X, expand = 0)\n\n        lFrame = tk.Frame(frame, relief = tk.FLAT)\n        lFrame.pack(fill = tk.X, expand = 1)\n\n        def delete(s = self, fr = frame):\n            i = s.rendererSpriteAnimationWidgetList.index(fr)\n            s.rendererSpriteAnimationWidgetList[i] = None\n            fr.pack_forget()\n            fr.destroy()\n            s.writeSpriteRendererAnimations()\n            s.readSpriteRendererAnimations()\n\n        tk.Button(lFrame, text = 'X', foreground = 'Red', font = ('MSSansSerif', 8, 'bold'),\n                  command = delete).pack(side = tk.RIGHT, expand = 0)\n\n        if anim == SpriteAnim.STTexture or anim == SpriteAnim.STFromNode:\n            frame.valid = False\n            frame.animSourceType = anim\n            if anim == SpriteAnim.STTexture:\n                type = 'Texture'\n            else:\n                type = 'From Node'\n        else:\n            frame.valid = True\n\n            if anim.getSourceType() == SpriteAnim.STTexture:\n                frame.animSourceType = SpriteAnim.STTexture\n                type = 'Texture'\n            else:\n                frame.animSourceType = SpriteAnim.STFromNode\n                type = 'From Node'\n\n        tk.Label(lFrame, text = animName+': '+type,\n                 foreground = 'Blue',\n                 font = ('MSSansSerif', 12, 'bold'),\n                 ).pack(fill = tk.X, expand = 1)\n\n        return frame\n\n    def createSpriteAnimationTextureWidget(self, parent, anim, animName):\n        ren = self.particles.getRenderer()\n        frame = self.createSpriteAnimationFrame(parent, anim, animName)\n        f = tk.Frame(frame)\n        f.pack(fill=tk.X)\n\n        tk.Label(f, text = 'Texture: ', font = ('MSSansSerif', 12), width=7).pack(side = tk.LEFT)\n        strVar = tk.StringVar()\n        entry = tk.Entry(f, textvariable = strVar).pack(padx=3, pady=3, side=tk.LEFT, fill=tk.X, expand=1)\n        if frame.valid:\n            strVar.set(anim.getTexSource())\n        else:\n            strVar.set('Base model path: ' + repr(getModelPath().getValue()))\n\n        def checkForTexture(strVar = strVar):\n            tex = base.loader.loadTexture(strVar.get())\n            if tex:\n                frame.valid = True\n            else:\n                frame.valid = False\n            self.writeSpriteRendererAnimations()\n\n        tk.Button(f, text = 'Update',\n                  command = checkForTexture).pack(side=tk.LEFT)\n        self.variableDict['Sprite Renderer-'+animName+' Anim Texture'] = strVar\n        self.widgetDict['Sprite Renderer-'+animName+' Anim Texture'] = entry\n\n        return frame\n\n    def createSpriteAnimationNodeWidget(self, parent, anim, animName):\n        ren = self.particles.getRenderer()\n        frame = self.createSpriteAnimationFrame(parent, anim, animName)\n        f = tk.Frame(frame)\n        f.pack(fill=tk.X)\n\n        lf = tk.Frame(f)\n        lf.pack(fill=tk.X, expand=1)\n        tk.Label(lf, text = 'Model: ', font = ('MSSansSerif', 12), width=7).pack(side = tk.LEFT)\n        mStrVar = tk.StringVar()\n        entry = tk.Entry(lf, textvariable = mStrVar).pack(padx=3, pady=3, side=tk.LEFT, fill=tk.X, expand=1)\n        if frame.valid:\n            mStrVar.set(anim.getModelSource())\n        else:\n            mStrVar.set('Base model path: ' + repr(getModelPath().getValue()))\n\n        mlf = lf\n\n        self.variableDict['Sprite Renderer-'+animName+' Anim Model'] = mStrVar\n        self.widgetDict['Sprite Renderer-'+animName+' Anim Model'] = entry\n\n        lf = tk.Frame(f)\n        lf.pack(fill=tk.X, expand=1)\n        tk.Label(lf, text = 'Node: ', font = ('MSSansSerif', 12), width=7).pack(side = tk.LEFT)\n        nStrVar = tk.StringVar()\n        entry = tk.Entry(lf, textvariable = nStrVar).pack(padx=3, pady=3, side=tk.LEFT, fill=tk.X, expand=1)\n        if frame.valid:\n            nStrVar.set(anim.getNodeSource())\n        else:\n            nStrVar.set('**/*')\n        nlf = lf\n\n        self.variableDict['Sprite Renderer-'+animName+' Anim Node'] = nStrVar\n        self.widgetDict['Sprite Renderer-'+animName+' Anim Node'] = entry\n\n        def checkForNode(modelStrVar=mStrVar, nodeStrVar=nStrVar):\n            mod = base.loader.loadModel(modelStrVar.get())\n            if mod:\n                node = mod.find(nodeStrVar.get())\n                if node:\n                    frame.valid = True\n                else:\n                    frame.valid = False\n            else:\n                frame.valid = False\n\n            self.writeSpriteRendererAnimations()\n\n        tk.Button(mlf, text = 'Update',\n                  command = checkForNode).pack(side=tk.LEFT)\n        tk.Button(nlf, text = 'Update',\n                  command = checkForNode).pack(side=tk.LEFT)\n\n        return frame\n\n    # get animation info from renderer into panel\n    def readSpriteRendererAnimations(self):\n        ren = self.particles.getRenderer()\n\n        for widget in self.rendererSpriteAnimationWidgetList:\n            if widget:\n                widget.pack_forget()\n                widget.destroy()\n\n        self.rendererSpriteAnimationWidgetList = []\n\n        for anim in [ren.getAnim(x) for x in range(ren.getNumAnims())]:\n            if anim.getSourceType() == SpriteAnim.STTexture:\n                w = self.createSpriteAnimationTextureWidget(self.rendererSpriteAnimationFrame, anim, repr(len(self.rendererSpriteAnimationWidgetList)))\n            else:\n                w = self.createSpriteAnimationNodeWidget(self.rendererSpriteAnimationFrame, anim, repr(len(self.rendererSpriteAnimationWidgetList)))\n            self.rendererSpriteAnimationWidgetList.append(w)\n\n    # set animation info from panel into renderer\n    def writeSpriteRendererAnimations(self):\n        ren = self.particles.getRenderer()\n\n        for x in range(ren.getNumAnims()):\n            ren.removeAnimation(0)\n\n        for x in range(len(self.rendererSpriteAnimationWidgetList)):\n            widget = self.rendererSpriteAnimationWidgetList[x]\n            if widget and widget.valid:\n                if widget.animSourceType == SpriteAnim.STTexture:\n                    texSource = self.getVariable('Sprite Renderer', repr(x) + ' Anim Texture').get()\n                    ren.addTextureFromFile(texSource)\n                else:\n                    modelSource = self.getVariable('Sprite Renderer', repr(x) + ' Anim Model').get()\n                    nodeSource = self.getVariable('Sprite Renderer', repr(x) + ' Anim Node').get()\n                    ren.addTextureFromNode(modelSource, nodeSource)\n\n    ## FORCEGROUP COMMANDS ##\n    def updateForceWidgets(self):\n        # Select appropriate notebook page\n        if self.forceGroup is not None:\n            self.forceGroupNotebook.pack(fill = tk.X)\n            self.forcePageName = (self.particleEffect.getName() + '-' +\n                                  self.forceGroup.getName())\n            self.forcePage = self.forcePagesDict.get(\n                self.forcePageName, None)\n            # Page doesn't exist, add it\n            if self.forcePage is None:\n                self.addForceGroupNotebookPage(\n                    self.particleEffect, self.forceGroup)\n            self.forceGroupNotebook.selectpage(self.forcePageName)\n        else:\n            self.forceGroupNotebook.pack_forget()\n\n    def addLinearVectorForce(self):\n        self.addForce(LinearVectorForce())\n\n    def addLinearFrictionForce(self):\n        self.addForce(LinearFrictionForce())\n\n    def addLinearJitterForce(self):\n        self.addForce(LinearJitterForce())\n\n    def addLinearNoiseForce(self):\n        self.addForce(LinearNoiseForce())\n\n    def addLinearSinkForce(self):\n        self.addForce(LinearSinkForce())\n\n    def addLinearSourceForce(self):\n        self.addForce(LinearSourceForce())\n\n    def addLinearCylinderVortexForce(self):\n        self.addForce(LinearCylinderVortexForce())\n\n    def addLinearUserDefinedForce(self):\n        self.addForce(LinearUserDefinedForce())\n\n    def addForce(self, f):\n        if self.forceGroup is None:\n            self.createNewForceGroup()\n        self.forceGroup.addForce(f)\n        self.addForceWidget(self.forceGroup, f)\n\n    ## SYSTEM COMMANDS ##\n    def createNewEffect(self):\n        name = askstring('Particle Panel', 'Effect Name:',\n                         parent = self.parent)\n        if name:\n            particles = Particles.Particles()\n            particles.setBirthRate(0.02)\n            particles.setLitterSize(10)\n            particles.setLitterSpread(0)\n            particles.setFactory(\"PointParticleFactory\")\n            particles.setRenderer(\"PointParticleRenderer\")\n            particles.setEmitter(\"SphereVolumeEmitter\")\n            particles.enable()\n            effect = ParticleEffect.ParticleEffect(name, particles)\n            self.effectsDict[name] = effect\n            self.updateMenusAndLabels()\n            self.selectEffectNamed(name)\n            effect.reparentTo(render)\n            effect.enable()\n\n    def createNewParticles(self):\n        name = askstring('Particle Panel', 'Particles Name:',\n                         parent = self.parent)\n        if name:\n            p = Particles.Particles(name)\n            self.particleEffect.addParticles(p)\n            self.updateParticlesMenus()\n            self.selectParticlesNamed(name)\n            p.enable()\n\n    def createNewForceGroup(self):\n        name = askstring('Particle Panel', 'ForceGroup Name:',\n                         parent = self.parent)\n        if name:\n            forceGroup = ForceGroup.ForceGroup(name)\n            self.particleEffect.addForceGroup(forceGroup)\n            self.updateForceGroupMenus()\n            self.addForceGroupNotebookPage(self.particleEffect, forceGroup)\n            self.selectForceGroupNamed(name)\n            forceGroup.enable()\n\n    def addForceGroupNotebookPage(self, particleEffect, forceGroup):\n        self.forcePageName = (particleEffect.getName() + '-' +\n                              forceGroup.getName())\n        self.forcePage = self.forceGroupNotebook.add(self.forcePageName)\n        self.forcePagesDict[self.forcePageName] = self.forcePage\n        for force in forceGroup:\n            self.addForceWidget(forceGroup, force)\n\n    def addForceWidget(self, forceGroup, force):\n        forcePage = self.forcePage\n        pageName = self.forcePageName\n        # How many forces of the same type in the force group object\n        count = 0\n        for f in forceGroup:\n            if f.getClassType() == force.getClassType():\n                count += 1\n        if isinstance(force, LinearVectorForce):\n            self.createLinearVectorForceWidget(\n                forcePage, pageName, count, force)\n        elif isinstance(force, LinearNoiseForce):\n            self.createLinearRandomForceWidget(\n                forcePage, pageName, count, force, 'Noise')\n        elif isinstance(force, LinearJitterForce):\n            self.createLinearRandomForceWidget(\n                forcePage, pageName, count, force, 'Jitter')\n        elif isinstance(force, LinearFrictionForce):\n            self.createLinearFrictionForceWidget(\n                forcePage, pageName, count, force)\n        elif isinstance(force, LinearCylinderVortexForce):\n            self.createLinearCylinderVortexForceWidget(\n                forcePage, pageName, count, force)\n        elif isinstance(force, LinearSinkForce):\n            self.createLinearDistanceForceWidget(\n                forcePage, pageName, count, force, 'Sink')\n        elif isinstance(force, LinearSourceForce):\n            self.createLinearDistanceForceWidget(\n                forcePage, pageName, count, force, 'Source')\n        elif isinstance(force, LinearUserDefinedForce):\n            # Nothing\n            pass\n        self.forceGroupNotebook.setnaturalsize()\n\n    def createForceFrame(self, forcePage, forceName, force):\n        frame = tk.Frame(forcePage, relief = tk.RAISED, borderwidth = 2)\n        lFrame = tk.Frame(frame, relief = tk.FLAT)\n\n        def removeForce(s = self, f = force, fr = frame):\n            s.forceGroup.removeForce(f)\n            fr.pack_forget()\n        b = tk.Button(lFrame, text = 'X',\n                      command = removeForce)\n        b.pack(side = 'right', expand = 0)\n        tk.Label(lFrame, text = forceName,\n                 foreground = 'Blue',\n                 font=('MSSansSerif', 12, 'bold'),\n                 ).pack(expand = 1, fill = 'x')\n        lFrame.pack(fill = 'x', expand =1)\n        frame.pack(pady = 3, fill = 'x', expand =0)\n        return frame\n\n    def createLinearForceWidgets(self, frame, pageName, forceName, force):\n        def setAmplitude(amp, f = force):\n            f.setAmplitude(amp)\n\n        def toggleMassDependent(s=self, f=force, p=pageName, n=forceName):\n            v = s.getVariable(p, n+' Mass Dependent')\n            f.setMassDependent(v.get())\n\n        def setVectorMasks(s=self, f=force, p=pageName, n=forceName):\n            xMask = s.getVariable(p, n+' Mask X').get()\n            yMask = s.getVariable(p, n+' Mask Y').get()\n            zMask = s.getVariable(p, n+' Mask Z').get()\n            f.setVectorMasks(xMask, yMask, zMask)\n        self.createFloater(frame, pageName, forceName + ' Amplitude',\n                           'Force amplitude multiplier',\n                           command = setAmplitude,\n                           value = force.getAmplitude())\n        cbf = tk.Frame(frame, relief = tk.FLAT)\n        self.createCheckbutton(cbf, pageName, forceName + ' Mass Dependent',\n                               ('On: force depends on mass; ' +\n                                'Off: force does not depend on mass'),\n                               toggleMassDependent,\n                               force.getMassDependent())\n        self.createCheckbutton(cbf, pageName, forceName + ' Mask X',\n                               'On: enable force along X axis',\n                               setVectorMasks, 1)\n        self.createCheckbutton(cbf, pageName, forceName + ' Mask Y',\n                               'On: enable force along X axis',\n                               setVectorMasks, 1)\n        self.createCheckbutton(cbf, pageName, forceName + ' Mask Z',\n                               'On: enable force along X axis',\n                               setVectorMasks, 1)\n        cbf.pack(fill = 'x', expand = 0)\n\n    def createForceActiveWidget(self, frame, pageName, forceName, force):\n        cbName = forceName + ' Active'\n\n        def toggle(s = self, f = force, p = pageName, n = cbName):\n            s.toggleForce(f, p, n)\n        self.createCheckbutton(frame, pageName, cbName,\n                               'On: force is enabled; Off: force is disabled',\n                               toggle, 1)\n\n    def createLinearVectorForceWidget(self, forcePage, pageName,\n                                      count, force):\n        def setVec(vec, f = force):\n            f.setVector(vec[0], vec[1], vec[2])\n        forceName = 'Vector Force-' + repr(count)\n        frame = self.createForceFrame(forcePage, forceName, force)\n        self.createLinearForceWidgets(frame, pageName, forceName, force)\n        vec = force.getLocalVector()\n        self.createVector3Entry(frame, pageName, forceName,\n                                'Set force direction and magnitude',\n                                command = setVec,\n                                value = [vec[0], vec[1], vec[2]])\n        self.createForceActiveWidget(frame, pageName, forceName, force)\n\n    def createLinearRandomForceWidget(self, forcePage, pageName, count,\n                                force, type):\n        forceName = type + ' Force-' + repr(count)\n        frame = self.createForceFrame(forcePage, forceName, force)\n        self.createLinearForceWidgets(frame, pageName, forceName, force)\n        self.createForceActiveWidget(frame, pageName, forceName, force)\n\n    def createLinearFrictionForceWidget(self, forcePage, pageName,\n                                        count, force):\n        def setCoef(coef, f = force):\n            f.setCoef(coef)\n        forceName = 'Friction Force-' + repr(count)\n        frame = self.createForceFrame(forcePage, forceName, force)\n        self.createLinearForceWidgets(frame, pageName, forceName, force)\n        self.createFloater(frame, pageName, forceName + ' Coef',\n                           'Set linear friction force',\n                           command = setCoef, min = None,\n                           value = force.getCoef())\n        self.createForceActiveWidget(frame, pageName, forceName, force)\n\n    def createLinearCylinderVortexForceWidget(self, forcePage, pageName,\n                                              count, force):\n        forceName = 'Vortex Force-' + repr(count)\n\n        def setCoef(coef, f = force):\n            f.setCoef(coef)\n\n        def setLength(length, f = force):\n            f.setLength(length)\n\n        def setRadius(radius, f = force):\n            f.setRadius(radius)\n        frame = self.createForceFrame(forcePage, forceName, force)\n        self.createLinearForceWidgets(frame, pageName, forceName, force)\n        self.createFloater(frame, pageName, forceName + ' Coef',\n                           'Set linear cylinder vortex coefficient',\n                           command = setCoef,\n                           value = force.getCoef())\n        self.createFloater(frame, pageName, forceName + ' Length',\n                           'Set linear cylinder vortex length',\n                           command = setLength,\n                           value = force.getLength())\n        self.createFloater(frame, pageName, forceName + ' Radius',\n                           'Set linear cylinder vortex radius',\n                           command = setRadius,\n                           value = force.getRadius())\n        self.createForceActiveWidget(frame, pageName, forceName, force)\n\n    def createLinearDistanceForceWidget(self, forcePage, pageName,\n                                        count, force, type):\n        def setFalloffType(type, f=force):\n            if type == 'FT_ONE_OVER_R':\n                #f.setFalloffType(LinearDistanceForce.FTONEOVERR)\n                f.setFalloffType(0)\n            if type == 'FT_ONE_OVER_R_SQUARED':\n                #f.setFalloffType(LinearDistanceForce.FTONEOVERRSQUARED)\n                f.setFalloffType(1)\n            if type == 'FT_ONE_OVER_R_CUBED':\n                #f.setFalloffType(LinearDistanceForce.FTONEOVERRCUBED)\n                f.setFalloffType(2)\n\n        def setForceCenter(vec, f = force):\n            f.setForceCenter(Point3(vec[0], vec[1], vec[2]))\n\n        def setRadius(radius, f = force):\n            f.setRadius(radius)\n        forceName = type + ' Force-' + repr(count)\n        frame = self.createForceFrame(forcePage, forceName, force)\n        self.createLinearForceWidgets(frame, pageName, forceName, force)\n        var = self.createOptionMenu(\n            frame, pageName, forceName + ' Falloff',\n            'Set force falloff type',\n            ('FT_ONE_OVER_R',\n             'FT_ONE_OVER_R_SQUARED',\n             'FT_ONE_OVER_R_CUBED'),\n            command = setFalloffType)\n        self.getWidget(pageName, forceName + ' Falloff').configure(\n            label_width = 16)\n        falloff = force.getFalloffType()\n        if falloff == LinearDistanceForce.FTONEOVERR:\n            var.set('FT_ONE_OVER_R')\n        elif falloff == LinearDistanceForce.FTONEOVERRSQUARED:\n            var.set('FT_ONE_OVER_R_SQUARED')\n        elif falloff == LinearDistanceForce.FTONEOVERRCUBED:\n            var.set('FT_ONE_OVER_R_CUBED')\n        vec = force.getForceCenter()\n        self.createVector3Entry(frame, pageName, forceName + ' Center',\n                                'Set center of force',\n                                command = setForceCenter,\n                                label_width = 16,\n                                value = [vec[0], vec[1], vec[2]])\n        self.createFloater(frame, pageName, forceName + ' Radius',\n                           'Set falloff radius',\n                           command = setRadius,\n                           min = 0.01,\n                           value = force.getRadius())\n        self.createForceActiveWidget(frame, pageName, forceName, force)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/tkpanels/ParticlePanel.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/44a6f4d1_ParticlePanel.json",
    "doc_id": "doc_56"
  }
}