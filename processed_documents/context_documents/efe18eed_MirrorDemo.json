{
  "content": "\"\"\"This file demonstrates one way to create a mirror effect in Panda.\nCall :func:`setupMirror()` to create a mirror in the world that reflects\neverything in front of it.\n\nThe approach taken here is to create an offscreen buffer with its own\ncamera that renders its view into a texture, which is then applied to\nthe mirror geometry.  The mirror's camera is repositioned each frame\nwith a task to keep it always on the opposite side of the mirror from\nthe main camera.\n\nThis demonstrates the basic interface for offscreen\nrender-to-a-texture in Panda.  Similar approaches can be used for\nrelated effects, such as a remote spy camera presenting its view onto\na closed-circuit television screen.\n\nIn this example the mirror itself is always perfectly flat--it's just\na single polygon, after all--but small distortions of the mirror\nsurface are possible, like a funhouse mirror.  However, the reflection\nitself is always basically planar; for more accurate convex\nreflections, you will need to use a sphere map or a cube map.\"\"\"\n\n__all__ = ['setupMirror', 'showFrustum']\n\nfrom panda3d.core import (\n    Camera,\n    CardMaker,\n    CullFaceAttrib,\n    GeomNode,\n    Lens,\n    NodePath,\n    PerspectiveLens,\n    Plane,\n    PlaneNode,\n    Point3,\n    Vec3,\n)\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\n\n\ndef setupMirror(name, width, height, rootCamera = None,\n                bufferSize = 256, clearColor = None):\n    # The return value is a NodePath that contains a rectangle that\n    # reflects render.  You can reparent, reposition, and rotate it\n    # anywhere you like.\n    if rootCamera is None:\n        rootCamera = base.camera\n\n    root = render.attachNewNode(name)\n\n    # Create a polygon to be the visible representation of the mirror.\n    cm = CardMaker('mirror')\n    cm.setFrame(width / 2.0, -width / 2.0, -height / 2.0, height / 2.0)\n    cm.setHasUvs(1)\n    card = root.attachNewNode(cm.generate())\n\n    # Create a PlaneNode to represent the mirror's position, for\n    # computing where the mirror's camera belongs each frame.\n    plane = Plane(Vec3(0, 1, 0), Point3(0, 0, 0))\n    planeNode = PlaneNode('mirrorPlane')\n    planeNode.setPlane(plane)\n    planeNP = root.attachNewNode(planeNode)\n\n    # Now create an offscreen buffer for rendering the mirror's point\n    # of view.  The parameters here control the resolution of the\n    # texture.\n    buffer = base.win.makeTextureBuffer(name, bufferSize, bufferSize)\n    if clearColor is None:\n        buffer.setClearColor(base.win.getClearColor())\n        #buffer.setClearColor(VBase4(0, 0, 1, 1))\n    else:\n        buffer.setClearColor(clearColor)\n\n    # Set up a display region on this buffer, and create a camera.\n    dr = buffer.makeDisplayRegion()\n    camera = Camera('mirrorCamera')\n    lens = PerspectiveLens()\n    lens.setFilmSize(width, height)\n    camera.setLens(lens)\n    cameraNP = planeNP.attachNewNode(camera)\n    dr.setCamera(cameraNP)\n\n    # Since the reflection matrix will reverse the vertex-winding\n    # order of all the polygons in the world, we have to tell the\n    # camera to reverse the direction of its face culling.  We also\n    # tell it not to draw (that is, to clip) anything behind the\n    # mirror plane.\n    dummy = NodePath('dummy')\n    dummy.setAttrib(CullFaceAttrib.makeReverse())\n    dummy.setClipPlane(planeNP)\n    camera.setInitialState(dummy.getState())\n\n    # Create a visible representation of the camera so we can see it.\n    #cameraVis = base.loader.loadModel('camera.egg')\n    #if not cameraVis.isEmpty():\n    #    cameraVis.reparentTo(cameraNP)\n\n    # Spawn a task to keep that camera on the opposite side of the\n    # mirror.\n    def moveCamera(task, cameraNP = cameraNP, plane = plane,\n                   planeNP = planeNP, card = card, lens = lens,\n                   width = width, height = height, rootCamera = rootCamera):\n        # Set the camera to the mirror-image position of the main camera.\n        cameraNP.setMat(rootCamera.getMat(planeNP) * plane.getReflectionMat())\n\n        # Set the cameras roll to the roll of the mirror. Otherwise\n        # mirrored objects will be moved unexpectedly\n        cameraNP.setR(planeNP.getR()-180)\n\n        # And reset the frustum to exactly frame the mirror's corners.\n        # This is a minor detail, but it helps to provide a realistic\n        # reflection and keep the subject centered.\n        ul = cameraNP.getRelativePoint(card, Point3(-width / 2.0, 0, height / 2.0))\n        ur = cameraNP.getRelativePoint(card, Point3(width / 2.0, 0, height / 2.0))\n        ll = cameraNP.getRelativePoint(card, Point3(-width / 2.0, 0, -height / 2.0))\n        lr = cameraNP.getRelativePoint(card, Point3(width / 2.0, 0, -height / 2.0))\n\n        # get the distance from the mirrors camera to the mirror plane\n        camvec = planeNP.getPos() - cameraNP.getPos()\n        camdist = camvec.length()\n\n        # set the discance on the mirrors corners so it will keep correct\n        # sizes of the mirrored objects\n        ul.setY(camdist)\n        ur.setY(camdist)\n        ll.setY(camdist)\n        lr.setY(camdist)\n\n        lens.setFrustumFromCorners(ul, ur, ll, lr, Lens.FCCameraPlane | Lens.FCOffAxis | Lens.FCAspectRatio)\n\n        return Task.cont\n\n    # Add it with a fairly high priority to make it happen late in the\n    # frame, after the avatar controls (or whatever) have been applied\n    # but before we render.\n    taskMgr.add(moveCamera, name, priority = 40)\n\n    # Now apply the output of this camera as a texture on the mirror's\n    # visible representation.\n    card.setTexture(buffer.getTexture())\n\n    return root\n\n\ndef showFrustum(np):\n    # Utility function to reveal the frustum for a particular camera.\n    cameraNP = np.find('**/+Camera')\n    camera = cameraNP.node()\n    lens = camera.getLens()\n    geomNode = GeomNode('frustum')\n    geomNode.addGeom(lens.makeGeometry())\n    cameraNP.attachNewNode(geomNode)\n\n\nif __name__ == \"__main__\":\n    from direct.showbase.ShowBase import ShowBase\n    base = ShowBase()\n\n    panda = base.loader.loadModel(\"panda\")\n    panda.setH(180)\n    panda.setPos(0, 10, -2.5)\n    panda.setScale(0.5)\n    panda.reparentTo(base.render)\n\n    myMirror = setupMirror(\"mirror\", 10, 10, bufferSize=1024, clearColor=(0, 0, 1, 1))\n    myMirror.setPos(0, 15, 2.5)\n    myMirror.setH(180)\n\n    # Uncomment this to show the frustum of the camera in the mirror\n    #showFrustum(render)\n\n    base.run()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/MirrorDemo.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/efe18eed_MirrorDemo.json",
    "doc_id": "doc_285"
  }
}