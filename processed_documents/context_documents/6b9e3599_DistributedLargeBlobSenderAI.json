{
  "content": "\"\"\"DistributedLargeBlobSenderAI module: contains the DistributedLargeBlobSenderAI class\"\"\"\n\nfrom direct.distributed import DistributedObjectAI\nfrom direct.directnotify import DirectNotifyGlobal\nfrom . import LargeBlobSenderConsts\n\nclass DistributedLargeBlobSenderAI(DistributedObjectAI.DistributedObjectAI):\n    \"\"\"DistributedLargeBlobSenderAI: for sending large chunks of data through\n    the DC system to a specific avatar\"\"\"\n    notify = DirectNotifyGlobal.directNotify.newCategory('DistributedLargeBlobSenderAI')\n\n    def __init__(self, air, zoneId, targetAvId, data, useDisk=0):\n        DistributedObjectAI.DistributedObjectAI.__init__(self, air)\n        self.targetAvId = targetAvId\n\n        self.mode = 0\n        if useDisk:\n            self.mode |= LargeBlobSenderConsts.USE_DISK\n\n        self.generateWithRequired(zoneId)\n\n        # send the data\n        s = str(data)\n        if useDisk:\n            # write the data to a file and tell the client where to get it\n            import os\n            import random\n            origDir = os.getcwd()\n            bPath = LargeBlobSenderConsts.getLargeBlobPath()\n            try:\n                os.chdir(bPath)\n            except OSError:\n                DistributedLargeBlobSenderAI.notify.error(\n                    'could not access %s' % bPath)\n            # find an unused temp filename\n            while 1:\n                num = random.randrange((1 << 30)-1)\n                filename = LargeBlobSenderConsts.FilePattern % num\n                try:\n                    os.stat(filename)\n                except OSError:\n                    break\n            # NOTE: there's a small chance of a race condition here, if\n            # the file is created by another AI just after the stat fails\n            f = open(filename, 'wb')\n            f.write(s)\n            f.close()\n            os.chdir(origDir)\n            self.sendUpdateToAvatarId(self.targetAvId,\n                                      'setFilename', [filename])\n        else:\n            chunkSize = LargeBlobSenderConsts.ChunkSize\n            while len(s) > 0:\n                self.sendUpdateToAvatarId(self.targetAvId,\n                                          'setChunk', [s[:chunkSize]])\n                s = s[chunkSize:]\n            # send final empty string\n            self.sendUpdateToAvatarId(self.targetAvId, 'setChunk', [''])\n\n    def getMode(self):\n        return self.mode\n\n    def getTargetAvId(self):\n        return self.targetAvId\n\n    def setAck(self):\n        DistributedLargeBlobSenderAI.notify.debug('setAck')\n        assert self.air.getAvatarIdFromSender() == self.targetAvId\n        self.requestDelete()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/directutil/DistributedLargeBlobSenderAI.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/6b9e3599_DistributedLargeBlobSenderAI.json",
    "doc_id": "doc_126"
  }
}