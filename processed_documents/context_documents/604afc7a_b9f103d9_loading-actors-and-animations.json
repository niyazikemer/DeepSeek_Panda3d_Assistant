{
  "content": "Loading Actors and Animations\n\npython\n\nThe Python class ~direct.actor.Actor.Actor is designed to hold an animatable model and a set of animations. Since the Actor class inherits from the .NodePath class, all common-state-changes are applicable to actors.\n\nNote, however, that Actor is a Python class that extends the C++ NodePath class. For the most part, you don't have to think about this: Actor inherits sensibly from NodePath and generally does what you expect. There are a few subtle oddities, though. When you attach an Actor into a scene graph, the low-level C++ Panda constructs only record the NodePath part of the Actor in the scene graph, which is fine as long as you also keep a pointer to the Actor instance in your Python objects. If you let the Actor destruct, however, its visible geometry will remain, but it will cease animating (because it is no longer an Actor). Also, even if you keep the Actor object around, if you retrieve a new pointer to the Actor from the scene graph (for instance, as returned by the collision system), you will get back just an ordinary NodePath, not an Actor.\n\nThe Actor interface provides a high-level interface on the low-level Panda constructs. In Panda, the low-level node that performs the animation is called .Character. You can see the Character node in the scene graph when you call actor.ls() <direct.actor.Actor.Actor.ls>.\n\nDo not confuse the Actor class with the ActorNode <enabling-physics-on-a-node> class, which is used for physics. They are completely unrelated classes with similar names.\n\nUsing Actors\n\nThe Actor class must be imported before any loading or manipulation of actors.\n\nfrom direct.actor.Actor import Actor\n\nOnce this is done, the actor object can be constructed, and the model and animations can be loaded.\n\nLoading each animation requires a dictionary, where each key is a meaningful name given to the animation and the corresponding value is the path to the animation file.\n\nAll of the above can be written as a single statement:\n\nactor = Actor('hero.egg', {\n    'walk': 'hero-walk.egg',\n    'swim': 'hero-swim.egg',\n})\n\nNote that it is also possible to store the animations and model in the same file. This is preferred in some other model formats, such as glTF. In that case, just create the Actor with just the model as parameter, without specifying a separate dictionary for the animations.\n\nWhen you wish to remove the actor from the scene, you need to call the ~direct.actor.Actor.Actor.cleanup() method. Note that calling ~direct.actor.Actor.Actor.removeNode() is not sufficient. This is due to the fact that Actor is a Python class containing additional data that can not be destroyed by the C++ ~.NodePath.remove_node() method.\n\nNote\n\nThe paths used in the Actor constructor must follow Panda's filename conventions, so a forward slash is used even on Windows. See filename-syntax for more information. Loading actors and animations utilizes the panda model path, the same as for static models.\n\ncpp\n\nThe Actor class which is available to Python users is not available to C++ users. If you need such a class you have to create your own class which at least should do the following:\n\nload the Actor Model\n\nload the animations\n\nbind the model and the animations using AnimControl or AnimControlCollection\n\nRequired Includes\n\n#include <auto_bind.h>\n#include <animControlCollection.h>\n\nLoad the Actor Model\n\nNodePath actor = window->load_model(window->get_render(), \"panda-model\");\n\nLoad the Animation\n\nwindow->load_model(actor, \"panda-walk\");\n\nBind the Model and the Animation\n\n// don't use PT or CPT with AnimControlCollection\nAnimControlCollection anim_collection;\n\n//bind the animations to the model\nauto_bind(actor.node(), anim_collection);\n\nControl the Animations\n\n// the name of an animation is preceded in the .egg file with <Bundle>:\n// loop a specific animation\nanim_collection.loop(\"panda_soft\", true);\n\n// loop all animations\nanim_collection.loop_all(true);\n\n// play an animation once:\nanim_collection.play(\"panda_soft\");\n\n// pose\nanim_collection.pose(\"panda_soft\", 5);\n\nto display names of loaded animations you could use:\n\nfor (int n = 0; n < anim_controls.get_num_anims(); ++n) {\n  std::cerr << anim_controls.get_anim_name(n) << std::endl;\n}\n\nIf you add more animations to some node after calling: auto_bind(...) they will not be controllable until auto_bind(...) is called again with proper arguments.\n\nNote that it is possible to store the animations and the model in the same file.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/b9f103d9_loading-actors-and-animations.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/604afc7a_b9f103d9_loading-actors-and-animations.json",
    "doc_id": "doc_694"
  }
}