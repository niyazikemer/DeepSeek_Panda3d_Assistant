{
  "content": "Reading existing geometry data\n\nYou can fairly easily extract and examine or operate on the vertices for an existing model, although you should be aware that the order in which the vertices appear in a model is undefined. There is no correlation between the order in which vertices are listed in an egg file, and the order in which they will appear in the resulting loaded model. Panda may rearrange the vertices, or even add or remove vertices, as needed to optimize the model for rendering performance. Even from one session to the next, the vertices might come out in a different order.\n\nThis does make certain kinds of vertex operations difficult; if you plan to write code that expects to encounter the vertices of a model in a particular order, we recommend you build up those vertices yourself using a GeomVertexWriter <more-about-geomvertexreader-geomvertexwriter-and-geomvertexrewriter> (as described in creating-and-filling-a-geomvertexdata), so that you have explicit control over the vertex order.\n\nHowever, if you have no need to operate on the vertices in any particular order, or if you just want to casually browse the vertices in a model, feel free to use the following instructions to read the data.\n\nWhen you load a model, you have a handle to the root node of the model, which is usually a ModelRoot node. The geometry itself will be stored in a series of GeomNodes <geomnode>, which will be children of the root node. In order to examine the vertex data, you must visit the GeomNodes in the model. One way to do this is to walk through all the GeomNodes like this:\n\npython\n\ngeomNodeCollection = model.findAllMatches('**/+GeomNode')\nfor nodePath in geomNodeCollection:\n    geomNode = nodePath.node()\n    processGeomNode(geomNode)\n\ncpp\n\nNodePathCollection geomNodeCollection = model.find_all_matches(\"**/+GeomNode\");\n\nfor (size_t i = 0; i < geomNodeCollection.get_num_paths(); ++i) {\n  PT(GeomNode) g = DCAST(GeomNode, geomNodeCollection.get_path(i).node());\n  processGeomNode(g);\n}\n\nOnce you have a particular GeomNode, you must walk through the list of Geoms <geom> stored on that node. Each Geom also has an associated RenderState, which controls the visible appearance of that Geom (e.g. texture, backfacing, etc.).\n\npython\n\ndef processGeomNode(geomNode):\n    for i in range(geomNode.getNumGeoms()):\n        geom = geomNode.getGeom(i)\n        state = geomNode.getGeomState(i)\n        print(geom)\n        print(state)\n        processGeom(geom)\n\ncpp\n\nvoid processGeomNode(GeomNode *geomnode) {\n  for (size_t j = 0; j < geomnode->get_num_geoms(); ++j) {\n    PT(Geom) geom = geomnode->get_geom(j);\n    geom->write(nout); // Outputs basic info on the geom\n    geomnode->get_geom_state(j)->write(nout); // Basic renderstate info\n    processGeom(geom);\n  }\n}\n\nNote that geomNode.getGeom() is only appropriate if you will be reading, but not modifying, the data. If you intend to modify the geom data in any way (including any nested data like vertices or primitives), you should use geomNode.modifyGeom() instead.\n\nEach Geom has an associated geomvertexdata, and one or more GeomPrimitives <geomprimitive>. Some GeomVertexData objects may be shared by more than one Geom, especially if you have used flattenStrong() to optimize a model.\n\npython\n\ndef processGeom(geom):\n    vdata = geom.getVertexData()\n    print(vdata)\n    processVertexData(vdata)\n    for i in range(geom.getNumPrimitives()):\n        prim = geom.getPrimitive(i)\n        print(prim)\n        processPrimitive(prim, vdata)\n\ncpp\n\nvoid processGeom(Geom *geom) {\n  PT(GeomVertexData) vdata = geom->get_vertex_data();\n  vdata->write(nout);\n  processVertexData(vdata);\n  for (size_t i = 0; i < geom.get_num_primitives(); ++i) {\n    PT(GeomPrimitive) prim = geom->get_primitive(i);\n    prim->write(nout,0);\n    processPrimitive(prim, vdata);\n  }\n}\n\nAs above, get_vertex_data() is only appropriate if you will only be reading, but not modifying, the vertex data. Similarly, getPrimitive() is appropriate only if you will not be modifying the primitive index array. If you intend to modify either one, use modifyVertexData() or modifyPrimitive(), respectively.\n\nYou can use the GeomVertexReader <more-about-geomvertexreader-geomvertexwriter-and-geomvertexrewriter> class to examine the vertex data. You should create a GeomVertexReader for each column of the data you intend to read. It is up to you to ensure that a given column exists in the vertex data before you attempt to read it (you can use vdata.hasColumn() to test this).\n\npython\n\ndef processVertexData(vdata):\n    vertex = GeomVertexReader(vdata, 'vertex')\n    texcoord = GeomVertexReader(vdata, 'texcoord')\n    while not vertex.isAtEnd():\n        v = vertex.getData3()\n        t = texcoord.getData2()\n        print(\"v = %s, t = %s\" % (repr(v), repr(t)))\n\ncpp\n\nvoid processVertexData(const GeomVertexData *vdata) {\n  GeomVertexReader vertex(vdata, \"vertex\");\n  GeomVertexReader texcoord(vdata, \"texcoord\");\n  while (!vertex.is_at_end()) {\n    LVector3 v = vertex.get_data3();\n    LVector3 t = texcoord.get_data2();\n    nout << \"V = \" << v << \"T = \" << t << endl;\n  }\n}\n\nEach GeomPrimitive may be any of a handful of different classes, according to the primitive type it is; but all GeomPrimitive classes have the same common interface to walk through the list of vertices referenced by the primitives stored within the class.\n\nYou can use the setRow() method of GeomVertexReader to set the reader to a particular vertex. This affects the next call to getData(). In this way, you can extract the vertex data for the vertices in the order that the primitive references them (instead of in order from the beginning to the end of the vertex table, as above).\n\npython\n\ndef processPrimitive(prim, vdata):\n    vertex = GeomVertexReader(vdata, 'vertex')\n\n    prim = prim.decompose()\n\n    for p in range(prim.getNumPrimitives()):\n        s = prim.getPrimitiveStart(p)\n        e = prim.getPrimitiveEnd(p)\n        for i in range(s, e):\n            vi = prim.getVertex(i)\n            vertex.setRow(vi)\n            v = vertex.getData3()\n            print(\"prim %s has vertex %s: %s\" % (p, vi, repr(v)))\n\ncpp\n\nvoid processPrimitive(const GeomPrimitive *orig_prim, const GeomVertexData *vdata) {\n  GeomVertexReader vertex(vdata, \"vertex\");\n\n  CPT(GeomPrimitive) prim = orig_prim->decompose();\n\n  for (size_t k = 0; k < prim->get_num_primitives(); ++k) {\n    int s = prim->get_primitive_start(k);\n    int e = prim->get_primitive_end(k);\n    for (int i = s; i < e; ++i) {\n      int vi = prim->get_vertex(b);\n      vertex.set_row(vi);\n      LVector3 v = vertex.get_data3();\n      nout << \"prim \" << k << \" has vertex \" << vi <<\": \" << v << endl;\n    }\n  }\n}\n\nYou may find the call to prim.decompose() useful (as shown in the above example). This call automatically decomposes higher-order primitive types, like GeomTristrips and GeomTrifans, into the equivalent component primitive types, like GeomTriangles; but when called on a GeomTriangles, it returns the GeomTriangles object unchanged. Similarly, GeomLinestrips will be decomposed into GeomLines. This way you can write code that doesn't have to know anything about GeomTristrips and GeomTrifans, which are fairly complex; it can assume it will only get the much simpler GeomTriangles (or, in the case of lines or points, GeomLines and GeomPoints, respectively).",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/71ed822e_reading-existing-geometry.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/4cbfd15d_71ed822e_reading-existing-geometry.json",
    "doc_id": "doc_373"
  }
}