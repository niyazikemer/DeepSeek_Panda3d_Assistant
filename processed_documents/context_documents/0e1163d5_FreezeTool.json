{
  "content": "\"\"\" This module contains code to freeze a number of Python modules\ninto a single (mostly) standalone DLL or EXE. \"\"\"\n\nimport modulefinder\nimport sys\nimport os\nimport marshal\nimport platform\nimport struct\nimport io\nimport sysconfig\nimport zipfile\nimport importlib\nimport warnings\nfrom importlib import machinery\n\nfrom . import pefile\n\n# Temporary (?) try..except to protect against unbuilt p3extend_frozen.\ntry:\n    import p3extend_frozen\nexcept ImportError:\n    p3extend_frozen = None\n\nfrom panda3d.core import Filename, Multifile, PandaSystem, StringStream\n\n# Old imp constants.\n_PY_SOURCE = 1\n_PY_COMPILED = 2\n_C_EXTENSION = 3\n_PKG_DIRECTORY = 5\n_C_BUILTIN = 6\n_PY_FROZEN = 7\n\n_PKG_NAMESPACE_DIRECTORY = object()\n\n# Check to see if we are running python_d, which implies we have a\n# debug build, and we have to build the module with debug options.\n# This is only relevant on Windows.\n\n# I wonder if there's a better way to determine this?\npython = os.path.splitext(os.path.split(sys.executable)[1])[0]\nisDebugBuild = (python.lower().endswith('_d'))\n\n# These are modules that Python always tries to import up-front.  They\n# must be frozen in any main.exe.\n# NB. if encodings are removed, be sure to remove them from the shortcut in\n# deploy-stub.c.\nstartupModules = [\n    'encodings', 'encodings.*', 'io', 'marshal', 'importlib.machinery',\n    'importlib.util',\n]\n\n# These are some special init functions for some built-in Python modules that\n# deviate from the standard naming convention.  A value of None means that a\n# dummy entry should be written to the inittab.\nbuiltinInitFuncs = {\n    'builtins': None,\n    'sys': None,\n    'exceptions': None,\n    '_warnings': '_PyWarnings_Init',\n    'marshal': 'PyMarshal_Init',\n}\nif sys.version_info < (3, 7):\n    builtinInitFuncs['_imp'] = 'PyInit_imp'\n\n# These are modules that are not found normally for these modules. Add them\n# to an include list so users do not have to do this manually.\ntry:\n    from pytest import freeze_includes as pytest_imports\nexcept ImportError:\n    def pytest_imports():\n        return []\n\ndefaultHiddenImports = {\n    'pytest': pytest_imports(),\n    'pkg_resources': [\n        'pkg_resources.*.*',\n    ],\n    'xml.etree.cElementTree': ['xml.etree.ElementTree'],\n    'datetime': ['_strptime'],\n    'keyring.backends': ['keyring.backends.*'],\n    'matplotlib.font_manager': ['encodings.mac_roman'],\n    'matplotlib.backends._backend_tk': ['tkinter'],\n    'direct.particles': ['direct.particles.ParticleManagerGlobal'],\n    'numpy.core._multiarray_umath': [\n        'numpy.core._internal',\n        'numpy.core._dtype_ctypes',\n        'numpy.core._methods',\n    ],\n    'pandas.compat': ['lzma', 'cmath'],\n    'pandas._libs.tslibs.conversion': ['pandas._libs.tslibs.base'],\n    'plyer': ['plyer.platforms'],\n    'scipy.linalg': ['scipy.linalg.cython_blas', 'scipy.linalg.cython_lapack'],\n    'scipy.sparse.csgraph': ['scipy.sparse.csgraph._validation'],\n    'scipy.spatial.qhull': ['scipy._lib.messagestream'],\n    'scipy.spatial._qhull': ['scipy._lib.messagestream'],\n    'scipy.spatial.transform.rotation': ['scipy.spatial.transform._rotation_groups'],\n    'scipy.spatial.transform._rotation': ['scipy.spatial.transform._rotation_groups'],\n    'scipy.special._ufuncs': ['scipy.special._ufuncs_cxx'],\n    'scipy.stats._stats': ['scipy.special.cython_special'],\n    'setuptools.monkey': ['setuptools.msvc'],\n    'shapely._geometry_helpers': ['shapely._geos'],\n}\n\n\n# These are modules that import other modules but shouldn't pick them up as\n# dependencies (usually because they are optional).  This prevents picking up\n# unwanted dependencies.\nignoreImports = {\n    'direct.showbase.PythonUtil': ['pstats', 'profile'],\n\n    'toml.encoder': ['numpy'],\n    'py._builtin': ['__builtin__'],\n\n    'site': ['android_log'],\n}\n\nif sys.version_info >= (3, 8):\n    # importlib.metadata is a \"provisional\" module introduced in Python 3.8 that\n    # conditionally pulls in dependency-rich packages like \"email\" and \"pep517\"\n    # (the latter of which is a thirdparty package!)  But it's only imported in\n    # one obscure corner, so we don't want to pull it in by default.\n    ignoreImports['importlib._bootstrap_external'] = ['importlib.metadata']\n    ignoreImports['importlib.metadata'] = ['pep517']\n\n\n# These are overrides for specific modules.\noverrideModules = {\n    # Used by the warnings module, among others, to get line numbers.  Since\n    # we set __file__, this would cause it to try and extract Python code\n    # lines from the main executable, which we don't want.\n    'linecache': \"\"\"__all__ = [\"getline\", \"clearcache\", \"checkcache\", \"lazycache\"]\n\ncache = {}\n\ndef getline(filename, lineno, module_globals=None):\n    return ''\n\ndef clearcache():\n    global cache\n    cache = {}\n\ndef getlines(filename, module_globals=None):\n    return []\n\ndef checkcache(filename=None):\n    pass\n\ndef updatecache(filename, module_globals=None):\n    pass\n\ndef lazycache(filename, module_globals):\n    pass\n\"\"\",\n\n    # Used by setuptools to redirect distutils to setuptools' vendored copy.\n    # This causes problems because it makes assumptions about __file__, so we\n    # simply implement the logic ourselves.\n    '_distutils_hack.override': '',\n}\n\n# These are missing modules that we've reported already this session.\nreportedMissing = {}\n\n\nclass CompilationEnvironment:\n    \"\"\" Create an instance of this class to record the commands to\n    invoke the compiler on a given platform.  If needed, the caller\n    can create a custom instance of this class (or simply set the\n    compile strings directly) to customize the build environment. \"\"\"\n\n    def __init__(self, platform):\n        self.platform = platform\n\n        # The command to compile a c to an object file.  Replace %(basename)s\n        # with the basename of the source file, and an implicit .c extension.\n        self.compileObj = 'error'\n\n        # The command to link a single object file into an executable.  As\n        # above, replace $(basename)s with the basename of the original source\n        # file, and of the target executable.\n        self.linkExe = 'error'\n\n        # The command to link a single object file into a shared library.\n        self.linkDll = 'error'\n\n        # Paths to Python stuff.\n        self.Python = None\n        self.PythonIPath = sysconfig.get_path('include')\n        self.PythonVersion = sysconfig.get_config_var(\"LDVERSION\") or sysconfig.get_python_version()\n\n        # The VC directory of Microsoft Visual Studio (if relevant)\n        self.MSVC = None\n        # Directory to Windows Platform SDK (if relevant)\n        self.PSDK = None\n\n        # The setting to control release vs. debug builds.  Only relevant on\n        # Windows.\n        self.MD = None\n\n        # Added to the path to the MSVC bin and lib directories on 64-bits Windows.\n        self.suffix64 = ''\n\n        # The _d extension to add to dll filenames on Windows in debug builds.\n        self.dllext = ''\n\n        # Any architecture-specific string.\n        self.arch = ''\n\n        self.determineStandardSetup()\n\n    def determineStandardSetup(self):\n        if self.platform.startswith('win'):\n            self.Python = sysconf.PREFIX\n\n            if 'VCINSTALLDIR' in os.environ:\n                self.MSVC = os.environ['VCINSTALLDIR']\n            elif Filename('/c/Program Files/Microsoft Visual Studio 9.0/VC').exists():\n                self.MSVC = Filename('/c/Program Files/Microsoft Visual Studio 9.0/VC').toOsSpecific()\n            elif Filename('/c/Program Files (x86)/Microsoft Visual Studio 9.0/VC').exists():\n                self.MSVC = Filename('/c/Program Files (x86)/Microsoft Visual Studio 9.0/VC').toOsSpecific()\n            elif Filename('/c/Program Files/Microsoft Visual Studio .NET 2003/Vc7').exists():\n                self.MSVC = Filename('/c/Program Files/Microsoft Visual Studio .NET 2003/Vc7').toOsSpecific()\n            else:\n                print('Could not locate Microsoft Visual C++ Compiler! Try running from the Visual Studio Command Prompt.')\n                sys.exit(1)\n\n            if 'WindowsSdkDir' in os.environ:\n                self.PSDK = os.environ['WindowsSdkDir']\n            elif platform.architecture()[0] == '32bit' and Filename('/c/Program Files/Microsoft Platform SDK for Windows Server 2003 R2').exists():\n                self.PSDK = Filename('/c/Program Files/Microsoft Platform SDK for Windows Server 2003 R2').toOsSpecific()\n            elif os.path.exists(os.path.join(self.MSVC, 'PlatformSDK')):\n                self.PSDK = os.path.join(self.MSVC, 'PlatformSDK')\n            else:\n                print('Could not locate the Microsoft Windows Platform SDK! Try running from the Visual Studio Command Prompt.')\n                sys.exit(1)\n\n            # We need to use the correct compiler setting for debug vs. release builds.\n            self.MD = '/MD'\n            if isDebugBuild:\n                self.MD = '/MDd'\n                self.dllext = '_d'\n\n            # MSVC/bin and /lib directories have a different location\n            # for win64.\n            if self.platform == 'win_amd64':\n                self.suffix64 = '\\\\amd64'\n\n            # If it is run by makepanda, it handles the MSVC and PlatformSDK paths itself.\n            if 'MAKEPANDA' in os.environ:\n                self.compileObjExe = 'cl /wd4996 /Fo%(basename)s.obj /nologo /c %(MD)s /Zi /O2 /Ob2 /EHsc /Zm300 /W3 /I\"%(pythonIPath)s\" %(filename)s'\n                self.compileObjDll = self.compileObjExe\n                self.linkExe = 'link /nologo /MAP:NUL /FIXED:NO /OPT:REF /STACK:4194304 /INCREMENTAL:NO /LIBPATH:\"%(python)s\\\\libs\"  /out:%(basename)s.exe %(basename)s.obj'\n                self.linkDll = 'link /nologo /DLL /MAP:NUL /FIXED:NO /OPT:REF /INCREMENTAL:NO /LIBPATH:\"%(python)s\\\\libs\"  /out:%(basename)s%(dllext)s.pyd %(basename)s.obj'\n            else:\n                os.environ['PATH'] += ';' + self.MSVC + '\\\\bin' + self.suffix64 + ';' + self.MSVC + '\\\\Common7\\\\IDE;' + self.PSDK + '\\\\bin'\n\n                self.compileObjExe = 'cl /wd4996 /Fo%(basename)s.obj /nologo /c %(MD)s /Zi /O2 /Ob2 /EHsc /Zm300 /W3 /I\"%(pythonIPath)s\" /I\"%(PSDK)s\\\\include\" /I\"%(MSVC)s\\\\include\" %(filename)s'\n                self.compileObjDll = self.compileObjExe\n                self.linkExe = 'link /nologo /MAP:NUL /FIXED:NO /OPT:REF /STACK:4194304 /INCREMENTAL:NO /LIBPATH:\"%(PSDK)s\\\\lib\" /LIBPATH:\"%(MSVC)s\\\\lib%(suffix64)s\" /LIBPATH:\"%(python)s\\\\libs\"  /out:%(basename)s.exe %(basename)s.obj'\n                self.linkDll = 'link /nologo /DLL /MAP:NUL /FIXED:NO /OPT:REF /INCREMENTAL:NO /LIBPATH:\"%(PSDK)s\\\\lib\" /LIBPATH:\"%(MSVC)s\\\\lib%(suffix64)s\" /LIBPATH:\"%(python)s\\\\libs\"  /out:%(basename)s%(dllext)s.pyd %(basename)s.obj'\n\n        elif self.platform.startswith('osx_'):\n            # macOS\n            proc = self.platform.split('_', 1)[1]\n            if proc == 'i386':\n                self.arch = '-arch i386'\n            elif proc == 'ppc':\n                self.arch = '-arch ppc'\n            elif proc == 'amd64':\n                self.arch = '-arch x86_64'\n            elif proc in ('arm64', 'aarch64'):\n                self.arch = '-arch arm64'\n            self.compileObjExe = \"clang -c %(arch)s -o %(basename)s.o -O2 -I%(pythonIPath)s %(filename)s\"\n            self.compileObjDll = \"clang -fPIC -c %(arch)s -o %(basename)s.o -O2 -I%(pythonIPath)s %(filename)s\"\n            self.linkExe = \"clang %(arch)s -o %(basename)s %(basename)s.o\"\n            if '/Python.framework/' in self.PythonIPath:\n                framework_dir = self.PythonIPath.split(\"/Python.framework/\", 1)[0]\n                if framework_dir != \"/System/Library/Frameworks\":\n                    self.linkExe += \" -F \" + framework_dir\n            self.linkExe += \" -framework Python\"\n            self.linkDll = \"clang %(arch)s -undefined dynamic_lookup -bundle -o %(basename)s.so %(basename)s.o\"\n\n        else:\n            # Unix\n            lib_dir = sysconf.get_python_lib(plat_specific=1, standard_lib=1)\n            #python_a = os.path.join(lib_dir, \"config\", \"libpython%(pythonVersion)s.a\")\n            self.compileObjExe = \"%(CC)s %(CFLAGS)s -c -o %(basename)s.o -pthread -O2 %(filename)s -I%(pythonIPath)s\"\n            self.compileObjDll = \"%(CC)s %(CFLAGS)s %(CCSHARED)s -c -o %(basename)s.o -O2 %(filename)s -I%(pythonIPath)s\"\n            self.linkExe = \"%(CC)s -o %(basename)s %(basename)s.o -L/usr/local/lib -lpython%(pythonVersion)s\"\n            self.linkDll = \"%(LDSHARED)s -o %(basename)s.so %(basename)s.o -L/usr/local/lib -lpython%(pythonVersion)s\"\n\n            if os.path.isdir(\"/usr/PCBSD/local/lib\"):\n                self.linkExe += \" -L/usr/PCBSD/local/lib\"\n                self.linkDll += \" -L/usr/PCBSD/local/lib\"\n\n    def compileExe(self, filename, basename, extraLink=[]):\n        compile = self.compileObjExe % dict({\n            'python': self.Python,\n            'MSVC': self.MSVC,\n            'PSDK': self.PSDK,\n            'suffix64': self.suffix64,\n            'MD': self.MD,\n            'pythonIPath': self.PythonIPath,\n            'pythonVersion': self.PythonVersion,\n            'arch': self.arch,\n            'filename': filename,\n            'basename': basename,\n        }, **sysconf.get_config_vars())\n        sys.stderr.write(compile + '\\n')\n        if os.system(compile) != 0:\n            raise Exception('failed to compile %s.' % basename)\n\n        link = self.linkExe % dict({\n            'python': self.Python,\n            'MSVC': self.MSVC,\n            'PSDK': self.PSDK,\n            'suffix64': self.suffix64,\n            'pythonIPath': self.PythonIPath,\n            'pythonVersion': self.PythonVersion,\n            'arch': self.arch,\n            'filename': filename,\n            'basename': basename,\n        }, **sysconf.get_config_vars())\n        link += ' ' + ' '.join(extraLink)\n        sys.stderr.write(link + '\\n')\n        if os.system(link) != 0:\n            raise Exception('failed to link %s.' % basename)\n\n    def compileDll(self, filename, basename, extraLink=[]):\n        compile = self.compileObjDll % dict({\n            'python': self.Python,\n            'MSVC': self.MSVC,\n            'PSDK': self.PSDK,\n            'suffix64': self.suffix64,\n            'MD': self.MD,\n            'pythonIPath': self.PythonIPath,\n            'pythonVersion': self.PythonVersion,\n            'arch': self.arch,\n            'filename': filename,\n            'basename': basename,\n        }, **sysconf.get_config_vars())\n        sys.stderr.write(compile + '\\n')\n        if os.system(compile) != 0:\n            raise Exception('failed to compile %s.' % basename)\n\n        link = self.linkDll % dict({\n            'python': self.Python,\n            'MSVC': self.MSVC,\n            'PSDK': self.PSDK,\n            'suffix64': self.suffix64,\n            'pythonIPath': self.PythonIPath,\n            'pythonVersion': self.PythonVersion,\n            'arch': self.arch,\n            'filename': filename,\n            'basename': basename,\n            'dllext': self.dllext,\n        }, **sysconf.get_config_vars())\n        link += ' ' + ' '.join(extraLink)\n        sys.stderr.write(link + '\\n')\n        if os.system(link) != 0:\n            raise Exception('failed to link %s.' % basename)\n\n\n# The code from frozenmain.c in the Python source repository.\nfrozenMainCode = \"\"\"\n/* Python interpreter main program for frozen scripts */\n\n#include <Python.h>\n\n#if PY_MAJOR_VERSION >= 3\n#include <locale.h>\n\n#if PY_MINOR_VERSION < 5\n#define Py_DecodeLocale _Py_char2wchar\n#endif\n#endif\n\n#ifdef MS_WINDOWS\nextern void PyWinFreeze_ExeInit(void);\nextern void PyWinFreeze_ExeTerm(void);\n\nextern PyAPI_FUNC(int) PyImport_ExtendInittab(struct _inittab *newtab);\n#endif\n\n/* Main program */\n\nEXTRA_INIT_FUNC_DECLS\n\nint\nPy_FrozenMain(int argc, char **argv)\n{\n    char *p;\n    int n, sts = 1;\n    int inspect = 0;\n    int unbuffered = 0;\n\n#if PY_MAJOR_VERSION >= 3\n    int i;\n    char *oldloc;\n    wchar_t **argv_copy = NULL;\n    /* We need a second copies, as Python might modify the first one. */\n    wchar_t **argv_copy2 = NULL;\n\n    if (argc > 0) {\n        argv_copy = (wchar_t **)alloca(sizeof(wchar_t *) * argc);\n        argv_copy2 = (wchar_t **)alloca(sizeof(wchar_t *) * argc);\n    }\n#endif\n\n    Py_FrozenFlag = 1; /* Suppress errors from getpath.c */\n    Py_NoSiteFlag = 1;\n    Py_NoUserSiteDirectory = 1;\n\n    if ((p = Py_GETENV(\"PYTHONINSPECT\")) && *p != '\\\\0')\n        inspect = 1;\n    if ((p = Py_GETENV(\"PYTHONUNBUFFERED\")) && *p != '\\\\0')\n        unbuffered = 1;\n\n    if (unbuffered) {\n        setbuf(stdin, (char *)NULL);\n        setbuf(stdout, (char *)NULL);\n        setbuf(stderr, (char *)NULL);\n    }\n\n#if PY_MAJOR_VERSION >= 3\n    oldloc = setlocale(LC_ALL, NULL);\n    setlocale(LC_ALL, \\\"\\\");\n    for (i = 0; i < argc; i++) {\n        argv_copy[i] = Py_DecodeLocale(argv[i], NULL);\n        argv_copy2[i] = argv_copy[i];\n        if (!argv_copy[i]) {\n            fprintf(stderr, \\\"Unable to decode the command line argument #%i\\\\n\\\",\n                            i + 1);\n            argc = i;\n            goto error;\n        }\n    }\n    setlocale(LC_ALL, oldloc);\n#endif\n\n#ifdef MS_WINDOWS\n    PyImport_ExtendInittab(extensions);\n#endif /* MS_WINDOWS */\n\n    if (argc >= 1) {\n#if PY_MAJOR_VERSION >= 3\n        Py_SetProgramName(argv_copy[0]);\n#else\n        Py_SetProgramName(argv[0]);\n#endif\n    }\n\n    Py_Initialize();\n#ifdef MS_WINDOWS\n    PyWinFreeze_ExeInit();\n#endif\n\n    if (Py_VerboseFlag)\n        fprintf(stderr, \"Python %s\\\\n%s\\\\n\",\n            Py_GetVersion(), Py_GetCopyright());\n\n#if PY_MAJOR_VERSION >= 3\n    PySys_SetArgv(argc, argv_copy);\n#else\n    PySys_SetArgv(argc, argv);\n#endif\n\nEXTRA_INIT_FUNC_CALLS\n\n    n = PyImport_ImportFrozenModule(\"__main__\");\n    if (n == 0)\n        Py_FatalError(\"__main__ not frozen\");\n    if (n < 0) {\n        PyErr_Print();\n        sts = 1;\n    }\n    else\n        sts = 0;\n\n    if (inspect && isatty((int)fileno(stdin)))\n        sts = PyRun_AnyFile(stdin, \"<stdin>\") != 0;\n\n#ifdef MS_WINDOWS\n    PyWinFreeze_ExeTerm();\n#endif\n    Py_Finalize();\n\n#if PY_MAJOR_VERSION >= 3\nerror:\n    if (argv_copy2) {\n        for (i = 0; i < argc; i++) {\n#if PY_MINOR_VERSION >= 4\n            PyMem_RawFree(argv_copy2[i]);\n#else\n            PyMem_Free(argv_copy2[i]);\n#endif\n        }\n    }\n#endif\n    return sts;\n}\n\"\"\"\n\n# The code from frozen_dllmain.c in the Python source repository.\n# Windows only.\nfrozenDllMainCode = \"\"\"\n#include <windows.h>\n\nstatic char *possibleModules[] = {\n    \"pywintypes\",\n    \"pythoncom\",\n    \"win32ui\",\n    NULL,\n};\n\nBOOL CallModuleDllMain(char *modName, DWORD dwReason);\n\n\n/*\n  Called by a frozen .EXE only, so that built-in extension\n  modules are initialized correctly\n*/\nvoid PyWinFreeze_ExeInit(void)\n{\n    char **modName;\n    for (modName = possibleModules;*modName;*modName++) {\n/*      printf(\"Initialising '%s'\\\\n\", *modName); */\n        CallModuleDllMain(*modName, DLL_PROCESS_ATTACH);\n    }\n}\n\n/*\n  Called by a frozen .EXE only, so that built-in extension\n  modules are cleaned up\n*/\nvoid PyWinFreeze_ExeTerm(void)\n{\n    // Must go backwards\n    char **modName;\n    for (modName = possibleModules+(sizeof(possibleModules) / sizeof(char *))-2;\n         modName >= possibleModules;\n         *modName--) {\n/*      printf(\"Terminating '%s'\\\\n\", *modName);*/\n        CallModuleDllMain(*modName, DLL_PROCESS_DETACH);\n    }\n}\n\nBOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)\n{\n    BOOL ret = TRUE;\n    switch (dwReason) {\n        case DLL_PROCESS_ATTACH:\n        {\n            char **modName;\n            for (modName = possibleModules;*modName;*modName++) {\n                BOOL ok = CallModuleDllMain(*modName, dwReason);\n                if (!ok)\n                    ret = FALSE;\n            }\n            break;\n        }\n        case DLL_PROCESS_DETACH:\n        {\n            // Must go backwards\n            char **modName;\n            for (modName = possibleModules+(sizeof(possibleModules) / sizeof(char *))-2;\n                 modName >= possibleModules;\n                 *modName--)\n                CallModuleDllMain(*modName, DLL_PROCESS_DETACH);\n            break;\n        }\n    }\n    return ret;\n}\n\nBOOL CallModuleDllMain(char *modName, DWORD dwReason)\n{\n    BOOL (WINAPI * pfndllmain)(HINSTANCE, DWORD, LPVOID);\n\n    char funcName[255];\n    HMODULE hmod = GetModuleHandle(NULL);\n    strcpy(funcName, \"_DllMain\");\n    strcat(funcName, modName);\n    strcat(funcName, \"@12\"); // stdcall convention.\n    pfndllmain = (BOOL (WINAPI *)(HINSTANCE, DWORD, LPVOID))GetProcAddress(hmod, funcName);\n    if (pfndllmain==NULL) {\n        /* No function by that name exported - then that module does\n           not appear in our frozen program - return OK\n                */\n        return TRUE;\n    }\n    return (*pfndllmain)(hmod, dwReason, NULL);\n}\n\"\"\"\n\n# Our own glue code to start up a Python executable.\nmainInitCode = \"\"\"\n%(frozenMainCode)s\n\nint\nmain(int argc, char *argv[]) {\n  PyImport_FrozenModules = _PyImport_FrozenModules;\n  return Py_FrozenMain(argc, argv);\n}\n\"\"\"\n\n# Our own glue code to start up a Python shared library.\ndllInitCode = \"\"\"\n/*\n * Call this function to extend the frozen modules array with a new\n * array of frozen modules, provided in a C-style array, at runtime.\n * Returns the total number of frozen modules.\n */\nstatic int\nextend_frozen_modules(const struct _frozen *new_modules, int new_count) {\n  int orig_count;\n  struct _frozen *realloc_FrozenModules;\n\n  /* First, count the number of frozen modules we had originally. */\n  orig_count = 0;\n  while (PyImport_FrozenModules[orig_count].name != NULL) {\n    ++orig_count;\n  }\n\n  if (new_count == 0) {\n    /* Trivial no-op. */\n    return orig_count;\n  }\n\n  /* Reallocate the PyImport_FrozenModules array bigger to make room\n     for the additional frozen modules.  We just leak the original\n     array; it's too risky to try to free it. */\n  realloc_FrozenModules = (struct _frozen *)malloc((orig_count + new_count + 1) * sizeof(struct _frozen));\n\n  /* The new frozen modules go at the front of the list. */\n  memcpy(realloc_FrozenModules, new_modules, new_count * sizeof(struct _frozen));\n\n  /* Then the original set of frozen modules. */\n  memcpy(realloc_FrozenModules + new_count, PyImport_FrozenModules, orig_count * sizeof(struct _frozen));\n\n  /* Finally, a single 0-valued entry marks the end of the array. */\n  memset(realloc_FrozenModules + orig_count + new_count, 0, sizeof(struct _frozen));\n\n  /* Assign the new pointer. */\n  PyImport_FrozenModules = realloc_FrozenModules;\n\n  return orig_count + new_count;\n}\n\n#if PY_MAJOR_VERSION >= 3\nstatic PyModuleDef mdef = {\n  PyModuleDef_HEAD_INIT,\n  \"%(moduleName)s\",\n  \"\",\n  -1,\n  NULL, NULL, NULL, NULL, NULL\n};\n\n%(dllexport)sPyObject *PyInit_%(moduleName)s(void) {\n  extend_frozen_modules(_PyImport_FrozenModules, sizeof(_PyImport_FrozenModules) / sizeof(struct _frozen));\n  return PyModule_Create(&mdef);\n}\n#else\nstatic PyMethodDef nullMethods[] = {\n  {NULL, NULL}\n};\n\n%(dllexport)svoid init%(moduleName)s(void) {\n  extend_frozen_modules(_PyImport_FrozenModules, sizeof(_PyImport_FrozenModules) / sizeof(struct _frozen));\n  Py_InitModule(\"%(moduleName)s\", nullMethods);\n}\n#endif\n\"\"\"\n\nprogramFile = \"\"\"\n#include <Python.h>\n#ifdef _WIN32\n#include <malloc.h>\n#endif\n\n%(moduleDefs)s\n\nstruct _frozen _PyImport_FrozenModules[] = {\n%(moduleList)s\n  {NULL, NULL, 0}\n};\n\"\"\"\n\n\nokMissing = [\n    '__main__', '_dummy_threading', 'Carbon', 'Carbon.Files',\n    'Carbon.Folder', 'Carbon.Folders', 'HouseGlobals', 'Carbon.File',\n    'MacOS', '_emx_link', 'ce', 'mac', 'org.python.core', 'os.path',\n    'os2', 'posix', 'pwd', 'readline', 'riscos', 'riscosenviron',\n    'riscospath', 'dbm', 'fcntl', 'win32api', 'win32pipe', 'usercustomize',\n    '_winreg', 'winreg', 'ctypes', 'ctypes.wintypes', 'nt','msvcrt',\n    'EasyDialogs', 'SOCKS', 'ic', 'rourl2path', 'termios', 'vms_lib',\n    'OverrideFrom23._Res', 'email', 'email.Utils', 'email.Generator',\n    'email.Iterators', '_subprocess', 'gestalt', 'java.lang',\n    'direct.extensions_native.extensions_darwin', '_manylinux',\n    'collections.Iterable', 'collections.Mapping', 'collections.MutableMapping',\n    'collections.Sequence', 'numpy_distutils', '_winapi',\n]\n\n# Since around macOS 10.15, Apple's codesigning process has become more strict.\n# Appending data to the end of a Mach-O binary is now explicitly forbidden. The\n# solution is to embed our own segment into the binary so it can be properly\n# signed.\nmach_header_64_layout = '<IIIIIIII'\n\n# Each load command is guaranteed to start with the command identifier and\n# command size. We'll call this the \"lc header\".\nlc_header_layout = '<II'\n\n# Each Mach-O segment is made up of sections. We need to change both the segment\n# and section information, so we'll need to know the layout of a section as\n# well.\nsection64_header_layout = '<16s16sQQIIIIIIII'\n\n# These are all of the load commands we'll need to modify parts of.\nLC_SEGMENT_64 = 0x19\nLC_DYLD_INFO_ONLY = 0x80000022\nLC_SYMTAB = 0x02\nLC_DYSYMTAB = 0x0B\nLC_FUNCTION_STARTS = 0x26\nLC_DATA_IN_CODE = 0x29\n\nlc_layouts = {\n    LC_SEGMENT_64: '<II16sQQQQIIII',\n    LC_DYLD_INFO_ONLY: '<IIIIIIIIIIII',\n    LC_SYMTAB: '<IIIIII',\n    LC_DYSYMTAB: '<IIIIIIIIIIIIIIIIIIII',\n    LC_FUNCTION_STARTS: '<IIII',\n    LC_DATA_IN_CODE: '<IIII',\n}\n\n# All of our modifications involve sliding some offsets, since we need to insert\n# our data in the middle of the binary (we can't just put the data at the end\n# since __LINKEDIT must be the last segment).\nlc_indices_to_slide = {\n    b'__PANDA': [4, 6],\n    b'__LINKEDIT': [3, 5],\n    LC_DYLD_INFO_ONLY: [2, 4, 8, 10],\n    LC_SYMTAB: [2, 4],\n    LC_DYSYMTAB: [14],\n    LC_FUNCTION_STARTS: [2],\n    LC_DATA_IN_CODE: [2],\n}\n\n\nclass Freezer:\n    class ModuleDef:\n        def __init__(self, moduleName, filename = None,\n                     implicit = False, guess = False,\n                     exclude = False, forbid = False,\n                     allowChildren = False, fromSource = None,\n                     text = None):\n            # The Python module name.\n            self.moduleName = moduleName\n\n            # The file on disk it was loaded from, if any.\n            self.filename = filename\n            if filename is not None and not isinstance(filename, Filename):\n                self.filename = Filename(filename)\n\n            # True if the module was found via the modulefinder.\n            self.implicit = implicit\n\n            # True if the moduleName might refer to some Python object\n            # other than a module, in which case the module should be\n            # ignored.\n            self.guess = guess\n\n            # True if the module should *not* be included in the\n            # generated output.\n            self.exclude = exclude\n\n            # True if the module should never be allowed, even if it\n            # exists at runtime.\n            self.forbid = forbid\n\n            # True if excluding the module still allows its children\n            # to be included.  This only makes sense if the module\n            # will exist at runtime through some other means\n            # (e.g. from another package).\n            self.allowChildren = allowChildren\n\n            # Additional black-box information about where this module\n            # record came from, supplied by the caller.\n            self.fromSource = fromSource\n\n            # If this is set, it contains Python code of the module.\n            self.text = text\n\n            # Some sanity checks.\n            if not self.exclude:\n                self.allowChildren = True\n\n            if self.forbid:\n                self.exclude = True\n                self.allowChildren = False\n\n        def __repr__(self):\n            args = [repr(self.moduleName), repr(self.filename)]\n            if self.implicit:\n                args.append('implicit = True')\n            if self.guess:\n                args.append('guess = True')\n            if self.exclude:\n                args.append('exclude = True')\n            if self.forbid:\n                args.append('forbid = True')\n            if self.allowChildren:\n                args.append('allowChildren = True')\n            return 'ModuleDef(%s)' % (', '.join(args))\n\n    def __init__(self, previous = None, debugLevel = 0,\n                 platform = None, path=None, hiddenImports=None, optimize=None):\n        # Normally, we are freezing for our own platform.  Change this\n        # if untrue.\n        self.platform = platform or PandaSystem.getPlatform()\n\n        # This is the compilation environment.  Fill in your own\n        # object here if you have custom needs (for instance, for a\n        # cross-compiler or something).  If this is None, then a\n        # default object will be created when it is needed.\n        self.cenv = None\n\n        # The filename extension to append to the source file before\n        # compiling.\n        self.sourceExtension = '.c'\n\n        # The filename extension to append to the object file.\n        self.objectExtension = '.o'\n        if self.platform.startswith('win'):\n            self.objectExtension = '.obj'\n\n        self.keepTemporaryFiles = False\n\n        # Change any of these to change the generated startup and glue\n        # code.\n        self.frozenMainCode = frozenMainCode\n        self.frozenDllMainCode = frozenDllMainCode\n        self.mainInitCode = mainInitCode\n\n        # Set this true to encode Python files in a Multifile as their\n        # original source if possible, or false to encode them as\n        # compiled pyc or pyo files.  This has no effect on frozen exe\n        # or dll's; those are always stored with compiled code.\n        self.storePythonSource = False\n\n        # This list will be filled in by generateCode() or\n        # addToMultifile().  It contains a list of all the extension\n        # modules that were discovered, which have not been added to\n        # the output.  The list is a list of tuples of the form\n        # (moduleName, filename).  filename will be None for built-in\n        # modules.\n        self.extras = []\n\n        # This is a list of init functions that must be called after\n        # Py_Initialize(), but before importing __main__.  This is a\n        # tuple of (return type, name).  They should use C calling\n        # convention.\n        self.extraInitFuncs = []\n\n        # Set this to true if extension modules should be linked in to\n        # the resulting executable.\n        self.linkExtensionModules = False\n\n        # End of public interface.  These remaining members should not\n        # be directly manipulated by callers.\n        self.previousModules = {}\n        self.modules = {}\n\n        if previous:\n            self.previousModules = dict(previous.modules)\n            self.modules = dict(previous.modules)\n\n        # Exclude doctest by default; it is not very useful in production\n        # builds.  It can be explicitly included if desired.\n        self.modules['doctest'] = self.ModuleDef('doctest', exclude = True)\n\n        # Actually, make sure we know how to find all of the\n        # already-imported modules.  (Some of them might do their own\n        # special path mangling.)\n        for moduleName, module in list(sys.modules.items()):\n            if module and getattr(module, '__path__', None) is not None:\n                modPath = list(getattr(module, '__path__'))\n                if modPath:\n                    modulefinder.AddPackagePath(moduleName, modPath[0])\n\n        # Module with non-obvious dependencies\n        self.hiddenImports = defaultHiddenImports.copy()\n        if hiddenImports is not None:\n            self.hiddenImports.update(hiddenImports)\n\n        # Special hack for plyer, which has platform-specific hidden imports\n        plyer_platform = None\n        if self.platform.startswith('android'):\n            plyer_platform = 'android'\n        elif self.platform.startswith('linux'):\n            plyer_platform = 'linux'\n        elif self.platform.startswith('mac'):\n            plyer_platform = 'macosx'\n        elif self.platform.startswith('win'):\n            plyer_platform = 'win'\n\n        if plyer_platform:\n            self.hiddenImports['plyer'].append(f'plyer.platforms.{plyer_platform}.*')\n\n        # Suffix/extension for Python C extension modules\n        if self.platform == PandaSystem.getPlatform():\n            suffixes = (\n                [(s, 'rb', _C_EXTENSION) for s in machinery.EXTENSION_SUFFIXES] +\n                [(s, 'rb', _PY_SOURCE) for s in machinery.SOURCE_SUFFIXES] +\n                [(s, 'rb', _PY_COMPILED) for s in machinery.BYTECODE_SUFFIXES]\n            )\n        else:\n            suffixes = [('.py', 'rb', 1), ('.pyc', 'rb', 2)]\n\n            abi_version = '{0}{1}'.format(*sys.version_info)\n            abi_flags = ''\n            if sys.version_info < (3, 8):\n                abi_flags += 'm'\n\n            if 'android' in self.platform:\n                arch = self.platform.split('_', 1)[1]\n                if arch in ('arm64', 'aarch64'):\n                    suffixes.append(('.cpython-{0}{1}-aarch64-linux-android.so'.format(abi_version, abi_flags), 'rb', 3))\n                elif arch in ('arm', 'armv7l'):\n                    suffixes.append(('.cpython-{0}{1}-arm-linux-androideabi.so'.format(abi_version, abi_flags), 'rb', 3))\n                elif arch in ('x86_64', 'amd64'):\n                    suffixes.append(('.cpython-{0}{1}-x86_64-linux-android.so'.format(abi_version, abi_flags), 'rb', 3))\n                elif arch in ('i386', 'i686'):\n                    suffixes.append(('.cpython-{0}{1}-i686-linux-android.so'.format(abi_version, abi_flags), 'rb', 3))\n\n                suffixes += [\n                    ('.abi{0}.so'.format(sys.version_info[0]), 'rb', 3),\n                    ('.so', 'rb', 3),\n                ]\n            elif 'linux' in self.platform:\n                suffixes += [\n                    ('.cpython-{0}{1}-x86_64-linux-gnu.so'.format(abi_version, abi_flags), 'rb', 3),\n                    ('.cpython-{0}{1}-i686-linux-gnu.so'.format(abi_version, abi_flags), 'rb', 3),\n                    ('.abi{0}.so'.format(sys.version_info[0]), 'rb', 3),\n                    ('.so', 'rb', 3),\n                ]\n            elif 'win' in self.platform:\n                # ABI flags are not appended on Windows.\n                suffixes += [\n                    ('.cp{0}-win_amd64.pyd'.format(abi_version), 'rb', 3),\n                    ('.cp{0}-win32.pyd'.format(abi_version), 'rb', 3),\n                    ('.pyd', 'rb', 3),\n                ]\n            elif 'mac' in self.platform:\n                suffixes += [\n                    ('.cpython-{0}{1}-darwin.so'.format(abi_version, abi_flags), 'rb', 3),\n                    ('.abi{0}.so'.format(sys.version_info[0]), 'rb', 3),\n                    ('.so', 'rb', 3),\n                ]\n            else: # FreeBSD et al.\n                suffixes += [\n                    ('.cpython-{0}{1}.so'.format(abi_version, abi_flags), 'rb', 3),\n                    ('.abi{0}.so'.format(sys.version_info[0]), 'rb', 3),\n                    ('.so', 'rb', 3),\n                ]\n\n        if optimize is None or optimize < 0:\n            self.optimize = sys.flags.optimize\n        else:\n            self.optimize = optimize\n\n        self.mf = PandaModuleFinder(excludes=['doctest'], suffixes=suffixes,\n                                    path=path, optimize=self.optimize)\n\n    def excludeFrom(self, freezer):\n        \"\"\" Excludes all modules that have already been processed by\n        the indicated FreezeTool.  This is equivalent to passing the\n        indicated FreezeTool object as previous to this object's\n        constructor, but it may be called at any point during\n        processing. \"\"\"\n\n        for key, value in list(freezer.modules.items()):\n            self.previousModules[key] = value\n            self.modules[key] = value\n\n    def excludeModule(self, moduleName, forbid = False, allowChildren = False,\n                      fromSource = None):\n        \"\"\" Adds a module to the list of modules not to be exported by\n        this tool.  If forbid is true, the module is furthermore\n        forbidden to be imported, even if it exists on disk.  If\n        allowChildren is true, the children of the indicated module\n        may still be included.\"\"\"\n\n        self.modules[moduleName] = self.ModuleDef(\n            moduleName, exclude = True,\n            forbid = forbid, allowChildren = allowChildren,\n            fromSource = fromSource)\n\n    def handleCustomPath(self, moduleName):\n        \"\"\" Indicates a module that may perform runtime manipulation\n        of its __path__ variable, and which must therefore be actually\n        imported at runtime in order to determine the true value of\n        __path__. \"\"\"\n\n        str = 'import %s' % (moduleName)\n        exec(str)\n\n        module = sys.modules[moduleName]\n        for path in module.__path__:\n            modulefinder.AddPackagePath(moduleName, path)\n\n    def getModulePath(self, moduleName):\n        \"\"\" Looks for the indicated directory module and returns the\n        __path__ member: the list of directories in which its python\n        files can be found.  If the module is a .py file and not a\n        directory, returns None. \"\"\"\n\n        path = None\n        baseName = moduleName\n        if '.' in baseName:\n            parentName, baseName = moduleName.rsplit('.', 1)\n            path = self.getModulePath(parentName)\n            if path is None:\n                return None\n\n        try:\n            file, pathname, description = self.mf.find_module(baseName, path)\n        except ImportError:\n            return None\n\n        if not self.mf._dir_exists(pathname):\n            return None\n\n        return [pathname]\n\n    def getModuleStar(self, moduleName):\n        \"\"\" Looks for the indicated directory module and returns the\n        __all__ member: the list of symbols within the module. \"\"\"\n\n        # Open the directory and scan for *.py files.\n        path = None\n        baseName = moduleName\n        if '.' in baseName:\n            parentName, baseName = moduleName.rsplit('.', 1)\n            path = self.getModulePath(parentName)\n            if path is None:\n                return None\n\n        try:\n            file, pathname, description = self.mf.find_module(baseName, path)\n        except ImportError:\n            return None\n\n        if not self.mf._dir_exists(pathname):\n            return None\n\n        # Scan the directory, looking for .py files.\n        modules = []\n        for basename in sorted(self.mf._listdir(pathname)):\n            if basename.endswith('.py') and basename != '__init__.py':\n                modules.append(basename[:-3])\n\n        return modules\n\n    def _gatherSubmodules(self, moduleName, implicit = False, newName = None,\n                          filename = None, guess = False, fromSource = None,\n                          text = None):\n        if not newName:\n            newName = moduleName\n\n        assert moduleName.endswith('.*')\n        assert newName.endswith('.*')\n\n        mdefs = {}\n\n        # Find the parent module, so we can get its directory.\n        parentName = moduleName[:-2]\n        newParentName = newName[:-2]\n        parentNames = [(parentName, newParentName)]\n\n        if parentName.endswith('.*'):\n            assert newParentName.endswith('.*')\n            # Another special case.  The parent name \"*\" means to\n            # return all possible directories within a particular\n            # directory.\n\n            topName = parentName[:-2]\n            newTopName = newParentName[:-2]\n            parentNames = []\n            modulePath = self.getModulePath(topName)\n            if modulePath:\n                for dirname in modulePath:\n                    for basename in sorted(self.mf._listdir(dirname)):\n                        if self.mf._file_exists(os.path.join(dirname, basename, '__init__.py')):\n                            parentName = '%s.%s' % (topName, basename)\n                            newParentName = '%s.%s' % (newTopName, basename)\n                            if self.getModulePath(parentName):\n                                parentNames.append((parentName, newParentName))\n\n        for parentName, newParentName in parentNames:\n            modules = self.getModuleStar(parentName)\n\n            if modules is None:\n                # It's actually a regular module.\n                mdefs[newParentName] = self.ModuleDef(\n                    parentName, implicit = implicit, guess = guess,\n                    fromSource = fromSource, text = text)\n\n            else:\n                # Now get all the py files in the parent directory.\n                for basename in modules:\n                    moduleName = '%s.%s' % (parentName, basename)\n                    newName = '%s.%s' % (newParentName, basename)\n                    mdefs[newName] = self.ModuleDef(\n                        moduleName, implicit = implicit, guess = True,\n                        fromSource = fromSource)\n        return mdefs\n\n    def addModule(self, moduleName, implicit = False, newName = None,\n                  filename = None, guess = False, fromSource = None,\n                  text = None):\n        \"\"\" Adds a module to the list of modules to be exported by\n        this tool.  If implicit is true, it is OK if the module does\n        not actually exist.\n\n        newName is the name to call the module when it appears in the\n        output.  The default is the same name it had in the original.\n        Use caution when renaming a module; if another module imports\n        this module by its original name, you will also need to\n        explicitly add the module under its original name, duplicating\n        the module twice in the output.\n\n        The module name may end in \".*\", which means to add all of the\n        .py files (other than __init__.py) in a particular directory.\n        It may also end in \".*.*\", which means to cycle through all\n        directories within a particular directory.\n        \"\"\"\n\n        if not newName:\n            newName = moduleName\n\n        if moduleName.endswith('.*'):\n            self.modules.update(self._gatherSubmodules(\n                moduleName, implicit, newName, filename,\n                guess, fromSource, text))\n        else:\n            # A normal, explicit module name.\n            self.modules[newName] = self.ModuleDef(\n                moduleName, filename = filename, implicit = implicit,\n                guess = guess, fromSource = fromSource, text = text)\n\n    def done(self, addStartupModules = False):\n        \"\"\" Call this method after you have added all modules with\n        addModule().  You may then call generateCode() or\n        writeMultifile() to dump the resulting output.  After a call\n        to done(), you may not add any more modules until you call\n        reset(). \"\"\"\n\n        # If we are building an exe, we also need to implicitly\n        # bring in Python's startup modules.\n        if addStartupModules:\n            self.modules['_frozen_importlib'] = self.ModuleDef('importlib._bootstrap', implicit = True)\n            self.modules['_frozen_importlib_external'] = self.ModuleDef('importlib._bootstrap_external', implicit = True)\n\n            if self.platform.startswith('android'):\n                self.modules['_android_support'] = self.ModuleDef('_android_support', implicit = True)\n\n            for moduleName in startupModules:\n                if moduleName not in self.modules:\n                    self.addModule(moduleName, implicit = True)\n\n        # Excluding a parent module also excludes all its\n        # (non-explicit) children, unless the parent has allowChildren\n        # set.\n\n        # Walk through the list in sorted order, so we reach parents\n        # before children.\n        excludeDict = {}\n        implicitParentDict = {}\n        includes = []\n        autoIncludes = []\n        origToNewName = {}\n        for newName, mdef in sorted(self.modules.items()):\n            moduleName = mdef.moduleName\n            origToNewName[moduleName] = newName\n            if mdef.implicit and '.' in newName:\n                # For implicit modules, check if the parent is excluded.\n                parentName, baseName = newName.rsplit('.', 1)\n                if parentName in excludeDict:\n                    mdef = excludeDict[parentName]\n\n            if mdef.exclude:\n                if not mdef.allowChildren:\n                    excludeDict[moduleName] = mdef\n            elif mdef.implicit or mdef.guess:\n                autoIncludes.append(mdef)\n            else:\n                includes.append(mdef)\n\n        # Add the excludes to the ModuleFinder.\n        for exclude in excludeDict:\n            self.mf.excludes.append(exclude)\n\n        # Attempt to import the explicit modules into the modulefinder.\n\n        # First, ensure the includes are sorted in order so that\n        # packages appear before the modules they contain.  This\n        # resolves potential ordering issues, especially with modules\n        # that are discovered by filename rather than through import\n        # statements.\n        includes.sort(key = self.__sortModuleKey)\n\n        # Now walk through the list and import them all.\n        for mdef in includes:\n            try:\n                self.__loadModule(mdef)\n            except ImportError as ex:\n                message = \"Unknown module: %s\" % (mdef.moduleName)\n                if str(ex) != \"No module named \" + str(mdef.moduleName):\n                    message += \" (%s)\" % (ex)\n                print(message)\n\n        # Also attempt to import any implicit modules.  If any of\n        # these fail to import, we don't really care.\n        for mdef in autoIncludes:\n            try:\n                self.__loadModule(mdef)\n                # Since it successfully loaded, it's no longer a guess.\n                mdef.guess = False\n            except Exception:\n                # Something went wrong, guess it's not an importable\n                # module.\n                pass\n\n        # Check if any new modules we found have \"hidden\" imports\n        for origName in list(self.mf.modules.keys()):\n            hidden = self.hiddenImports.get(origName, [])\n            for modname in hidden:\n                if modname.endswith('.*'):\n                    mdefs = self._gatherSubmodules(modname, implicit = True)\n                    for mdef in mdefs.values():\n                        try:\n                            self.__loadModule(mdef)\n                        except ImportError:\n                            pass\n                else:\n                    try:\n                        self.__loadModule(self.ModuleDef(modname, implicit = True))\n                    except ImportError:\n                        pass\n\n        # Special case for sysconfig, which depends on a platform-specific\n        # sysconfigdata module on POSIX systems.\n        missing = []\n        if 'sysconfig' in self.mf.modules and \\\n           ('linux' in self.platform or 'mac' in self.platform or 'emscripten' in self.platform):\n            modname = '_sysconfigdata'\n            if sys.version_info >= (3, 6):\n                modname += '_'\n                if sys.version_info < (3, 8):\n                    modname += 'm'\n\n                if 'linux' in self.platform:\n                    arch = self.platform.split('_', 1)[1]\n                    modname += '_linux_' + arch + '-linux-gnu'\n                elif 'mac' in self.platform:\n                    modname += '_darwin_darwin'\n                elif 'emscripten' in self.platform:\n                    if '_' in self.platform:\n                        arch = self.platform.split('_', 1)[1]\n                    else:\n                        arch = 'wasm32'\n                    modname += '_emscripten_' + arch + '-emscripten'\n\n            try:\n                self.__loadModule(self.ModuleDef(modname, implicit=True))\n            except Exception:\n                missing.append(modname)\n\n        # Now, any new modules we found get added to the export list.\n        for origName in list(self.mf.modules.keys()):\n            if origName not in origToNewName:\n                self.modules[origName] = self.ModuleDef(origName, implicit = True)\n\n        for origName in self.mf.any_missing_maybe()[0]:\n            if origName in startupModules:\n                continue\n            if origName in self.previousModules:\n                continue\n            if origName in self.modules:\n                continue\n\n            # This module is missing.  Let it be missing in the\n            # runtime also.\n            self.modules[origName] = self.ModuleDef(origName, exclude = True,\n                                                    implicit = True)\n\n            if origName in okMissing:\n                # If it's listed in okMissing, don't even report it.\n                continue\n\n            prefix = origName.split('.')[0]\n            if origName not in reportedMissing:\n                missing.append(origName)\n                reportedMissing[origName] = True\n\n        if missing:\n            missing.sort()\n            print(\"There are some missing modules: %r\" % missing)\n\n    def __sortModuleKey(self, mdef):\n        \"\"\" A sort key function to sort a list of mdef's into order,\n        primarily to ensure that packages proceed their modules. \"\"\"\n\n        if mdef.moduleName:\n            # If we have a moduleName, the key consists of the split\n            # tuple of packages names.  That way, parents always sort\n            # before children.\n            return ('a', mdef.moduleName.split('.'))\n        else:\n            # If we don't have a moduleName, the key doesn't really\n            # matter--we use filename--but we start with 'b' to ensure\n            # that all of non-named modules appear following all of\n            # the named modules.\n            return ('b', mdef.filename)\n\n    def __loadModule(self, mdef):\n        \"\"\" Adds the indicated module to the modulefinder. \"\"\"\n\n        if mdef.filename:\n            # If it has a filename, then we found it as a file on\n            # disk.  In this case, the moduleName may not be accurate\n            # and useful, so load it as a file instead.\n\n            tempPath = None\n            if '.' not in mdef.moduleName:\n                # If we loaded a python file from the root, we need to\n                # temporarily add its directory to the module search\n                # path, so the modulefinder can find any sibling\n                # python files it imports as well.\n                tempPath = Filename(mdef.filename.getDirname()).toOsSpecific()\n                self.mf.path.append(tempPath)\n\n            pathname = mdef.filename.toOsSpecific()\n            ext = mdef.filename.getExtension()\n            if ext == 'pyc' or ext == 'pyo':\n                fp = open(pathname, 'rb')\n                stuff = (\"\", \"rb\", _PY_COMPILED)\n                self.mf.load_module(mdef.moduleName, fp, pathname, stuff)\n            else:\n                stuff = (\"\", \"rb\", _PY_SOURCE)\n                if mdef.text is not None:\n                    fp = io.StringIO(mdef.text)\n                else:\n                    fp = open(pathname, 'rb')\n                self.mf.load_module(mdef.moduleName, fp, pathname, stuff)\n\n            if tempPath:\n                del self.mf.path[-1]\n\n        else:\n            # Otherwise, we can just import it normally.\n            self.mf.import_hook(mdef.moduleName)\n\n    def reset(self):\n        \"\"\" After a previous call to done(), this resets the\n        FreezeTool object for a new pass.  More modules may be added\n        and dumped to a new target.  Previously-added modules are\n        remembered and will not be dumped again. \"\"\"\n\n        self.mf = None\n        self.previousModules = dict(self.modules)\n\n    def mangleName(self, moduleName):\n        return 'M_' + moduleName.replace('.', '__').replace('-', '_')\n\n    def getAllModuleNames(self):\n        \"\"\" Return a list of all module names that have been included\n        or forbidden, either in this current pass or in a previous\n        pass.  Module names that have been excluded are not included\n        in this list. \"\"\"\n\n        moduleNames = []\n\n        for newName, mdef in list(self.modules.items()):\n            if mdef.guess:\n                # Not really a module.\n                pass\n            elif mdef.exclude and not mdef.forbid:\n                # An excluded (but not forbidden) file.\n                pass\n            else:\n                moduleNames.append(newName)\n\n        moduleNames.sort()\n        return moduleNames\n\n    def getModuleDefs(self):\n        \"\"\" Return a list of all of the modules we will be explicitly\n        or implicitly including.  The return value is actually a list\n        of tuples: (moduleName, moduleDef).\"\"\"\n\n        moduleDefs = []\n\n        for newName, mdef in list(self.modules.items()):\n            prev = self.previousModules.get(newName, None)\n            if not mdef.exclude:\n                # Include this module (even if a previous pass\n                # excluded it).  But don't bother if we exported it\n                # previously.\n                if prev and not prev.exclude:\n                    # Previously exported.\n                    pass\n                elif mdef.moduleName in self.mf.modules or \\\n                     mdef.moduleName in startupModules or \\\n                     mdef.filename:\n                    moduleDefs.append((newName, mdef))\n            elif mdef.forbid:\n                if not prev or not prev.forbid:\n                    moduleDefs.append((newName, mdef))\n\n        moduleDefs.sort()\n        return moduleDefs\n\n    def __replacePaths(self):\n        # Build up the replacement pathname table, so we can eliminate\n        # the personal information in the frozen pathnames.  The\n        # actual filename we put in there is meaningful only for stack\n        # traces, so we'll just use the module name.\n        replace_paths = []\n        for moduleName, module in list(self.mf.modules.items()):\n            if module.__code__:\n                origPathname = module.__code__.co_filename\n                if origPathname:\n                    replace_paths.append((origPathname, moduleName))\n        self.mf.replace_paths = replace_paths\n\n        # Now that we have built up the replacement mapping, go back\n        # through and actually replace the paths.\n        for moduleName, module in list(self.mf.modules.items()):\n            if module.__code__:\n                co = self.mf.replace_paths_in_code(module.__code__)\n                module.__code__ = co\n\n    def __addPyc(self, multifile, filename, code, compressionLevel):\n        if code:\n            data = importlib.util.MAGIC_NUMBER + b'\\0\\0\\0\\0\\0\\0\\0\\0'\n            data += marshal.dumps(code)\n\n            stream = StringStream(data)\n            multifile.addSubfile(filename, stream, compressionLevel)\n            multifile.flush()\n\n    def __addPythonDirs(self, multifile, moduleDirs, dirnames, compressionLevel):\n        \"\"\" Adds all of the names on dirnames as a module directory. \"\"\"\n        if not dirnames:\n            return\n\n        str = '.'.join(dirnames)\n        if str not in moduleDirs:\n            # Add an implicit __init__.py file (but only if there's\n            # not already a legitimate __init__.py file).\n            moduleName = '.'.join(dirnames)\n            filename = '/'.join(dirnames) + '/__init__'\n\n            if self.storePythonSource:\n                filename += '.py'\n                stream = StringStream(b'')\n                if multifile.findSubfile(filename) < 0:\n                    multifile.addSubfile(filename, stream, 0)\n                    multifile.flush()\n            else:\n                if __debug__:\n                    filename += '.pyc'\n                else:\n                    filename += '.pyo'\n                if multifile.findSubfile(filename) < 0:\n                    code = compile('', moduleName, 'exec', optimize=self.optimize)\n                    self.__addPyc(multifile, filename, code, compressionLevel)\n\n            moduleDirs[str] = True\n            self.__addPythonDirs(multifile, moduleDirs, dirnames[:-1], compressionLevel)\n\n    def __addPythonFile(self, multifile, moduleDirs, moduleName, mdef,\n                        compressionLevel):\n        \"\"\" Adds the named module to the multifile as a .pyc file. \"\"\"\n\n        # First, split the module into its subdirectory names.\n        dirnames = moduleName.split('.')\n        if len(dirnames) > 1 and dirnames[-1] == '__init__':\n            # The \"module\" may end in __init__, but that really means\n            # the parent directory.\n            dirnames = dirnames[:-1]\n\n        self.__addPythonDirs(multifile, moduleDirs, dirnames[:-1], compressionLevel)\n\n        filename = '/'.join(dirnames)\n\n        module = self.mf.modules.get(mdef.moduleName, None)\n        if getattr(module, '__path__', None) is not None or \\\n          (getattr(module, '__file__', None) is not None and getattr(module, '__file__').endswith('/__init__.py')):\n            # It's actually a package.  In this case, we really write\n            # the file moduleName/__init__.py.\n            filename += '/__init__'\n            moduleDirs[moduleName] = True\n\n            # Ensure we don't have an implicit filename from above.\n            multifile.removeSubfile(filename + '.py')\n            if __debug__:\n                multifile.removeSubfile(filename + '.pyc')\n            else:\n                multifile.removeSubfile(filename + '.pyo')\n\n        # Attempt to add the original source file if we can.\n        sourceFilename = None\n        if mdef.filename and mdef.filename.getExtension() == \"py\":\n            sourceFilename = mdef.filename\n        elif getattr(module, '__file__', None):\n            sourceFilename = Filename.fromOsSpecific(module.__file__)\n            sourceFilename.setExtension(\"py\")\n            sourceFilename.setText()\n\n        if self.storePythonSource:\n            if sourceFilename and sourceFilename.exists():\n                filename += '.py'\n                multifile.addSubfile(filename, sourceFilename, compressionLevel)\n                return\n\n        # If we can't find the source file, add the compiled pyc instead.\n        if __debug__:\n            filename += '.pyc'\n        else:\n            filename += '.pyo'\n\n        code = None\n        if module:\n            # Get the compiled code directly from the module object.\n            code = getattr(module, \"__code__\", None)\n            if not code:\n                # This is a module with no associated Python\n                # code.  It must be an extension module.  Get the\n                # filename.\n                extensionFilename = getattr(module, '__file__', None)\n                if extensionFilename:\n                    self.extras.append((moduleName, extensionFilename))\n                else:\n                    # It doesn't even have a filename; it must\n                    # be a built-in module.  No worries about\n                    # this one, then.\n                    pass\n\n        else:\n            # Read the code from the source file and compile it on-the-fly.\n            if sourceFilename and sourceFilename.exists():\n                source = open(sourceFilename.toOsSpecific(), 'r').read()\n                if source and source[-1] != '\\n':\n                    source = source + '\\n'\n                code = compile(source, str(sourceFilename), 'exec', optimize=self.optimize)\n\n        self.__addPyc(multifile, filename, code, compressionLevel)\n\n    def addToMultifile(self, multifile, compressionLevel = 0):\n        \"\"\" After a call to done(), this stores all of the accumulated\n        python code into the indicated Multifile.  Additional\n        extension modules are listed in self.extras.  \"\"\"\n\n        moduleDirs = {}\n        for moduleName, mdef in self.getModuleDefs():\n            if not mdef.exclude:\n                self.__addPythonFile(multifile, moduleDirs, moduleName, mdef,\n                                     compressionLevel)\n\n    def writeMultifile(self, mfname):\n        \"\"\" After a call to done(), this stores all of the accumulated\n        python code into a Multifile with the indicated filename,\n        including the extension.  Additional extension modules are\n        listed in self.extras.\"\"\"\n\n        self.__replacePaths()\n\n        Filename(mfname).unlink()\n        multifile = Multifile()\n        if not multifile.openReadWrite(mfname):\n            raise Exception\n\n        self.addToMultifile(multifile)\n\n        multifile.flush()\n        multifile.repack()\n\n    def writeCode(self, filename, initCode = \"\"):\n        \"\"\" After a call to done(), this freezes all of the accumulated\n        Python code into a C source file. \"\"\"\n\n        self.__replacePaths()\n\n        # Now generate the actual export table.\n        moduleDefs = []\n        moduleList = []\n\n        for moduleName, mdef in self.getModuleDefs():\n            origName = mdef.moduleName\n            if mdef.forbid:\n                # Explicitly disallow importing this module.\n                moduleList.append(self.makeForbiddenModuleListEntry(moduleName))\n                continue\n\n            assert not mdef.exclude\n            # Allow importing this module.\n            module = self.mf.modules.get(origName, None)\n            code = getattr(module, \"__code__\", None)\n            if code:\n                code = marshal.dumps(code)\n\n                mangledName = self.mangleName(moduleName)\n                moduleDefs.append(self.makeModuleDef(mangledName, code))\n                moduleList.append(self.makeModuleListEntry(mangledName, code, moduleName, module))\n                continue\n\n            #if moduleName in startupModules:\n            #    # Forbid the loading of this startup module.\n            #    moduleList.append(self.makeForbiddenModuleListEntry(moduleName))\n            #    continue\n\n            # This is a module with no associated Python code.  It is either\n            # an extension module or a builtin module.  Get the filename, if\n            # it is the former.\n            extensionFilename = getattr(module, '__file__', None)\n\n            if extensionFilename or self.linkExtensionModules:\n                self.extras.append((moduleName, extensionFilename))\n\n            # If it is a submodule of a frozen module, Python will have\n            # trouble importing it as a builtin module.  Synthesize a frozen\n            # module that loads it as builtin.\n            if '.' in moduleName and self.linkExtensionModules:\n                code = compile('import sys;del sys.modules[\"%s\"];from importlib._bootstrap import _builtin_from_name;_builtin_from_name(\"%s\")' % (moduleName, moduleName), moduleName, 'exec', optimize=self.optimize)\n                code = marshal.dumps(code)\n                mangledName = self.mangleName(moduleName)\n                moduleDefs.append(self.makeModuleDef(mangledName, code))\n                moduleList.append(self.makeModuleListEntry(mangledName, code, moduleName, None))\n            elif '.' in moduleName:\n                # Nothing we can do about this case except warn the user they\n                # are in for some trouble.\n                print('WARNING: Python cannot import extension modules under '\n                      'frozen Python packages; %s will be inaccessible.  '\n                      'passing either -l to link in extension modules or use '\n                      '-x %s to exclude the entire package.' % (moduleName, moduleName.split('.')[0]))\n\n        text = programFile % {\n            'moduleDefs': '\\n'.join(moduleDefs),\n            'moduleList': '\\n'.join(moduleList),\n        }\n\n        if self.linkExtensionModules and self.extras:\n            # Should we link in extension modules?  If so, we write out a new\n            # built-in module table that directly hooks up with the init\n            # functions.  On Linux, we completely override Python's own\n            # built-in module table; on Windows, we can't do this, so we\n            # instead use PyImport_ExtendInittab to add to it.\n\n            # Python 3 case.\n            text += '#if PY_MAJOR_VERSION >= 3\\n'\n            for module, fn in self.extras:\n                if sys.platform != \"win32\" or fn:\n                    libName = module.split('.')[-1]\n                    initFunc = builtinInitFuncs.get(module, 'PyInit_' + libName)\n                    if initFunc:\n                        text += 'extern PyAPI_FUNC(PyObject) *%s(void);\\n' % (initFunc)\n            text += '\\n'\n\n            if sys.platform == \"win32\":\n                text += 'static struct _inittab extensions[] = {\\n'\n            else:\n                text += 'struct _inittab _PyImport_Inittab[] = {\\n'\n\n            for module, fn in self.extras:\n                if sys.platform != \"win32\" or fn:\n                    libName = module.split('.')[-1]\n                    initFunc = builtinInitFuncs.get(module, 'PyInit_' + libName) or 'NULL'\n                    text += '  {\"%s\", %s},\\n' % (module, initFunc)\n            text += '  {0, 0},\\n'\n            text += '};\\n\\n'\n\n            # Python 2 case.\n            text += '#else\\n'\n            for module, fn in self.extras:\n                if sys.platform != \"win32\" or fn:\n                    libName = module.split('.')[-1]\n                    initFunc = builtinInitFuncs.get(module, 'init' + libName)\n                    if initFunc:\n                        text += 'extern PyAPI_FUNC(void) %s(void);\\n' % (initFunc)\n            text += '\\n'\n\n            if sys.platform == \"win32\":\n                text += 'static struct _inittab extensions[] = {\\n'\n            else:\n                text += 'struct _inittab _PyImport_Inittab[] = {\\n'\n\n            for module, fn in self.extras:\n                if sys.platform != \"win32\" or fn:\n                    libName = module.split('.')[-1]\n                    initFunc = builtinInitFuncs.get(module, 'init' + libName) or 'NULL'\n                    text += '  {\"%s\", %s},\\n' % (module, initFunc)\n            text += '  {0, 0},\\n'\n            text += '};\\n'\n            text += '#endif\\n\\n'\n\n        elif sys.platform == \"win32\":\n            text += 'static struct _inittab extensions[] = {\\n'\n            text += '  {0, 0},\\n'\n            text += '};\\n\\n'\n\n        text += initCode\n\n        if filename is not None:\n            file = open(filename, 'w')\n            file.write(text)\n            file.close()\n\n    def generateCode(self, basename, compileToExe = False):\n        \"\"\" After a call to done(), this freezes all of the\n        accumulated python code into either an executable program (if\n        compileToExe is true) or a dynamic library (if compileToExe is\n        false).  The basename is the name of the file to write,\n        without the extension.\n\n        The return value is the newly-generated filename, including\n        the filename extension.  Additional extension modules are\n        listed in self.extras. \"\"\"\n\n        if compileToExe:\n            # We must have a __main__ module to make an exe file.\n            if not self.__writingModule('__main__'):\n                message = \"Can't generate an executable without a __main__ module.\"\n                raise Exception(message)\n\n        filename = basename + self.sourceExtension\n\n        dllexport = ''\n        dllimport = ''\n        if self.platform.startswith('win'):\n            dllexport = '__declspec(dllexport) '\n            dllimport = '__declspec(dllimport) '\n\n        if not self.cenv:\n            self.cenv = CompilationEnvironment(platform = self.platform)\n\n        if compileToExe:\n            code = self.frozenMainCode\n\n            decls = ''\n            calls = ''\n            for func in self.extraInitFuncs:\n                if isinstance(func, str):\n                    func = ('void', func)\n                decls += f'extern {func[0]} {func[1]}();\\n'\n                calls += f'    {func[1]}();\\n';\n\n            code = code.replace('EXTRA_INIT_FUNC_DECLS', decls)\n            code = code.replace('EXTRA_INIT_FUNC_CALLS', calls)\n\n            if self.platform.startswith('win'):\n                code += self.frozenDllMainCode\n            initCode = self.mainInitCode % {\n                'frozenMainCode': code,\n                'programName': os.path.basename(basename),\n                'dllexport': dllexport,\n                'dllimport': dllimport,\n            }\n            if self.platform.startswith('win'):\n                target = basename + '.exe'\n            else:\n                target = basename\n\n            compileFunc = self.cenv.compileExe\n\n        else:\n            if self.platform.startswith('win'):\n                target = basename + self.cenv.dllext + '.pyd'\n            else:\n                target = basename + '.so'\n\n            initCode = dllInitCode % {\n                'moduleName': os.path.basename(basename),\n                'dllexport': dllexport,\n                'dllimport': dllimport,\n            }\n            compileFunc = self.cenv.compileDll\n\n        self.writeCode(filename, initCode=initCode)\n\n        # Keep track of the files we should clean up after use.\n        cleanFiles = [filename, basename + self.objectExtension]\n\n        extraLink = []\n        if self.linkExtensionModules:\n            for mod, fn in self.extras:\n                if not fn:\n                    continue\n                if sys.platform == 'win32':\n                    # We can't link with a .pyd directly on Windows.  Check\n                    # if there is a corresponding .lib file in the Python libs\n                    # directory.\n                    libsdir = os.path.join(sys.exec_prefix, 'libs')\n                    libfile = os.path.join(libsdir, mod + '.lib')\n                    if os.path.isfile(libfile):\n                        extraLink.append(mod + '.lib')\n                        continue\n\n                    # No, so we have to generate a .lib file.  This is pretty\n                    # easy given that we know the only symbol we need is a\n                    # initmodule or PyInit_module function.\n                    modname = mod.split('.')[-1]\n                    libfile = modname + '.lib'\n                    symbolName = 'PyInit_' + modname\n                    os.system('lib /nologo /def /export:%s /name:%s.pyd /out:%s' % (symbolName, modname, libfile))\n                    extraLink.append(libfile)\n                    cleanFiles += [libfile, modname + '.exp']\n                else:\n                    extraLink.append(fn)\n\n        try:\n            compileFunc(filename, basename, extraLink=extraLink)\n        finally:\n            if not self.keepTemporaryFiles:\n                for file in cleanFiles:\n                    if os.path.exists(file):\n                        os.unlink(file)\n\n        return target\n\n    def generateRuntimeFromStub(self, target, stub_file, use_console, fields={},\n                                log_append=False, log_filename_strftime=False):\n        self.__replacePaths()\n\n        # We must have a __main__ module to make an exe file.\n        if not self.__writingModule('__main__'):\n            message = \"Can't generate an executable without a __main__ module.\"\n            raise Exception(message)\n\n        if self.platform.startswith('win'):\n            modext = '.pyd'\n        else:\n            modext = '.so'\n\n        # First gather up the strings and code for all the module names, and\n        # put those in a string pool.\n        pool = b\"\"\n        strings = set()\n\n        for moduleName, mdef in self.getModuleDefs():\n            strings.add(moduleName.encode('ascii'))\n\n        for value in fields.values():\n            if value is not None:\n                strings.add(value.encode('utf-8'))\n\n        # Sort by length descending, allowing reuse of partial strings.\n        strings = sorted(strings, key=lambda str:-len(str))\n        string_offsets = {}\n\n        # Now add the strings to the pool, and collect the offsets relative to\n        # the beginning of the pool.\n        for string in strings:\n            # First check whether it's already in there; it could be part of\n            # a longer string.\n            offset = pool.find(string + b'\\0')\n            if offset < 0:\n                offset = len(pool)\n                pool += string + b'\\0'\n            string_offsets[string] = offset\n\n        # Now go through the modules and add them to the pool as well.  These\n        # are not 0-terminated, but we later record their sizes and names in\n        # a table after the blob header.\n        moduleList = []\n\n        for moduleName, mdef in self.getModuleDefs():\n            origName = mdef.moduleName\n            if mdef.forbid:\n                # Explicitly disallow importing this module.\n                moduleList.append((moduleName, 0, 0))\n                continue\n\n            # For whatever it's worth, align the code blocks.\n            if len(pool) & 3 != 0:\n                pad = (4 - (len(pool) & 3))\n                pool += b'\\0' * pad\n\n            assert not mdef.exclude\n            # Allow importing this module.\n            module = self.mf.modules.get(origName, None)\n            code = getattr(module, \"__code__\", None)\n            if code:\n                code = marshal.dumps(code)\n                size = len(code)\n                if getattr(module, \"__path__\", None):\n                    # Indicate package by negative size\n                    size = -size\n                moduleList.append((moduleName, len(pool), size))\n                pool += code\n                continue\n\n            # This is a module with no associated Python code.  It is either\n            # an extension module or a builtin module.  Get the filename, if\n            # it is the former.\n            extensionFilename = getattr(module, '__file__', None)\n\n            if extensionFilename:\n                self.extras.append((moduleName, extensionFilename))\n\n            # If it is a submodule of a frozen module, Python will have\n            # trouble importing it as a builtin module.  Synthesize a frozen\n            # module that loads it dynamically.\n            if '.' in moduleName and not self.platform.startswith('android'):\n                if self.platform.startswith(\"macosx\") and not use_console:\n                    # We write the Frameworks directory to sys.path[0].\n                    direxpr = 'sys.path[0]'\n                else:\n                    direxpr = 'os.path.dirname(sys.executable)'\n\n                code = \\\n                    f'import sys;' \\\n                    f'del sys.modules[\"{moduleName}\"];' \\\n                    f'import sys,os;' \\\n                    f'from importlib.machinery import ExtensionFileLoader,ModuleSpec;' \\\n                    f'from importlib._bootstrap import _load;' \\\n                    f'path=os.path.join({direxpr}, \"{moduleName}{modext}\");' \\\n                    f'_load(ModuleSpec(name=\"{moduleName}\", loader=ExtensionFileLoader(\"{moduleName}\", path), origin=path))'\n\n                code = compile(code, moduleName, 'exec', optimize=self.optimize)\n                code = marshal.dumps(code)\n                moduleList.append((moduleName, len(pool), len(code)))\n                pool += code\n\n        # Determine the format of the header and module list entries depending\n        # on the platform.\n        num_pointers = 12\n        stub_data = bytearray(stub_file.read())\n        bitnesses = self._get_executable_bitnesses(stub_data)\n\n        header_layouts = {\n            32: '<QQHHHH8x%dII' % num_pointers,\n            64: '<QQHHHH8x%dQQ' % num_pointers,\n        }\n        entry_layouts = {\n            32: '<IIi',\n            64: '<QQixxxx',\n        }\n\n        # Calculate the size of the module tables, so that we can determine\n        # the proper offset for the string pointers.  There can be more than\n        # one module table for macOS executables.  Sort the bitnesses so that\n        # the alignment is correct.\n        bitnesses = sorted(bitnesses, reverse=True)\n\n        pool_offset = 0\n        for bitness in bitnesses:\n            pool_offset += (len(moduleList) + 1) * struct.calcsize(entry_layouts[bitness])\n\n        # Now we can determine the offset of the blob.\n        if self.platform.startswith('win'):\n            # We don't use mmap on Windows.  Align just for good measure.\n            blob_align = 32\n        elif self.platform.endswith('_aarch64') or self.platform.endswith('_arm64'):\n            # Most arm64 operating systems are configured with 16 KiB pages.\n            blob_align = 16384\n        else:\n            # Align to page size, so that it can be mmapped.\n            blob_align = 4096\n\n        # Also determine the total blob size now.  Add padding to the end.\n        blob_size = pool_offset + len(pool)\n        if blob_size & (blob_align - 1) != 0:\n            pad = (blob_align - (blob_size & (blob_align - 1)))\n            blob_size += pad\n\n        # TODO: Support creating custom sections in universal binaries.\n        append_blob = True\n        if self.platform.startswith('macosx') and len(bitnesses) == 1:\n            # If our deploy-stub has a __PANDA segment, we know we're meant to\n            # put our blob there rather than attach it to the end.\n            load_commands = self._parse_macho_load_commands(stub_data)\n            if b'__PANDA' in load_commands.keys():\n                append_blob = False\n\n        if self.platform.startswith(\"macosx\") and not append_blob:\n            # Take this time to shift any Mach-O structures around to fit our\n            # blob. We don't need to worry about aligning the offset since the\n            # compiler already took care of that when creating the segment.\n            blob_offset = self._shift_macho_structures(stub_data, load_commands, blob_size)\n        else:\n            # Add padding before the blob if necessary.\n            blob_offset = len(stub_data)\n            if (blob_offset & (blob_align - 1)) != 0:\n                pad = (blob_align - (blob_offset & (blob_align - 1)))\n                stub_data += (b'\\0' * pad)\n                blob_offset += pad\n            assert (blob_offset % blob_align) == 0\n            assert blob_offset == len(stub_data)\n\n        # Calculate the offsets for the variables.  These are pointers,\n        # relative to the beginning of the blob.\n        field_offsets = {}\n        for key, value in fields.items():\n            if value is not None:\n                encoded = value.encode('utf-8')\n                field_offsets[key] = pool_offset + string_offsets[encoded]\n\n        # OK, now go and write the blob.  This consists of the module table\n        # (there may be two in the case of a macOS universal (fat) binary).\n        blob = b\"\"\n        append_offset = False\n        for bitness in bitnesses:\n            entry_layout = entry_layouts[bitness]\n            header_layout = header_layouts[bitness]\n\n            table_offset = len(blob)\n            for moduleName, offset, size in moduleList:\n                encoded = moduleName.encode('ascii')\n                string_offset = pool_offset + string_offsets[encoded]\n                if size != 0:\n                    offset += pool_offset\n                blob += struct.pack(entry_layout, string_offset, offset, size)\n\n            # A null entry marks the end of the module table.\n            blob += struct.pack(entry_layout, 0, 0, 0)\n\n            # These flags should match the enum in deploy-stub.c\n            flags = 0\n            if log_append:\n                flags |= 1\n            if log_filename_strftime:\n                flags |= 2\n            if self.optimize < 2:\n                flags |= 4 # keep_docstrings\n\n            # Compose the header we will be writing to the stub, to tell it\n            # where to find the module data blob, as well as other variables.\n            header = struct.pack(header_layout,\n                blob_offset,\n                blob_size,\n                1, # Version number\n                num_pointers, # Number of pointers that follow\n                0, # Codepage, not yet used\n                flags,\n                table_offset, # Module table pointer.\n                # The following variables need to be set before static init\n                # time.  See configPageManager.cxx, where they are read.\n                field_offsets.get('prc_data', 0),\n                field_offsets.get('default_prc_dir', 0),\n                field_offsets.get('prc_dir_envvars', 0),\n                field_offsets.get('prc_path_envvars', 0),\n                field_offsets.get('prc_patterns', 0),\n                field_offsets.get('prc_encrypted_patterns', 0),\n                field_offsets.get('prc_encryption_key', 0),\n                field_offsets.get('prc_executable_patterns', 0),\n                field_offsets.get('prc_executable_args_envvar', 0),\n                field_offsets.get('main_dir', 0),\n                field_offsets.get('log_filename', 0),\n                0)\n\n            # Now, find the location of the 'blobinfo' symbol in the binary,\n            # to which we will write our header.\n            if not self._replace_symbol(stub_data, b'blobinfo', header, bitness=bitness):\n                # This must be a legacy deploy-stub, which requires the offset to\n                # be appended to the end.\n                append_offset = True\n\n        # Add the string/code pool.\n        assert len(blob) == pool_offset\n        blob += pool\n        del pool\n\n        # Now pad out the blob to the calculated blob size.\n        if len(blob) < blob_size:\n            blob += b'\\0' * (blob_size - len(blob))\n        assert len(blob) == blob_size\n\n        if append_offset:\n            # This is for legacy deploy-stub.\n            warnings.warn(\"Could not find blob header. Is deploy-stub outdated?\")\n            blob += struct.pack('<Q', blob_offset)\n\n        with open(target, 'wb') as f:\n            if append_blob:\n                f.write(stub_data)\n                assert f.tell() == blob_offset\n                f.write(blob)\n            else:\n                stub_data[blob_offset:blob_offset + blob_size] = blob\n                f.write(stub_data)\n\n        os.chmod(target, 0o755)\n        return target\n\n    def _get_executable_bitnesses(self, data):\n        \"\"\"Returns the bitnesses (32 or 64) of the given executable data.\n        This will contain 1 element for non-fat executables.\"\"\"\n\n        if data.startswith(b'MZ'):\n            # A Windows PE file.\n            offset, = struct.unpack_from('<I', data, 0x3c)\n            assert data[offset:offset+4] == b'PE\\0\\0'\n\n            magic, = struct.unpack_from('<H', data, offset + 24)\n            assert magic in (0x010b, 0x020b)\n            if magic == 0x020b:\n                return (64,)\n            else:\n                return (32,)\n\n        elif data.startswith(b\"\\177ELF\"):\n            # A Linux/FreeBSD ELF executable.\n            elfclass = ord(data[4:5])\n            assert elfclass in (1, 2)\n            return (elfclass * 32,)\n\n        elif data[:4] in (b'\\xFE\\xED\\xFA\\xCE', b'\\xCE\\xFA\\xED\\xFE'):\n            # 32-bit Mach-O file, as used on macOS.\n            return (32,)\n\n        elif data[:4] in (b'\\xFE\\xED\\xFA\\xCF', b'\\xCF\\xFA\\xED\\xFE'):\n            # 64-bit Mach-O file, as used on macOS.\n            return (64,)\n\n        elif data[:4] in (b'\\xCA\\xFE\\xBA\\xBE', b'\\xBE\\xBA\\xFE\\xCA'):\n            # Universal binary with 32-bit offsets.\n            num_fat, = struct.unpack_from('>I', data, 4)\n            bitnesses = set()\n            ptr = 8\n            for i in range(num_fat):\n                cputype, cpusubtype, offset, size, align = \\\n                    struct.unpack_from('>IIIII', data, ptr)\n                ptr += 20\n\n                if (cputype & 0x1000000) != 0:\n                    bitnesses.add(64)\n                else:\n                    bitnesses.add(32)\n            return tuple(bitnesses)\n\n        elif data[:4] in (b'\\xCA\\xFE\\xBA\\xBF', b'\\xBF\\xBA\\xFE\\xCA'):\n            # Universal binary with 64-bit offsets.\n            num_fat, = struct.unpack_from('>I', data, 4)\n            bitnesses = set()\n            ptr = 8\n            for i in range(num_fat):\n                cputype, cpusubtype, offset, size, align = \\\n                    struct.unpack_from('>QQQQQ', data, ptr)\n                ptr += 40\n\n                if (cputype & 0x1000000) != 0:\n                    bitnesses.add(64)\n                else:\n                    bitnesses.add(32)\n            return tuple(bitnesses)\n\n    def _replace_symbol(self, data, symbol_name, replacement, bitness=None):\n        \"\"\"We store a custom section in the binary file containing a header\n        containing offsets to the binary data.\n        If bitness is set, and the binary in question is a macOS universal\n        binary, it only replaces for binaries with the given bitness. \"\"\"\n\n        if data.startswith(b'MZ'):\n            # A Windows PE file.\n            pe = pefile.PEFile()\n            pe.read(io.BytesIO(data))\n            addr = pe.get_export_address(symbol_name)\n            if addr is not None:\n                # We found it, return its offset in the file.\n                offset = pe.get_address_offset(addr)\n                if offset is not None:\n                    data[offset:offset+len(replacement)] = replacement\n                    return True\n\n        elif data.startswith(b\"\\177ELF\"):\n            return self._replace_symbol_elf(data, symbol_name, replacement)\n\n        elif data[:4] in (b'\\xFE\\xED\\xFA\\xCE', b'\\xCE\\xFA\\xED\\xFE',\n                          b'\\xFE\\xED\\xFA\\xCF', b'\\xCF\\xFA\\xED\\xFE'):\n            off = self._find_symbol_macho(data, symbol_name)\n            if off is not None:\n                data[off:off+len(replacement)] = replacement\n                return True\n            return False\n\n        elif data[:4] in (b'\\xCA\\xFE\\xBA\\xBE', b'\\xBE\\xBA\\xFE\\xCA'):\n            # Universal binary with 32-bit offsets.\n            num_fat, = struct.unpack_from('>I', data, 4)\n            replaced = False\n            ptr = 8\n            for i in range(num_fat):\n                cputype, cpusubtype, offset, size, align = \\\n                    struct.unpack_from('>IIIII', data, ptr)\n                ptr += 20\n\n                # Does this match the requested bitness?\n                if bitness is not None and ((cputype & 0x1000000) != 0) != (bitness == 64):\n                    continue\n\n                macho_data = data[offset:offset+size]\n                off = self._find_symbol_macho(macho_data, symbol_name)\n                if off is not None:\n                    off += offset\n                    data[off:off+len(replacement)] = replacement\n                    replaced = True\n\n            return replaced\n\n        elif data[:4] in (b'\\xCA\\xFE\\xBA\\xBF', b'\\xBF\\xBA\\xFE\\xCA'):\n            # Universal binary with 64-bit offsets.\n            num_fat, = struct.unpack_from('>I', data, 4)\n            replaced = False\n            ptr = 8\n            for i in range(num_fat):\n                cputype, cpusubtype, offset, size, align = \\\n                    struct.unpack_from('>QQQQQ', data, ptr)\n                ptr += 40\n\n                # Does this match the requested bitness?\n                if bitness is not None and ((cputype & 0x1000000) != 0) != (bitness == 64):\n                    continue\n\n                macho_data = data[offset:offset+size]\n                off = self._find_symbol_macho(macho_data, symbol_name)\n                if off is not None:\n                    off += offset\n                    data[off:off+len(replacement)] = replacement\n                    replaced = True\n\n            return replaced\n\n        # We don't know what kind of file this is.\n        return False\n\n    def _replace_symbol_elf(self, elf_data, symbol_name, replacement):\n        \"\"\" The Linux/FreeBSD implementation of _replace_symbol. \"\"\"\n\n        replaced = False\n\n        # Make sure we read in the correct endianness and integer size\n        endian = \"<>\"[ord(elf_data[5:6]) - 1]\n        is_64bit = ord(elf_data[4:5]) - 1 # 0 = 32-bits, 1 = 64-bits\n        header_struct = endian + (\"HHIIIIIHHHHHH\", \"HHIQQQIHHHHHH\")[is_64bit]\n        section_struct = endian + (\"4xI4xIIII8xI\", \"4xI8xQQQI12xQ\")[is_64bit]\n        symbol_struct = endian + (\"IIIBBH\", \"IBBHQQ\")[is_64bit]\n\n        header_size = struct.calcsize(header_struct)\n        type, machine, version, entry, phoff, shoff, flags, ehsize, phentsize, phnum, shentsize, shnum, shstrndx \\\n          = struct.unpack_from(header_struct, elf_data, 16)\n        section_offsets = []\n        symbol_tables = []\n        string_tables = {}\n\n        # Seek to the section header table and find the symbol tables.\n        ptr = shoff\n        for i in range(shnum):\n            type, addr, offset, size, link, entsize = struct.unpack_from(section_struct, elf_data[ptr:ptr+shentsize])\n            ptr += shentsize\n            section_offsets.append(offset - addr)\n            if type == 0x0B and link != 0: # SHT_DYNSYM, links to string table\n                symbol_tables.append((offset, size, link, entsize))\n                string_tables[link] = None\n\n        # Read the relevant string tables.\n        for idx in list(string_tables.keys()):\n            ptr = shoff + idx * shentsize\n            type, addr, offset, size, link, entsize = struct.unpack_from(section_struct, elf_data[ptr:ptr+shentsize])\n            if type == 3:\n                string_tables[idx] = elf_data[offset:offset+size]\n\n        # Loop through to find the offset of the \"blobinfo\" symbol.\n        for offset, size, link, entsize in symbol_tables:\n            entries = size // entsize\n            for i in range(entries):\n                ptr = offset + i * entsize\n                fields = struct.unpack_from(symbol_struct, elf_data[ptr:ptr+entsize])\n                if is_64bit:\n                    name, info, other, shndx, value, size = fields\n                else:\n                    name, value, size, info, other, shndx = fields\n\n                if not name:\n                    continue\n\n                name = string_tables[link][name : string_tables[link].find(b'\\0', name)]\n                if name == symbol_name:\n                    if shndx == 0: # SHN_UNDEF\n                        continue\n                    elif shndx >= 0xff00 and shndx <= 0xffff:\n                        assert False\n                    else:\n                        # Got it.  Make the replacement.\n                        off = section_offsets[shndx] + value\n                        elf_data[off:off+len(replacement)] = replacement\n                        replaced = True\n\n        return replaced\n\n    def _find_symbol_macho(self, macho_data, symbol_name):\n        \"\"\" Returns the offset of the given symbol in the binary file. \"\"\"\n\n        if macho_data[:4] in (b'\\xCE\\xFA\\xED\\xFE', b'\\xCF\\xFA\\xED\\xFE'):\n            endian = '<'\n        else:\n            endian = '>'\n\n        cputype, cpusubtype, filetype, ncmds, sizeofcmds, flags = \\\n            struct.unpack_from(endian + 'IIIIII', macho_data, 4)\n\n        is_64bit = (cputype & 0x1000000) != 0\n        segments = []\n\n        cmd_ptr = 28\n        nlist_struct = endian + 'IBBHI'\n        if is_64bit:\n            nlist_struct = endian + 'IBBHQ'\n            cmd_ptr += 4\n        nlist_size = struct.calcsize(nlist_struct)\n\n        for i in range(ncmds):\n            cmd, cmd_size = struct.unpack_from(endian + 'II', macho_data, cmd_ptr)\n            cmd_data = macho_data[cmd_ptr+8:cmd_ptr+cmd_size]\n            cmd_ptr += cmd_size\n\n            cmd &= ~0x80000000\n\n            if cmd == 0x01: # LC_SEGMENT\n                segname, vmaddr, vmsize, fileoff, filesize, maxprot, initprot, nsects, flags = \\\n                    struct.unpack_from(endian + '16sIIIIIIII', cmd_data)\n                segments.append((vmaddr, vmsize, fileoff))\n\n            elif cmd == 0x19: # LC_SEGMENT_64\n                segname, vmaddr, vmsize, fileoff, filesize, maxprot, initprot, nsects, flags = \\\n                    struct.unpack_from(endian + '16sQQQQIIII', cmd_data)\n                segments.append((vmaddr, vmsize, fileoff))\n\n            elif cmd == 0x2: # LC_SYMTAB\n                symoff, nsyms, stroff, strsize = \\\n                    struct.unpack_from(endian + 'IIII', cmd_data)\n\n                strings = macho_data[stroff:stroff+strsize]\n\n                for j in range(nsyms):\n                    strx, type, sect, desc, value = struct.unpack_from(nlist_struct, macho_data, symoff)\n                    symoff += nlist_size\n                    name = strings[strx : strings.find(b'\\0', strx)]\n\n                    # If the entry's type has any bits at 0xe0 set, it's a debug\n                    # symbol, and will point us to the wrong place.\n                    if name == b'_' + symbol_name and type & 0xe0 == 0:\n                        # Find out in which segment this is.\n                        for vmaddr, vmsize, fileoff in segments:\n                            # Is it defined in this segment?\n                            rel = value - vmaddr\n                            if rel >= 0 and rel < vmsize:\n                                # Yes, so return the symbol offset.\n                                return fileoff + rel\n                        print(\"Could not find memory address for symbol %s\" % (symbol_name))\n\n    def _parse_macho_load_commands(self, macho_data):\n        \"\"\"Returns the list of load commands from macho_data.\"\"\"\n        mach_header_64 = list(\n            struct.unpack_from(mach_header_64_layout, macho_data, 0))\n\n        num_load_commands = mach_header_64[4]\n\n        load_commands = {}\n\n        curr_lc_offset = struct.calcsize(mach_header_64_layout)\n        for i in range(num_load_commands):\n            lc = struct.unpack_from(lc_header_layout, macho_data, curr_lc_offset)\n            layout = lc_layouts.get(lc[0])\n            if layout:\n                # Make it a list since we want to mutate it.\n                lc = list(struct.unpack_from(layout, macho_data, curr_lc_offset))\n\n                if lc[0] == LC_SEGMENT_64:\n                    stripped_name = lc[2].rstrip(b'\\0')\n                    if stripped_name in [b'__PANDA', b'__LINKEDIT']:\n                        load_commands[stripped_name] = (curr_lc_offset, lc)\n                else:\n                    load_commands[lc[0]] = (curr_lc_offset, lc)\n\n            curr_lc_offset += lc[1]\n\n        return load_commands\n\n    def _shift_macho_structures(self, macho_data, load_commands, blob_size):\n        \"\"\"Given the stub and the size of our blob, make room for it and edit\n        all of the necessary structures to keep the binary valid. Returns the\n        offset where the blob should be placed.\"\"\"\n\n        for lc_key in load_commands.keys():\n            for index in lc_indices_to_slide[lc_key]:\n                load_commands[lc_key][1][index] += blob_size\n\n            if lc_key == b'__PANDA':\n                section_header_offset = load_commands[lc_key][0] + struct.calcsize(lc_layouts[LC_SEGMENT_64])\n                section_header = list(struct.unpack_from(section64_header_layout, macho_data, section_header_offset))\n                section_header[3] = blob_size\n                struct.pack_into(section64_header_layout, macho_data, section_header_offset, *section_header)\n\n            layout = LC_SEGMENT_64 if lc_key in [b'__PANDA', b'__LINKEDIT'] else lc_key\n            struct.pack_into(lc_layouts[layout], macho_data, load_commands[lc_key][0], *load_commands[lc_key][1])\n\n        blob_offset = load_commands[b'__PANDA'][1][5]\n\n        # Write in some null bytes until we write in the actual blob.\n        macho_data[blob_offset:blob_offset] = b'\\0' * blob_size\n\n        return blob_offset\n\n    def makeModuleDef(self, mangledName, code):\n        lines = ',\\n  '.join(','.join(map(str, code[i:i+16])) for i in range(0, len(code), 16))\n        return f'static unsigned char {mangledName}[] = {{\\n  {lines}\\n}};\\n'\n\n    def makeModuleListEntry(self, mangledName, code, moduleName, module):\n        size = len(code)\n        if getattr(module, \"__path__\", None):\n            # Indicate package by negative size\n            size = -size\n        return '  {\"%s\", %s, %s},' % (moduleName, mangledName, size)\n\n    def makeForbiddenModuleListEntry(self, moduleName):\n        return '  {\"%s\", NULL, 0},' % (moduleName)\n\n    def __writingModule(self, moduleName):\n        \"\"\" Returns true if we are outputting the named module in this\n        pass, false if we have already output in a previous pass, or\n        if it is not yet on the output table. \"\"\"\n\n        mdef = self.modules.get(moduleName, (None, None))\n        if mdef.exclude:\n            return False\n\n        if moduleName in self.previousModules:\n            return False\n\n        return True\n\n\nclass PandaModuleFinder(modulefinder.ModuleFinder):\n\n    def __init__(self, *args, **kw):\n        \"\"\"\n        :param path: search path to look on, defaults to sys.path\n        :param suffixes: defaults to imp.get_suffixes()\n        :param excludes: a list of modules to exclude\n        :param debug: an integer indicating the level of verbosity\n        \"\"\"\n\n        self.builtin_module_names = kw.pop('builtin_module_names', sys.builtin_module_names)\n\n        self.suffixes = kw.pop('suffixes', (\n            [(s, 'rb', _C_EXTENSION) for s in machinery.EXTENSION_SUFFIXES] +\n            [(s, 'r', _PY_SOURCE) for s in machinery.SOURCE_SUFFIXES] +\n            [(s, 'rb', _PY_COMPILED) for s in machinery.BYTECODE_SUFFIXES]\n        ))\n\n        self.optimize = kw.pop('optimize', -1)\n\n        modulefinder.ModuleFinder.__init__(self, *args, **kw)\n\n        # Make sure we don't open a .whl/.zip file more than once.\n        self._zip_files = {}\n\n    def _open_file(self, path, mode):\n        \"\"\" Opens a module at the given path, which may contain a zip file.\n        Returns None if the module could not be found. \"\"\"\n\n        if os.path.isfile(path):\n            if 'b' not in mode:\n                return io.open(path, mode, encoding='utf8')\n            else:\n                return open(path, mode)\n\n        # Is there a zip file along the path?\n        dir, dirname = os.path.split(path)\n        fn = dirname\n        while dirname:\n            if os.path.isfile(dir):\n                # Okay, this is actually a file.  Is it a zip file?\n                if dir in self._zip_files:\n                    # Yes, and we've previously opened this.\n                    zip = self._zip_files[dir]\n                elif zipfile.is_zipfile(dir):\n                    zip = zipfile.ZipFile(dir)\n                    self._zip_files[dir] = zip\n                else:\n                    # It's a different kind of file.  Stop looking.\n                    return None\n\n                try:\n                    zip_fn = fn.replace(os.path.sep, '/')\n                    if zip_fn.startswith('deploy_libs/_tkinter.'):\n                        # If we have a tkinter wheel on the path, ignore the\n                        # _tkinter extension in deploy-libs.\n                        if any(entry.endswith(\".whl\") and os.path.basename(entry).startswith(\"tkinter-\") for entry in self.path):\n                            return None\n                    fp = zip.open(zip_fn, 'r')\n                except KeyError:\n                    return None\n\n                if 'b' not in mode:\n                    return io.TextIOWrapper(fp, encoding='utf8')\n                return fp\n\n            # Look at the parent directory.\n            dir, dirname = os.path.split(dir)\n            fn = os.path.join(dirname, fn)\n\n        return None\n\n    def _file_exists(self, path):\n        if os.path.exists(path):\n            return os.path.isfile(path)\n\n        fh = self._open_file(path, 'rb')\n        if fh:\n            fh.close()\n            return True\n\n        return False\n\n    def _dir_exists(self, path):\n        \"\"\"Returns True if the given directory exists, either on disk or inside\n        a wheel.\"\"\"\n\n        if os.path.isdir(path):\n            return True\n\n        # Is there a zip file along the path?\n        dir, dirname = os.path.split(path.rstrip(os.path.sep + '/'))\n        fn = dirname\n        while dirname:\n            if os.path.isfile(dir):\n                # Okay, this is actually a file.  Is it a zip file?\n                if dir in self._zip_files:\n                    # Yes, and we've previously opened this.\n                    zip = self._zip_files[dir]\n                elif zipfile.is_zipfile(dir):\n                    zip = zipfile.ZipFile(dir)\n                    self._zip_files[dir] = zip\n                else:\n                    # It's a different kind of file.  Stop looking.\n                    return None\n\n                # (Most) zip files do not store directories; check instead for a\n                # file whose path starts with this directory name.\n                prefix = fn.replace(os.path.sep, '/') + '/'\n                for name in zip.namelist():\n                    if name.startswith(prefix):\n                        return True\n\n                return False\n\n            # Look at the parent directory.\n            dir, dirname = os.path.split(dir)\n            fn = os.path.join(dirname, fn)\n\n        return False\n\n    def _listdir(self, path):\n        \"\"\"Lists files in the given directory if it exists.\"\"\"\n\n        if os.path.isdir(path):\n            return os.listdir(path)\n\n        # Is there a zip file along the path?\n        dir, dirname = os.path.split(path.rstrip(os.path.sep + '/'))\n        fn = dirname\n        while dirname:\n            if os.path.isfile(dir):\n                # Okay, this is actually a file.  Is it a zip file?\n                if dir in self._zip_files:\n                    # Yes, and we've previously opened this.\n                    zip = self._zip_files[dir]\n                elif zipfile.is_zipfile(dir):\n                    zip = zipfile.ZipFile(dir)\n                    self._zip_files[dir] = zip\n                else:\n                    # It's not a directory or zip file.\n                    return []\n\n                # List files whose path start with our directory name.\n                prefix = fn.replace(os.path.sep, '/') + '/'\n                result = []\n                for name in zip.namelist():\n                    if name.startswith(prefix) and '/' not in name[len(prefix):]:\n                        result.append(name[len(prefix):])\n\n                return result\n\n            # Look at the parent directory.\n            dir, dirname = os.path.split(dir)\n            fn = os.path.join(dirname, fn)\n\n        return []\n\n    def load_module(self, fqname, fp, pathname, file_info):\n        \"\"\"Copied from ModuleFinder.load_module with fixes to handle sending bytes\n        to compile() for PY_SOURCE types. Sending bytes to compile allows it to\n        handle file encodings.\"\"\"\n\n        suffix, mode, type = file_info\n        self.msgin(2, \"load_module\", fqname, fp and \"fp\", pathname)\n        if type == _PKG_DIRECTORY:\n            m = self.load_package(fqname, pathname)\n            self.msgout(2, \"load_module ->\", m)\n            return m\n\n        if type is _PKG_NAMESPACE_DIRECTORY:\n            m = self.add_module(fqname)\n            m.__code__ = compile('', '', 'exec', optimize=self.optimize)\n            m.__path__ = pathname\n            return m\n\n        if type == _PY_SOURCE:\n            if fqname in overrideModules:\n                # This module has a custom override.\n                code = overrideModules[fqname]\n            else:\n                code = fp.read()\n\n            # Strip out delvewheel patch (see GitHub issue #1492)\n            if isinstance(code, bytes):\n                # Don't look for \\n at the end, it may also be \\r\\n\n                start_marker = b'# start delvewheel patch'\n                end_marker = b'# end delvewheel patch'\n            else:\n                start_marker = '# start delvewheel patch'\n                end_marker = '# end delvewheel patch'\n\n            start = code.find(start_marker)\n            while start >= 0:\n                end = code.find(end_marker, start) + len(end_marker)\n                code = code[:start] + code[end:]\n                start = code.find(start_marker)\n\n            code += b'\\n' if isinstance(code, bytes) else '\\n'\n            co = compile(code, pathname, 'exec', optimize=self.optimize)\n        elif type == _PY_COMPILED:\n            if sys.version_info >= (3, 7):\n                try:\n                    data = fp.read()\n                    importlib._bootstrap_external._classify_pyc(data, fqname, {})\n                except ImportError as exc:\n                    self.msgout(2, \"raise ImportError: \" + str(exc), pathname)\n                    raise\n\n                co = marshal.loads(memoryview(data)[16:])\n            else:\n                try:\n                    marshal_data = importlib._bootstrap_external._validate_bytecode_header(fp.read())\n                except ImportError as exc:\n                    self.msgout(2, \"raise ImportError: \" + str(exc), pathname)\n                    raise\n\n                co = marshal.loads(marshal_data)\n        else:\n            co = None\n\n        m = self.add_module(fqname)\n        m.__file__ = pathname\n        if co:\n            if self.replace_paths:\n                co = self.replace_paths_in_code(co)\n            m.__code__ = co\n            self.scan_code(co, m)\n        self.msgout(2, \"load_module ->\", m)\n        return m\n\n    # This function is provided here since the Python library version has a bug\n    # (see bpo-35376)\n    def _safe_import_hook(self, name, caller, fromlist, level=-1):\n        # wrapper for self.import_hook() that won't raise ImportError\n        if name in self.badmodules:\n            self._add_badmodule(name, caller)\n            return\n\n        if level <= 0 and caller and caller.__name__ in ignoreImports:\n            if name in ignoreImports[caller.__name__]:\n                return\n\n        try:\n            self.import_hook(name, caller, level=level)\n        except ImportError as msg:\n            self.msg(2, \"ImportError:\", str(msg))\n            self._add_badmodule(name, caller)\n        except SyntaxError as msg:\n            self.msg(2, \"SyntaxError:\", str(msg))\n            self._add_badmodule(name, caller)\n        else:\n            if fromlist:\n                for sub in fromlist:\n                    fullname = name + \".\" + sub\n                    if fullname in self.badmodules:\n                        self._add_badmodule(fullname, caller)\n                        continue\n                    try:\n                        self.import_hook(name, caller, [sub], level=level)\n                    except ImportError as msg:\n                        self.msg(2, \"ImportError:\", str(msg))\n                        self._add_badmodule(fullname, caller)\n\n    def scan_code(self, co, m):\n        code = co.co_code\n        # This was renamed to scan_opcodes in Python 3.6\n        if hasattr(self, 'scan_opcodes_25'):\n            scanner = self.scan_opcodes_25\n        else:\n            scanner = self.scan_opcodes\n\n        for what, args in scanner(co):\n            if what == \"store\":\n                name, = args\n                m.globalnames[name] = 1\n            elif what in (\"import\", \"absolute_import\"):\n                fromlist, name = args\n                have_star = 0\n                if fromlist is not None:\n                    if \"*\" in fromlist:\n                        have_star = 1\n                    fromlist = [f for f in fromlist if f != \"*\"]\n                if what == \"absolute_import\":\n                    level = 0\n                else:\n                    level = -1\n                self._safe_import_hook(name, m, fromlist, level=level)\n                if have_star:\n                    # We've encountered an \"import *\". If it is a Python module,\n                    # the code has already been parsed and we can suck out the\n                    # global names.\n                    mm = None\n                    if m.__path__:\n                        # At this point we don't know whether 'name' is a\n                        # submodule of 'm' or a global module. Let's just try\n                        # the full name first.\n                        mm = self.modules.get(m.__name__ + \".\" + name)\n                    if mm is None:\n                        mm = self.modules.get(name)\n                    if mm is not None:\n                        m.globalnames.update(mm.globalnames)\n                        m.starimports.update(mm.starimports)\n                        if mm.__code__ is None:\n                            m.starimports[name] = 1\n                    else:\n                        m.starimports[name] = 1\n            elif what == \"relative_import\":\n                level, fromlist, name = args\n                parent = self.determine_parent(m, level=level)\n                if name:\n                    self._safe_import_hook(name, m, fromlist, level=level)\n                else:\n                    self._safe_import_hook(parent.__name__, None, fromlist, level=0)\n\n                if fromlist and \"*\" in fromlist:\n                    if name:\n                        mm = self.modules.get(parent.__name__ + \".\" + name)\n                    else:\n                        mm = self.modules.get(parent.__name__)\n\n                    if mm is not None:\n                        m.globalnames.update(mm.globalnames)\n                        m.starimports.update(mm.starimports)\n                        if mm.__code__ is None:\n                            m.starimports[name] = 1\n                    else:\n                        m.starimports[name] = 1\n            else:\n                # We don't expect anything else from the generator.\n                raise RuntimeError(what)\n\n        for c in co.co_consts:\n            if isinstance(c, type(co)):\n                self.scan_code(c, m)\n\n    def find_module(self, name, path=None, parent=None):\n        \"\"\" Finds a module with the indicated name on the given search path\n        (or self.path if None).  Returns a tuple like (fp, path, stuff), where\n        stuff is a tuple like (suffix, mode, type). \"\"\"\n\n        #if imp.is_frozen(name):\n        #    # Don't pick up modules that are frozen into p3dpython.\n        #    raise ImportError(\"'%s' is a frozen module\" % (name))\n\n        if parent is not None:\n            fullname = parent.__name__+'.'+name\n        else:\n            fullname = name\n        if fullname in self.excludes:\n            raise ImportError(name)\n\n        # If we have a custom override for this module, we know we have it.\n        if fullname in overrideModules:\n            return (None, '', ('.py', 'r', _PY_SOURCE))\n\n        # It's built into the interpreter.\n        if fullname in self.builtin_module_names:\n            return (None, None, ('', '', _C_BUILTIN))\n\n        # If no search path is given, look for a built-in module.\n        if path is None:\n            path = self.path\n\n            if fullname == 'distutils' and hasattr(sys, 'real_prefix'):\n                # The PyPI version of virtualenv inserts a special version of\n                # distutils that does some bizarre stuff that won't work in our\n                # deployed application.  Force it to find the regular one.\n                try:\n                    fp, fn, stuff = self.find_module('opcode')\n                    if fn:\n                        path = [os.path.dirname(fn)] + path\n                except ImportError:\n                    pass\n\n            elif (fullname == 'distutils' and 'setuptools' in self.modules and\n                  '_distutils_hack.override' in self.modules):\n                # Redirect to setuptools' vendored copy.\n                setuptools = self.modules['setuptools']\n                return self.find_module('_distutils', setuptools.__path__, parent=setuptools)\n\n        elif parent is not None and parent.__name__ in ('setuptools.extern', 'pkg_resources.extern'):\n            # Look for vendored versions of these libraries.\n            root = self.modules[parent.__name__.split('.', 1)[0]]\n            try:\n                fp, fn, stuff = self.find_module('_vendor', root.__path__, parent=root)\n                vendor = self.load_module(root.__name__ + '._vendor', fp, fn, stuff)\n                return self.find_module(name, vendor.__path__, parent=vendor)\n            except ImportError:\n                pass\n\n        # Look for the module on the search path.\n        ns_dirs = []\n\n        for dir_path in path:\n            basename = os.path.join(dir_path, name.split('.')[-1])\n\n            # Look for recognized extensions.\n            for stuff in self.suffixes:\n                suffix, mode, _ = stuff\n                fp = self._open_file(basename + suffix, mode)\n                if fp:\n                    return (fp, basename + suffix, stuff)\n\n            # Consider a package, i.e. a directory containing __init__.py.\n            for suffix, mode, _ in self.suffixes:\n                init = os.path.join(basename, '__init__' + suffix)\n                if self._open_file(init, mode):\n                    return (None, basename, ('', '', _PKG_DIRECTORY))\n\n            # This may be a namespace package.\n            if self._dir_exists(basename):\n                ns_dirs.append(basename)\n\n        # It wasn't found through the normal channels.  Maybe it's one of\n        # ours, or maybe it's frozen?\n        if not path:\n            # Only if we're not looking on a particular path, though.\n            if p3extend_frozen and p3extend_frozen.is_frozen_module(name):\n                # It's a frozen module.\n                return (None, name, ('', '', _PY_FROZEN))\n\n        # If we found folders on the path with this module name without an\n        # __init__.py file, we should consider this a namespace package.\n        if ns_dirs:\n            return (None, ns_dirs, ('', '', _PKG_NAMESPACE_DIRECTORY))\n\n        raise ImportError(name)\n\n    def find_all_submodules(self, m):\n        # Overridden so that we can define our own suffixes.\n        if not m.__path__:\n            return\n        modules = {}\n        for dir in m.__path__:\n            try:\n                names = self._listdir(dir)\n            except OSError:\n                self.msg(2, \"can't list directory\", dir)\n                continue\n            for name in sorted(names):\n                mod = None\n                for suff in self.suffixes:\n                    n = len(suff)\n                    if name[-n:] == suff:\n                        mod = name[:-n]\n                        break\n                if mod and mod != \"__init__\":\n                    modules[mod] = mod\n        return modules.keys()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/dist/FreezeTool.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/0e1163d5_FreezeTool.json",
    "doc_id": "doc_133"
  }
}