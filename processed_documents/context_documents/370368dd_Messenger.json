{
  "content": "\"\"\"This defines the Messenger class, which is responsible for most of the\n:ref:`event handling <event-handlers>` that happens on the Python side.\n\"\"\"\n\n__all__ = ['Messenger']\n\nfrom direct.stdpy.threading import Lock\nfrom direct.directnotify import DirectNotifyGlobal\nfrom .PythonUtil import safeRepr\nimport types\n\n\nclass Messenger:\n\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"Messenger\")\n\n    def __init__(self):\n        \"\"\"\n        One is keyed off the event name. It has the following structure::\n\n            {event1: {object1: [method, extraArgs, persistent],\n                       object2: [method, extraArgs, persistent]},\n             event2: {object1: [method, extraArgs, persistent],\n                       object2: [method, extraArgs, persistent]}}\n\n        This dictionary allows for efficient callbacks when the\n        messenger hears an event.\n\n        A second dictionary remembers which objects are accepting which\n        events. This allows for efficient ignoreAll commands.\n\n        Or, for an example with more real data::\n\n            {'mouseDown': {avatar: [avatar.jump, [2.0], 1]}}\n        \"\"\"\n        # eventName->objMsgrId->callbackInfo\n        self.__callbacks = {}\n        # objMsgrId->set(eventName)\n        self.__objectEvents = {}\n        self._messengerIdGen = 0\n        # objMsgrId->listenerObject\n        self._id2object = {}\n\n        # A mapping of taskChain -> eventList, used for sending events\n        # across task chains (and therefore across threads).\n        self._eventQueuesByTaskChain = {}\n\n        # This protects the data structures within this object from\n        # multithreaded access.\n        self.lock = Lock()\n\n        if __debug__:\n            self.__isWatching=0\n            self.__watching={}\n        # I'd like this to be in the __debug__, but I fear that someone will\n        # want this in a release build.  If you're sure that that will not be\n        # then please remove this comment and put the quiet/verbose stuff\n        # under __debug__.\n        self.quieting={\"NewFrame\":1,\n                       \"avatarMoving\":1,\n                       \"event-loop-done\":1,\n                       'collisionLoopFinished':1,\n                       } # see def quiet()\n\n    def _getMessengerId(self, object):\n        # TODO: allocate this id in DirectObject.__init__ and get derived\n        # classes to call down (speed optimization, assuming objects\n        # accept/ignore more than once over their lifetime)\n        # get unique messenger id for this object\n        # assumes lock is held.\n        if not hasattr(object, '_MSGRmessengerId'):\n            object._MSGRmessengerId = (object.__class__.__name__, self._messengerIdGen)\n            self._messengerIdGen += 1\n        return object._MSGRmessengerId\n\n    def _storeObject(self, object):\n        # store reference-counted reference to object in case we need to\n        # retrieve it later.  assumes lock is held.\n        id = self._getMessengerId(object)\n        if id not in self._id2object:\n            self._id2object[id] = [1, object]\n        else:\n            self._id2object[id][0] += 1\n\n    def _getObject(self, id):\n        return self._id2object[id][1]\n\n    def _getObjects(self):\n        self.lock.acquire()\n        try:\n            objs = []\n            for refCount, obj in self._id2object.values():\n                objs.append(obj)\n            return objs\n        finally:\n            self.lock.release()\n\n    def _getNumListeners(self, event):\n        return len(self.__callbacks.get(event, {}))\n\n    def _getEvents(self):\n        return list(self.__callbacks.keys())\n\n    def _releaseObject(self, object):\n        # assumes lock is held.\n        id = self._getMessengerId(object)\n        if id in self._id2object:\n            record = self._id2object[id]\n            record[0] -= 1\n            if record[0] <= 0:\n                del self._id2object[id]\n\n    def future(self, event):\n        \"\"\" Returns a future that is triggered by the given event name.  This\n        will function only once. \"\"\"\n\n        from .EventManagerGlobal import eventMgr\n        return eventMgr.eventHandler.get_future(event)\n\n    def accept(self, event, object, method, extraArgs=[], persistent=1):\n        \"\"\" accept(self, string, DirectObject, Function, List, Boolean)\n\n        Make this object accept this event. When the event is\n        sent (using Messenger.send or from C++), method will be executed,\n        optionally passing in extraArgs.\n\n        If the persistent flag is set, it will continue to respond\n        to this event, otherwise it will respond only once.\n        \"\"\"\n        notifyDebug = Messenger.notify.getDebug()\n        if notifyDebug:\n            Messenger.notify.debug(\n                \"object: %s (%s)\\n accepting: %s\\n method: %s\\n extraArgs: %s\\n persistent: %s\" %\n                (safeRepr(object), self._getMessengerId(object), event, safeRepr(method),\n                 safeRepr(extraArgs), persistent))\n\n        # Make sure that the method is callable\n        assert hasattr(method, '__call__'), (\n            \"method not callable in accept (ignoring): %s %s\"%\n            (safeRepr(method), safeRepr(extraArgs)))\n\n        # Make sure extraArgs is a list or tuple\n        if not (isinstance(extraArgs, list) or isinstance(extraArgs, tuple) or isinstance(extraArgs, set)):\n            raise TypeError(\"A list is required as extraArgs argument\")\n\n        self.lock.acquire()\n        try:\n            acceptorDict = self.__callbacks.setdefault(event, {})\n\n            id = self._getMessengerId(object)\n\n            # Make sure we are not inadvertently overwriting an existing event\n            # on this particular object.\n            if id in acceptorDict:\n                # TODO: we're replacing the existing callback. should this be an error?\n                if notifyDebug:\n                    oldMethod = acceptorDict[id][0]\n                    if oldMethod == method:\n                        self.notify.warning(\n                            \"object: %s was already accepting: \\\"%s\\\" with same callback: %s()\" %\n                            (object.__class__.__name__, safeRepr(event), method.__name__))\n                    else:\n                        self.notify.warning(\n                            \"object: %s accept: \\\"%s\\\" new callback: %s() supplanting old callback: %s()\" %\n                            (object.__class__.__name__, safeRepr(event), method.__name__, oldMethod.__name__))\n\n            acceptorDict[id] = [method, extraArgs, persistent]\n\n            # Remember that this object is listening for this event\n            eventDict = self.__objectEvents.setdefault(id, {})\n            if event not in eventDict:\n                self._storeObject(object)\n                eventDict[event] = None\n        finally:\n            self.lock.release()\n\n    def ignore(self, event, object):\n        \"\"\" ignore(self, string, DirectObject)\n        Make this object no longer respond to this event.\n        It is safe to call even if it was not already accepting\n        \"\"\"\n        if Messenger.notify.getDebug():\n            Messenger.notify.debug(\n                safeRepr(object) + ' (%s)\\n now ignoring: ' % (self._getMessengerId(object), ) + safeRepr(event))\n\n        self.lock.acquire()\n        try:\n            id = self._getMessengerId(object)\n\n            # Find the dictionary of all the objects accepting this event\n            acceptorDict = self.__callbacks.get(event)\n            # If this object is there, delete it from the dictionary\n            if acceptorDict and id in acceptorDict:\n                del acceptorDict[id]\n                # If this dictionary is now empty, remove the event\n                # entry from the Messenger alltogether\n                if len(acceptorDict) == 0:\n                    del self.__callbacks[event]\n\n            # This object is no longer listening for this event\n            eventDict = self.__objectEvents.get(id)\n            if eventDict and event in eventDict:\n                del eventDict[event]\n                if len(eventDict) == 0:\n                    del self.__objectEvents[id]\n\n                self._releaseObject(object)\n        finally:\n            self.lock.release()\n\n    def ignoreAll(self, object):\n        \"\"\"\n        Make this object no longer respond to any events it was accepting\n        Useful for cleanup\n        \"\"\"\n        if Messenger.notify.getDebug():\n            Messenger.notify.debug(\n                safeRepr(object) + ' (%s)\\n now ignoring all events' % (self._getMessengerId(object), ))\n\n        self.lock.acquire()\n        try:\n            id = self._getMessengerId(object)\n            # Get the list of events this object is listening to\n            eventDict = self.__objectEvents.get(id)\n            if eventDict:\n                for event in list(eventDict.keys()):\n                    # Find the dictionary of all the objects accepting this event\n                    acceptorDict = self.__callbacks.get(event)\n                    # If this object is there, delete it from the dictionary\n                    if acceptorDict and id in acceptorDict:\n                        del acceptorDict[id]\n                        # If this dictionary is now empty, remove the event\n                        # entry from the Messenger alltogether\n                        if len(acceptorDict) == 0:\n                            del self.__callbacks[event]\n                    self._releaseObject(object)\n                del self.__objectEvents[id]\n        finally:\n            self.lock.release()\n\n    def getAllAccepting(self, object):\n        \"\"\"\n        Returns the list of all events accepted by the indicated object.\n        \"\"\"\n        self.lock.acquire()\n        try:\n            id = self._getMessengerId(object)\n\n            # Get the list of events this object is listening to\n            eventDict = self.__objectEvents.get(id)\n            if eventDict:\n                return list(eventDict.keys())\n            return []\n        finally:\n            self.lock.release()\n\n    def isAccepting(self, event, object):\n        \"\"\" isAccepting(self, string, DirectOject)\n        Is this object accepting this event?\n        \"\"\"\n        self.lock.acquire()\n        try:\n            acceptorDict = self.__callbacks.get(event)\n            id = self._getMessengerId(object)\n            if acceptorDict and id in acceptorDict:\n                # Found it, return true\n                return 1\n            # If we looked in both dictionaries and made it here\n            # that object must not be accepting that event.\n            return 0\n        finally:\n            self.lock.release()\n\n    def whoAccepts(self, event):\n        \"\"\"\n        Return objects accepting the given event\n        \"\"\"\n        return self.__callbacks.get(event)\n\n    def isIgnoring(self, event, object):\n        \"\"\" isIgnorning(self, string, DirectObject)\n        Is this object ignoring this event?\n        \"\"\"\n        return not self.isAccepting(event, object)\n\n    def send(self, event, sentArgs=[], taskChain=None):\n        \"\"\"\n        Send this event, optionally passing in arguments.\n\n        Args:\n            event (str): The name of the event.\n            sentArgs (list): A list of arguments to be passed along to the\n                handlers listening to this event.\n            taskChain (str, optional): If not None, the name of the task chain\n                which should receive the event.  If None, then the event is\n                handled immediately. Setting a non-None taskChain will defer\n                the event (possibly till next frame or even later) and create a\n                new, temporary task within the named taskChain, but this is the\n                only way to send an event across threads.\n        \"\"\"\n        if Messenger.notify.getDebug() and not self.quieting.get(event):\n            assert Messenger.notify.debug(\n                'sent event: %s sentArgs = %s, taskChain = %s' % (\n                event, sentArgs, taskChain))\n\n        self.lock.acquire()\n        try:\n            foundWatch = 0\n            if __debug__:\n                if self.__isWatching:\n                    for i in self.__watching:\n                        if str(event).find(i) >= 0:\n                            foundWatch = 1\n                            break\n            acceptorDict = self.__callbacks.get(event)\n            if not acceptorDict:\n                if __debug__:\n                    if foundWatch:\n                        print(\"Messenger: \\\"%s\\\" was sent, but no function in Python listened.\"%(event,))\n                return\n\n            if taskChain:\n                # Queue the event onto the indicated task chain.\n                from direct.task.TaskManagerGlobal import taskMgr\n                queue = self._eventQueuesByTaskChain.setdefault(taskChain, [])\n                queue.append((acceptorDict, event, sentArgs, foundWatch))\n                if len(queue) == 1:\n                    # If this is the first (only) item on the queue,\n                    # spawn the task to empty it.\n                    taskMgr.add(self.__taskChainDispatch, name = 'Messenger-%s' % (taskChain),\n                                extraArgs = [taskChain], taskChain = taskChain,\n                                appendTask = True)\n            else:\n                # Handle the event immediately.\n                self.__dispatch(acceptorDict, event, sentArgs, foundWatch)\n        finally:\n            self.lock.release()\n\n    def __taskChainDispatch(self, taskChain, task):\n        \"\"\" This task is spawned each time an event is sent across\n        task chains.  Its job is to empty the task events on the queue\n        for this particular task chain.  This guarantees that events\n        are still delivered in the same order they were sent. \"\"\"\n\n        while True:\n            eventTuple = None\n            self.lock.acquire()\n            try:\n                queue = self._eventQueuesByTaskChain.get(taskChain, None)\n                if queue:\n                    eventTuple = queue[0]\n                    del queue[0]\n                if not queue:\n                    # The queue is empty, we're done.\n                    if queue is not None:\n                        del self._eventQueuesByTaskChain[taskChain]\n\n                if not eventTuple:\n                    # No event; we're done.\n                    return task.done\n\n                self.__dispatch(*eventTuple)\n            finally:\n                self.lock.release()\n\n        return task.done\n\n    def __dispatch(self, acceptorDict, event, sentArgs, foundWatch):\n        for id in list(acceptorDict.keys()):\n            # We have to make this apparently redundant check, because\n            # it is possible that one object removes its own hooks\n            # in response to a handler called by a previous object.\n            #\n            # NOTE: there is no danger of skipping over objects due to\n            # modifications to acceptorDict, since the for..in above\n            # iterates over a list of objects that is created once at\n            # the start\n            callInfo = acceptorDict.get(id)\n            if callInfo:\n                method, extraArgs, persistent = callInfo\n                # If this object was only accepting this event once,\n                # remove it from the dictionary\n                if not persistent:\n                    # This object is no longer listening for this event\n                    eventDict = self.__objectEvents.get(id)\n                    if eventDict and event in eventDict:\n                        del eventDict[event]\n                        if len(eventDict) == 0:\n                            del self.__objectEvents[id]\n                        self._releaseObject(self._getObject(id))\n\n                    del acceptorDict[id]\n                    # If the dictionary at this event is now empty, remove\n                    # the event entry from the Messenger altogether\n                    if event in self.__callbacks \\\n                            and (len(self.__callbacks[event]) == 0):\n                        del self.__callbacks[event]\n\n                if __debug__:\n                    if foundWatch:\n                        print(\"Messenger: \\\"%s\\\" --> %s%s\"%(\n                            event,\n                            self.__methodRepr(method),\n                            tuple(extraArgs + sentArgs)))\n\n                #print \"Messenger: \\\"%s\\\" --> %s%s\"%(\n                #            event,\n                #            self.__methodRepr(method),\n                #            tuple(extraArgs + sentArgs))\n\n                # It is important to make the actual call here, after\n                # we have cleaned up the accept hook, because the\n                # method itself might call accept() or acceptOnce()\n                # again.\n                assert hasattr(method, '__call__')\n\n                # Release the lock temporarily while we call the method.\n                self.lock.release()\n                try:\n                    result = method(*(extraArgs + sentArgs))\n                finally:\n                    self.lock.acquire()\n\n                if hasattr(result, 'cr_await'):\n                    # It's a coroutine, so schedule it with the task manager.\n                    from direct.task.TaskManagerGlobal import taskMgr\n                    taskMgr.add(result)\n\n    def clear(self):\n        \"\"\"\n        Start fresh with a clear dict\n        \"\"\"\n        self.lock.acquire()\n        try:\n            self.__callbacks.clear()\n            self.__objectEvents.clear()\n            self._id2object.clear()\n        finally:\n            self.lock.release()\n\n    def isEmpty(self):\n        return len(self.__callbacks) == 0\n\n    def getEvents(self):\n        return list(self.__callbacks.keys())\n\n    def replaceMethod(self, oldMethod, newFunction):\n        \"\"\"\n        This is only used by Finder.py - the module that lets\n        you redefine functions with Control-c-Control-v\n        \"\"\"\n        retFlag = 0\n        for entry in list(self.__callbacks.items()):\n            event, objectDict = entry\n            for objectEntry in list(objectDict.items()):\n                object, params = objectEntry\n                method = params[0]\n                if isinstance(method, types.MethodType):\n                    function = method.__func__\n                else:\n                    function = method\n                #print ('function: ' + repr(function) + '\\n' +\n                #       'method: ' + repr(method) + '\\n' +\n                #       'oldMethod: ' + repr(oldMethod) + '\\n' +\n                #       'newFunction: ' + repr(newFunction) + '\\n')\n                if function == oldMethod:\n                    newMethod = types.MethodType(newFunction, method.__self__)\n                    params[0] = newMethod\n                    # Found it retrun true\n                    retFlag += 1\n        # didn't find that method, return false\n        return retFlag\n\n    def toggleVerbose(self):\n        isVerbose = 1 - Messenger.notify.getDebug()\n        Messenger.notify.setDebug(isVerbose)\n        if isVerbose:\n            print(\"Verbose mode true.  quiet list = %s\"%(\n                list(self.quieting.keys()),))\n\n    if __debug__:\n        def watch(self, needle):\n            \"\"\"\n            return a matching event (needle) if found (in haystack).\n            This is primarily a debugging tool.\n\n            This is intended for debugging use only.\n            This function is not defined if python is ran with -O (optimize).\n\n            See Also: `unwatch`\n            \"\"\"\n            if not self.__watching.get(needle):\n                self.__isWatching += 1\n                self.__watching[needle]=1\n\n        def unwatch(self, needle):\n            \"\"\"\n            return a matching event (needle) if found (in haystack).\n            This is primarily a debugging tool.\n\n            This is intended for debugging use only.\n            This function is not defined if python is ran with -O (optimize).\n\n            See Also: `watch`\n            \"\"\"\n            if self.__watching.get(needle):\n                self.__isWatching -= 1\n                del self.__watching[needle]\n\n        def quiet(self, message):\n            \"\"\"\n            When verbose mode is on, don't spam the output with messages\n            marked as quiet.\n            This is primarily a debugging tool.\n\n            This is intended for debugging use only.\n            This function is not defined if python is ran with -O (optimize).\n\n            See Also: `unquiet`\n            \"\"\"\n            if not self.quieting.get(message):\n                self.quieting[message]=1\n\n        def unquiet(self, message):\n            \"\"\"\n            Remove a message from the list of messages that are not reported\n            in verbose mode.\n            This is primarily a debugging tool.\n\n            This is intended for debugging use only.\n            This function is not defined if python is ran with -O (optimize).\n\n            See Also: `quiet`\n            \"\"\"\n            if self.quieting.get(message):\n                del self.quieting[message]\n\n    def find(self, needle):\n        \"\"\"\n        return a matching event (needle) if found (in haystack).\n        This is primarily a debugging tool.\n        \"\"\"\n        for event in sorted(self.__callbacks):\n            if repr(event).find(needle) >= 0:\n                return {event: self.__callbacks[event]}\n\n    def findAll(self, needle, limit=None):\n        \"\"\"\n        return a dict of events (needle) if found (in haystack).\n        limit may be None or an integer (e.g. 1).\n        This is primarily a debugging tool.\n        \"\"\"\n        matches = {}\n        for event in sorted(self.__callbacks):\n            if repr(event).find(needle) >= 0:\n                matches[event] = self.__callbacks[event]\n                # if the limit is not None, decrement and\n                # check for break:\n                if limit > 0:\n                    limit -= 1\n                    if limit == 0:\n                        break\n        return matches\n\n    def __methodRepr(self, method):\n        \"\"\"\n        return string version of class.method or method.\n        \"\"\"\n        if isinstance(method, types.MethodType):\n            functionName = method.__self__.__class__.__name__ + '.' + \\\n                method.__func__.__name__\n        else:\n            if hasattr(method, \"__name__\"):\n                functionName = method.__name__\n            else:\n                return \"\"\n        return functionName\n\n    def __eventRepr(self, event):\n        \"\"\"\n        Compact version of event, acceptor pairs\n        \"\"\"\n        str = event.ljust(32) + '\\t'\n        acceptorDict = self.__callbacks[event]\n        for key, (method, extraArgs, persistent) in list(acceptorDict.items()):\n            str = str + self.__methodRepr(method) + ' '\n        str = str + '\\n'\n        return str\n\n    def __repr__(self):\n        \"\"\"\n        Compact version of event, acceptor pairs\n        \"\"\"\n        str = \"The messenger is currently handling:\\n\" + \"=\"*64 + \"\\n\"\n        for event in sorted(self.__callbacks):\n            str += self.__eventRepr(event)\n        # Print out the object: event dictionary too\n        str += \"=\"*64 + \"\\n\"\n        for key, eventDict in list(self.__objectEvents.items()):\n            object = self._getObject(key)\n            str += \"%s:\\n\" % repr(object)\n            for event in list(eventDict.keys()):\n                str += \"     %s\\n\" % repr(event)\n\n        str += \"=\"*64 + \"\\n\" + \"End of messenger info.\\n\"\n        return str\n\n    def detailedRepr(self):\n        \"\"\"\n        Print out the table in a detailed readable format\n        \"\"\"\n        str = 'Messenger\\n'\n        str = str + '='*50 + '\\n'\n        for event in sorted(self.__callbacks):\n            acceptorDict = self.__callbacks[event]\n            str = str + 'Event: ' + event + '\\n'\n            for key in list(acceptorDict.keys()):\n                function, extraArgs, persistent = acceptorDict[key]\n                object = self._getObject(key)\n                objectClass = getattr(object, '__class__', None)\n                if objectClass:\n                    className = objectClass.__name__\n                else:\n                    className = \"Not a class\"\n                functionName = function.__name__\n                str = (str + '\\t' +\n                       'Acceptor:     ' + className + ' instance' + '\\n\\t' +\n                       'Function name:' + functionName + '\\n\\t' +\n                       'Extra Args:   ' + repr(extraArgs) + '\\n\\t' +\n                       'Persistent:   ' + repr(persistent) + '\\n')\n                # If this is a class method, get its actual function\n                if isinstance(function, types.MethodType):\n                    str = (str + '\\t' +\n                           'Method:       ' + repr(function) + '\\n\\t' +\n                           'Function:     ' + repr(function.__func__) + '\\n')\n                else:\n                    str = (str + '\\t' +\n                           'Function:     ' + repr(function) + '\\n')\n        str = str + '='*50 + '\\n'\n        return str\n\n    #snake_case alias:\n    get_events = getEvents\n    is_ignoring = isIgnoring\n    who_accepts = whoAccepts\n    find_all = findAll\n    replace_method = replaceMethod\n    ignore_all = ignoreAll\n    is_accepting = isAccepting\n    is_empty = isEmpty\n    detailed_repr = detailedRepr\n    get_all_accepting = getAllAccepting\n    toggle_verbose = toggleVerbose\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/Messenger.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/370368dd_Messenger.json",
    "doc_id": "doc_286"
  }
}