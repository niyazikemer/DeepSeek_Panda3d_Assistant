{
  "content": "Clicking on 3D Objects\n\nThe simplest way to click on 3D objects in Panda3D is to use very simplistic collision detection coupled with event processing. First, after a .CollisionTraverser and a .CollisionHandler have been set up, attach a .CollisionRay node to the camera. This node will have its \"from\" collision mask set to .GeomNode.get_default_collide_mask() in order to be as general as possible.\n\npython\n\npickerNode = CollisionNode('mouseRay')\npickerNP = camera.attachNewNode(pickerNode)\npickerNode.setFromCollideMask(GeomNode.getDefaultCollideMask())\npickerRay = CollisionRay()\npickerNode.addSolid(pickerRay)\nmyTraverser.addCollider(pickerNP, myHandler)\n\ncpp\n\nPT(MouseWatcher) mouseWatcher;\nPT(CollisionRay) pickerRay;\nCollisionTraverser myTraverser = CollisionTraverser(\"ctraverser\");\nPT(CollisionHandlerQueue) myHandler;\nPT(CollisionNode) pickerNode;\nNodePath pickerNP;\n\npickerNode = new CollisionNode(\"mouseRay\");\npickerNP = camera.attach_new_node (pickerNode);\npickerNode->set_from_collide_mask(GeomNode::get_default_collide_mask());\npickerRay = new CollisionRay();\npickerNode->add_solid(pickerRay);\nmyHandler = new CollisionHandlerQueue();\nmyTraverser.add_collider(pickerNP, myHandler);\n\nFor any object that you want to be pickable you should add a flag to it. The easiest way is to use the ~.NodePath.set_tag() function:\n\npython\n\nobject1.setTag('myObjectTag', '1')\nobject2.setTag('myObjectTag', '2')\n\ncpp\n\nobject1.set_tag(\"myObjectTag\", \"1\");\nobject2.set_tag(\"myObjectTag\", \"2\");\n\nThe above example sets the tag 'myObjectTag' on two objects in your graph that you want to designate as pickable. We will check for the presence of this tag after we get the response back from the collision system.\n\npython\n\nBecause Actors <loading-actors-and-animations> use a different set-up, the collision system will return the geometry but not the NodePath. Use object.set_python_tag('myObjectTag', 1) <.NodePath.set_python_tag> and object.get_python_tag('myObjectTag') <.NodePath.get_python_tag> instead to return the node path of an Actor.\n\nNow assume that the function myFunction() is set up to be called for the 'mouse1' event. In myFunction() is where you call pickerRay.set_from_lens(origin, destX, destY) <.CollisionRay.set_from_lens>. This makes the ray's origin origin and the ray's vector the direction from origin to the point (destX, destY).\n\npython\n\ndef myFunction():\n    # First we check that the mouse is not outside the screen.\n    if base.mouseWatcherNode.hasMouse():\n        # This gives up the screen coordinates of the mouse.\n        mpos = base.mouseWatcherNode.getMouse()\n\n    # This makes the ray's origin the camera and makes the ray point\n    # to the screen coordinates of the mouse.\n    pickerRay.setFromLens(base.camNode, mpos.x, mpos.y)\n\ncpp\n\nvoid myFunction() {\n  if (!mouseWatcher->has_mouse()) {\n    // The mouse is probably outside the screen.\n    return;\n  }\n\n  // This gives up the screen coordinates of the mouse.\n  LPoint2 mpos = mouseWatcher->get_mouse();\n\n  // This makes the ray's origin the camera and makes the ray point\n  // to the screen coordinates of the mouse.\n  pickerRay->set_from_lens(window->get_camera(0), mpos.get_x(), mpos.get_y());\n}\n\nAfter this, you now call the traverser like any other collision, get the closest object and \"pick\" it.\n\npython\n\ndef myFunction():\n    mpos = base.mouseWatcherNode.getMouse()\n    pickerRay.setFromLens(base.camNode, mpos.getX(), mpos.getY())\n\n    myTraverser.traverse(render)\n    # Assume for simplicity's sake that myHandler is a CollisionHandlerQueue.\n    if myHandler.getNumEntries() > 0:\n        # This is so we get the closest object\n        myHandler.sortEntries()\n        pickedObj = myHandler.getEntry(0).getIntoNodePath()\n\nThe node returned by the collision system may not be the object itself, but might be just a part of the object. In particular, it will be one of the GeomNodes that make up the object. (The .GeomNode class contains the visible geometry primitives that are used to define renderable objects in Panda3D.) Since your object might consist of more than one .GeomNode, what you probably would prefer to get is the .NodePath that represents the parent of all of these GeomNodes that is, the .NodePath that you set the 'myObjectTag' tag on above. You can use .NodePath.find_net_tag() to return the parent .NodePath that contains a specified tag. (There are also other, similar methods on .NodePath that can be used to query the tag specified on a parent node, such as ~.NodePath.get_net_tag() and ~.NodePath.has_net_tag(). For simplicity, we shall restrict this example to ~.NodePath.find_net_tag().)\n\npython\n\nNow you can edit myFunction() to look like this:\n\ndef myFunction():\n    mpos = base.mouseWatcherNode.getMouse()\n    pickerRay.setFromLens(base.camNode, mpos.getX(), mpos.getY())\n    myTraverser.traverse(render)\n    # Assume for simplicity's sake that myHandler is a CollisionHandlerQueue.\n    if myHandler.getNumEntries() > 0:\n        # This is so we get the closest object.\n        myHandler.sortEntries()\n        pickedObj = myHandler.getEntry(0).getIntoNodePath()\n        pickedObj = pickedObj.findNetTag('myObjectTag')\n        if not pickedObj.isEmpty():\n            handlePickedObject(pickedObj)",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/91a421cd_clicking-on-3d-objects.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/89de807b_91a421cd_clicking-on-3d-objects.json",
    "doc_id": "doc_642"
  }
}