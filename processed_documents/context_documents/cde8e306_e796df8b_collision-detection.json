{
  "content": "Collision Detection with ODE\n\nCollision Detection\n\nThere are two types of collision detection: the kind that immediately makes the objects bounce back on a collision, and the kind that instead of making the objects bounce back immediately creates control joints instead. The latter is the method the Open Dynamics Engine uses. Normally, you would use near callbacks to make the control joints and have the objects bounce back. However, Panda3D has an autoCollide feature that automatically does these things for you.\n\nThese are the steps needed to have your objects collide with each other:\n\nCreate an OdeSpace (explained below). Use setAutoCollideWorld(world) to let the OdeSpace know in which world you want to collide things.\n\nCreate an OdeJointGroup() to hold the contact joints. Use space.setAutoCollideJointGroup to let the space know in which OdeJointGroup you would like to store the contact joints.\n\nConfigure the surface table for the world.\n\nCreate ODE collision geometry for your bodies, e.g. OdeBoxGeom, OdePlaneGeom, etc. Be sure to set collide and category bitmasks <collision-bitmasks> on it using the setCollideBits and setCategoryBits methods. Assign it to your body using geom.setBody(body).\n\nIn your simulation loop, call space.autoCollide() before you call world.quickStep.\n\nAfter using quickStep, you need to empty your OdeJointGroup using the empty() method.\n\nSpaces\n\nTo be able to use collision detection, you will need to create an OdeSpace. There are three different kinds of space types you have to choose from, any one will work but each one is more optimized for a special kind of simulation.\n\nOdeSimpleSpace. This is the most simple kind of space available. This does not perform any collision culling at all, that's why it is not preferred for a large number of objects. If you have a small amount of objects, however, you will most likely prefer an OdeSimpleSpace.\n\nIf you have more objects and a larger scene, you will want to use the OdeQuadTreeSpace. This uses a pre-allocated hierarchical grid-based AABB tree to quickly cull collision checks. It's exceptionally quick for large amounts of objects in landscape-shaped worlds.\n\nFinally, there's the OdeHashSpace, which uses an internal data structure that records how each geom overlaps cells in one of several three dimensional grids. Each grid has cubical cells of side lengths 2**i, where i is an integer that ranges from a minimum to a maximum value. You can set this minimum and maximum value using the setMinLevel and setMaxLevel functions respectively, or you can use setLevels to set them all in one call.\n\nGeometry\n\nGeometry are the collision solids that you place in a space. These collision solids are separate from panda's own collision solids but there are similar collision solid types. The general code for creating geometry is OdeGeom(space, [parameters]), where space is the OdeSpace the geometry is being placed in. Parameters are dependent on which geometry solid you choose. The geometry types that you can choose from are:\n\nGeometry Shape Initialization Parameters OdeBoxGeom Box OdeBoxGeom(space, length, width, height) OdeCappedCylinderGeom Capsule OdeCappedCylinderGeom(space, radius, length) OdeCylinderGeom Cylinder OdeCylinderGeom(space, radius, length) OdePlaneGeom Infinite Plane OdePlaneGeom(space, Vec4(<vector of plane normal>)) OdeRayGeom Finite Ray OdeRayGeom(space, ray_length) OdeSphereGeom Sphere OdeSphereGeom(space, radius) OdeTriMeshGeom 3D Mesh OdeTriMeshGeom(space, OdeTriMeshData)\n\nTo set the position and direction of an OdeRayGeom, you must call OdeRayGeom.set(Vec3(<position>), Vec3(<direction>)). The length of the direction vector is always set to the ray length specified during instantiation.\n\nA trimesh geometry allows you to create collision geometry of an arbitrary shape from a 3d model. However collision detection with a trimesh is the most expensive and might be unreliable, for most applications you are better off approximating the shape with another collision solid. To get the OdeTriMeshGeom from a model requires two steps:\n\npython\n\nmodelTrimesh = OdeTriMeshData(modelNodePath, True)\nmodelGeom = OdeTriMeshGeom(space, modelTrimesh)\n\ncpp\n\nPT(OdeTriMeshData) modelTrimesh = new OdeTriMeshData(modelNodePath, true);\nOdeTriMeshGeom modelGeom (space, modelTrimesh);\n\nIf a geometry represents a physically dynamic object you can associate it with the dynamic body using odeGeom.setBody(body). This will automatically reposition the geometry with regard to the position of the related body in the OdeWorld.\n\nSurfaces\n\nSufaces define the material a geometry is made of and the Surface Table defines how materials react with each other setting the bounce, friction etc. To set up the surface system, you must first initialize the surface table which is done with odeWorld.initSurfaceTable(numberOfSurfaces)\n\nOnce you have done that, you have to setup the parameters for collisions between two surfaces using odeWorld.setSurfaceEntry(surfaceId1, surfaceId2, mu, bounce, bounce_vel, soft_erp, soft_cfm, slip, dampen). The surface identifiers start from 0 so if you initialized your surface table with 3 surfaces, the surface IDs are 0, 1, 2.\n\nThese are what the rest of the parameters mean:\n\nIf you have multiple surfaces, you need to tell ODE which surface belongs to which geometry. You can assign surfaces to your geometry using odeSpace.setSurfaceType(geometry, surfaceId)\n\nCollision Events\n\nIt is also possible to receive an event when a collision occurs. You need to set the name of the event by doing:\n\npython\n\nspace.setCollisionEvent(\"yourCollision\")\n\ncpp\n\nspace.set_collision_event(\"yourCollision\");\n\nYou can then use this event name in an accept() call. The parameter passed to the event is an OdeCollisionEntry, which holds all the geoms and contacts in the collision. See the API Reference page for ~panda3d.ode.OdeCollisionEntry for more details.\n\nThe following code shows how it works (the methods used are not real):\n\n# Setup collision event\ndef onCollision(entry):\n    geom1 = entry.getGeom1()\n    geom2 = entry.getGeom2()\n    body1 = entry.getBody1()\n    body2 = entry.getBody2()\n    if (body1 and body1 == spear) or (body2 and body2 == spear):\n        # Must have hit someone\n        for p in entry.getContactPoints()\n            particleSystem.drawBlood(p)\n\nspace.setCollisionEvent(\"ode-collision\")\nbase.accept(\"ode-collision\", onCollision)\n\nExample\n\nThis is an example of some random boxes falling down and colliding with the floor.\n\nfrom direct.directbase import DirectStart\nfrom panda3d.ode import OdeWorld, OdeSimpleSpace, OdeJointGroup\nfrom panda3d.ode import OdeBody, OdeMass, OdeBoxGeom, OdePlaneGeom\nfrom panda3d.core import BitMask32, CardMaker, Vec4, Quat\nfrom random import randint, random\n\n# Setup our physics world\nworld = OdeWorld()\nworld.setGravity(0, 0, -9.81)\n\n# The surface table is needed for autoCollide\nworld.initSurfaceTable(1)\nworld.setSurfaceEntry(0, 0, 150, 0.0, 9.1, 0.9, 0.00001, 0.0, 0.002)\n\n# Create a space and add a contactgroup to it to add the contact joints\nspace = OdeSimpleSpace()\nspace.setAutoCollideWorld(world)\ncontactgroup = OdeJointGroup()\nspace.setAutoCollideJointGroup(contactgroup)\n\n# Load the box\nbox = loader.loadModel(\"box\")\n# Make sure its center is at 0, 0, 0 like OdeBoxGeom\nbox.setPos(-.5, -.5, -.5)\nbox.flattenLight() # Apply transform\nbox.setTextureOff()\n\n# Add a random amount of boxes\nboxes = []\nfor i in range(randint(15, 30)):\n    # Setup the geometry\n    boxNP = box.copyTo(render)\n    boxNP.setPos(randint(-10, 10), randint(-10, 10), 10 + random())\n    boxNP.setColor(random(), random(), random(), 1)\n    boxNP.setHpr(randint(-45, 45), randint(-45, 45), randint(-45, 45))\n    # Create the body and set the mass\n    boxBody = OdeBody(world)\n    M = OdeMass()\n    M.setBox(50, 1, 1, 1)\n    boxBody.setMass(M)\n    boxBody.setPosition(boxNP.getPos(render))\n    boxBody.setQuaternion(boxNP.getQuat(render))\n    # Create a BoxGeom\n    boxGeom = OdeBoxGeom(space, 1, 1, 1)\n    boxGeom.setCollideBits(BitMask32(0x00000002))\n    boxGeom.setCategoryBits(BitMask32(0x00000001))\n    boxGeom.setBody(boxBody)\n    boxes.append((boxNP, boxBody))\n\n# Add a plane to collide with\ncm = CardMaker(\"ground\")\ncm.setFrame(-20, 20, -20, 20)\nground = render.attachNewNode(cm.generate())\nground.setPos(0, 0, 0); ground.lookAt(0, 0, -1)\ngroundGeom = OdePlaneGeom(space, Vec4(0, 0, 1, 0))\ngroundGeom.setCollideBits(BitMask32(0x00000001))\ngroundGeom.setCategoryBits(BitMask32(0x00000002))\n\n# Set the camera position\nbase.disableMouse()\nbase.camera.setPos(40, 40, 20)\nbase.camera.lookAt(0, 0, 0)\n\n# The task for our simulation\ndef simulationTask(task):\n    space.autoCollide() # Setup the contact joints\n    # Step the simulation and set the new positions\n    world.quickStep(globalClock.getDt())\n    for np, body in boxes:\n        np.setPosQuat(render, body.getPosition(), Quat(body.getQuaternion()))\n    contactgroup.empty() # Clear the contact joints\n    return task.cont\n\n# Wait a split second, then start the simulation\ntaskMgr.doMethodLater(0.5, simulationTask, \"Physics Simulation\")\n\nbase.run()\n\nIn this example, we're creating a random amount of boxes with a random orientation and position, assigning collision solids to them, and adding a tuple of the NodePath <the-scene-graph> and the body to a list. This way we can easily keep track of all the boxes and loop through them to copy over the positions from the OdeBody to Panda's NodePath in the simulation loop.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/e796df8b_collision-detection.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/cde8e306_e796df8b_collision-detection.json",
    "doc_id": "doc_624"
  }
}