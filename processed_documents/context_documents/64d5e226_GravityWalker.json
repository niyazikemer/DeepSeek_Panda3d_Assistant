{
  "content": "\"\"\"\nGravityWalker.py is for avatars.\n\nA walker control such as this one provides:\n\n- creation of the collision nodes\n- handling the keyboard and mouse input for avatar movement\n- moving the avatar\n\nit does not:\n\n- play sounds\n- play animations\n\nalthough it does send messages that allow a listener to play sounds or\nanimations based on walker events.\n\"\"\"\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.showbase import DirectObject\nfrom direct.controls.ControlManager import CollisionHandlerRayStart\nfrom direct.showbase.InputStateGlobal import inputState\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.task.Task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.extensions_native import VBase3_extensions # pylint: disable=unused-import\nfrom direct.extensions_native import VBase4_extensions # pylint: disable=unused-import\nfrom panda3d.core import (\n    BitMask32,\n    ClockObject,\n    CollisionHandlerEvent,\n    CollisionHandlerFluidPusher,\n    CollisionHandlerGravity,\n    CollisionHandlerPusher,\n    CollisionNode,\n    CollisionRay,\n    CollisionSphere,\n    CollisionTraverser,\n    ConfigVariableBool,\n    Mat3,\n    Point3,\n    Vec3,\n)\nimport math\n\n\nclass GravityWalker(DirectObject.DirectObject):\n    notify = directNotify.newCategory(\"GravityWalker\")\n    wantDebugIndicator = ConfigVariableBool('want-avatar-physics-indicator', False)\n    wantFloorSphere = ConfigVariableBool('want-floor-sphere', False)\n    earlyEventSphere = ConfigVariableBool('early-event-sphere', False)\n\n    DiagonalFactor = math.sqrt(2.) / 2.\n\n    # special methods\n    def __init__(self, gravity = 64.348, standableGround=0.707,\n            hardLandingForce=16.0, legacyLifter=False):\n        assert self.notify.debugStateCall(self)\n        DirectObject.DirectObject.__init__(self)\n        self.__gravity=gravity\n        self.__standableGround=standableGround\n        self.__hardLandingForce=hardLandingForce\n        self._legacyLifter = legacyLifter\n\n        self.mayJump = 1\n        self.jumpDelayTask = None\n\n        self.controlsTask = None\n        self.indicatorTask = None\n\n        self.falling = 0\n        self.needToDeltaPos = 0\n        self.physVelocityIndicator=None\n        self.avatarControlForwardSpeed=0\n        self.avatarControlJumpForce=0\n        self.avatarControlReverseSpeed=0\n        self.avatarControlRotateSpeed=0\n        self.getAirborneHeight=None\n\n        self.priorParent=Vec3(0)\n        self.__oldPosDelta=Vec3(0)\n        self.__oldDt=0\n\n        self.moving=0\n        self.speed=0.0\n        self.rotationSpeed=0.0\n        self.slideSpeed=0.0\n        self.vel=Vec3(0.0)\n        self.collisionsActive = 0\n\n        self.isAirborne = 0\n        self.highMark = 0\n\n    def setWalkSpeed(self, forward, jump, reverse, rotate):\n        assert self.notify.debugStateCall(self)\n        self.avatarControlForwardSpeed=forward\n        self.avatarControlJumpForce=jump\n        self.avatarControlReverseSpeed=reverse\n        self.avatarControlRotateSpeed=rotate\n\n    def getSpeeds(self):\n        #assert self.debugPrint(\"getSpeeds()\")\n        return (self.speed, self.rotationSpeed, self.slideSpeed)\n\n    def getIsAirborne(self):\n        return self.isAirborne\n\n    def setAvatar(self, avatar):\n        self.avatar = avatar\n        if avatar is not None:\n            pass # setup the avatar\n\n    def setupRay(self, bitmask, floorOffset, reach):\n        assert self.notify.debugStateCall(self)\n        # This is a ray cast from your head down to detect floor polygons.\n        # This ray start is arbitrarily high in the air.  Feel free to use\n        # a higher or lower value depending on whether you want an avatar\n        # that is outside of the world to step up to the floor when they\n        # get under valid floor:\n        self.cRay = CollisionRay(0.0, 0.0, CollisionHandlerRayStart, 0.0, 0.0, -1.0)\n        cRayNode = CollisionNode('GW.cRayNode')\n        cRayNode.addSolid(self.cRay)\n        self.cRayNodePath = self.avatarNodePath.attachNewNode(cRayNode)\n        cRayNode.setFromCollideMask(bitmask)\n        cRayNode.setIntoCollideMask(BitMask32.allOff())\n\n        # set up floor collision mechanism\n        self.lifter = CollisionHandlerGravity()\n        #self.lifter = CollisionHandlerHighestEvent()\n        self.lifter.setLegacyMode(self._legacyLifter)\n        self.lifter.setGravity(self.__gravity)\n        self.lifter.addInPattern(\"enter%in\")\n        self.lifter.addAgainPattern(\"again%in\")\n        self.lifter.addOutPattern(\"exit%in\")\n        self.lifter.setOffset(floorOffset)\n        self.lifter.setReach(reach)\n\n        # Limit our rate-of-fall with the lifter.\n        # If this is too low, we actually \"fall\" off steep stairs\n        # and float above them as we go down. I increased this\n        # from 8.0 to 16.0 to prevent this\n        #self.lifter.setMaxVelocity(16.0)\n\n        self.lifter.addCollider(self.cRayNodePath, self.avatarNodePath)\n\n    def setupWallSphere(self, bitmask, avatarRadius):\n        \"\"\"\n        Set up the collision sphere\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        # This is a sphere on the ground to detect collisions with\n        # walls, but not the floor.\n        self.avatarRadius = avatarRadius\n        cSphere = CollisionSphere(0.0, 0.0, avatarRadius, avatarRadius)\n        cSphereNode = CollisionNode('GW.cWallSphereNode')\n        cSphereNode.addSolid(cSphere)\n        cSphereNodePath = self.avatarNodePath.attachNewNode(cSphereNode)\n\n        cSphereNode.setFromCollideMask(bitmask)\n        cSphereNode.setIntoCollideMask(BitMask32.allOff())\n\n        # set up collision mechanism\n        if ConfigVariableBool('want-fluid-pusher', 0):\n            self.pusher = CollisionHandlerFluidPusher()\n        else:\n            self.pusher = CollisionHandlerPusher()\n        self.pusher.addCollider(cSphereNodePath, self.avatarNodePath)\n        self.cWallSphereNodePath = cSphereNodePath\n\n    def setupEventSphere(self, bitmask, avatarRadius):\n        \"\"\"\n        Set up the collision sphere\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        # This is a sphere a little larger than the wall sphere to\n        # trigger events.\n        self.avatarRadius = avatarRadius\n        cSphere = CollisionSphere(0.0, 0.0, avatarRadius-0.1, avatarRadius*1.04)\n        # Mark it intangible just to emphasize its non-physical purpose.\n        cSphere.setTangible(0)\n        cSphereNode = CollisionNode('GW.cEventSphereNode')\n        cSphereNode.addSolid(cSphere)\n        cSphereNodePath = self.avatarNodePath.attachNewNode(cSphereNode)\n\n        cSphereNode.setFromCollideMask(bitmask)\n        cSphereNode.setIntoCollideMask(BitMask32.allOff())\n\n        # set up collision mechanism\n        self.event = CollisionHandlerEvent()\n        self.event.addInPattern(\"enter%in\")\n        self.event.addOutPattern(\"exit%in\")\n        self.cEventSphereNodePath = cSphereNodePath\n\n    def setupFloorSphere(self, bitmask, avatarRadius):\n        \"\"\"\n        Set up the collision sphere\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        # This is a tiny sphere concentric with the wallSphere to keep\n        # us from slipping through floors.\n        self.avatarRadius = avatarRadius\n        cSphere = CollisionSphere(0.0, 0.0, avatarRadius, 0.01)\n        cSphereNode = CollisionNode('GW.cFloorSphereNode')\n        cSphereNode.addSolid(cSphere)\n        cSphereNodePath = self.avatarNodePath.attachNewNode(cSphereNode)\n\n        cSphereNode.setFromCollideMask(bitmask)\n        cSphereNode.setIntoCollideMask(BitMask32.allOff())\n\n        # set up collision mechanism\n        self.pusherFloorhandler = CollisionHandlerPusher()\n        self.pusherFloor.addCollider(cSphereNodePath, self.avatarNodePath)\n        self.cFloorSphereNodePath = cSphereNodePath\n\n    def setWallBitMask(self, bitMask):\n        self.wallBitmask = bitMask\n\n    def setFloorBitMask(self, bitMask):\n        self.floorBitmask = bitMask\n\n    def swapFloorBitMask(self, oldMask, newMask):\n        self.floorBitmask = self.floorBitmask &~ oldMask\n        self.floorBitmask |= newMask\n\n        if self.cRayNodePath and not self.cRayNodePath.isEmpty():\n            self.cRayNodePath.node().setFromCollideMask(self.floorBitmask)\n\n    def setGravity(self, gravity):\n        self.__gravity = gravity\n        self.lifter.setGravity(self.__gravity)\n\n    def getGravity(self, gravity):\n        return self.__gravity\n\n    def initializeCollisions(self, collisionTraverser, avatarNodePath,\n            avatarRadius = 1.4, floorOffset = 1.0, reach = 1.0):\n        \"\"\"\n        floorOffset is how high the avatar can reach.  I.e. if the avatar\n            walks under a ledge that is <= floorOffset above the ground (a\n            double floor situation), the avatar will step up on to the\n            ledge (instantly).\n\n        Set up the avatar collisions\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n\n        assert not avatarNodePath.isEmpty()\n        self.avatarNodePath = avatarNodePath\n\n        self.cTrav = collisionTraverser\n\n        self.setupRay(self.floorBitmask, floorOffset, reach)\n        self.setupWallSphere(self.wallBitmask, avatarRadius)\n        self.setupEventSphere(self.wallBitmask, avatarRadius)\n        if self.wantFloorSphere:\n            self.setupFloorSphere(self.floorBitmask, avatarRadius)\n\n        self.setCollisionsActive(1)\n\n    def setTag(self, key, value):\n        self.cEventSphereNodePath.setTag(key, value)\n\n    def setAirborneHeightFunc(self, unused_parameter):\n        assert self.notify.debugStateCall(self)\n        self.getAirborneHeight = self.lifter.getAirborneHeight\n\n    def getAirborneHeight(self):\n        assert self.notify.debugStateCall(self)\n        self.lifter.getAirborneHeight()\n\n    def setAvatarPhysicsIndicator(self, indicator):\n        \"\"\"\n        indicator is a NodePath\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        self.cWallSphereNodePath.show()\n\n    def deleteCollisions(self):\n        assert self.notify.debugStateCall(self)\n        del self.cTrav\n\n        self.cWallSphereNodePath.removeNode()\n        del self.cWallSphereNodePath\n        if self.wantFloorSphere:\n            self.cFloorSphereNodePath.removeNode()\n            del self.cFloorSphereNodePath\n\n        del self.pusher\n        # del self.pusherFloor\n        del self.event\n        del self.lifter\n\n        del self.getAirborneHeight\n\n    def setCollisionsActive(self, active = 1):\n        assert self.notify.debugStateCall(self)\n        if self.collisionsActive != active:\n            self.collisionsActive = active\n            # Each time we change the collision geometry, make one\n            # more pass to ensure we aren't standing in a wall.\n            self.oneTimeCollide()\n            # make sure we have a shadow traverser\n            base.initShadowTrav()\n            if active:\n                # Please let skyler or drose know if this is causing a problem\n                # This is a bit of a hack fix:\n                self.avatarNodePath.setP(0.0)\n                self.avatarNodePath.setR(0.0)\n\n                self.cTrav.addCollider(self.cWallSphereNodePath, self.pusher)\n                if self.wantFloorSphere:\n                    self.cTrav.addCollider(self.cFloorSphereNodePath, self.pusherFloor)\n                # Add the lifter to the shadow traverser, which runs after\n                # our traverser. This prevents the \"fall through wall and\n                # off ledge\" bug. The problem was that we couldn't control\n                # which collided first, the wall pusher or the lifter, if\n                # they're in the same collision traverser. If the lifter\n                # collided first, we'd start falling before getting pushed\n                # back behind the wall.\n                base.shadowTrav.addCollider(self.cRayNodePath, self.lifter)\n\n                if self.earlyEventSphere:\n                    # If we want to trigger the events at the same\n                    # time as we intersect walls (e.g. Toontown, for\n                    # backward compatibility issues), add the event\n                    # sphere to the main traverser.  This allows us to\n                    # hit door triggers that are just slightly behind\n                    # the door itself.\n                    self.cTrav.addCollider(self.cEventSphereNodePath, self.event)\n                else:\n                    # Normally, we'd rather trigger the events after\n                    # the pusher has had a chance to fix up our\n                    # position, so we never trigger things that are\n                    # behind other polygons.\n                    base.shadowTrav.addCollider(self.cEventSphereNodePath, self.event)\n\n            else:\n                if hasattr(self, 'cTrav'):\n                    self.cTrav.removeCollider(self.cWallSphereNodePath)\n                    if self.wantFloorSphere:\n                        self.cTrav.removeCollider(self.cFloorSphereNodePath)\n                    self.cTrav.removeCollider(self.cEventSphereNodePath)\n                base.shadowTrav.removeCollider(self.cEventSphereNodePath)\n                base.shadowTrav.removeCollider(self.cRayNodePath)\n\n    def getCollisionsActive(self):\n        assert self.debugPrint(\"getCollisionsActive() returning=%s\"%(\n            self.collisionsActive,))\n        return self.collisionsActive\n\n    def placeOnFloor(self):\n        \"\"\"\n        Make a reasonable effor to place the avatar on the ground.\n        For example, this is useful when switching away from the\n        current walker.\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        self.oneTimeCollide()\n        self.avatarNodePath.setZ(self.avatarNodePath.getZ()-self.lifter.getAirborneHeight())\n\n    def oneTimeCollide(self):\n        \"\"\"\n        Makes one quick collision pass for the avatar, for instance as\n        a one-time straighten-things-up operation after collisions\n        have been disabled.\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        if not hasattr(self, 'cWallSphereNodePath'):\n            return\n        self.isAirborne = 0\n        self.mayJump = 1\n        tempCTrav = CollisionTraverser(\"oneTimeCollide\")\n        tempCTrav.addCollider(self.cWallSphereNodePath, self.pusher)\n        if self.wantFloorSphere:\n            tempCTrav.addCollider(self.cFloorSphereNodePath, self.event)\n        tempCTrav.addCollider(self.cRayNodePath, self.lifter)\n        tempCTrav.traverse(render)\n\n    def setMayJump(self, task):\n        \"\"\"\n        This function's use is internal to this class (maybe I'll add\n        the __ someday).  Anyway, if you want to enable or disable\n        jumping in a general way see the ControlManager (don't use this).\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        self.mayJump = 1\n        return Task.done\n\n    def startJumpDelay(self, delay):\n        assert self.notify.debugStateCall(self)\n        if self.jumpDelayTask:\n            self.jumpDelayTask.remove()\n        self.mayJump = 0\n        self.jumpDelayTask=taskMgr.doMethodLater(\n            delay,\n            self.setMayJump,\n            \"jumpDelay-%s\"%id(self))\n\n    def addBlastForce(self, vector):\n        self.lifter.addVelocity(vector.length())\n\n    def displayDebugInfo(self):\n        \"\"\"\n        For debug use.\n        \"\"\"\n        onScreenDebug.add(\"w controls\", \"GravityWalker\")\n\n        onScreenDebug.add(\"w airborneHeight\", self.lifter.getAirborneHeight())\n        onScreenDebug.add(\"w falling\", self.falling)\n        onScreenDebug.add(\"w isOnGround\", self.lifter.isOnGround())\n        #onScreenDebug.add(\"w gravity\", self.lifter.getGravity())\n        #onScreenDebug.add(\"w jumpForce\", self.avatarControlJumpForce)\n        onScreenDebug.add(\"w contact normal\", self.lifter.getContactNormal().pPrintValues())\n        onScreenDebug.add(\"w mayJump\", self.mayJump)\n        onScreenDebug.add(\"w impact\", self.lifter.getImpactVelocity())\n        onScreenDebug.add(\"w velocity\", self.lifter.getVelocity())\n        onScreenDebug.add(\"w isAirborne\", self.isAirborne)\n        onScreenDebug.add(\"w hasContact\", self.lifter.hasContact())\n\n    def handleAvatarControls(self, task):\n        \"\"\"\n        Check on the arrow keys and update the avatar.\n        \"\"\"\n        # get the button states:\n        run = inputState.isSet(\"run\")\n        forward = inputState.isSet(\"forward\")\n        reverse = inputState.isSet(\"reverse\")\n        turnLeft = inputState.isSet(\"turnLeft\")\n        turnRight = inputState.isSet(\"turnRight\")\n        slideLeft = inputState.isSet(\"slideLeft\")\n        slideRight = inputState.isSet(\"slideRight\")\n        jump = inputState.isSet(\"jump\")\n\n        # Check for Auto-Run\n        if 'localAvatar' in __builtins__:\n            if base.localAvatar and base.localAvatar.getAutoRun():\n                forward = 1\n                reverse = 0\n\n        # Determine what the speeds are based on the buttons:\n        self.speed=(forward and self.avatarControlForwardSpeed or\n                    reverse and -self.avatarControlReverseSpeed)\n        # Slide speed is a scaled down version of forward speed\n        # Note: you can multiply a factor in here if you want slide to\n        # be slower than normal walk/run. Let's try full speed.\n        #self.slideSpeed=(slideLeft and -self.avatarControlForwardSpeed*0.75 or\n        #                 slideRight and self.avatarControlForwardSpeed*0.75)\n        self.slideSpeed=(reverse and slideLeft and -self.avatarControlReverseSpeed*0.75 or\n                         reverse and slideRight and self.avatarControlReverseSpeed*0.75 or\n                         slideLeft and -self.avatarControlForwardSpeed*0.75 or\n                         slideRight and self.avatarControlForwardSpeed*0.75)\n        self.rotationSpeed=not (slideLeft or slideRight) and (\n                (turnLeft and self.avatarControlRotateSpeed) or\n                (turnRight and -self.avatarControlRotateSpeed))\n\n        if self.speed and self.slideSpeed:\n            self.speed *= GravityWalker.DiagonalFactor\n            self.slideSpeed *= GravityWalker.DiagonalFactor\n\n        debugRunning = inputState.isSet(\"debugRunning\")\n        if debugRunning:\n            self.speed*=base.debugRunningMultiplier\n            self.slideSpeed*=base.debugRunningMultiplier\n            self.rotationSpeed*=1.25\n\n        if self.needToDeltaPos:\n            self.setPriorParentVector()\n            self.needToDeltaPos = 0\n        if self.wantDebugIndicator:\n            self.displayDebugInfo()\n        if self.lifter.isOnGround():\n            if self.isAirborne:\n                self.isAirborne = 0\n                assert self.debugPrint(\"isAirborne 0 due to isOnGround() true\")\n                impact = self.lifter.getImpactVelocity()\n                if impact < -30.0:\n                    messenger.send(\"jumpHardLand\")\n                    self.startJumpDelay(0.3)\n                else:\n                    messenger.send(\"jumpLand\")\n                    if impact < -5.0:\n                        self.startJumpDelay(0.2)\n                    # else, ignore the little potholes.\n            assert self.isAirborne == 0\n            self.priorParent = Vec3.zero()\n            if jump and self.mayJump:\n                # The jump button is down and we're close\n                # enough to the ground to jump.\n                self.lifter.addVelocity(self.avatarControlJumpForce)\n                messenger.send(\"jumpStart\")\n                self.isAirborne = 1\n                assert self.debugPrint(\"isAirborne 1 due to jump\")\n        else:\n            if self.isAirborne == 0:\n                assert self.debugPrint(\"isAirborne 1 due to isOnGround() false\")\n            self.isAirborne = 1\n\n        self.__oldPosDelta = self.avatarNodePath.getPosDelta(render)\n        # How far did we move based on the amount of time elapsed?\n        self.__oldDt = ClockObject.getGlobalClock().getDt()\n        dt=self.__oldDt\n\n        # Check to see if we're moving at all:\n        self.moving = self.speed or self.slideSpeed or self.rotationSpeed or (self.priorParent!=Vec3.zero())\n        if self.moving:\n            distance = dt * self.speed\n            slideDistance = dt * self.slideSpeed\n            rotation = dt * self.rotationSpeed\n\n            # Take a step in the direction of our previous heading.\n            if distance or slideDistance or self.priorParent != Vec3.zero():\n                # rotMat is the rotation matrix corresponding to\n                # our previous heading.\n                rotMat=Mat3.rotateMatNormaxis(self.avatarNodePath.getH(), Vec3.up())\n                if self.isAirborne:\n                    forward = Vec3.forward()\n                else:\n                    contact = self.lifter.getContactNormal()\n                    forward = contact.cross(Vec3.right())\n                    # Consider commenting out this normalize.  If you do so\n                    # then going up and down slops is a touch slower and\n                    # steeper terrain can cut the movement in half.  Without\n                    # the normalize the movement is slowed by the cosine of\n                    # the slope (i.e. it is multiplied by the sign as a\n                    # side effect of the cross product above).\n                    forward.normalize()\n                self.vel=Vec3(forward * distance)\n                if slideDistance:\n                    if self.isAirborne:\n                        right = Vec3.right()\n                    else:\n                        right = forward.cross(contact)\n                        # See note above for forward.normalize()\n                        right.normalize()\n                    self.vel=Vec3(self.vel + (right * slideDistance))\n                self.vel=Vec3(rotMat.xform(self.vel))\n                step=self.vel + (self.priorParent * dt)\n                self.avatarNodePath.setFluidPos(Point3(\n                        self.avatarNodePath.getPos()+step))\n            self.avatarNodePath.setH(self.avatarNodePath.getH()+rotation)\n        else:\n            self.vel.set(0.0, 0.0, 0.0)\n        if self.moving or jump:\n            messenger.send(\"avatarMoving\")\n        return Task.cont\n\n    def doDeltaPos(self):\n        assert self.notify.debugStateCall(self)\n        self.needToDeltaPos = 1\n\n    def setPriorParentVector(self):\n        assert self.notify.debugStateCall(self)\n        if __debug__:\n            onScreenDebug.add(\"__oldDt\", \"% 10.4f\"%self.__oldDt)\n            onScreenDebug.add(\"self.__oldPosDelta\",\n                              self.__oldPosDelta.pPrintValues())\n        # avoid divide by zero crash - grw\n        if self.__oldDt == 0:\n            velocity = 0\n        else:\n            velocity = self.__oldPosDelta*(1.0/self.__oldDt)\n        self.priorParent = Vec3(velocity)\n        if __debug__:\n            if self.wantDebugIndicator:\n                onScreenDebug.add(\"priorParent\", self.priorParent.pPrintValues())\n\n    def reset(self):\n        assert self.notify.debugStateCall(self)\n        self.lifter.setVelocity(0.0)\n        self.priorParent=Vec3.zero()\n\n    def getVelocity(self):\n        return self.vel\n\n    def enableAvatarControls(self):\n        \"\"\"\n        Activate the arrow keys, etc.\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        assert self.collisionsActive\n\n        #*#if __debug__:\n        #*#    self.accept(\"control-f3\", self.spawnTest) #*#\n\n        # remove any old\n        if self.controlsTask:\n            self.controlsTask.remove()\n        # spawn the new task\n        taskName = \"AvatarControls-%s\"%(id(self),)\n        self.controlsTask = taskMgr.add(self.handleAvatarControls, taskName, 25)\n\n        self.isAirborne = 0\n        self.mayJump = 1\n\n        if self.physVelocityIndicator:\n            if self.indicatorTask:\n                self.indicatorTask.remove()\n            self.indicatorTask = taskMgr.add(\n                self.avatarPhysicsIndicator,\n                \"AvatarControlsIndicator-%s\"%(id(self),), 35)\n\n    def disableAvatarControls(self):\n        \"\"\"\n        Ignore the arrow keys, etc.\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        if self.controlsTask:\n            self.controlsTask.remove()\n            self.controlsTask = None\n        if self.indicatorTask:\n            self.indicatorTask.remove()\n            self.indicatorTask = None\n        if self.jumpDelayTask:\n            self.jumpDelayTask.remove()\n            self.jumpDelayTask = None\n\n        if __debug__:\n            self.ignore(\"control-f3\") #*#\n\n\n    def flushEventHandlers(self):\n        if hasattr(self, 'cTrav'):\n            self.pusher.flush()\n            if self.wantFloorSphere:\n                self.floorPusher.flush()\n            self.event.flush()\n        self.lifter.flush() # not currently defined or needed\n\n    if __debug__:\n        def debugPrint(self, message):\n            \"\"\"for debugging\"\"\"\n            return self.notify.debug(\n                    str(id(self))+' '+message)\n\n    # There are sometimes issues if the collision ray height is\n    # so tall that it collides with multiple levels of floors.\n    def setCollisionRayHeight(self, height):\n        self.cRay.setOrigin(0.0, 0.0, height)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/controls/GravityWalker.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/64d5e226_GravityWalker.json",
    "doc_id": "doc_226"
  }
}