{
  "content": "Shader Basics\n\nOverview of Shaders\n\nPanda3D supports two shading languages: GLSL and Cg. This section assumes that you have a working knowledge of a shader language. If not, it would be wise to read about GLSL or Cg before trying to understand how they fit into Panda3D.\n\nThough Panda3D has used only Cg in the past, it is recommended that you create new shaders in GLSL unless you want to target DirectX as well, since the NVIDIA Cg toolkit is no longer being maintained.\n\nThere are various types of shaders, each capable of describing a different stage in the rendering process. In the most simple case, a model simply has a vertex shader, which describes how each vertex is processed, and a fragment shader (also called a pixel shader in DirectX parlance), describing how the color of each visible pixel on the model is determined. A shader pipeline can be composed of one or more of the following types of shaders:\n\nThere is also another advanced type of shader called a Compute shader <compute-shaders>, which stands on its own and does not fit into the pipeline above.\n\nYou will usually only find a vertex and fragment shader, since geometry and tessellation shaders are relatively new features that are useful only in more specific cases.\n\nGLSL Shaders\n\nGLSL shaders are always separated up into separate files for vertex, fragment and geometry shaders, with the main entry point being called main(). All GLSL shaders begin with a #version line indicating the version of the GLSL standard that the shader is written in, which maps to a corresponding version of OpenGL. For example, version 120 will require OpenGL 2.1, version 150 requires OpenGL 3.2, and version 330 requires OpenGL 3.3.\n\nIn the future, Panda3D will automatically convert the shader to the appropriate version of GLSL supported by the graphics card. In the meantime, it is recommended to write your shaders in GLSL 150 or later, unless you need to support very old graphics hardware, in which case it may be necessary to target GLSL 120.\n\nExample Shader\n\nThis example applies the first texture of the model using the first texture coordinate set, but switches the red and blue channels around.\n\nThis is the vertex shader, named myshader.vert:\n\n#version 150\n\n// Uniform inputs\nuniform mat4 p3d_ModelViewProjectionMatrix;\n\n// Vertex inputs\nin vec4 p3d_Vertex;\nin vec2 p3d_MultiTexCoord0;\n\n// Output to fragment shader\nout vec2 texcoord;\n\nvoid main() {\n  gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex;\n  texcoord = p3d_MultiTexCoord0;\n}\n\nThis is the fragment shader, named myshader.frag:\n\n#version 150\n\nuniform sampler2D p3d_Texture0;\n\n// Input from vertex shader\nin vec2 texcoord;\n\n// Output to the screen\nout vec4 p3d_FragColor;\n\nvoid main() {\n  vec4 color = texture(p3d_Texture0, texcoord);\n  p3d_FragColor = color.bgra;\n}\n\nLoading a GLSL Shader\n\nTo load the above shader and apply it to a model, we can use the following code:\n\npython\n\nshader = Shader.load(Shader.SL_GLSL,\n                     vertex=\"myshader.vert\",\n                     fragment=\"myshader.frag\")\nmodel.setShader(shader)\n\ncpp\n\nPT(Shader) shader = Shader::load(Shader.SL_GLSL, \"myvertexshader.vert\", \"myfragmentshader.frag\");\nmodel.set_shader(shader);\n\nTo add a geometry shader, simply add the filename of the geometry shader as additional parameter, following the fragment shader.\n\nCg Shaders\n\nCaution\n\nSupport for Cg shaders will be deprecated in an upcoming version of Panda3D.\n\nA Cg shader must contain procedures named vshader() and fshader(); the vertex shader and fragment shader respectively. If a geometry shader is used, then it must also contain a procedure named gshader().\n\nSingle-File Cg Shaders\n\nTo write a Cg shader in a single file, you must create a shader program that looks much like the one shown below. This example preserves position but switches the red and green channels of everything it is applied to:\n\n//Cg\n\nvoid vshader(float4 vtx_position : POSITION,\n             float4 vtx_color: COLOR,\n             out float4 l_position : POSITION,\n             out float4 l_color0 : COLOR0,\n             uniform float4x4 mat_modelproj)\n{\n  l_position = mul(mat_modelproj, vtx_position);\n  l_color0 = vtx_color;\n}\n\nvoid fshader(float4 l_color0 : COLOR0,\n             out float4 o_color : COLOR)\n{\n  o_color = l_color0.grba;\n}\n\nMulti-File Cg Shaders\n\nCg shaders can be divided into several files as well; one for the vertex shader, another for the fragment shader, and a third for the geometry shader. The procedure names are still required to be vshader(), fshader() and gshader() in their respective shader files.\n\nLoading a Cg Shader\n\nLoading a single-file Cg shader is done with the .Shader.load() procedure. The first parameter is the path to the shader file, and the second is the shader language, which in this case is .Shader.SL_Cg. The following is an example of using this procedure:\n\npython\n\nfrom panda3d.core import Shader\n\nshader = Shader.load(\"myshader.sha\", Shader.SL_Cg)\nmodel.setShader(shader)\n\ncpp\n\n#include \"shader.h\"\n\nPT(Shader) shader = Shader::load(\"myshader.sha\", Shader.SL_Cg);\nmodel.set_shader(shader);\n\nLoading a multi-file Cg shader requires a different set of parameters for the ~.Shader.load() function; the first being the shader language, and the second, third and fourth being paths to the vertex, fragment and geometry shaders respectively. Here is an example:\n\npython\n\nshader = Shader.load(Shader.SL_Cg,\n                     vertex=\"myvertexshader.sha\",\n                     fragment=\"myfragmentshader.sha\",\n                     geometry=\"mygeometryshader.sha\")\nmodel.setShader(shader)\n\ncpp\n\nPT(Shader) shader = Shader::load(Shader.SL_Cg, \"myvertexshader.sha\", \"myfragmentshader.sha\", \"mygeometryshader.sha\");\nmodel.set_shader(shader);\n\nApplying the Shader\n\nShaders can be applied to any part of the scene graph. The call to .NodePath.set_shader() causes the model to be rendered with the shader passed to it as a parameter. Shaders propagate down the scene graph, like any other render attribute; the node and everything beneath it will use the shader.\n\nAs with other state changes, it is possible to pass a second priority parameter to indicate that the shader specified at that node should override shaders specified on a higher or lower node that have a lower priority value.\n\nFetching Data from the Panda3D Runtime\n\nEach shader program contains a parameter list. Panda3D scans the parameter list and interprets each parameter name as a request to extract data from the panda runtime. For example, if the shader contains a parameter declaration p3d_Vertex (or for Cg, float3 vtx_position : POSITION), Panda3D will interpret that as a request for the vertex position, and it will satisfy the request. Panda3D will only allow parameter declarations that it recognizes and understands.\n\nPanda3D will generate an error if the parameter qualifiers do not match what Panda3D is expecting. For example, if you declare the parameter float3 vtx_position, then Panda3D will be happy. If, on the other hand, you were to declare uniform sampler2D vtx_position, then Panda3D would generate two separate errors: Panda3D knows that vtx_position is supposed to be a float-vector, not a texture, and that it is supposed to be varying, not uniform.\n\nAgain, all parameter names must be recognized. There is a list of GLSL shader inputs <list-of-glsl-shader-inputs> as well as a list of Cg shader inputs <list-of-possible-cg-shader-inputs> that shows all the valid parameter names and the data that Panda3D will supply.\n\nSupplying Data to the Shader Manually\n\nMost of the data that the shader could want can be fetched from Panda3D at runtime by using the appropriate parameter names. However, it is sometimes necessary to supply some user-provided data to the shader. For this, you need .NodePath.set_shader_input(). Here is an example:\n\npython\n\nmyModel.setShaderInput(\"tint\", (1.0, 0.5, 0.5, 1.0))\n\ncpp\n\nmyModel.set_shader_input(\"tint\", LVector4(1.0, 0.5, 0.5, 1.0));\n\nThe method .NodePath.set_shader_input() stores data that can be accessed by the shader. It is possible to store data of type .Texture, .NodePath, and any vector object.\n\nThe data that you store using ~.NodePath.set_shader_input() isn't necessarily used by the shader. Instead, the values are stored in the node, but unless the shader explicitly asks for them, they will sit unused. So the example above simply stores the vector, but it is up to the shader whether or not it is interested in a data item labeled \"tint\".\n\nTo fetch data that was supplied using ~.NodePath.set_shader_input(), the shader must use the appropriate parameter name. See the list of GLSL shader inputs <list-of-glsl-shader-inputs> or the list of Cg shader inputs <list-of-possible-cg-shader-inputs>, many of which refer to the data that was stored using ~.NodePath.set_shader_input().\n\nShader inputs propagate down the scene graph, and accumulate as they go. For example, if you store set_shader_input(\"x\", 1) <.NodePath.set_shader_input> on a node, and set_shader_input(\"y\", 2) <.NodePath.set_shader_input> on its child, then the child will contain both values. If you store set_shader_input(\"z\", 1) <.NodePath.set_shader_input> on a node, and set_shader_input(\"z\", 2) <.NodePath.set_shader_input> on its child, then the latter will override the former.\n\nThis method also accepts a third parameter, priority, which defaults to zero. If you store set_shader_input(\"w\", 1, priority=1000) <.NodePath.set_shader_input> on a node, and set_shader_input(\"w\", 2, priority=500) <.NodePath.set_shader_input> on the child, then the child will contain a \"w\" value of 1, because the priority 1000 overrides the priority 500.\n\npython\n\nTo set multiple shader inputs at once, it is most efficient to use a single call to ~.NodePath.set_shader_inputs():\n\nmyModel.setShaderInputs(\n    tint=(1.0, 0.5, 0.5, 1.0),\n    tex=myTexture,\n)\n\nShader Render Attributes\n\nThe functions .NodePath.set_shader() and ~.NodePath.set_shader_input() are used to apply a shader to a node in the scene graph. Internally, these functions manipulate a render attribute of class .ShaderAttrib on the node.\n\nIn rare occasions, it is necessary to manipulate .ShaderAttrib objects explicitly. As an example, the code below shows how to create a .ShaderAttrib and apply it to a camera:\n\npython\n\nattrib = ShaderAttrib.make()\nattrib = attrib.setShader(Shader.load(\"myshader.sha\"))\nattrib = attrib.setShaderInput(\"tint\", (1.0, 0.5, 0.5, 1.0))\nbase.cam.node().setInitialState(attrib)\n\ncpp\n\nCPT(ShaderAttrib) attrib = DCAST(ShaderAttrib, ShaderAttrib::make());\nattrib = attrib->set_shader(Shader::load(\"myshader.sha\"));\nattrib = attrib->set_shader_input(\"tint\", LVector4(1.0, 0.5, 0.5, 1.0));\ncamera.set_initial_state(attrib);\n\nBe careful: attribs are immutable objects. So when you apply a function like ~.NodePath.set_shader() or ~.NodePath.set_shader_input() to a .ShaderAttrib, you aren't modifying the attrib. Instead, these functions work by returning a new attrib (which contains the modified data).\n\nDeferred Shader Compilation\n\nWhen you create a Cg shader object, it compiles the shader, checking for syntax errors. But it does not check whether or not your video card is powerful enough to handle the shader. This only happens later on, when you try to render something with the shader. In the case of GLSL shaders, all of this will only happen when the shader is first used to render something.\n\nIn the unusual event that your computer contains multiple video cards, the shader may be compiled more than once. It is possible that the compilation could succeed for one video card, and fail for the other.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/94b58d23_shader-basics.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/8ddfa146_94b58d23_shader-basics.json",
    "doc_id": "doc_462"
  }
}