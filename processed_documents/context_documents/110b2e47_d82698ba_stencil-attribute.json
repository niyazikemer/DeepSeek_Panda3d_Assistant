{
  "content": "Stencil Attribute\n\nThe .StencilAttrib is used for testing and writing to the stencil buffer. Note that both of these actions can be performed simultaneously with a single StencilAttrib.\n\nThe stencil buffer is an ancillary graphics buffer, in addition to the more well-known color and depth buffers. It provides a per-pixel mask for the rendering pipeline which can be exploited to selectively render objects or parts of objects. Typical applications of the stencil buffer include binary masking, shadowing and planar reflections.\n\nUsually, using the stencil buffer involves creating some objects which are not rendered into the color buffer. Their contribution to the rendered scene is to provide an invisible boundary that can be used to turn color buffer rendering on and off for other objects in the scene. Think of it as a cardboard cut-out through which the world is viewed.\n\nDuring a stencil comparison, the StencilAttrib's reference value is compared against the value stored in the stencil buffer. The order matters here. For example, consider comparison function StencilAttrib.SCFGreaterThan with reference value r=1. A pixel passes the stencil test if r > Sp, where Sp is the value in the stencil buffer at pixel p. Objects contributing values to the stencil buffer that will be read by other StencilAttributes' comparison functions must be rendered first, or unexpected results will occur. See how-to-control-render-order.\n\nThe stencil buffer is disabled by default. In order to use StencilAttribs, you must add the following line to your config.prc file:\n\nframebuffer-stencil true\n\nStencilAttribs are defined exclusively by their constructor functions, so let's examine one to understand what each part does. The following code creates an attribute which tells an object to render only if the stencil buffer is exactly 1, and does not itself modify the stencil buffer.\n\nstencilReader =\n    StencilAttrib.make(1, StencilAttrib.SCFEqual,StencilAttrib.SOKeep,\n                          StencilAttrib.SOKeep,StencilAttrib.SOKeep,1,1,0)\n\nThe first parameter is a boolean. If this parameter is zero, the StencilAttrib is not processed. Next is the comparison function this attribute uses, in this case Equal. The next three parameters determine what happens to the stencil buffer depending on the result of the comparison. We'll get to these in a minute. The three Keep values tell this attribute never to modify the values in the buffer. Next is the reference value for the comparison function. Before the reference value is passed to the comparison function, however, it is bitwise ANDed with a mask. In our case, we're interested in reading but not in writing to the stencil buffer, so we pass 1 and 0 for the read and write masks, respectively. These masks are the last two parameters for the StencilAttrib.\n\nNext, we'll look at a stencil attribute that writes to the stencil buffer. Presumably, these two functions will work in tandem to create an effect.\n\nconstantOneStencil =\n    StencilAttrib.make(1, StencilAttrib.SCFAlways,StencilAttrib.SOZero,\n                          StencilAttrib.SOReplace,StencilAttrib.SOReplace,1,0,1)\n\nAgain we start by enabling the attribute. The comparison function here is Always, meaning that the test passes no matter the parameters. Next is the operation to perform on the stencil buffer if the test fails (which in this case will never happen) -- we set the stencil buffer value to zero. The next parameter determines what should happen if the stencil function passes, but the depth test fails, and finally, what should happen if both the stencil and depth tests pass. In our case we want to set the value of the stencil buffer whether we pass the depth test or not, so both are set to Replace. The reference value to set in the stencil buffer is 1. We're writing regardless of what's in the buffer already, so we'll set the read and write masks to 0 and 1, respectively.\n\nNow we can add these attributes to nodes in the scene to exploit the effect. Here is the entire script.\n\nfrom panda3d.core import *\n\n# Do this before the next import:\nloadPrcFileData(\"\", \"framebuffer-stencil #t\")\n\nimport direct.directbase.DirectStart\n\nconstantOneStencil = StencilAttrib.make(1,StencilAttrib.SCFAlways,\nStencilAttrib.SOZero,StencilAttrib.SOReplace,\nStencilAttrib.SOReplace,1,0,1)\n\nstencilReader = StencilAttrib.make(1,StencilAttrib.SCFEqual,\nStencilAttrib.SOKeep, StencilAttrib.SOKeep,\nStencilAttrib.SOKeep,1,1,0)\n\ncm = CardMaker(\"cardmaker\")\ncm.setFrame(-.5,.5,-.5,.5)\n\n# To rotate the card to face the camera, we create\n# it and then parent it to the camera.\nviewingSquare = render.attachNewNode(cm.generate())\nviewingSquare.reparentTo(base.camera)\nviewingSquare.setPos(0, 5, 0)\n\nviewingSquare.node().setAttrib(constantOneStencil)\nviewingSquare.node().setAttrib(ColorWriteAttrib.make(0))\nviewingSquare.setBin('background',0)\nviewingSquare.setDepthWrite(0)\n\nview = loader.loadModel(\"panda\")\nview.reparentTo(render)\nview.setScale(3)\nview.setY(150)\nview.node().setAttrib(stencilReader)\n\nbase.run()\n\nYou can get a little more insight into stencils in this thread on the forums: https://discourse.panda3d.org/t/using-stencils-solved/7409/7",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/d82698ba_stencil-attribute.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/110b2e47_d82698ba_stencil-attribute.json",
    "doc_id": "doc_426"
  }
}