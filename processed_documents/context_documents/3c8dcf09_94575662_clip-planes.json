{
  "content": "Clip Planes\n\nA clip plane fundamentally divides space into two halves: one half which is clipped (hidden from rendering), and one half which is rendered.\n\nA common use case is when rendering reflections of flat mirror surfaces (such as water), to ensure that a camera that is rendering the reflected scene will only render the part of the scene that is above the surface of the mirror.\n\nIt is possible to have multiple clip planes enabled at the same time. This will cause multiple areas to be culled away. There is an implementation-specific limit on the number of clip planes that can be active at any one time.\n\nA plane is defined by four coordinates. The first three represent the X, Y, Z of the plane's surface normal. The last parameter is used to determine the origin point of the plane. You can create a plane either using three points, or by using a normal vector and an origin point:\n\npython\n\n# Create a plane going through these three points\nplane = Plane((100, 0, 2), (100, 100, 2), (0, 100, 2))\n\n# Create an identical plane pointing upward with a height of 2\nplane = Plane((0, 0, 1), (0, 0, 2))\n\n# Create the same plane by directly specifying its parameters\nplane = Plane(0, 0, 1, -2)\n\ncpp\n\n// Create a plane going through these three points\nLPlane plane((100, 0, 2), (100, 100, 2), (0, 100, 2));\n\n// Create an identical plane pointing upward with a height of 2\nLPlane plane((0, 0, 1), (0, 0, 2));\n\n// Create the same plane by directly specifying its parameters\nLPlane plane(0, 0, 1, -2);\n\nBefore we can use it as a clip plane, we need to place it in the scene graph. This is done by creating a .PlaneNode:\n\npython\n\nplane = Plane(0, 0, 1, -2)\nplane_node = PlaneNode(\"plane\", plane)\nplane_np = render.attach_new_node(plane_node)\n\ncpp\n\nLPlane plane(0, 0, 1, -2);\nPT(PlaneNode) plane_node = new PlaneNode(\"plane\", plane);\nNodePath plane_np = render.attach_new_node(plane_node);\n\nTo see a debug representation of the plane, call ~.NodePath.show() on the resulting node path.\n\nFinally, we can use ~.NodePath.set_clip_plane() in order to apply it to any node on which the clipping should take effect:\n\npython\n\nrender.setClipPlane(plane_np)\n\ncpp\n\nrender.set_clip_plane(plane_np);\n\nInternally, this will create a .ClipPlaneAttrib and assign it to the node's render state.\n\npython\n\nThis is a complete sample program showing a teapot that is being affected by two clip planes:\n\nfrom direct.showbase.ShowBase import ShowBase\nfrom panda3d.core import *\n\nbase = ShowBase()\n\nteapot = loader.loadModel(\"models/teapot\")\nteapot.setScale(10)\nteapot.reparentTo(render)\n\nplane1 = Plane((0, 0, 1), (0, 0, 5))\nplane1_np = render.attachNewNode(PlaneNode(\"plane1\", plane1))\nplane1_np.show()\nteapot.setClipPlane(plane1_np)\n\nplane2 = Plane((1, 0, 0), (-10, 0, 0))\nplane2_np = render.attachNewNode(PlaneNode(\"plane2\", plane2))\nplane2_np.show()\nteapot.setClipPlane(plane2_np)\n\nbase.cam.setPos(10, -200, 30)\nbase.run()\n\nNote\n\nClip planes work normally in the fixed-function pipeline and with the shader generator, but if you are using a custom shader, it is your responsibility to implement the effect of the clip planes. In GLSL shaders, you can use the built-in p3d_ClipPlane[] input, which contains the view-space coordinates of each active plane. One way to implement it is to put something like this in the fragment shader:\n\nuniform vec4 p3d_ClipPlane[2];\n\n// View-space vertex position passed in from vertex shader\nin vec4 vpos;\n\nvoid main() {\n  if (dot(p3d_ClipPlane[0], vpos) < 0) {\n    discard;\n  }\n  if (dot(p3d_ClipPlane[1], vpos) < 0) {\n    discard;\n  }\n\n  // Rest of fragment shader\n}",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/94575662_clip-planes.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/3c8dcf09_94575662_clip-planes.json",
    "doc_id": "doc_370"
  }
}