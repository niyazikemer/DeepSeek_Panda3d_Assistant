{
  "content": "Multi-Part Actors\n\nIt is possible to assemble a character model out of several separate pieces (separate models). If this is the case, then the pieces must contain bones that can be attached to each other. For example, if you have a robot consisting of a set of legs and a swappable torso, and if you want to glue them together at the waist, then the legs model should contain a bone \"waist\", and the torso model should also contain a bone \"waist\". You can then attach them together:\n\nnodePath = Actor.Actor(\n    {\n        'legs':'RobotLegs.egg',\n        'torso':'RobotTorso1.egg',\n    }, {\n        'legs':{'dance':'RobotLegs-Dance.egg'},\n        'torso':{'dance':'RobotTorso1-Dance.egg'},\n    })\nnodePath.attach('torso','legs','waist')\n\nMulti-part actors are fairly complicated. Each part is loaded from a separate egg file, and each part has its own set of animations that are applied to it. For each animation you want to play, you will need to have a corresponding egg file for each part.\n\nIn the Actor constructor, you specify the list of model files with a dictionary of part name to egg file, as shown above. The list of animation files is more complicated; it's a dictionary of dictionaries. The outer dictionary maps part names to animation dictionaries. Each animation dictionary maps animation name to animation egg file for the corresponding part.\n\nHere's another example:\n\nmyactor = Actor(\n    # part dictionary\n    {\n        \"head\": \"char/dogMM/dogMM_Shorts-head-mod\",\n        \"torso\": \"char/dogMM/dogMM_Shorts-torso-mod\",\n        \"legs\": \"char/dogMM/dogMM_Shorts-legs-mod\"\n    },\n    # dictionary of anim dictionaries\n    {\n        \"head\": {\n            \"walk\": \"char/dogMM/dogMM_Shorts-head-walk\",\n            \"run\": \"char/dogMM/dogMM_Shorts-head-run\",\n        },\n        \"torso\": {\n            \"walk\": \"char/dogMM/dogMM_Shorts-torso-walk\",\n            \"run\": \"char/dogMM/dogMM_Shorts-torso-run\",\n        },\n        \"legs\": {\n            \"walk\":\"char/dogMM/dogMM_Shorts-legs-walk\",\n            \"run\":\"char/dogMM/dogMM_Shorts-legs-run\",\n        },\n    })\n\nIn addition multipart actor parts need to be connected together in a meaningful fashion:\n\nmyactor.attach(\"head\", \"torso\", \"joint-head\")\nmyactor.attach(\"torso\", \"legs\", \"joint-hips\")\n\nThe ~direct.actor.Actor.Actor.attach() call names two parts, and reparents the part named by the first parameter onto the part named by the second parameter, at the node named by the third parameter, which should be an exposed joint (that is, a joint in the part named by the second parameter). You must have already exposed the joint before this call, either with the egg- optchar command line tool, or by calling actor.exposeJoint() <direct.actor.Actor.Actor.exposeJoint> at runtime.\n\nAfter calling ~direct.actor.Actor.Actor.attach(), the stacked part will inherit the animation from the attachment joint, by virtue of the scene graph relationship.\n\nAnimation\n\nYou can animate the parts as normal animations, but you need to supply the partname, like this:\n\nmyactor.play('Animation Name', 'Part Name')\n\nIf you want to use AnimControl, as explained in this section <actor-animations>, you must supply the part name as second parameter in ~direct.actor.Actor.Actor.getAnimControl():\n\n# you can see you just need to call\n# actor.getAnimControl('Animation Name', 'Part Name')\n# to get access to the AnimControl of that part.\n\nac = actor.getAnimControl('Animation Name', 'Part Name')\nac.isPlaying() # Returns a boolean whether the animation is playing or not\nac.getFrame() # Returns the current frame number\nac.getFrameRate() # Returns the speed of the animation, in frames per second\nac.getFullFframe() # Returns a floating-point frame number.\nac.getFullFrame() # Returns an integer frame number.\nac.getNextFrame() # Returns the number of the next frame on the queue.\nac.getNumFrames() # Returns the total number of frames\nac.getPlayRate() # Returns the playrate. explained further below\nac.loop() # Starts playing the animation in a loop\nac.play() # Starts playing the animation\nac.pose(frame) # Poses at frame frame\nac.setPlayRate(rate) # Sets the playrate.  explained further below\nac.stop() # Stops the animation\n\n# Note: the numbers returned by getFullFrame and getFullFframe keep counting\n# and may exceed the total number of frames.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/707eb733_multi-part-actors.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/cf700b32_707eb733_multi-part-actors.json",
    "doc_id": "doc_512"
  }
}