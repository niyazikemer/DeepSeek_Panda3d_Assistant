{
  "content": "\"\"\"ServerRepository module: contains the ServerRepository class\"\"\"\n\nfrom panda3d.core import (\n    ConfigVariableBool,\n    ConfigVariableDouble,\n    ConfigVariableInt,\n    DatagramIterator,\n    Filename,\n    TPLow,\n    UniqueIdAllocator,\n    VirtualFileSystem,\n    getModelPath,\n)\nfrom panda3d.net import (\n    ConnectionWriter,\n    NetAddress,\n    NetDatagram,\n    PointerToConnection,\n    QueuedConnectionListener,\n    QueuedConnectionManager,\n    QueuedConnectionReader,\n)\nfrom panda3d.direct import DCFile\nfrom direct.distributed.MsgTypesCMU import (\n    CLIENT_DISCONNECT_CMU,\n    CLIENT_OBJECT_GENERATE_CMU,\n    CLIENT_OBJECT_UPDATE_FIELD,\n    CLIENT_OBJECT_UPDATE_FIELD_TARGETED_CMU,\n    CLIENT_SET_INTEREST_CMU,\n    OBJECT_DELETE_CMU,\n    OBJECT_DISABLE_CMU,\n    OBJECT_GENERATE_CMU,\n    OBJECT_SET_ZONE_CMU,\n    OBJECT_UPDATE_FIELD_CMU,\n    REQUEST_GENERATES_CMU,\n    SET_DOID_RANGE_CMU,\n)\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.distributed.PyDatagram import PyDatagram\n\nimport inspect\n\n\n_server_doid_range = ConfigVariableInt('server-doid-range', 1000000)\n\n\nclass ServerRepository:\n\n    \"\"\" This maintains the server-side connection with a Panda server.\n    It is only for use with the Panda LAN server provided by CMU.\"\"\"\n\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"ServerRepository\")\n\n    class Client:\n        \"\"\" This internal class keeps track of the data associated\n        with each connected client. \"\"\"\n        def __init__(self, connection, netAddress, doIdBase):\n            # The connection used to communicate with the client.\n            self.connection = connection\n\n            # The net address to the client, including IP address.\n            # Used for reporting purposes only.\n            self.netAddress = netAddress\n\n            # The first doId in the range assigned to the client.\n            # This also serves as a unique numeric ID for this client.\n            # (It is sometimes called \"avatarId\" in some update\n            # messages, even though the client is not required to use\n            # this particular number as an avatar ID.)\n            self.doIdBase = doIdBase\n\n            # The set of zoneIds that the client explicitly has\n            # interest in.  The client will receive updates for all\n            # distributed objects appearing in one of these zones.\n            # (The client will also receive updates for all zones in\n            # which any one of the distributed obejcts that it has\n            # created still exist.)\n            self.explicitInterestZoneIds = set()\n\n            # The set of interest zones sent to the client at the last\n            # update.  This is the actual set of zones the client is\n            # informed of.  Changing the explicitInterestZoneIds,\n            # above, creating or deleting objects in different zones,\n            # or moving objects between zones, might influence this\n            # set.\n            self.currentInterestZoneIds = set()\n\n            # A dictionary of doId -> Object, for distributed objects\n            # currently in existence that were created by the client.\n            self.objectsByDoId = {}\n\n            # A dictionary of zoneId -> set([Object]), listing the\n            # distributed objects assigned to each zone, of the\n            # objects created by this client.\n            self.objectsByZoneId = {}\n\n    class Object:\n        \"\"\" This internal class keeps track of the data associated\n        with each extent distributed object. \"\"\"\n        def __init__(self, doId, zoneId, dclass):\n            # The object's distributed ID.\n            self.doId = doId\n\n            # The object's current zone.  Each object is associated\n            # with only one zone.\n            self.zoneId = zoneId\n\n            # The object's class type.\n            self.dclass = dclass\n\n            # Note that the server does not store any other data about\n            # the distributed objects; in particular, it doesn't\n            # record its current fields.  That is left to the clients.\n\n\n    def __init__(self, tcpPort, serverAddress = None,\n                 udpPort = None, dcFileNames = None,\n                 threadedNet = None):\n        if threadedNet is None:\n            # Default value.\n            threadedNet = ConfigVariableBool('threaded-net', False).value\n\n        # Set up networking interfaces.\n        numThreads = 0\n        if threadedNet:\n            numThreads = 1\n        self.qcm = QueuedConnectionManager()\n        self.qcl = QueuedConnectionListener(self.qcm, numThreads)\n        self.qcr = QueuedConnectionReader(self.qcm, numThreads)\n        self.cw = ConnectionWriter(self.qcm, numThreads)\n\n        taskMgr.setupTaskChain('flushTask')\n        if threadedNet:\n            taskMgr.setupTaskChain('flushTask', numThreads = 1,\n                                   threadPriority = TPLow, frameSync = True)\n\n        self.tcpRendezvous = self.qcm.openTCPServerRendezvous(\n            serverAddress or '', tcpPort, 10)\n        self.qcl.addConnection(self.tcpRendezvous)\n        taskMgr.add(self.listenerPoll, \"serverListenerPollTask\")\n        taskMgr.add(self.readerPollUntilEmpty, \"serverReaderPollTask\")\n        taskMgr.add(self.clientHardDisconnectTask, \"clientHardDisconnect\")\n\n        # A set of clients that have recently been written to and may\n        # need to be flushed.\n        self.needsFlush = set()\n\n        collectTcpInterval = ConfigVariableDouble('collect-tcp-interval').getValue()\n        taskMgr.doMethodLater(collectTcpInterval, self.flushTask, 'flushTask',\n                              taskChain = 'flushTask')\n\n        # A dictionary of connection -> Client object, tracking all of\n        # the clients we currently have connected.\n        self.clientsByConnection = {}\n\n        # A similar dictionary of doIdBase -> Client object, indexing\n        # by the client's doIdBase number instead.\n        self.clientsByDoIdBase = {}\n\n        # A dictionary of zoneId -> set([Client]), listing the clients\n        # that have an interest in each zoneId.\n        self.zonesToClients = {}\n\n        # A dictionary of zoneId -> set([Object]), listing the\n        # distributed objects assigned to each zone, globally.\n        self.objectsByZoneId = {}\n\n        # The number of doId's to assign to each client.  Must remain\n        # constant during server lifetime.\n        self.doIdRange = _server_doid_range.value\n\n        # An allocator object that assigns the next doIdBase to each\n        # client.\n        self.idAllocator = UniqueIdAllocator(0, 0xffffffff // self.doIdRange)\n\n        self.dcFile = DCFile()\n        self.dcSuffix = ''\n        self.readDCFile(dcFileNames)\n\n    def flushTask(self, task):\n        \"\"\" This task is run periodically to flush any connections\n        that might need it.  It's only necessary in cases where\n        collect-tcp is set true (if this is false, messages are sent\n        immediately and do not require periodic flushing). \"\"\"\n\n        flush = self.needsFlush\n        self.needsFlush = set()\n        for client in flush:\n            client.connection.flush()\n\n        return Task.again\n\n    def setTcpHeaderSize(self, headerSize):\n        \"\"\"Sets the header size of TCP packets.  At the present, legal\n        values for this are 0, 2, or 4; this specifies the number of\n        bytes to use encode the datagram length at the start of each\n        TCP datagram.  Sender and receiver must independently agree on\n        this.\"\"\"\n        self.qcr.setTcpHeaderSize(headerSize)\n        self.cw.setTcpHeaderSize(headerSize)\n\n    def getTcpHeaderSize(self):\n        \"\"\"Returns the current setting of TCP header size. See\n        setTcpHeaderSize(). \"\"\"\n        return self.qcr.getTcpHeaderSize()\n\n\n    def importModule(self, dcImports, moduleName, importSymbols):\n        \"\"\" Imports the indicated moduleName and all of its symbols\n        into the current namespace.  This more-or-less reimplements\n        the Python import command. \"\"\"\n\n        module = __import__(moduleName, globals(), locals(), importSymbols)\n\n        if importSymbols:\n            # \"from moduleName import symbolName, symbolName, ...\"\n            # Copy just the named symbols into the dictionary.\n            if importSymbols == ['*']:\n                # \"from moduleName import *\"\n                if hasattr(module, \"__all__\"):\n                    importSymbols = module.__all__\n                else:\n                    importSymbols = module.__dict__.keys()\n\n            for symbolName in importSymbols:\n                if hasattr(module, symbolName):\n                    dcImports[symbolName] = getattr(module, symbolName)\n\n                else:\n                    raise Exception('Symbol %s not defined in module %s.' % (symbolName, moduleName))\n\n        else:\n            # \"import moduleName\"\n\n            # Copy the root module name into the dictionary.\n\n            # Follow the dotted chain down to the actual module.\n            components = moduleName.split('.')\n            dcImports[components[0]] = module\n\n    def readDCFile(self, dcFileNames = None):\n        \"\"\"\n        Reads in the dc files listed in dcFileNames, or if\n        dcFileNames is None, reads in all of the dc files listed in\n        the Configrc file.\n        \"\"\"\n        dcFile = self.dcFile\n        dcFile.clear()\n        self.dclassesByName = {}\n        self.dclassesByNumber = {}\n        self.hashVal = 0\n\n        dcImports = {}\n        if dcFileNames is None:\n            readResult = dcFile.readAll()\n            if not readResult:\n                self.notify.error(\"Could not read dc file.\")\n        else:\n            searchPath = getModelPath().getValue()\n            for dcFileName in dcFileNames:\n                pathname = Filename(dcFileName)\n                vfs = VirtualFileSystem.getGlobalPtr()\n                vfs.resolveFilename(pathname, searchPath)\n                readResult = dcFile.read(pathname)\n                if not readResult:\n                    self.notify.error(\"Could not read dc file: %s\" % (pathname))\n\n        self.hashVal = dcFile.getHash()\n\n        # Now import all of the modules required by the DC file.\n        for n in range(dcFile.getNumImportModules()):\n            moduleName = dcFile.getImportModule(n)\n\n            # Maybe the module name is represented as \"moduleName/AI\".\n            suffix = moduleName.split('/')\n            moduleName = suffix[0]\n            if self.dcSuffix and self.dcSuffix in suffix[1:]:\n                moduleName += self.dcSuffix\n\n            importSymbols = []\n            for i in range(dcFile.getNumImportSymbols(n)):\n                symbolName = dcFile.getImportSymbol(n, i)\n\n                # Maybe the symbol name is represented as \"symbolName/AI\".\n                suffix = symbolName.split('/')\n                symbolName = suffix[0]\n                if self.dcSuffix and self.dcSuffix in suffix[1:]:\n                    symbolName += self.dcSuffix\n\n                importSymbols.append(symbolName)\n\n            self.importModule(dcImports, moduleName, importSymbols)\n\n        # Now get the class definition for the classes named in the DC\n        # file.\n        for i in range(dcFile.getNumClasses()):\n            dclass = dcFile.getClass(i)\n            number = dclass.getNumber()\n            className = dclass.getName() + self.dcSuffix\n\n            # Does the class have a definition defined in the newly\n            # imported namespace?\n            classDef = dcImports.get(className)\n\n            # Also try it without the dcSuffix.\n            if classDef is None:\n                className = dclass.getName()\n                classDef = dcImports.get(className)\n\n            if classDef is None:\n                self.notify.debug(\"No class definition for %s.\" % (className))\n            else:\n                if inspect.ismodule(classDef):\n                    if not hasattr(classDef, className):\n                        self.notify.error(\"Module %s does not define class %s.\" % (className, className))\n                    classDef = getattr(classDef, className)\n\n                if not inspect.isclass(classDef):\n                    self.notify.error(\"Symbol %s is not a class name.\" % (className))\n                else:\n                    dclass.setClassDef(classDef)\n\n            self.dclassesByName[className] = dclass\n            if number >= 0:\n                self.dclassesByNumber[number] = dclass\n\n\n# listens for new clients\n\n    def listenerPoll(self, task):\n        if self.qcl.newConnectionAvailable():\n            rendezvous = PointerToConnection()\n            netAddress = NetAddress()\n            newConnection = PointerToConnection()\n            retVal = self.qcl.getNewConnection(rendezvous, netAddress,\n                                               newConnection)\n            if not retVal:\n                return Task.cont\n\n            # Crazy dereferencing\n            newConnection = newConnection.p()\n\n            #  Add clients information to dictionary\n            id = self.idAllocator.allocate()\n            doIdBase = id * self.doIdRange + 1\n\n            self.notify.info(\n                \"Got client %s from %s\" % (doIdBase, netAddress))\n\n            client = self.Client(newConnection, netAddress, doIdBase)\n            self.clientsByConnection[client.connection] = client\n            self.clientsByDoIdBase[client.doIdBase] = client\n\n            # Now we can start listening to that new connection.\n            self.qcr.addConnection(newConnection)\n\n            self.lastConnection = newConnection\n            self.sendDoIdRange(client)\n\n        return Task.cont\n\n    def readerPollUntilEmpty(self, task):\n        \"\"\" continuously polls for new messages on the server \"\"\"\n        while self.readerPollOnce():\n            pass\n        return Task.cont\n\n    def readerPollOnce(self):\n        \"\"\" checks for available messages to the server \"\"\"\n\n        availGetVal = self.qcr.dataAvailable()\n        if availGetVal:\n            datagram = NetDatagram()\n            readRetVal = self.qcr.getData(datagram)\n            if readRetVal:\n                # need to send to message processing unit\n                self.handleDatagram(datagram)\n        return availGetVal\n\n    def handleDatagram(self, datagram):\n        \"\"\" switching station for messages \"\"\"\n\n        client = self.clientsByConnection.get(datagram.getConnection())\n\n        if not client:\n            # This shouldn't be possible, though it appears to happen\n            # sometimes?\n            self.notify.warning(\n                \"Ignoring datagram from unknown connection %s\" % (datagram.getConnection()))\n            return\n\n        if self.notify.getDebug():\n            self.notify.debug(\n                \"ServerRepository received datagram from %s:\" % (client.doIdBase))\n            #datagram.dumpHex(ostream)\n\n        dgi = DatagramIterator(datagram)\n\n        type = dgi.getUint16()\n\n        if type == CLIENT_DISCONNECT_CMU:\n            self.handleClientDisconnect(client)\n        elif type == CLIENT_SET_INTEREST_CMU:\n            self.handleClientSetInterest(client, dgi)\n        elif type == CLIENT_OBJECT_GENERATE_CMU:\n            self.handleClientCreateObject(datagram, dgi)\n        elif type == CLIENT_OBJECT_UPDATE_FIELD:\n            self.handleClientObjectUpdateField(datagram, dgi)\n        elif type == CLIENT_OBJECT_UPDATE_FIELD_TARGETED_CMU:\n            self.handleClientObjectUpdateField(datagram, dgi, targeted = True)\n        elif type == OBJECT_DELETE_CMU:\n            self.handleClientDeleteObject(datagram, dgi.getUint32())\n        elif type == OBJECT_SET_ZONE_CMU:\n            self.handleClientObjectSetZone(datagram, dgi)\n        else:\n            self.handleMessageType(type, dgi)\n\n    def handleMessageType(self, msgType, di):\n        self.notify.warning(\"unrecognized message type %s\" % (msgType))\n\n    def handleClientCreateObject(self, datagram, dgi):\n        \"\"\" client wants to create an object, so we store appropriate\n        data, and then pass message along to corresponding zones \"\"\"\n\n        connection = datagram.getConnection()\n        zoneId  = dgi.getUint32()\n        classId = dgi.getUint16()\n        doId    = dgi.getUint32()\n\n        client = self.clientsByConnection[connection]\n\n        if self.getDoIdBase(doId) != client.doIdBase:\n            self.notify.warning(\n                \"Ignoring attempt to create invalid doId %s from client %s\" % (doId, client.doIdBase))\n            return\n\n        dclass = self.dclassesByNumber[classId]\n\n        object = client.objectsByDoId.get(doId)\n        if object:\n            # This doId is already in use; thus, this message is\n            # really just an update.\n            if object.dclass != dclass:\n                self.notify.warning(\n                    \"Ignoring attempt to change object %s from %s to %s by client %s\" % (\n                    doId, object.dclass.getName(), dclass.getName(), client.doIdBase))\n                return\n            self.setObjectZone(client, object, zoneId)\n        else:\n            if self.notify.getDebug():\n                self.notify.debug(\n                    \"Creating object %s of type %s by client %s\" % (\n                    doId, dclass.getName(), client.doIdBase))\n\n            object = self.Object(doId, zoneId, dclass)\n            client.objectsByDoId[doId] = object\n            client.objectsByZoneId.setdefault(zoneId, set()).add(object)\n            self.objectsByZoneId.setdefault(zoneId, set()).add(object)\n\n            self.updateClientInterestZones(client)\n\n\n        # Rebuild the new datagram that we'll send on.  We shim in the\n        # doIdBase of the owner.\n        dg = PyDatagram()\n        dg.addUint16(OBJECT_GENERATE_CMU)\n        dg.addUint32(client.doIdBase)\n        dg.addUint32(zoneId)\n        dg.addUint16(classId)\n        dg.addUint32(doId)\n        dg.appendData(dgi.getRemainingBytes())\n\n        self.sendToZoneExcept(zoneId, dg, [client])\n\n    def handleClientObjectUpdateField(self, datagram, dgi, targeted = False):\n        \"\"\" Received an update request from a client. \"\"\"\n        connection = datagram.getConnection()\n        client = self.clientsByConnection[connection]\n\n        if targeted:\n            targetId = dgi.getUint32()\n        doId = dgi.getUint32()\n        fieldId = dgi.getUint16()\n\n        doIdBase = self.getDoIdBase(doId)\n        owner = self.clientsByDoIdBase.get(doIdBase)\n        object = owner and owner.objectsByDoId.get(doId)\n        if not object:\n            self.notify.warning(\n                \"Ignoring update for unknown object %s from client %s\" % (\n                doId, client.doIdBase))\n            return\n\n        dcfield = object.dclass.getFieldByIndex(fieldId)\n        if dcfield is None:\n            self.notify.warning(\n                \"Ignoring update for field %s on object %s from client %s; no such field for class %s.\" % (\n                fieldId, doId, client.doIdBase, object.dclass.getName()))\n\n        if client != owner:\n            # This message was not sent by the object's owner.\n            if not dcfield.hasKeyword('clsend') and not dcfield.hasKeyword('p2p'):\n                self.notify.warning(\n                    \"Ignoring update for %s.%s on object %s from client %s: not owner\" % (\n                    object.dclass.getName(), dcfield.getName(), doId, client.doIdBase))\n                return\n\n        # We reformat the message slightly to insert the sender's\n        # doIdBase.\n        dg = PyDatagram()\n        dg.addUint16(OBJECT_UPDATE_FIELD_CMU)\n        dg.addUint32(client.doIdBase)\n        dg.addUint32(doId)\n        dg.addUint16(fieldId)\n        dg.appendData(dgi.getRemainingBytes())\n\n        if targeted:\n            # A targeted update: only to the indicated client.\n            target = self.clientsByDoIdBase.get(targetId)\n            if not target:\n                self.notify.warning(\n                    \"Ignoring targeted update to %s for %s.%s on object %s from client %s: target not known\" % (\n                    targetId,\n                    dclass.getName(), dcfield.getName(), doId, client.doIdBase))\n                return\n            self.cw.send(dg, target.connection)\n            self.needsFlush.add(target)\n\n        elif dcfield.hasKeyword('p2p'):\n            # p2p: to object owner only\n            self.cw.send(dg, owner.connection)\n            self.needsFlush.add(owner)\n\n        elif dcfield.hasKeyword('broadcast'):\n            # Broadcast: to everyone except orig sender\n            self.sendToZoneExcept(object.zoneId, dg, [client])\n\n        elif dcfield.hasKeyword('reflect'):\n            # Reflect: broadcast to everyone including orig sender\n            self.sendToZoneExcept(object.zoneId, dg, [])\n\n        else:\n            self.notify.warning(\n                \"Message is not broadcast or p2p\")\n\n    def getDoIdBase(self, doId):\n        \"\"\" Given a doId, return the corresponding doIdBase.  This\n        will be the owner of the object (clients may only create\n        object doId's within their assigned range). \"\"\"\n\n        return int(doId / self.doIdRange) * self.doIdRange + 1\n\n    def handleClientDeleteObject(self, datagram, doId):\n        \"\"\" client deletes an object, let everyone who has interest in\n        the object's zone know about it. \"\"\"\n\n        connection = datagram.getConnection()\n        client = self.clientsByConnection[connection]\n        object = client.objectsByDoId.get(doId)\n        if not object:\n            self.notify.warning(\n                \"Ignoring update for unknown object %s from client %s\" % (\n                doId, client.doIdBase))\n            return\n\n        self.sendToZoneExcept(object.zoneId, datagram, [])\n\n        self.objectsByZoneId[object.zoneId].remove(object)\n        if not self.objectsByZoneId[object.zoneId]:\n            del self.objectsByZoneId[object.zoneId]\n        client.objectsByZoneId[object.zoneId].remove(object)\n        if not client.objectsByZoneId[object.zoneId]:\n            del client.objectsByZoneId[object.zoneId]\n        del client.objectsByDoId[doId]\n\n        self.updateClientInterestZones(client)\n\n    def handleClientObjectSetZone(self, datagram, dgi):\n        \"\"\" The client is telling us the object is changing to a new\n        zone. \"\"\"\n        doId = dgi.getUint32()\n        zoneId = dgi.getUint32()\n\n        connection = datagram.getConnection()\n        client = self.clientsByConnection[connection]\n        object = client.objectsByDoId.get(doId)\n        if not object:\n            # Don't know this object.\n            self.notify.warning(\"Ignoring object location for %s: unknown\" % (doId))\n            return\n\n        self.setObjectZone(client, object, zoneId)\n\n    def setObjectZone(self, owner, object, zoneId):\n        if object.zoneId == zoneId:\n            # No change.\n            return\n\n        oldZoneId = object.zoneId\n        self.objectsByZoneId[object.zoneId].remove(object)\n        if not self.objectsByZoneId[object.zoneId]:\n            del self.objectsByZoneId[object.zoneId]\n        owner.objectsByZoneId[object.zoneId].remove(object)\n        if not owner.objectsByZoneId[object.zoneId]:\n            del owner.objectsByZoneId[object.zoneId]\n\n        object.zoneId = zoneId\n        self.objectsByZoneId.setdefault(zoneId, set()).add(object)\n        owner.objectsByZoneId.setdefault(zoneId, set()).add(object)\n\n        self.updateClientInterestZones(owner)\n\n        # Any clients that are listening to oldZoneId but not zoneId\n        # should receive a disable message: this object has just gone\n        # out of scope for you.\n        datagram = PyDatagram()\n        datagram.addUint16(OBJECT_DISABLE_CMU)\n        datagram.addUint32(object.doId)\n        for client in self.zonesToClients[oldZoneId]:\n            if client != owner:\n                if zoneId not in client.currentInterestZoneIds:\n                    self.cw.send(datagram, client.connection)\n                    self.needsFlush.add(client)\n\n        # The client is now responsible for sending a generate for the\n        # object that just switched zones, to inform the clients that\n        # are listening to the new zoneId but not the old zoneId.\n\n    def sendDoIdRange(self, client):\n        \"\"\" sends the client the range of doid's that the client can\n        use \"\"\"\n\n        datagram = NetDatagram()\n        datagram.addUint16(SET_DOID_RANGE_CMU)\n        datagram.addUint32(client.doIdBase)\n        datagram.addUint32(self.doIdRange)\n\n        self.cw.send(datagram, client.connection)\n        self.needsFlush.add(client)\n\n    # a client disconnected from us, we need to update our data, also\n    # tell other clients to remove the disconnected clients objects\n    def handleClientDisconnect(self, client):\n        for zoneId in client.currentInterestZoneIds:\n            if len(self.zonesToClients[zoneId]) == 1:\n                del self.zonesToClients[zoneId]\n            else:\n                self.zonesToClients[zoneId].remove(client)\n\n        for object in client.objectsByDoId.values():\n            #create and send delete message\n            datagram = NetDatagram()\n            datagram.addUint16(OBJECT_DELETE_CMU)\n            datagram.addUint32(object.doId)\n            self.sendToZoneExcept(object.zoneId, datagram, [])\n            self.objectsByZoneId[object.zoneId].remove(object)\n            if not self.objectsByZoneId[object.zoneId]:\n                del self.objectsByZoneId[object.zoneId]\n\n        client.objectsByDoId = {}\n        client.objectsByZoneId = {}\n\n        del self.clientsByConnection[client.connection]\n        del self.clientsByDoIdBase[client.doIdBase]\n\n        id = client.doIdBase // self.doIdRange\n        self.idAllocator.free(id)\n\n        self.qcr.removeConnection(client.connection)\n        self.qcm.closeConnection(client.connection)\n\n\n    def handleClientSetInterest(self, client, dgi):\n        \"\"\" The client is specifying a particular set of zones it is\n        interested in. \"\"\"\n\n        zoneIds = set()\n        while dgi.getRemainingSize() > 0:\n            zoneId = dgi.getUint32()\n            zoneIds.add(zoneId)\n\n        client.explicitInterestZoneIds = zoneIds\n        self.updateClientInterestZones(client)\n\n    def updateClientInterestZones(self, client):\n        \"\"\" Something about the client has caused its set of interest\n        zones to potentially change.  Recompute them. \"\"\"\n\n        origZoneIds = client.currentInterestZoneIds\n        newZoneIds = client.explicitInterestZoneIds | set(client.objectsByZoneId.keys())\n        if origZoneIds == newZoneIds:\n            # No change.\n            return\n\n        client.currentInterestZoneIds = newZoneIds\n        addedZoneIds = newZoneIds - origZoneIds\n        removedZoneIds = origZoneIds - newZoneIds\n\n        for zoneId in addedZoneIds:\n            self.zonesToClients.setdefault(zoneId, set()).add(client)\n\n            # The client is opening interest in this zone. Need to get\n            # all of the data from clients who may have objects in\n            # this zone\n            datagram = NetDatagram()\n            datagram.addUint16(REQUEST_GENERATES_CMU)\n            datagram.addUint32(zoneId)\n            self.sendToZoneExcept(zoneId, datagram, [client])\n\n        datagram = PyDatagram()\n        datagram.addUint16(OBJECT_DISABLE_CMU)\n        for zoneId in removedZoneIds:\n            self.zonesToClients[zoneId].remove(client)\n\n            # The client is abandoning interest in this zone.  Any\n            # objects in this zone should be disabled for the client.\n            for object in self.objectsByZoneId.get(zoneId, []):\n                datagram.addUint32(object.doId)\n        self.cw.send(datagram, client.connection)\n\n        self.needsFlush.add(client)\n\n\n    def clientHardDisconnectTask(self, task):\n        \"\"\" client did not tell us he was leaving but we lost connection to\n        him, so we need to update our data and tell others \"\"\"\n        for client in list(self.clientsByConnection.values()):\n            if not self.qcr.isConnectionOk(client.connection):\n                self.handleClientDisconnect(client)\n        return Task.cont\n\n    def sendToZoneExcept(self, zoneId, datagram, exceptionList):\n        \"\"\"sends a message to everyone who has interest in the\n        indicated zone, except for the clients on exceptionList.\"\"\"\n\n        if self.notify.getDebug():\n            self.notify.debug(\n                \"ServerRepository sending to all in zone %s except %s:\" % (zoneId, [c.doIdBase for c in exceptionList]))\n            #datagram.dumpHex(ostream)\n\n        for client in self.zonesToClients.get(zoneId, []):\n            if client not in exceptionList:\n                if self.notify.getDebug():\n                    self.notify.debug(\n                        \"  -> %s\" % (client.doIdBase))\n                self.cw.send(datagram, client.connection)\n                self.needsFlush.add(client)\n\n    def sendToAllExcept(self, datagram, exceptionList):\n        \"\"\" sends a message to all connected clients, except for\n        clients on exceptionList. \"\"\"\n\n        if self.notify.getDebug():\n            self.notify.debug(\n                \"ServerRepository sending to all except %s:\" % ([c.doIdBase for c in exceptionList],))\n            #datagram.dumpHex(ostream)\n\n        for client in self.clientsByConnection.values():\n            if client not in exceptionList:\n                if self.notify.getDebug():\n                    self.notify.debug(\n                        \"  -> %s\" % (client.doIdBase))\n                self.cw.send(datagram, client.connection)\n                self.needsFlush.add(client)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/ServerRepository.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/081ab7e4_ServerRepository.json",
    "doc_id": "doc_293"
  }
}