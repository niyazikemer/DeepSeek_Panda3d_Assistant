{
  "content": "\"\"\" This script generates a pandadoc.hpp file representing the Python\nwrappers that can be parsed by doxygen to generate the Python documentation.\nYou need to run this before invoking Doxyfile.python.\n\nIt requires a valid makepanda installation with interrogatedb .in\nfiles in the lib/pandac/input directory. \"\"\"\n\nfrom __future__ import print_function\n\n__all__ = []\n\nimport os\nimport panda3d\nimport pandac\nfrom panda3d.interrogatedb import *\n\n\nif 'interrogate_element_is_sequence' not in globals():\n    def interrogate_element_is_sequence(element): # pylint: disable=function-redefined\n        return False\n\nif 'interrogate_element_is_mapping' not in globals():\n    def interrogate_element_is_mapping(element): # pylint: disable=function-redefined\n        return False\n\n\nLICENSE = \"\"\"PANDA 3D SOFTWARE\nCopyright (c) Carnegie Mellon University.  All rights reserved.\nAll use of this software is subject to the terms of the revised BSD\nlicense.  You should have received a copy of this license along\nwith this source code in a file named \\\"LICENSE.\\\"\"\"\".split(\"\\n\")\n\nMAINPAGE = \"\"\"@mainpage Panda3D Python API Reference\nWelcome to the Panda3D API reference.\n\nUse the links at the top of this page to browse through the list of modules or\nthe list of classes.\n\nThis reference is automatically generated from comments in the source code.\n\"\"\"\n\n\ndef comment(code):\n    if not code:\n        return \"\"\n\n    comment = ''\n\n    empty_line = False\n    for line in code.splitlines(False):\n        line = line.strip('\\t\\n /')\n        if line:\n            if empty_line:\n                # New paragraph.\n                comment += '\\n\\n'\n                empty_line = False\n            elif comment:\n                comment += '\\n'\n            comment += '/// ' + line\n        else:\n            empty_line = True\n\n    if comment:\n        return comment\n    else:\n        return ''\n\n\ndef block_comment(code):\n    code = code.strip()\n\n    if not code.startswith('///<') and '@verbatim' not in code:\n        code = code.replace('<', '\\\\<').replace('>', '\\\\>')\n\n    if not code or code[0] != '/':\n        # Not really a comment; get rid of it.\n        return \"\"\n\n    return code\n\n\ndef translateFunctionName(name):\n    if name.startswith(\"__\"):\n        return name\n\n    new = \"\"\n    for i in name.split(\"_\"):\n        if new == \"\":\n            new += i\n        elif i == \"\":\n            pass\n        elif len(i) == 1:\n            new += i[0].upper()\n        else:\n            new += i[0].upper() + i[1:]\n    return new\n\n\ndef translateTypeName(name, mangle=True):\n    # Equivalent to C++ classNameFromCppName\n    class_name = \"\"\n    bad_chars = \"!@#$%^&*()<>,.-=+~{}? \"\n    next_cap = False\n    first_char = mangle\n\n    for chr in name:\n        if (chr == '_' or chr == ' ') and mangle:\n            next_cap = True\n        elif chr in bad_chars:\n            if not mangle:\n                class_name += '_'\n        elif next_cap or first_char:\n            class_name += chr.upper()\n            next_cap = False\n            first_char = False\n        else:\n            class_name += chr\n\n    return class_name\n\n\ndef translated_type_name(type, scoped=True):\n    while interrogate_type_is_wrapped(type):\n        if interrogate_type_is_const(type):\n            return 'const ' + translated_type_name(interrogate_type_wrapped_type(type))\n        else:\n            type = interrogate_type_wrapped_type(type)\n\n    typename = interrogate_type_name(type)\n    if typename in (\"PyObject\", \"_object\"):\n        return \"object\"\n    elif typename == \"PN_stdfloat\":\n        return \"float\"\n    elif typename == \"size_t\":\n        return \"int\"\n\n    if interrogate_type_is_atomic(type):\n        token = interrogate_type_atomic_token(type)\n        if token == 7:\n            return 'str'\n        elif token == 8:\n            return 'long'\n        elif token == 9:\n            return 'NoneType'\n        else:\n            return typename\n\n    if not typename.endswith('_t'):\n        # Hack: don't mangle size_t etc.\n        typename = translateTypeName(typename)\n\n    if scoped and interrogate_type_is_nested(type):\n        return translated_type_name(interrogate_type_outer_class(type)) + '::' + typename\n    else:\n        return typename\n\n\ndef processElement(handle, element):\n    if interrogate_element_has_comment(element):\n        print(comment(interrogate_element_comment(element)), file=handle)\n    elif interrogate_element_has_getter(element):\n        # If the property has no comment, use the comment of the getter.\n        getter = interrogate_element_getter(element)\n        if interrogate_function_has_comment(getter):\n            print(block_comment(interrogate_function_comment(getter)), file=handle)\n\n    if interrogate_element_is_mapping(element) or \\\n       interrogate_element_is_sequence(element):\n        suffix = \"[]\"\n    else:\n        suffix = \"\"\n\n    print(translated_type_name(interrogate_element_type(element)), end=' ', file=handle)\n    print(interrogate_element_name(element) + suffix + ';', file=handle)\n\n\ndef processFunction(handle, function, isConstructor = False):\n    for i_wrapper in range(interrogate_function_number_of_python_wrappers(function)):\n        wrapper = interrogate_function_python_wrapper(function, i_wrapper)\n        if interrogate_wrapper_has_comment(wrapper):\n            print(block_comment(interrogate_wrapper_comment(wrapper)), file=handle)\n\n        if not isConstructor:\n            if interrogate_function_is_method(function):\n                if not interrogate_wrapper_number_of_parameters(wrapper) > 0 or not interrogate_wrapper_parameter_is_this(wrapper, 0):\n                    print(\"static\", end=' ', file=handle)\n\n            if interrogate_wrapper_has_return_value(wrapper):\n                print(translated_type_name(interrogate_wrapper_return_type(wrapper)), end=' ', file=handle)\n            else:\n                pass#print >>handle, \"void\",\n\n            print(translateFunctionName(interrogate_function_name(function)) + \"(\", end=' ', file=handle)\n        else:\n            print(\"__init__(\", end=' ', file=handle)\n\n        first = True\n        for i_param in range(interrogate_wrapper_number_of_parameters(wrapper)):\n            if not interrogate_wrapper_parameter_is_this(wrapper, i_param):\n                if not first:\n                    print(\",\", end=' ', file=handle)\n                print(translated_type_name(interrogate_wrapper_parameter_type(wrapper, i_param)), end=' ', file=handle)\n                if interrogate_wrapper_parameter_has_name(wrapper, i_param):\n                    print(interrogate_wrapper_parameter_name(wrapper, i_param), end=' ', file=handle)\n                first = False\n\n        print(\");\", file=handle)\n\n\ndef processType(handle, type):\n    typename = translated_type_name(type, scoped=False)\n    derivations = [translated_type_name(interrogate_type_get_derivation(type, n)) for n in range(interrogate_type_number_of_derivations(type))]\n\n    if interrogate_type_has_comment(type):\n        print(block_comment(interrogate_type_comment(type)), file=handle)\n\n    if interrogate_type_is_enum(type):\n        print(\"enum %s {\" % typename, file=handle)\n        for i_value in range(interrogate_type_number_of_enum_values(type)):\n            docstring = comment(interrogate_type_enum_value_comment(type, i_value))\n            if docstring:\n                print(docstring, file=handle)\n            print(interrogate_type_enum_value_name(type, i_value), \"=\", interrogate_type_enum_value(type, i_value), \",\", file=handle)\n\n    elif interrogate_type_is_typedef(type):\n        wrapped_type = interrogate_type_wrapped_type(type)\n        if interrogate_type_is_global(wrapped_type):\n            wrapped_type_name = translated_type_name(wrapped_type)\n            print(\"typedef %s %s;\" % (wrapped_type_name, typename), file=handle)\n        return\n    else:\n        if interrogate_type_is_struct(type):\n            classtype = \"struct\"\n        elif interrogate_type_is_class(type):\n            classtype = \"class\"\n        elif interrogate_type_is_union(type):\n            classtype = \"union\"\n        else:\n            print(\"I don't know what type %s is\" % interrogate_type_true_name(type))\n            return\n\n        if len(derivations) > 0:\n            print(\"%s %s : public %s {\" % (classtype, typename, \", public \".join(derivations)), file=handle)\n        else:\n            print(\"%s %s {\" % (classtype, typename), file=handle)\n        print(\"public:\", file=handle)\n\n    for i_ntype in range(interrogate_type_number_of_nested_types(type)):\n        processType(handle, interrogate_type_get_nested_type(type, i_ntype))\n\n    for i_method in range(interrogate_type_number_of_constructors(type)):\n        processFunction(handle, interrogate_type_get_constructor(type, i_method), True)\n\n    for i_method in range(interrogate_type_number_of_methods(type)):\n        processFunction(handle, interrogate_type_get_method(type, i_method))\n\n    for i_method in range(interrogate_type_number_of_make_seqs(type)):\n        print(\"list\", translateFunctionName(interrogate_make_seq_seq_name(interrogate_type_get_make_seq(type, i_method))), \"();\", file=handle)\n\n    for i_element in range(interrogate_type_number_of_elements(type)):\n        processElement(handle, interrogate_type_get_element(type, i_element))\n\n    print(\"};\", file=handle)\n\n\ndef processModule(handle, package):\n    print(\"Processing module %s\" % (package))\n    print(\"namespace %s {\" % package, file=handle)\n\n    if package != \"core\":\n        print(\"using namespace core;\", file=handle)\n\n    for i_type in range(interrogate_number_of_global_types()):\n        type = interrogate_get_global_type(i_type)\n\n        if interrogate_type_has_module_name(type):\n            module_name = interrogate_type_module_name(type)\n            if \"panda3d.\" + package == module_name:\n                processType(handle, type)\n        else:\n            typename = interrogate_type_name(type)\n            print(\"Type %s has no module name\" % typename)\n\n    for i_func in range(interrogate_number_of_global_functions()):\n        func = interrogate_get_global_function(i_func)\n\n        if interrogate_function_has_module_name(func):\n            module_name = interrogate_function_module_name(func)\n            if \"panda3d.\" + package == module_name:\n                processFunction(handle, func)\n        else:\n            funcname = interrogate_function_name(func)\n            print(\"Function %s has no module name\" % funcname)\n\n    print(\"}\", file=handle)\n\n\nif __name__ == \"__main__\":\n    handle = open(\"pandadoc.hpp\", \"w\")\n\n    mainpage = MAINPAGE.strip()\n    if mainpage:\n        print(\"/**\\n * \" + mainpage.replace('\\n', '\\n * ') + '\\n */', file=handle)\n\n    print(comment(\"Panda3D modules that are implemented in C++.\"), file=handle)\n    print(\"namespace panda3d {\", file=handle)\n\n    # Determine the path to the interrogatedb files\n    pandac = os.path.dirname(pandac.__file__)\n    interrogate_add_search_directory(os.path.join(pandac, \"..\", \"..\", \"etc\"))\n    interrogate_add_search_directory(os.path.join(pandac, \"input\"))\n\n    import panda3d.core\n    processModule(handle, \"core\")\n\n    # Determine the suffix for the extension modules.\n    import _imp\n    ext_suffix = _imp.extension_suffixes()[0]\n\n    for lib in os.listdir(os.path.dirname(panda3d.__file__)):\n        if lib.endswith(ext_suffix) and not lib.startswith('core.'):\n            module_name = lib[:-len(ext_suffix)]\n            __import__(\"panda3d.\" + module_name)\n            processModule(handle, module_name)\n\n    print(\"}\", file=handle)\n    handle.close()\n\n    print(\"Wrote output to pandadoc.hpp.  You can now run:\")\n    print()\n    print(\"  doxygen built/direct/directscripts/Doxyfile.python\")\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/directscripts/extract_docs.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/94f279c8_extract_docs.json",
    "doc_id": "doc_95"
  }
}