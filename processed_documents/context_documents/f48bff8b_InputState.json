{
  "content": "from direct.directnotify import DirectNotifyGlobal\nfrom direct.showbase import DirectObject\nfrom direct.showbase.PythonUtil import SerialNumGen\nfrom direct.showbase.MessengerGlobal import messenger\n\n\n# internal class, don't create these on your own\nclass InputStateToken:\n    _SerialGen = SerialNumGen()\n    Inval = 'invalidatedToken'\n\n    def __init__(self, inputState):\n        self._id = InputStateToken._SerialGen.next()\n        self._hash = self._id\n        self._inputState = inputState\n\n    def release(self):\n        # subclasses will override\n        assert False\n\n    def isValid(self):\n        return self._id != InputStateToken.Inval\n\n    def invalidate(self):\n        self._id = InputStateToken.Inval\n\n    def __hash__(self):\n        return self._hash\n\n    #snake_case alias:\n    is_valid = isValid\n\n\nclass InputStateWatchToken(InputStateToken, DirectObject.DirectObject):\n    def release(self):\n        self._inputState._ignore(self)\n        self.ignoreAll()\n\n\nclass InputStateForceToken(InputStateToken):\n    def release(self):\n        self._inputState._unforce(self)\n\n\nclass InputStateTokenGroup:\n    def __init__(self):\n        self._tokens = []\n\n    def addToken(self, token):\n        self._tokens.append(token)\n\n    def release(self):\n        for token in self._tokens:\n            token.release()\n        self._tokens = []\n\n    #snake_case alias:\n    add_token = addToken\n\n\nclass InputState(DirectObject.DirectObject):\n    \"\"\"\n    InputState is for tracking the on/off state of some events.\n    The initial usage is to watch some keyboard keys so that another\n    task can poll the key states.  By the way, in general polling is\n    not a good idea, but it is useful in some situations.  Know when\n    to use it:)  If in doubt, don't use this class and listen for\n    events instead.\n    \"\"\"\n\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"InputState\")\n\n    # standard input sources\n    WASD = 'WASD'\n    QE = 'QE'\n    ArrowKeys = 'ArrowKeys'\n    Keyboard = 'Keyboard'\n    Mouse = 'Mouse'\n\n    def __init__(self):\n        # stateName->set(SourceNames)\n        self._state = {}\n        # stateName->set(SourceNames)\n        self._forcingOn = {}\n        # stateName->set(SourceNames)\n        self._forcingOff = {}\n        # tables to look up the info needed to undo operations\n        self._token2inputSource = {}\n        self._token2forceInfo = {}\n        # inputSource->token->(name, eventOn, eventOff)\n        self._watching = {}\n        assert self.debugPrint(\"InputState()\")\n\n    def delete(self):\n        del self._watching\n        del self._token2forceInfo\n        del self._token2inputSource\n        del self._forcingOff\n        del self._forcingOn\n        del self._state\n        self.ignoreAll()\n\n    def isSet(self, name, inputSource=None):\n        \"\"\"\n        returns True/False\n        \"\"\"\n        #assert self.debugPrint(\"isSet(name=%s)\"%(name))\n        if name in self._forcingOn:\n            return True\n        elif name in self._forcingOff:\n            return False\n        if inputSource:\n            s = self._state.get(name)\n            if s:\n                return inputSource in s\n            else:\n                return False\n        else:\n            return name in self._state\n\n    def getEventName(self, name):\n        return \"InputState-%s\" % (name,)\n\n    def set(self, name, isActive, inputSource=None):\n        assert self.debugPrint(\"set(name=%s, isActive=%s, inputSource=%s)\"%(name, isActive, inputSource))\n        # inputSource is a string that identifies where this input change\n        # is coming from (like 'WASD', 'ArrowKeys', etc.)\n        # Each unique inputSource is allowed to influence this input item\n        # once: it's either 'active' or 'not active'. If at least one source\n        # activates this input item, the input item is considered to be active\n        if inputSource is None:\n            inputSource = 'anonymous'\n        if isActive:\n            self._state.setdefault(name, set())\n            self._state[name].add(inputSource)\n        else:\n            if name in self._state:\n                self._state[name].discard(inputSource)\n                if len(self._state[name]) == 0:\n                    del self._state[name]\n        # We change the name before sending it because this may\n        # be the same name that messenger used to call InputState.set()\n        # this avoids running in circles:\n        messenger.send(self.getEventName(name), [self.isSet(name)])\n\n    def releaseInputs(self, name):\n        # call this to act as if all inputs affecting this state have been released\n        del self._state[name]\n\n    def watch(self, name, eventOn, eventOff, startState=False, inputSource=None):\n        \"\"\"\n        This returns a token; hold onto the token and call token.release() when\n        you no longer want to watch for these events.\n\n        Example::\n\n            # set up\n            token = inputState.watch('forward', 'w', 'w-up', inputSource=inputState.WASD)\n            ...\n            # tear down\n            token.release()\n        \"\"\"\n        assert self.debugPrint(\n            \"watch(name=%s, eventOn=%s, eventOff=%s, startState=%s)\"%(\n            name, eventOn, eventOff, startState))\n        if inputSource is None:\n            inputSource = \"eventPair('%s','%s')\" % (eventOn, eventOff)\n        # Do we really need to reset the input state just because\n        # we're watching it?  Remember, there may be multiple things\n        # watching this input state.\n        self.set(name, startState, inputSource)\n        token = InputStateWatchToken(self)\n        # make the token listen for the events, to allow multiple listeners for the same event\n        token.accept(eventOn, self.set, [name, True, inputSource])\n        token.accept(eventOff, self.set, [name, False, inputSource])\n        self._token2inputSource[token] = inputSource\n        self._watching.setdefault(inputSource, {})\n        self._watching[inputSource][token] = (name, eventOn, eventOff)\n        return token\n\n    def watchWithModifiers(self, name, event, startState=False, inputSource=None):\n        patterns = ('%s', 'control-%s', 'shift-control-%s', 'alt-%s',\n                    'control-alt-%s', 'shift-%s', 'shift-alt-%s')\n        tGroup = InputStateTokenGroup()\n        for pattern in patterns:\n            tGroup.addToken(self.watch(name, pattern % event, '%s-up' % event, startState=startState, inputSource=inputSource))\n        return tGroup\n\n    def _ignore(self, token):\n        \"\"\"\n        Undo a watch(). Don't call this directly, call release() on the token that watch() returned.\n        \"\"\"\n        inputSource = self._token2inputSource.pop(token)\n        name, eventOn, eventOff = self._watching[inputSource].pop(token)\n        token.invalidate()\n        DirectObject.DirectObject.ignore(self, eventOn)\n        DirectObject.DirectObject.ignore(self, eventOff)\n        if len(self._watching[inputSource]) == 0:\n            del self._watching[inputSource]\n\n        # I commented this out because we shouldn't be modifying an\n        # input state simply because we're not looking at it anymore.\n        # self.set(name, False, inputSource)\n\n    def force(self, name, value, inputSource):\n        \"\"\"\n        Force isSet(name) to return 'value'.\n\n        This returns a token; hold onto the token and call token.release() when\n        you no longer want to force the state.\n\n        Example::\n\n            # set up\n            token = inputState.force('forward', True, inputSource='myForwardForcer')\n            ...\n            # tear down\n            token.release()\n        \"\"\"\n        token = InputStateForceToken(self)\n        self._token2forceInfo[token] = (name, inputSource)\n        if value:\n            if name in self._forcingOff:\n                self.notify.error(\n                    \"%s is trying to force '%s' to ON, but '%s' is already being forced OFF by %s\" %\n                    (inputSource, name, name, self._forcingOff[name])\n                )\n            self._forcingOn.setdefault(name, set())\n            self._forcingOn[name].add(inputSource)\n        else:\n            if name in self._forcingOn:\n                self.notify.error(\n                    \"%s is trying to force '%s' to OFF, but '%s' is already being forced ON by %s\" %\n                    (inputSource, name, name, self._forcingOn[name])\n                )\n            self._forcingOff.setdefault(name, set())\n            self._forcingOff[name].add(inputSource)\n        return token\n\n    def _unforce(self, token):\n        \"\"\"\n        Stop forcing a value. Don't call this directly, call release() on your token.\n        \"\"\"\n        name, inputSource = self._token2forceInfo[token]\n        token.invalidate()\n        if name in self._forcingOn:\n            self._forcingOn[name].discard(inputSource)\n            if len(self._forcingOn[name]) == 0:\n                del self._forcingOn[name]\n        if name in self._forcingOff:\n            self._forcingOff[name].discard(inputSource)\n            if len(self._forcingOff[name]) == 0:\n                del self._forcingOff[name]\n\n    def debugPrint(self, message):\n        \"\"\"for debugging\"\"\"\n        return self.notify.debug(\n            \"%s (%s) %s\"%(id(self), len(self._state), message))\n\n    #snake_case alias:\n    watch_with_modifiers = watchWithModifiers\n    is_set = isSet\n    get_event_name = getEventName\n    debug_print = debugPrint\n    release_inputs = releaseInputs\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/controls/InputState.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/f48bff8b_InputState.json",
    "doc_id": "doc_232"
  }
}