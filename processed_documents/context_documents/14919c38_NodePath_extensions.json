{
  "content": "####################################################################\n#Dtool_funcToMethod(func, class)\n#del func\n#####################################################################\n\n\"\"\"\nNodePath-extensions module: contains methods to extend functionality\nof the NodePath class\n\"\"\"\n\nfrom panda3d.core import NodePath\nfrom .extension_native_helpers import Dtool_funcToMethod\nimport warnings\n\n####################################################################\ndef id(self):\n    \"\"\"Deprecated.  Returns a unique id identifying the NodePath instance\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.id() is deprecated.  Use hash(NodePath) or NodePath.get_key() instead.\", DeprecationWarning, stacklevel=2)\n    return self.getKey()\n\nDtool_funcToMethod(id, NodePath)\ndel id\n#####################################################################\ndef getChildrenAsList(self):\n    \"\"\"Deprecated.  Converts a node path's child NodePathCollection into a list\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.getChildrenAsList() is deprecated.  Use get_children() instead.\", DeprecationWarning, stacklevel=2)\n    return list(self.getChildren())\n\nDtool_funcToMethod(getChildrenAsList, NodePath)\ndel getChildrenAsList\n#####################################################################\n\ndef printChildren(self):\n    \"\"\"Deprecated.  Prints out the children of the bottom node of a node path\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.printChildren() is deprecated.\", DeprecationWarning, stacklevel=2)\n    for child in self.getChildren():\n        print(child.getName())\nDtool_funcToMethod(printChildren, NodePath)\ndel printChildren\n#####################################################################\n\ndef removeChildren(self):\n    \"\"\"Deprecated.  Deletes the children of the bottom node of a node path\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.removeChildren() is deprecated.  Use get_children().detach() instead.\", DeprecationWarning, stacklevel=2)\n    self.getChildren().detach()\nDtool_funcToMethod(removeChildren, NodePath)\ndel removeChildren\n#####################################################################\n\ndef toggleVis(self):\n    \"\"\"Deprecated.  Toggles visibility of a nodePath\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.toggleVis() is deprecated.  Use is_hidden(), show() and hide() instead.\", DeprecationWarning, stacklevel=2)\n    if self.isHidden():\n        self.show()\n        return 1\n    else:\n        self.hide()\n        return 0\nDtool_funcToMethod(toggleVis, NodePath)\ndel toggleVis\n#####################################################################\n\ndef showSiblings(self):\n    \"\"\"Deprecated.  Show all the siblings of a node path\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.showSiblings() is deprecated.\", DeprecationWarning, stacklevel=2)\n    for sib in self.getParent().getChildren():\n        if sib.node() != self.node():\n            sib.show()\nDtool_funcToMethod(showSiblings, NodePath)\ndel showSiblings\n#####################################################################\n\ndef hideSiblings(self):\n    \"\"\"Deprecated.  Hide all the siblings of a node path\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.hideSiblings() is deprecated.\", DeprecationWarning, stacklevel=2)\n    for sib in self.getParent().getChildren():\n        if sib.node() != self.node():\n            sib.hide()\nDtool_funcToMethod(hideSiblings, NodePath)\ndel hideSiblings\n#####################################################################\n\ndef showAllDescendants(self):\n    \"\"\"Deprecated.  Show the node path and all its children\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.showAllDescendants() is deprecated.\", DeprecationWarning, stacklevel=2)\n    self.show()\n    for child in self.getChildren():\n        child.showAllDescendants()\nDtool_funcToMethod(showAllDescendants, NodePath)\ndel showAllDescendants\n#####################################################################\n\ndef isolate(self):\n    \"\"\"Deprecated.  Show the node path and hide its siblings\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.isolate() is deprecated.\", DeprecationWarning, stacklevel=2)\n    self.showAllDescendants()\n    for sib in self.getParent().getChildren():\n        if sib.node() != self.node():\n            sib.hide()\nDtool_funcToMethod(isolate, NodePath)\ndel isolate\n#####################################################################\n\ndef remove(self):\n    \"\"\"Deprecated.  Remove a node path from the scene graph\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.remove() is deprecated.  Use remove_node() instead.\", DeprecationWarning, stacklevel=2)\n    # Send message in case anyone needs to do something\n    # before node is deleted\n    from direct.showbase.MessengerGlobal import messenger\n    messenger.send('preRemoveNodePath', [self])\n    # Remove nodePath\n    self.removeNode()\nDtool_funcToMethod(remove, NodePath)\ndel remove\n#####################################################################\n\ndef lsNames(self):\n    \"\"\"Deprecated. Walk down a tree and print out the path\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.lsNames() is deprecated.\", DeprecationWarning, stacklevel=2)\n    if self.isEmpty():\n        print(\"(empty)\")\n    else:\n        type = self.node().getType().getName()\n        name = self.getName()\n        print(type + \"  \" + name)\n        self.lsNamesRecurse()\n\nDtool_funcToMethod(lsNames, NodePath)\ndel lsNames\n#####################################################################\ndef lsNamesRecurse(self, indentString=' '):\n    \"\"\"Deprecated.  Walk down a tree and print out the path\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.lsNamesRecurse() is deprecated.\", DeprecationWarning, stacklevel=2)\n    for nodePath in self.getChildren():\n        type = nodePath.node().getType().getName()\n        name = nodePath.getName()\n        print(indentString + type + \"  \" + name)\n        nodePath.lsNamesRecurse(indentString + \" \")\n\nDtool_funcToMethod(lsNamesRecurse, NodePath)\ndel lsNamesRecurse\n#####################################################################\ndef reverseLsNames(self):\n    \"\"\"Deprecated.  Walk up a tree and print out the path to the root\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.reverseLsNames() is deprecated.\", DeprecationWarning, stacklevel=2)\n    ancestors = list(self.getAncestors())\n    ancestry = ancestors.reverse()\n    indentString = \"\"\n    for nodePath in ancestry:\n        type = nodePath.node().getType().getName()\n        name = nodePath.getName()\n        print(indentString + type + \"  \" + name)\n        indentString = indentString + \" \"\n\nDtool_funcToMethod(reverseLsNames, NodePath)\ndel reverseLsNames\n#####################################################################\ndef getAncestry(self):\n    \"\"\"Deprecated.  Get a list of a node path's ancestors\"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.getAncestry() is deprecated.  Use get_ancestors() instead.\", DeprecationWarning, stacklevel=2)\n    ancestors = list(self.getAncestors())\n    ancestors.reverse()\n    return ancestors\n\nDtool_funcToMethod(getAncestry, NodePath)\ndel getAncestry\n#####################################################################\n\ndef pPrintString(self, other = None):\n    \"\"\"\n    Deprecated.  pretty print\n    \"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.pPrintString() is deprecated.\", DeprecationWarning, stacklevel=2)\n        # Normally I would have put the if __debug__ around\n        # the entire funciton, the that doesn't seem to work\n        # with -extensions.  Maybe someone will look into\n        # this further.\n        if other:\n            pos = self.getPos(other)\n            hpr = self.getHpr(other)\n            scale = self.getScale(other)\n            shear = self.getShear(other)\n            otherString = \"  'other': %s,\\n\" % (other.getName(),)\n        else:\n            pos = self.getPos()\n            hpr = self.getHpr()\n            scale = self.getScale()\n            shear = self.getShear()\n            otherString = '\\n'\n        return (\n            \"%s = {\"%(self.getName()) +\n            otherString +\n            \"  'Pos':   (%s),\\n\" % pos.pPrintValues() +\n            \"  'Hpr':   (%s),\\n\" % hpr.pPrintValues() +\n            \"  'Scale': (%s),\\n\" % scale.pPrintValues() +\n            \"  'Shear': (%s),\\n\" % shear.pPrintValues() +\n            \"}\")\n\nDtool_funcToMethod(pPrintString, NodePath)\ndel pPrintString\n#####################################################################\n\ndef printPos(self, other = None, sd = 2):\n    \"\"\" Deprecated.  Pretty print a node path's pos \"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.printPos() is deprecated.\", DeprecationWarning, stacklevel=2)\n    formatString = '%0.' + '%d' % sd + 'f'\n    if other:\n        pos = self.getPos(other)\n        otherString = other.getName() + ', '\n    else:\n        pos = self.getPos()\n        otherString = ''\n    print((self.getName() + '.setPos(' + otherString +\n           formatString % pos[0] + ', ' +\n           formatString % pos[1] + ', ' +\n           formatString % pos[2] +\n           ')\\n'))\nDtool_funcToMethod(printPos, NodePath)\ndel printPos\n#####################################################################\n\ndef printHpr(self, other = None, sd = 2):\n    \"\"\" Deprecated.  Pretty print a node path's hpr \"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.printHpr() is deprecated.\", DeprecationWarning, stacklevel=2)\n    formatString = '%0.' + '%d' % sd + 'f'\n    if other:\n        hpr = self.getHpr(other)\n        otherString = other.getName() + ', '\n    else:\n        hpr = self.getHpr()\n        otherString = ''\n    print((self.getName() + '.setHpr(' + otherString +\n           formatString % hpr[0] + ', ' +\n           formatString % hpr[1] + ', ' +\n           formatString % hpr[2] +\n           ')\\n'))\nDtool_funcToMethod(printHpr, NodePath)\ndel printHpr\n#####################################################################\n\ndef printScale(self, other = None, sd = 2):\n    \"\"\" Deprecated.  Pretty print a node path's scale \"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.printScale() is deprecated.\", DeprecationWarning, stacklevel=2)\n    formatString = '%0.' + '%d' % sd + 'f'\n    if other:\n        scale = self.getScale(other)\n        otherString = other.getName() + ', '\n    else:\n        scale = self.getScale()\n        otherString = ''\n    print((self.getName() + '.setScale(' + otherString +\n           formatString % scale[0] + ', ' +\n           formatString % scale[1] + ', ' +\n           formatString % scale[2] +\n           ')\\n'))\n\nDtool_funcToMethod(printScale, NodePath)\ndel printScale\n#####################################################################\ndef printPosHpr(self, other = None, sd = 2):\n    \"\"\" Deprecated.  Pretty print a node path's pos and, hpr \"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.printPosHpr() is deprecated.\", DeprecationWarning, stacklevel=2)\n    formatString = '%0.' + '%d' % sd + 'f'\n    if other:\n        pos = self.getPos(other)\n        hpr = self.getHpr(other)\n        otherString = other.getName() + ', '\n    else:\n        pos = self.getPos()\n        hpr = self.getHpr()\n        otherString = ''\n    print((self.getName() + '.setPosHpr(' + otherString +\n           formatString % pos[0] + ', ' +\n           formatString % pos[1] + ', ' +\n           formatString % pos[2] + ', ' +\n           formatString % hpr[0] + ', ' +\n           formatString % hpr[1] + ', ' +\n           formatString % hpr[2] +\n           ')\\n'))\n\nDtool_funcToMethod(printPosHpr, NodePath)\ndel printPosHpr\n#####################################################################\ndef printPosHprScale(self, other = None, sd = 2):\n    \"\"\" Deprecated.  Pretty print a node path's pos, hpr, and scale \"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.printPosHprScale() is deprecated.\", DeprecationWarning, stacklevel=2)\n    formatString = '%0.' + '%d' % sd + 'f'\n    if other:\n        pos = self.getPos(other)\n        hpr = self.getHpr(other)\n        scale = self.getScale(other)\n        otherString = other.getName() + ', '\n    else:\n        pos = self.getPos()\n        hpr = self.getHpr()\n        scale = self.getScale()\n        otherString = ''\n    print((self.getName() + '.setPosHprScale(' + otherString +\n           formatString % pos[0] + ', ' +\n           formatString % pos[1] + ', ' +\n           formatString % pos[2] + ', ' +\n           formatString % hpr[0] + ', ' +\n           formatString % hpr[1] + ', ' +\n           formatString % hpr[2] + ', ' +\n           formatString % scale[0] + ', ' +\n           formatString % scale[1] + ', ' +\n           formatString % scale[2] +\n           ')\\n'))\n\nDtool_funcToMethod(printPosHprScale, NodePath)\ndel printPosHprScale\n#####################################################################\n\ndef printTransform(self, other = None, sd = 2, fRecursive = 0):\n    \"Deprecated.\"\n    if __debug__:\n        warnings.warn(\"NodePath.printTransform() is deprecated.\", DeprecationWarning, stacklevel=2)\n    from panda3d.core import Vec3\n    fmtStr = '%%0.%df' % sd\n    name = self.getName()\n    if other is None:\n        transform = self.getTransform()\n    else:\n        transform = self.getTransform(other)\n    if transform.hasPos():\n        pos = transform.getPos()\n        if not pos.almostEqual(Vec3(0)):\n            outputString = '%s.setPos(%s, %s, %s)' % (name, fmtStr, fmtStr, fmtStr)\n            print(outputString % (pos[0], pos[1], pos[2]))\n    if transform.hasHpr():\n        hpr = transform.getHpr()\n        if not hpr.almostEqual(Vec3(0)):\n            outputString = '%s.setHpr(%s, %s, %s)' % (name, fmtStr, fmtStr, fmtStr)\n            print(outputString % (hpr[0], hpr[1], hpr[2]))\n    if transform.hasScale():\n        if transform.hasUniformScale():\n            scale = transform.getUniformScale()\n            if scale != 1.0:\n                outputString = '%s.setScale(%s)' % (name, fmtStr)\n                print(outputString % scale)\n        else:\n            scale = transform.getScale()\n            if not scale.almostEqual(Vec3(1)):\n                outputString = '%s.setScale(%s, %s, %s)' % (name, fmtStr, fmtStr, fmtStr)\n                print(outputString % (scale[0], scale[1], scale[2]))\n    if fRecursive:\n        for child in self.getChildren():\n            child.printTransform(other, sd, fRecursive)\n\nDtool_funcToMethod(printTransform, NodePath)\ndel printTransform\n#####################################################################\n\n\ndef iPos(self, other = None):\n    \"\"\" Deprecated.  Set node path's pos to 0, 0, 0 \"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.iPos() is deprecated.\", DeprecationWarning, stacklevel=2)\n    if other:\n        self.setPos(other, 0, 0, 0)\n    else:\n        self.setPos(0, 0, 0)\n\nDtool_funcToMethod(iPos, NodePath)\ndel iPos\n#####################################################################\n\ndef iHpr(self, other = None):\n    \"\"\" Deprecated.  Set node path's hpr to 0, 0, 0 \"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.iHpr() is deprecated.\", DeprecationWarning, stacklevel=2)\n    if other:\n        self.setHpr(other, 0, 0, 0)\n    else:\n        self.setHpr(0, 0, 0)\n\nDtool_funcToMethod(iHpr, NodePath)\ndel iHpr\n#####################################################################\ndef iScale(self, other = None):\n    \"\"\" Deprecated.  Set node path's scale to 1, 1, 1 \"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.iScale() is deprecated.\", DeprecationWarning, stacklevel=2)\n    if other:\n        self.setScale(other, 1, 1, 1)\n    else:\n        self.setScale(1, 1, 1)\n\nDtool_funcToMethod(iScale, NodePath)\ndel iScale\n#####################################################################\ndef iPosHpr(self, other = None):\n    \"\"\" Deprecated.  Set node path's pos and hpr to 0, 0, 0 \"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.iPosHpr() is deprecated.\", DeprecationWarning, stacklevel=2)\n    if other:\n        self.setPosHpr(other, 0, 0, 0, 0, 0, 0)\n    else:\n        self.setPosHpr(0, 0, 0, 0, 0, 0)\n\nDtool_funcToMethod(iPosHpr, NodePath)\ndel iPosHpr\n#####################################################################\ndef iPosHprScale(self, other = None):\n    \"\"\" Deprecated.  Set node path's pos and hpr to 0, 0, 0 and scale to 1, 1, 1 \"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.iPosHprScale() is deprecated.\", DeprecationWarning, stacklevel=2)\n    if other:\n        self.setPosHprScale(other, 0, 0, 0, 0, 0, 0, 1, 1, 1)\n    else:\n        self.setPosHprScale(0, 0, 0, 0, 0, 0, 1, 1, 1)\n\n    # private methods\nDtool_funcToMethod(iPosHprScale, NodePath)\ndel iPosHprScale\n#####################################################################\ndef place(self):\n    from direct.showbase import ShowBaseGlobal\n    ShowBaseGlobal.base.startDirect(fWantTk = 1)\n    # Don't use a regular import, to prevent ModuleFinder from picking\n    # it up as a dependency when building a .p3d package.\n    import importlib\n    Placer = importlib.import_module('direct.tkpanels.Placer')\n    return Placer.place(self)\n\nDtool_funcToMethod(place, NodePath)\ndel place\n#####################################################################\ndef explore(self):\n    from direct.showbase import ShowBaseGlobal\n    ShowBaseGlobal.base.startDirect(fWantTk = 1)\n    # Don't use a regular import, to prevent ModuleFinder from picking\n    # it up as a dependency when building a .p3d package.\n    import importlib\n    SceneGraphExplorer = importlib.import_module('direct.tkwidgets.SceneGraphExplorer')\n    return SceneGraphExplorer.explore(self)\n\nDtool_funcToMethod(explore, NodePath)\ndel explore\n#####################################################################\ndef rgbPanel(self, cb = None):\n    from direct.showbase import ShowBaseGlobal\n    ShowBaseGlobal.base.startTk()\n    # Don't use a regular import, to prevent ModuleFinder from picking\n    # it up as a dependency when building a .p3d package.\n    import importlib\n    Valuator = importlib.import_module('direct.tkwidgets.Valuator')\n    return Valuator.rgbPanel(self, cb)\n\nDtool_funcToMethod(rgbPanel, NodePath)\ndel rgbPanel\n#####################################################################\ndef select(self):\n    from direct.showbase import ShowBaseGlobal\n    base = ShowBaseGlobal.base\n    base.startDirect(fWantTk = 0)\n    base.direct.select(self)\n\nDtool_funcToMethod(select, NodePath)\ndel select\n#####################################################################\ndef deselect(self):\n    from direct.showbase import ShowBaseGlobal\n    base = ShowBaseGlobal.base\n    base.startDirect(fWantTk = 0)\n    base.direct.deselect(self)\n\nDtool_funcToMethod(deselect, NodePath)\ndel deselect\n#####################################################################\ndef showCS(self, mask = None):\n    \"\"\"\n    Deprecated.\n    Shows the collision solids at or below this node.  If mask is\n    not None, it is a BitMask32 object (e.g. WallBitmask,\n    CameraBitmask) that indicates which particular collision\n    solids should be made visible; otherwise, all of them will be.\n    \"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.showCS() is deprecated.  Use findAllMatches('**/+CollisionNode').show() instead.\", DeprecationWarning, stacklevel=2)\n    npc = self.findAllMatches('**/+CollisionNode')\n    for p in range(0, npc.getNumPaths()):\n        np = npc[p]\n        if mask is None or (np.node().getIntoCollideMask() & mask).getWord():\n            np.show()\n\nDtool_funcToMethod(showCS, NodePath)\ndel showCS\n#####################################################################\ndef hideCS(self, mask = None):\n    \"\"\"\n    Deprecated.\n    Hides the collision solids at or below this node.  If mask is\n    not None, it is a BitMask32 object (e.g. WallBitmask,\n    CameraBitmask) that indicates which particular collision\n    solids should be hidden; otherwise, all of them will be.\n    \"\"\"\n    if __debug__:\n        warnings.warn(\"NodePath.hideCS() is deprecated.  Use findAllMatches('**/+CollisionNode').hide() instead.\", DeprecationWarning, stacklevel=2)\n    npc = self.findAllMatches('**/+CollisionNode')\n    for p in range(0, npc.getNumPaths()):\n        np = npc[p]\n        if mask is None or (np.node().getIntoCollideMask() & mask).getWord():\n            np.hide()\n\nDtool_funcToMethod(hideCS, NodePath)\ndel hideCS\n#####################################################################\ndef posInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpPosInterval(self, *args, **kw)\n\nDtool_funcToMethod(posInterval, NodePath)\ndel posInterval\n#####################################################################\ndef hprInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpHprInterval(self, *args, **kw)\n\nDtool_funcToMethod(hprInterval, NodePath)\ndel hprInterval\n#####################################################################\ndef quatInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpQuatInterval(self, *args, **kw)\n\nDtool_funcToMethod(quatInterval, NodePath)\ndel quatInterval\n#####################################################################\ndef scaleInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpScaleInterval(self, *args, **kw)\n\nDtool_funcToMethod(scaleInterval, NodePath)\ndel scaleInterval\n#####################################################################\ndef shearInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpShearInterval(self, *args, **kw)\n\nDtool_funcToMethod(shearInterval, NodePath)\ndel shearInterval\n#####################################################################\ndef posHprInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpPosHprInterval(self, *args, **kw)\n\nDtool_funcToMethod(posHprInterval, NodePath)\ndel posHprInterval\n#####################################################################\ndef posQuatInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpPosQuatInterval(self, *args, **kw)\n\nDtool_funcToMethod(posQuatInterval, NodePath)\ndel posQuatInterval\n#####################################################################\ndef hprScaleInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpHprScaleInterval(self, *args, **kw)\n\nDtool_funcToMethod(hprScaleInterval, NodePath)\ndel hprScaleInterval\n#####################################################################\ndef quatScaleInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpQuatScaleInterval(self, *args, **kw)\n\nDtool_funcToMethod(quatScaleInterval, NodePath)\ndel quatScaleInterval\n#####################################################################\ndef posHprScaleInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpPosHprScaleInterval(self, *args, **kw)\n\nDtool_funcToMethod(posHprScaleInterval, NodePath)\ndel posHprScaleInterval\n#####################################################################\ndef posQuatScaleInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpPosQuatScaleInterval(self, *args, **kw)\n\nDtool_funcToMethod(posQuatScaleInterval, NodePath)\ndel posQuatScaleInterval\n#####################################################################\ndef posHprScaleShearInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpPosHprScaleShearInterval(self, *args, **kw)\n\nDtool_funcToMethod(posHprScaleShearInterval, NodePath)\ndel posHprScaleShearInterval\n#####################################################################\ndef posQuatScaleShearInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpPosQuatScaleShearInterval(self, *args, **kw)\n\nDtool_funcToMethod(posQuatScaleShearInterval, NodePath)\ndel posQuatScaleShearInterval\n#####################################################################\ndef colorInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpColorInterval(self, *args, **kw)\n\nDtool_funcToMethod(colorInterval, NodePath)\ndel colorInterval\n#####################################################################\ndef colorScaleInterval(self, *args, **kw):\n    from direct.interval import LerpInterval\n    return LerpInterval.LerpColorScaleInterval(self, *args, **kw)\n\nDtool_funcToMethod(colorScaleInterval, NodePath)\ndel colorScaleInterval\n#####################################################################\ndef attachCollisionSphere(self, name, cx, cy, cz, r, fromCollide, intoCollide):\n    from panda3d.core import CollisionSphere\n    from panda3d.core import CollisionNode\n    coll = CollisionSphere(cx, cy, cz, r)\n    collNode = CollisionNode(name)\n    collNode.addSolid(coll)\n    collNode.setFromCollideMask(fromCollide)\n    collNode.setIntoCollideMask(intoCollide)\n    collNodePath = self.attachNewNode(collNode)\n    return collNodePath\n\nDtool_funcToMethod(attachCollisionSphere, NodePath)\ndel attachCollisionSphere\n#####################################################################\ndef attachCollisionSegment(self, name, ax, ay, az, bx, by, bz, fromCollide, intoCollide):\n    from panda3d.core import CollisionSegment\n    from panda3d.core import CollisionNode\n    coll = CollisionSegment(ax, ay, az, bx, by, bz)\n    collNode = CollisionNode(name)\n    collNode.addSolid(coll)\n    collNode.setFromCollideMask(fromCollide)\n    collNode.setIntoCollideMask(intoCollide)\n    collNodePath = self.attachNewNode(collNode)\n    return collNodePath\n\nDtool_funcToMethod(attachCollisionSegment, NodePath)\ndel attachCollisionSegment\n#####################################################################\ndef attachCollisionRay(self, name, ox, oy, oz, dx, dy, dz, fromCollide, intoCollide):\n    from panda3d.core import CollisionRay\n    from panda3d.core import CollisionNode\n    coll = CollisionRay(ox, oy, oz, dx, dy, dz)\n    collNode = CollisionNode(name)\n    collNode.addSolid(coll)\n    collNode.setFromCollideMask(fromCollide)\n    collNode.setIntoCollideMask(intoCollide)\n    collNodePath = self.attachNewNode(collNode)\n    return collNodePath\n\nDtool_funcToMethod(attachCollisionRay, NodePath)\ndel attachCollisionRay\n#####################################################################\ndef flattenMultitex(self, stateFrom = None, target = None,\n                        useGeom = 0, allowTexMat = 0, win = None):\n    from panda3d.core import MultitexReducer\n    mr = MultitexReducer()\n    if target is not None:\n        mr.setTarget(target)\n    mr.setUseGeom(useGeom)\n    mr.setAllowTexMat(allowTexMat)\n\n    if win is None:\n        from direct.showbase import ShowBaseGlobal\n        win = ShowBaseGlobal.base.win\n\n    if stateFrom is None:\n        mr.scan(self)\n    else:\n        mr.scan(self, stateFrom)\n    mr.flatten(win)\nDtool_funcToMethod(flattenMultitex, NodePath)\ndel flattenMultitex\n#####################################################################\ndef getNumDescendants(self):\n    return len(self.findAllMatches('**')) - 1\nDtool_funcToMethod(getNumDescendants, NodePath)\ndel getNumDescendants\n#####################################################################\ndef removeNonCollisions(self):\n    # remove anything that is not collision-related\n    print(\"NodePath.removeNonCollisions() is deprecated\")\n    stack = [self]\n    while len(stack) > 0:\n        np = stack.pop()\n        # if there are no CollisionNodes under this node, remove it\n        if np.find('**/+CollisionNode').isEmpty():\n            np.detachNode()\n        else:\n            stack.extend(np.getChildren())\nDtool_funcToMethod(removeNonCollisions, NodePath)\ndel removeNonCollisions\n#####################################################################\n\ndef subdivideCollisions(self, numSolidsInLeaves):\n    \"\"\"\n    expand CollisionNodes out into balanced trees, with a particular number\n    of solids in the leaves\n    TODO: better splitting logic at each level of the tree wrt spatial separation\n    and cost of bounding volume tests vs. cost of collision solid tests\n    \"\"\"\n    colNps = self.findAllMatches('**/+CollisionNode')\n    for colNp in colNps:\n        node = colNp.node()\n        numSolids = node.getNumSolids()\n        if numSolids <= numSolidsInLeaves:\n            # this CollisionNode doesn't need to be split\n            continue\n        solids = []\n        for i in range(numSolids):\n            solids.append(node.getSolid(i))\n        # recursively subdivide the solids into a spatial binary tree\n        solidTree = self.r_subdivideCollisions(solids, numSolidsInLeaves)\n        root = colNp.getParent().attachNewNode('%s-subDivRoot' % colNp.getName())\n        self.r_constructCollisionTree(solidTree, root, colNp.getName())\n        colNp.stash()\n\ndef r_subdivideCollisions(self, solids, numSolidsInLeaves):\n    # takes a list of solids, returns a list containing some number of lists,\n    # with the solids evenly distributed between them (recursively nested until\n    # the lists at the leaves contain no more than numSolidsInLeaves)\n    # if solids is already small enough, returns solids unchanged\n    if len(solids) <= numSolidsInLeaves:\n        return solids\n    origins = []\n    avgX = 0\n    avgY = 0\n    avgZ = 0\n    minX = None\n    minY = None\n    minZ = None\n    maxX = None\n    maxY = None\n    maxZ = None\n    for solid in solids:\n        origin = solid.getCollisionOrigin()\n        origins.append(origin)\n        x = origin.getX()\n        y = origin.getY()\n        z = origin.getZ()\n        avgX += x\n        avgY += y\n        avgZ += z\n        if minX is None:\n            minX = x\n            minY = y\n            minZ = z\n            maxX = x\n            maxY = y\n            maxZ = z\n        else:\n            minX = min(x, minX)\n            minY = min(y, minY)\n            minZ = min(z, minZ)\n            maxX = max(x, maxX)\n            maxY = max(y, maxY)\n            maxZ = max(z, maxZ)\n    avgX /= len(solids)\n    avgY /= len(solids)\n    avgZ /= len(solids)\n    extentX = maxX - minX\n    extentY = maxY - minY\n    extentZ = maxZ - minZ\n    maxExtent = max(extentX, extentY, extentZ)\n    # sparse octree\n    xyzSolids = []\n    XyzSolids = []\n    xYzSolids = []\n    XYzSolids = []\n    xyZSolids = []\n    XyZSolids = []\n    xYZSolids = []\n    XYZSolids = []\n    midX = avgX\n    midY = avgY\n    midZ = avgZ\n    # throw out axes that are not close to the max axis extent; try and keep\n    # the divisions square/spherical\n    if extentX < (maxExtent * .75) or extentX > (maxExtent * 1.25):\n        midX += maxExtent\n    if extentY < (maxExtent * .75) or extentY > (maxExtent * 1.25):\n        midY += maxExtent\n    if extentZ < (maxExtent * .75) or extentZ > (maxExtent * 1.25):\n        midZ += maxExtent\n    for i, solid in enumerate(solids):\n        origin = origins[i]\n        x = origin.getX()\n        y = origin.getY()\n        z = origin.getZ()\n        if x < midX:\n            if y < midY:\n                if z < midZ:\n                    xyzSolids.append(solids[i])\n                else:\n                    xyZSolids.append(solids[i])\n            else:\n                if z < midZ:\n                    xYzSolids.append(solids[i])\n                else:\n                    xYZSolids.append(solids[i])\n        else:\n            if y < midY:\n                if z < midZ:\n                    XyzSolids.append(solids[i])\n                else:\n                    XyZSolids.append(solids[i])\n            else:\n                if z < midZ:\n                    XYzSolids.append(solids[i])\n                else:\n                    XYZSolids.append(solids[i])\n    newSolids = []\n    if len(xyzSolids) > 0:\n        newSolids.append(self.r_subdivideCollisions(xyzSolids, numSolidsInLeaves))\n    if len(XyzSolids) > 0:\n        newSolids.append(self.r_subdivideCollisions(XyzSolids, numSolidsInLeaves))\n    if len(xYzSolids) > 0:\n        newSolids.append(self.r_subdivideCollisions(xYzSolids, numSolidsInLeaves))\n    if len(XYzSolids) > 0:\n        newSolids.append(self.r_subdivideCollisions(XYzSolids, numSolidsInLeaves))\n    if len(xyZSolids) > 0:\n        newSolids.append(self.r_subdivideCollisions(xyZSolids, numSolidsInLeaves))\n    if len(XyZSolids) > 0:\n        newSolids.append(self.r_subdivideCollisions(XyZSolids, numSolidsInLeaves))\n    if len(xYZSolids) > 0:\n        newSolids.append(self.r_subdivideCollisions(xYZSolids, numSolidsInLeaves))\n    if len(XYZSolids) > 0:\n        newSolids.append(self.r_subdivideCollisions(XYZSolids, numSolidsInLeaves))\n    #import pdb;pdb.set_trace()\n    return newSolids\n\ndef r_constructCollisionTree(self, solidTree, parentNode, colName):\n    from panda3d.core import CollisionNode\n    for item in solidTree:\n        if isinstance(item[0], list):\n            newNode = parentNode.attachNewNode(f'{colName}-branch')\n            self.r_constructCollisionTree(item, newNode, colName)\n        else:\n            cn = CollisionNode(f'{colName}-leaf')\n            for solid in item:\n                cn.addSolid(solid)\n            parentNode.attachNewNode(cn)\n\nDtool_funcToMethod(subdivideCollisions, NodePath)\nDtool_funcToMethod(r_subdivideCollisions, NodePath)\nDtool_funcToMethod(r_constructCollisionTree, NodePath)\ndel subdivideCollisions\ndel r_subdivideCollisions\ndel r_constructCollisionTree\n\n#####################################################################\ndef analyze(self):\n    \"\"\"\n    Analyzes the geometry below this node and reports the\n    number of vertices, triangles, etc.  This is the same\n    information reported by the bam-info program.\n    \"\"\"\n    from panda3d.core import SceneGraphAnalyzer\n    sga = SceneGraphAnalyzer()\n    sga.addNode(self.node())\n    if sga.getNumLodNodes() == 0:\n        print(sga)\n    else:\n        print(\"At highest LOD:\")\n        sga2 = SceneGraphAnalyzer()\n        sga2.setLodMode(sga2.LMHighest)\n        sga2.addNode(self.node())\n        print(sga2)\n\n        print(\"\\nAt lowest LOD:\")\n        sga2.clear()\n        sga2.setLodMode(sga2.LMLowest)\n        sga2.addNode(self.node())\n        print(sga2)\n\n        print(\"\\nAll nodes:\")\n        print(sga)\n\nDtool_funcToMethod(analyze, NodePath)\ndel analyze\n#####################################################################\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/extensions_native/NodePath_extensions.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/14919c38_NodePath_extensions.json",
    "doc_id": "doc_341"
  }
}