{
  "content": "\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.distributed.PyDatagram import PyDatagram\nfrom direct.showbase.Messenger import Messenger\nfrom pickle import dumps, loads\n\n\n# Messages do not need to be in the MESSAGE_TYPES list.\n# This is just an optimization.  If the message is found\n# in this list, it is reduced to an integer index and\n# the message string is not sent.  Otherwise, the message\n# string is sent in the datagram.\nMESSAGE_TYPES=(\n    \"avatarOnline\",\n    \"avatarOffline\",\n    \"create\",\n    \"needUberdogCreates\",\n    \"transferDo\",\n)\n\n# This is the reverse look up for the recipient of the\n# datagram:\nMESSAGE_STRINGS = {}\nfor i in zip(MESSAGE_TYPES, range(1, len(MESSAGE_TYPES) + 1)):\n    MESSAGE_STRINGS[i[0]] = i[1]\n\n\nclass NetMessenger(Messenger):\n    \"\"\"\n    This works very much like the Messenger class except that messages\n    are sent over the network and (possibly) handled (accepted) on a\n    remote machine (server).\n    \"\"\"\n    notify = DirectNotifyGlobal.directNotify.newCategory('NetMessenger')\n\n    def __init__(self, air, channels):\n        \"\"\"\n        air is the AI Repository.\n        channels is a list of channel IDs (uint32 values)\n        \"\"\"\n        assert self.notify.debugCall()\n        Messenger.__init__(self)\n        self.air=air\n        self.channels=channels\n        for i in self.channels:\n            self.air.registerForChannel(i)\n\n    def clear(self):\n        assert self.notify.debugCall()\n        for i in self.channels:\n            self.air.unRegisterChannel(i)\n        del self.air\n        del self.channels\n        Messenger.clear(self)\n\n    def send(self, message, sentArgs=[]):\n        \"\"\"\n        Send message to All AI and Uber Dog servers.\n        \"\"\"\n        assert self.notify.debugCall()\n        datagram = PyDatagram()\n        # To:\n        datagram.addUint8(1)\n        datagram.addChannel(self.channels[0])\n        # From:\n        datagram.addChannel(self.air.ourChannel)\n        #if 1: # We send this just because the air expects it:\n        #    # Add an 'A' for AI\n        #    datagram.addUint8(ord('A'))\n\n        messageType=MESSAGE_STRINGS.get(message, 0)\n        datagram.addUint16(messageType)\n        if messageType:\n            datagram.addString(str(dumps(sentArgs)))\n        else:\n            datagram.addString(str(dumps((message, sentArgs))))\n        self.air.send(datagram)\n\n    def handle(self, pickleData):\n        \"\"\"\n        Send pickleData from the net on the local netMessenger.\n        The internal data in pickleData should have a tuple of\n        (messageString, sendArgsList).\n        \"\"\"\n        assert self.notify.debugCall()\n        messageType=self.air.getMsgType()\n        if messageType:\n            message=MESSAGE_TYPES[messageType-1]\n            sentArgs=loads(pickleData)\n        else:\n            (message, sentArgs) = loads(pickleData)\n        Messenger.send(self, message, sentArgs=sentArgs)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/NetMessenger.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/9d0f4180_NetMessenger.json",
    "doc_id": "doc_313"
  }
}