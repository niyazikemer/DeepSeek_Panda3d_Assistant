{
  "content": "\"\"\"Contains the DirectScrolledList class.\n\nSee the :ref:`directscrolledlist` page in the programming manual for a more\nin-depth explanation and an example of how to use this class.\n\"\"\"\n\n__all__ = ['DirectScrolledListItem', 'DirectScrolledList']\n\nfrom panda3d.core import TextNode\nfrom direct.showbase import ShowBaseGlobal\nfrom direct.showbase.MessengerGlobal import messenger\nfrom . import DirectGuiGlobals as DGG\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.task.Task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom .DirectFrame import DirectFrame\nfrom .DirectButton import DirectButton\n\n\nclass DirectScrolledListItem(DirectButton):\n    \"\"\"\n    While you are not required to use a DirectScrolledListItem for a\n    DirectScrolledList, doing so takes care of the highlighting and\n    unhighlighting of the list items.\n    \"\"\"\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"DirectScrolledListItem\")\n\n    def __init__(self, parent=None, **kw):\n        assert self.notify.debugStateCall(self)\n        self._parent = parent\n        if \"command\" in kw:\n            self.nextCommand = kw.get(\"command\")\n            del kw[\"command\"]\n        if \"extraArgs\" in kw:\n            self.nextCommandExtraArgs = kw.get(\"extraArgs\")\n            del kw[\"extraArgs\"]\n        optiondefs = (\n            ('parent', self._parent,    None),\n            ('command', self.select, None),\n        )\n        # Merge keyword options with default options\n        self.defineoptions(kw, optiondefs)\n        DirectButton.__init__(self)\n        self.initialiseoptions(DirectScrolledListItem)\n\n    def select(self):\n        assert self.notify.debugStateCall(self)\n        self.nextCommand(*self.nextCommandExtraArgs)\n        self._parent.selectListItem(self)\n\n\nclass DirectScrolledList(DirectFrame):\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"DirectScrolledList\")\n\n    def __init__(self, parent = None, **kw):\n        assert self.notify.debugStateCall(self)\n        self.index = 0\n        self.__forceHeight = None\n\n        \"\"\" If one were to want a scrolledList that makes and adds its items\n           as needed, simply pass in an items list of strings (type 'str')\n           and when that item is needed, itemMakeFunction will be called\n           with the text, the index, and itemMakeExtraArgs.  If itemMakeFunction\n           is not specified, it will create a DirectFrame with the text.\"\"\"\n\n        # if 'items' is a list of strings, make a copy for our use\n        # so we can modify it without mangling the user's list\n        if 'items' in kw:\n            for item in kw['items']:\n                if not isinstance(item, str):\n                    break\n            else:\n                # we get here if every item in 'items' is a string\n                # make a copy\n                kw['items'] = kw['items'][:]\n\n        self.nextItemID = 10\n\n        # Inherits from DirectFrame\n        optiondefs = (\n            # Define type of DirectGuiWidget\n            ('items',              [],        None),\n            ('itemsAlign',  TextNode.ACenter, DGG.INITOPT),\n            ('itemsWordwrap',      None,      DGG.INITOPT),\n            ('command',            None,      None),\n            ('extraArgs',          [],        None),\n            ('itemMakeFunction',   None,      None),\n            ('itemMakeExtraArgs',  [],        None),\n            ('numItemsVisible',    1,         self.setNumItemsVisible),\n            ('scrollSpeed',        8,         self.setScrollSpeed),\n            ('forceHeight',        None,      self.setForceHeight),\n            ('incButtonCallback',  None,      self.setIncButtonCallback),\n            ('decButtonCallback',  None,      self.setDecButtonCallback),\n        )\n        # Merge keyword options with default options\n        self.defineoptions(kw, optiondefs)\n\n        # Initialize superclasses\n        DirectFrame.__init__(self, parent)\n\n        self.incButton = self.createcomponent(\"incButton\", (), None,\n                                              DirectButton, (self,),\n                                              )\n        self.incButton.bind(DGG.B1PRESS, self.__incButtonDown)\n        self.incButton.bind(DGG.B1RELEASE, self.__buttonUp)\n        self.decButton = self.createcomponent(\"decButton\", (), None,\n                                              DirectButton, (self,),\n                                              )\n        self.decButton.bind(DGG.B1PRESS, self.__decButtonDown)\n        self.decButton.bind(DGG.B1RELEASE, self.__buttonUp)\n        self.itemFrame = self.createcomponent(\"itemFrame\", (), None,\n                                              DirectFrame, (self,),\n                                              )\n        for item in self[\"items\"]:\n            if not isinstance(item, str):\n                item.reparentTo(self.itemFrame)\n\n        self.initialiseoptions(DirectScrolledList)\n        self.recordMaxHeight()\n        self.scrollTo(0)\n\n    def setForceHeight(self):\n        assert self.notify.debugStateCall(self)\n        self.__forceHeight = self[\"forceHeight\"]\n\n    def recordMaxHeight(self):\n        assert self.notify.debugStateCall(self)\n        if self.__forceHeight is not None:\n            self.maxHeight = self.__forceHeight\n        else:\n            self.maxHeight = 0.0\n            for item in self[\"items\"]:\n                if not isinstance(item, str):\n                    self.maxHeight = max(self.maxHeight, item.getHeight())\n\n    def setScrollSpeed(self):\n        assert self.notify.debugStateCall(self)\n        # Items per second to move\n        self.__scrollSpeed = self[\"scrollSpeed\"]\n        if self.__scrollSpeed <= 0:\n            self.__scrollSpeed = 1\n\n    def setNumItemsVisible(self):\n        assert self.notify.debugStateCall(self)\n        # Items per second to move\n        self.__numItemsVisible = self[\"numItemsVisible\"]\n\n    def destroy(self):\n        assert self.notify.debugStateCall(self)\n        taskMgr.remove(self.taskName(\"scroll\"))\n        if hasattr(self, \"currentSelected\"):\n            del self.currentSelected\n        if self.__incButtonCallback:\n            self.__incButtonCallback = None\n        if self.__decButtonCallback:\n            self.__decButtonCallback = None\n        self.incButton.destroy()\n        self.decButton.destroy()\n        DirectFrame.destroy(self)\n\n    def selectListItem(self, item):\n        assert self.notify.debugStateCall(self)\n        if hasattr(self, \"currentSelected\"):\n            self.currentSelected['state'] = DGG.NORMAL\n        item['state'] = DGG.DISABLED\n        self.currentSelected = item\n\n    def scrollBy(self, delta):\n        assert self.notify.debugStateCall(self)\n        #print \"scrollBy[\", delta,\"]\"\n        return self.scrollTo(self.index + delta)\n\n    def getItemIndexForItemID(self, itemID):\n        assert self.notify.debugStateCall(self)\n        #for i in range(len(self[\"items\"])):\n        #    print \"buttontext[\", i,\"]\", self[\"items\"][i][\"text\"]\n\n        if len(self[\"items\"]) == 0:\n            return 0\n\n        if isinstance(self[\"items\"][0], str):\n            self.notify.warning(\"getItemIndexForItemID: cant find itemID for non-class list items!\")\n            return 0\n\n        for i in range(len(self[\"items\"])):\n            if self[\"items\"][i].itemID == itemID:\n                return i\n        self.notify.warning(\"getItemIndexForItemID: item not found!\")\n        return 0\n\n    def scrollToItemID(self, itemID, centered=0):\n        assert self.notify.debugStateCall(self)\n        self.scrollTo(self.getItemIndexForItemID(itemID), centered)\n\n    def scrollTo(self, index, centered=0):\n        \"\"\" scrolls list so selected index is at top, or centered in box\"\"\"\n        assert self.notify.debugStateCall(self)\n        #print \"scrollTo[\", index,\"] called, len(self[items])=\", len(self[\"items\"]),\" self[numItemsVisible]=\", self[\"numItemsVisible\"]\n        try:\n            self[\"numItemsVisible\"]\n        except Exception:\n            # RAU hack to kill 27633\n            self.notify.info('crash 27633 fixed!')\n            return\n\n        numItemsVisible = self[\"numItemsVisible\"]\n        numItemsTotal = len(self[\"items\"])\n        if centered:\n            self.index = index - (numItemsVisible // 2)\n        else:\n            self.index = index\n\n        # Not enough items to even worry about scrolling,\n        # just disable the buttons and do nothing\n        if len(self[\"items\"]) <= numItemsVisible:\n            self.incButton['state'] = DGG.DISABLED\n            self.decButton['state'] = DGG.DISABLED\n            # Hmm.. just reset self.index to 0 and bail out\n            self.index = 0\n            ret = 0\n        else:\n            if self.index <= 0:\n                self.index = 0\n                #print \"at list start, \", len(self[\"items\"]),\"  \", self[\"numItemsVisible\"]\n                self.decButton['state'] = DGG.DISABLED\n                self.incButton['state'] = DGG.NORMAL\n                ret = 0\n            elif self.index >= (numItemsTotal - numItemsVisible):\n                self.index = numItemsTotal - numItemsVisible\n                #print \"at list end, \", len(self[\"items\"]),\"  \", self[\"numItemsVisible\"]\n                self.incButton['state'] = DGG.DISABLED\n                self.decButton['state'] = DGG.NORMAL\n                ret = 0\n            else:\n                # deal with an edge condition - make sure any tasks are removed from the disabled arrows.\n                if self.incButton['state'] == DGG.DISABLED or self.decButton['state'] == DGG.DISABLED:\n                    #print \"leaving list start/end, \", len(self[\"items\"]),\"  \", self[\"numItemsVisible\"]\n                    self.__buttonUp(0)\n                self.incButton['state'] = DGG.NORMAL\n                self.decButton['state'] = DGG.NORMAL\n                ret = 1\n\n        #print \"self.index set to \", self.index\n\n        # Hide them all\n        for item in self[\"items\"]:\n            if not isinstance(item, str):\n                item.hide()\n\n        # Then show the ones in range, and stack their positions\n        upperRange = min(numItemsTotal, numItemsVisible)\n        for i in range(self.index, self.index + upperRange):\n            item = self[\"items\"][i]\n            #print \"stacking buttontext[\", i,\"]\", self[\"items\"][i][\"text\"]\n            # If the item is a 'str', then it has not been created (scrolled list is 'as needed')\n            #  Therefore, use the the function given to make it or just make it a frame\n            if isinstance(item, str):\n                if self['itemMakeFunction']:\n                    # If there is a function to create the item\n                    item = self['itemMakeFunction'](item, i, self['itemMakeExtraArgs'])\n                else:\n                    item = DirectFrame(text = item,\n                                       text_align = self['itemsAlign'],\n                                       text_wordwrap = self['itemsWordwrap'],\n                                       relief = None)\n                #print \"str stacking buttontext[\", i,\"]\", self[\"items\"][i][\"text\"]\n                # Then add the newly formed item back into the normal item list\n                self[\"items\"][i] = item\n                item.reparentTo(self.itemFrame)\n                self.recordMaxHeight()\n\n            item.show()\n            item.setPos(0, 0,  -(i-self.index) * self.maxHeight)\n            #print 'height bug tracker: i-%s idx-%s h-%s' % (i, self.index, self.maxHeight)\n\n        if self['command']:\n            # Pass any extra args to command\n            self['command'](*self['extraArgs'])\n        return ret\n\n    def makeAllItems(self):\n        assert self.notify.debugStateCall(self)\n        for i in range(len(self['items'])):\n            item = self[\"items\"][i]\n            # If the item is a 'str', then it has not been created\n            # Therefore, use the the function given to make it or\n            # just make it a frame\n            #print \"Making \" + str(item)\n            if isinstance(item, str):\n                if self['itemMakeFunction']:\n                    # If there is a function to create the item\n                    item = self['itemMakeFunction'](item, i, self['itemMakeExtraArgs'])\n                else:\n                    item = DirectFrame(text = item,\n                                       text_align = self['itemsAlign'],\n                                       text_wordwrap = self['itemsWordwrap'],\n                                       relief = None)\n                # Then add the newly formed item back into the normal item list\n                self[\"items\"][i] = item\n                item.reparentTo(self.itemFrame)\n        self.recordMaxHeight()\n\n    def __scrollByTask(self, task):\n        assert self.notify.debugStateCall(self)\n        if (task.time - task.prevTime) < task.delayTime:\n            return Task.cont\n        else:\n            ret = self.scrollBy(task.delta)\n            task.prevTime = task.time\n            if ret:\n                return Task.cont\n            else:\n                return Task.done\n\n    def __incButtonDown(self, event):\n        assert self.notify.debugStateCall(self)\n        task = Task(self.__scrollByTask)\n        task.setDelay(1.0 / self.__scrollSpeed)\n        task.prevTime = 0.0\n        task.delta = 1\n        taskName = self.taskName(\"scroll\")\n        #print \"incButtonDown: adding \", taskName\n        taskMgr.add(task, taskName)\n        self.scrollBy(task.delta)\n        messenger.send('wakeup')\n        if self.__incButtonCallback:\n            self.__incButtonCallback()\n\n    def __decButtonDown(self, event):\n        assert self.notify.debugStateCall(self)\n        task = Task(self.__scrollByTask)\n        task.setDelay(1.0 / self.__scrollSpeed)\n        task.prevTime = 0.0\n        task.delta = -1\n        taskName = self.taskName(\"scroll\")\n        #print \"decButtonDown: adding \", taskName\n        taskMgr.add(task, taskName)\n        self.scrollBy(task.delta)\n        messenger.send('wakeup')\n        if self.__decButtonCallback:\n            self.__decButtonCallback()\n\n    def __buttonUp(self, event):\n        assert self.notify.debugStateCall(self)\n        taskName = self.taskName(\"scroll\")\n        #print \"buttonUp: removing \", taskName\n        taskMgr.remove(taskName)\n\n    def addItem(self, item, refresh=1):\n        \"\"\"\n        Add this string and extraArg to the list\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        if not isinstance(item, str):\n            # cant add attribs to non-classes (like strings & ints)\n            item.itemID = self.nextItemID\n            self.nextItemID += 1\n        self['items'].append(item)\n        if not isinstance(item, str):\n            item.reparentTo(self.itemFrame)\n        if refresh:\n            self.refresh()\n        if not isinstance(item, str):\n            return item.itemID  # to pass to scrollToItemID\n\n    def removeItem(self, item, refresh=1):\n        \"\"\"\n        Remove this item from the panel\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        #print \"remove item called\", item\n        #print \"items list\", self['items']\n        if item in self[\"items\"]:\n            #print \"removing item\", item\n            if hasattr(self, \"currentSelected\") and self.currentSelected is item:\n                del self.currentSelected\n            self[\"items\"].remove(item)\n            if not isinstance(item, str):\n                item.reparentTo(ShowBaseGlobal.hidden)\n            self.refresh()\n            return 1\n        else:\n            return 0\n\n    def removeAndDestroyItem(self, item, refresh = 1):\n        \"\"\"\n        Remove and destroy this item from the panel.\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        if item in self[\"items\"]:\n            if hasattr(self, \"currentSelected\") and self.currentSelected is item:\n                del self.currentSelected\n            if hasattr(item, 'destroy') and hasattr(item.destroy, '__call__'):\n                item.destroy()\n            self[\"items\"].remove(item)\n            if not isinstance(item, str):\n                item.reparentTo(ShowBaseGlobal.hidden)\n            self.refresh()\n            return 1\n        else:\n            return 0\n\n    def removeAllItems(self, refresh=1):\n        \"\"\"\n        Remove this item from the panel\n        Warning 2006_10_19 tested only in the trolley metagame\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        retval = 0\n        #print \"remove item called\", item\n        #print \"items list\", self['items']\n        while len(self[\"items\"]) > 0:\n            item = self['items'][0]\n            #print \"removing item\", item\n            if hasattr(self, \"currentSelected\") and self.currentSelected is item:\n                del self.currentSelected\n            self[\"items\"].remove(item)\n            if not isinstance(item, str):\n                #RAU possible leak here, let's try to do the right thing\n                #item.reparentTo(ShowBaseGlobal.hidden)\n                item.removeNode()\n            retval = 1\n\n        if refresh:\n            self.refresh()\n\n        return retval\n\n    def removeAndDestroyAllItems(self, refresh = 1):\n        \"\"\"\n        Remove and destroy all items from the panel.\n        Warning 2006_10_19 tested only in the trolley metagame\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        retval = 0\n        while len(self[\"items\"]) > 0:\n            item = self['items'][0]\n            if hasattr(self, \"currentSelected\") and self.currentSelected is item:\n                del self.currentSelected\n            if hasattr(item, 'destroy') and hasattr(item.destroy, '__call__'):\n                item.destroy()\n            self[\"items\"].remove(item)\n            if not isinstance(item, str):\n                #RAU possible leak here, let's try to do the right thing\n                #item.reparentTo(ShowBaseGlobal.hidden)\n                item.removeNode()\n            retval = 1\n        if refresh:\n            self.refresh()\n        return retval\n\n    def refresh(self):\n        \"\"\"\n        Update the list - useful when adding or deleting items\n        or changing properties that would affect the scrolling\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        self.recordMaxHeight()\n        #print \"refresh called\"\n        self.scrollTo(self.index)\n\n    def getSelectedIndex(self):\n        assert self.notify.debugStateCall(self)\n        return self.index\n\n    def getSelectedText(self):\n        assert self.notify.debugStateCall(self)\n        if isinstance(self['items'][self.index], str):\n            return self['items'][self.index]\n        else:\n            return self['items'][self.index]['text']\n\n    def setIncButtonCallback(self):\n        assert self.notify.debugStateCall(self)\n        self.__incButtonCallback = self[\"incButtonCallback\"]\n\n    def setDecButtonCallback(self):\n        assert self.notify.debugStateCall(self)\n        self.__decButtonCallback = self[\"decButtonCallback\"]\n\n\n#from DirectGui import *\n#\n#def makeButton(itemName, itemNum, *extraArgs):\n#    def buttonCommand():\n#        print itemName, itemNum\n#    return DirectButton(text = itemName,\n#                        relief = DGG.RAISED,\n#                        frameSize = (-3.5, 3.5, -0.2, 0.8),\n#                        scale = 0.85,\n#                        command = buttonCommand)\n#\n#s = scrollList = DirectScrolledList(\n#    parent = aspect2d,\n#    relief = None,\n#    # Use the default dialog box image as the background\n#    image = DGG.getDefaultDialogGeom(),\n#    # Scale it to fit around everyting\n#    image_scale = (0.7, 1, .8),\n#    # Give it a label\n#    text = \"Scrolled List Example\",\n#    text_scale = 0.06,\n#    text_align = TextNode.ACenter,\n#    text_pos = (0, 0.3),\n#    text_fg = (0, 0, 0, 1),\n#    # inc and dec are DirectButtons\n#    # They can contain a combination of text, geometry and images\n#    # Just a simple text one for now\n#    incButton_text = 'Increment',\n#    incButton_relief = DGG.RAISED,\n#    incButton_pos = (0.0, 0.0, -0.36),\n#    incButton_scale = 0.1,\n#    # Same for the decrement button\n#    decButton_text = 'Decrement',\n#    decButton_relief = DGG.RAISED,\n#    decButton_pos = (0.0, 0.0, 0.175),\n#    decButton_scale = 0.1,\n#    # each item is a button with text on it\n#    numItemsVisible = 4,\n#    itemMakeFunction = makeButton,\n#    items = ['Able', 'Baker', 'Charlie', 'Delta', 'Echo', 'Foxtrot',\n#             'Golf', 'Hotel', 'India', 'Juliet', 'Kilo', 'Lima'],\n#    # itemFrame is a DirectFrame\n#    # Use it to scale up or down the items and to place it relative\n#    # to eveything else\n#    itemFrame_pos = (0, 0, 0.06),\n#    itemFrame_scale = 0.1,\n#    itemFrame_frameSize = (-3.1, 3.1, -3.3, 0.8),\n#    itemFrame_relief = DGG.GROOVE,\n#    )\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/gui/DirectScrolledList.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/803d185d_DirectScrolledList.json",
    "doc_id": "doc_93"
  }
}