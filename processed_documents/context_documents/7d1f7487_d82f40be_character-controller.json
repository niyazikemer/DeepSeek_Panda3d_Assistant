{
  "content": "Bullet Character Controller\n\nBullet comes with a simple character controller already included. A character controller is a class intended to provide a simple way of controlling a player (or NPC) object the way we are used to from many first-person-shooters or role-playing-games. Achieving satisfying results for character movement is usually a difficult thing when using \"physicals\", e. g. rigid bodies. The solution is to use so-called \"kinematic\" objects, that is objects which don't respond to forces, and instead get moved by pushing/turning them around by hand.\n\nNotice: The module panda3d.bullet doesn't implement it's own character controller. It simple exposes the character controller which comes with the Bullet physics engine. This character controller is still in an early stage, and it lacks a few features. In particular, Bullet does not implement a proper interaction between dynamic bodies and the character controller.\n\nSetup\n\nThe following code will first create a shape with total height of 1.75 units and total width of 0.8 units. We have to subtract twice the radius from the total height in order to get the length of the cylindrical part of the capsule shape.\n\npython\n\nfrom panda3d.bullet import BulletCharacterControllerNode\nfrom panda3d.bullet import BulletCapsuleShape\nfrom panda3d.bullet import ZUp\n\nheight = 1.75\nradius = 0.4\nshape = BulletCapsuleShape(radius, height - 2*radius, ZUp)\n\nplayerNode = BulletCharacterControllerNode(shape, 0.4, 'Player')\nplayerNP = self.worldNP.attachNewNode(playerNode)\nplayerNP.setPos(-2, 0, 14)\nplayerNP.setH(45)\nplayerNP.setCollideMask(BitMask32.allOn())\n\nworld.attachCharacter(playerNP.node())\n\ncpp\n\nfloat height = 1.75;\nfloat radius = 0.4;\n\nPT(BulletCapsuleShape) c_shape = new BulletCapsuleShape(radius, height -2 * radius);\nPT(BulletCharacterControllerNode) controller;\ncontroller = new BulletCharacterControllerNode(c_shape, 0.4f, name.c_str());\nphysicsWorld->attach_character(controller);\n\nNodePath cha_np = window->get_render().attach_new_node(controller);\ncha_np.set_pos(-2, 0, 14);\ncha_np.set_h(45);\ncha_np.set_collide_mask(mask1);\n\nMoving\n\nNow that we have a character controller within our scene we need to control it's movement. The following code snippet shows one way of moving the character controller by keyboard input. Of course a character controller representing a NPC (non-player character) would not read the keyboard state but have the linear velocity (speed) and the angular velocity (omega) computed by some kind of AI algorithm.\n\npython\n\ndef processInput(self):\n    speed = Vec3(0, 0, 0)\n    omega = 0.0\n\n    if inputState.isSet('forward'): speed.setY( 3.0)\n    if inputState.isSet('reverse'): speed.setY(-3.0)\n    if inputState.isSet('left'):    speed.setX(-3.0)\n    if inputState.isSet('right'):   speed.setX( 3.0)\n    if inputState.isSet('turnLeft'):  omega =  120.0\n    if inputState.isSet('turnRight'): omega = -120.0\n\n    self.player.setAngularMovement(omega)\n    self.player.setLinearMovement(speed, True)\n\ncpp\n\nvoid characterMove (std::vector<bool> *KeyMap) {\n        LVecBase3 speed = LVecBase3(0, 0, 0);\n        float omega = 0.0;\n\n        if (KeyMap->at(MOVE_FORWARD)) { speed.set_y (3.0); }\n        if (KeyMap->at(MOVE_REVERSE)) { speed.set_y (-3.0); }\n        if (KeyMap->at(MOVE_LEFT)) { speed.set_x (-3.0); }\n        if (KeyMap->at(MOVE_RIGHT)) { speed.set_x (3.0); }\n        if (keyMap->at(TURN_LEFT)) { omege = 120.0; }\n        if (keyMap->at(TURN_RIGHT)) { omega = -120.0 }\n\n        controller->set_linear_movement(speed, true);\n        controller->set_angular_movement(omega);\n}\n\nJumping\n\nNext we want to make the character controller jump. The following code snippet shows a sample method which will make the character jump. We could for example call this method when the player presses a specific key.\n\nAfter setting the maximum jump height and the initial upward speed we need to trigger the jump using the ~panda3d.bullet.BulletCharacterControllerNode.do_jump() method.\n\npython\n\ndef doJump(self):\n    self.player.setMaxJumpHeight(5.0)\n    self.player.setJumpSpeed(8.0)\n    self.player.doJump()\n\ncpp\n\nvoid do_jump(void ) {\n    controller->set_max_jump_height(5.0)\n    controller->set_jump_speed(8.0)\n    controller->do_jump()\n}\n\nIt is possible to check whether the character controller is airborne using the ~panda3d.bullet.BulletCharacterControllerNode.is_on_ground() method.\n\nCrouching\n\nFinally we want the character to crouch or duck. To achieve this we simply change the scale of the character's collision shape. Here in this example we reduce the vertical dimension to 60 percent (0.6) when crouching, while the normal vertical scale is 1.0. We don't change the horizontal scales. In a more realistic example, one would have the player enter a crouching animation.\n\nSince we have the visual node of the player reparented to the character controller node it will automatically change its scale to match the player.\n\npython\n\nself.crouching = False\n\ndef doCrouch(self):\n    self.crouching = not self.crouching\n    sz = self.crouching and 0.6 or 1.0\n\n    self.player.getShape().setLocalScale(Vec3(1, 1, sz))\n\n    self.playerNP.setScale(Vec3(1, 1, sz) * 0.3048)\n    self.playerNP.setPos(0, 0, -1 * sz)",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/d82f40be_character-controller.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/7d1f7487_d82f40be_character-controller.json",
    "doc_id": "doc_554"
  }
}