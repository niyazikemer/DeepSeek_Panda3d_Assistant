{
  "content": "from direct.distributed import DoHierarchy\nimport re\n\n#hack:\nBAD_DO_ID = BAD_ZONE_ID = 0 # 0xFFFFFFFF\nBAD_CHANNEL_ID = 0 # 0xFFFFFFFFFFFFFFFF\n\n\nclass DoCollectionManager:\n    def __init__(self):\n        # Dict of {DistributedObject ids: DistributedObjects}\n        self.doId2do = {}\n        # (parentId, zoneId) to dict of doId->DistributedObjectAI\n        ## self.zoneId2doIds={}\n        if self.hasOwnerView():\n            # Dict of {DistributedObject ids: DistributedObjects}\n            # for 'owner' views of objects\n            self.doId2ownerView = {}\n        # Dict of {\n        #   parent DistributedObject id:\n        #     { zoneIds: [child DistributedObject ids] }}\n        self._doHierarchy = DoHierarchy.DoHierarchy()\n\n    def getDo(self, doId):\n        return self.doId2do.get(doId)\n\n    def getGameDoId(self):\n        return self.GameGlobalsId\n\n    def callbackWithDo(self, doId, callback):\n        do = self.doId2do.get(doId)\n        if do is not None:\n            callback(do)\n        else:\n            relatedObjectMgr(doId, allCallback=callback)\n\n    def getOwnerView(self, doId):\n        assert self.hasOwnerView()\n        return self.doId2ownerView.get(doId)\n\n    def callbackWithOwnerView(self, doId, callback):\n        assert self.hasOwnerView()\n        do = self.doId2ownerView.get(doId)\n        if do is not None:\n            callback(do)\n        else:\n            pass #relatedObjectMgr(doId, allCallback=callback)\n\n    def getDoTable(self, ownerView):\n        if ownerView:\n            assert self.hasOwnerView()\n            return self.doId2ownerView\n        else:\n            return self.doId2do\n\n    def doFind(self, str):\n        \"\"\"\n        Returns list of distributed objects with matching str in value.\n        \"\"\"\n        for value in self.doId2do.values():\n            if repr(value).find(str) >= 0:\n                return value\n\n    def doFindAll(self, str):\n        \"\"\"\n        Returns list of distributed objects with matching str in value.\n        \"\"\"\n        matches = []\n        for value in self.doId2do.values():\n            if repr(value).find(str) >= 0:\n                matches.append(value)\n        return matches\n\n    def doFindAllMatching(self, str):\n        \"\"\"\n        Returns list of distributed objects with matching str in value.\n        \"\"\"\n        matches = []\n        for value in self.doId2do.values():\n            if re.search(str,repr(value)):\n                matches.append(value)\n        return matches\n\n    def doFindAllOfType(self, query):\n        \"\"\"\n        Useful method for searching through the Distributed Object collection\n        for objects of a particular type\n        \"\"\"\n        matches = []\n        for value in self.doId2do.values():\n            if query in str(value.__class__):\n                matches.append(value)\n        return matches, len(matches)\n\n    def doFindAllInstances(self, cls):\n        matches = []\n        for value in self.doId2do.values():\n            if isinstance(value, cls):\n                matches.append(value)\n        return matches\n\n    def _getDistanceFromLA(self, do):\n        if hasattr(do, 'getPos'):\n            return do.getPos(localAvatar).length()\n        return None\n\n    def _compareDistance(self, do1, do2):\n        dist1 = self._getDistanceFromLA(do1)\n        dist2 = self._getDistanceFromLA(do2)\n        if dist1 is None and dist2 is None:\n            return 0\n        if dist1 is None:\n            return 1\n        if dist2 is None:\n            return -1\n        if dist1 < dist2:\n            return -1\n        return 1\n\n    def dosByDistance(self):\n        objs = list(self.doId2do.values())\n        objs.sort(cmp=self._compareDistance)\n        return objs\n\n    def doByDistance(self):\n        objs = self.dosByDistance()\n        for obj in objs:\n            print('%s\\t%s\\t%s' % (obj.doId, self._getDistanceFromLA(obj),\n                                  obj.dclass.getName()))\n\n    if __debug__:\n        def printObjects(self):\n            format=\"%10s %10s %10s %30s %20s\"\n            title=format%(\"parentId\", \"zoneId\", \"doId\", \"dclass\", \"name\")\n            print(title)\n            print('-'*len(title))\n            for distObj in self.doId2do.values():\n                print(format%(\n                    distObj.__dict__.get(\"parentId\"),\n                    distObj.__dict__.get(\"zoneId\"),\n                    distObj.__dict__.get(\"doId\"),\n                    distObj.dclass.getName(),\n                    distObj.__dict__.get(\"name\")))\n\n    def _printObjects(self, table):\n        class2count = {}\n        for obj in self.getDoTable(ownerView=False).values():\n            className = obj.__class__.__name__\n            class2count.setdefault(className, 0)\n            class2count[className] += 1\n        count2classes = invertDictLossless(class2count)\n        for count in sorted(count2classes, reverse=True):\n            count2classes[count].sort()\n            for name in count2classes[count]:\n                print('%s %s' % (count, name))\n        print('')\n\n    def _returnObjects(self, table):\n        class2count = {}\n        stringToReturn = ''\n        for obj in self.getDoTable(ownerView=False).values():\n            className = obj.__class__.__name__\n            class2count.setdefault(className, 0)\n            class2count[className] += 1\n        count2classes = invertDictLossless(class2count)\n        for count in sorted(count2classes, reverse=True):\n            count2classes[count].sort()\n            for name in count2classes[count]:\n                # print '%s %s' % (count, name)\n                stringToReturn = '%s%s %s\\n' % (stringToReturn, count, name)\n        # print ''\n        return stringToReturn\n\n    def webPrintObjectCount(self):\n        strToReturn = '==== OBJECT COUNT ====\\n'\n        if self.hasOwnerView():\n            strToReturn = '%s == doId2do\\n' % (strToReturn)\n        strToReturn = '%s%s' % (strToReturn, self._returnObjects(self.getDoTable(ownerView=False)))\n        if self.hasOwnerView():\n            strToReturn = '%s\\n== doId2ownerView\\n' % (strToReturn)\n            strToReturn = '%s%s' % (strToReturn, self._returnObjects(self.getDoTable(ownerView=False)))\n        return strToReturn\n\n    def printObjectCount(self):\n        # print object counts by distributed object type\n        print('==== OBJECT COUNT ====')\n        if self.hasOwnerView():\n            print('== doId2do')\n        self._printObjects(self.getDoTable(ownerView=False))\n        if self.hasOwnerView():\n            print('== doId2ownerView')\n            self._printObjects(self.getDoTable(ownerView=True))\n\n    def getDoList(self, parentId, zoneId=None, classType=None):\n        \"\"\"\n        Args:\n            parentId: any distributed object id.\n            zoneId: a uint32, defaults to None (all zones).  Try zone 2 if\n                you're not sure which zone to use (0 is a bad/null zone and\n                1 has had reserved use in the past as a no messages zone, while\n                2 has traditionally been a global, uber, misc stuff zone).\n            dclassType: a distributed class type filter, defaults to None\n                (no filter).\n\n        If dclassName is None then all objects in the zone are returned;\n        otherwise the list is filtered to only include objects of that type.\n        \"\"\"\n        return [self.doId2do.get(i)\n            for i in self.getDoIdList(parentId, zoneId, classType)]\n\n    def getDoIdList(self, parentId, zoneId=None, classType=None):\n        return self._doHierarchy.getDoIds(self.getDo,\n                                          parentId, zoneId, classType)\n\n    def hasOwnerViewDoId(self, doId):\n        assert self.hasOwnerView()\n        return doId in self.doId2ownerView\n\n    def getOwnerViewDoList(self, classType):\n        assert self.hasOwnerView()\n        l = []\n        for obj in self.doId2ownerView.values():\n            if isinstance(obj, classType):\n                l.append(obj)\n        return l\n\n    def getOwnerViewDoIdList(self, classType):\n        assert self.hasOwnerView()\n        l = []\n        for doId, obj in self.doId2ownerView.items():\n            if isinstance(obj, classType):\n                l.append(doId)\n        return l\n\n    def countObjects(self, classType):\n        \"\"\"\n        Counts the number of objects of the given type in the\n        repository (for testing purposes)\n        \"\"\"\n        count = 0\n        for dobj in self.doId2do.values():\n            if isinstance(dobj, classType):\n                count += 1\n        return count\n\n\n    def getAllOfType(self, type):\n        # Returns a list of all DistributedObjects in the repository\n        # of a particular type.\n        result = []\n        for obj in self.doId2do.values():\n            if isinstance(obj, type):\n                result.append(obj)\n        return result\n\n    def findAnyOfType(self, type):\n        # Searches the repository for any object of the given type.\n        for obj in self.doId2do.values():\n            if isinstance(obj, type):\n                return obj\n        return None\n\n    #----------------------------------\n\n    def deleteDistributedObjects(self):\n        # Get rid of all the distributed objects\n        for do in list(self.doId2do.values()):\n            self.deleteDistObject(do)\n\n        # Get rid of everything that manages distributed objects\n        self.deleteObjects()\n\n        # the zoneId2doIds table should be empty now\n        if not self._doHierarchy.isEmpty():\n            self.notify.warning(\n                '_doHierarchy table not empty: %s' % self._doHierarchy)\n            self._doHierarchy.clear()\n\n    def handleObjectLocation(self, di):\n        # CLIENT_OBJECT_LOCATION\n        doId = di.getUint32()\n        parentId = di.getUint32()\n        zoneId = di.getUint32()\n        obj = self.doId2do.get(doId)\n        if obj is not None:\n            self.notify.debug(\n                \"handleObjectLocation: doId: %s parentId: %s zoneId: %s\"%\n                (doId, parentId, zoneId))\n            # Let the object finish the job\n            # calls storeObjectLocation()\n            obj.setLocation(parentId, zoneId)\n        else:\n            self.notify.warning(\n                \"handleObjectLocation: Asked to update non-existent obj: %s\" % (doId))\n\n    def handleSetLocation(self, di):\n        # This was initially added because creating a distributed quest\n        # object would cause a message like this to be generated.\n        assert self.notify.debugStateCall(self)\n        parentId = di.getUint32()\n        zoneId = di.getUint32()\n        distObj = self.doId2do.get(self.getMsgChannel())\n        if distObj is not None:\n            distObj.setLocation(parentId, zoneId)\n        else:\n            self.notify.warning('handleSetLocation: object %s not present' % self.getMsgChannel())\n\n    def storeObjectLocation(self, object, parentId, zoneId):\n        oldParentId = object.parentId\n        oldZoneId = object.zoneId\n        if oldParentId != parentId:\n            # notify any existing parent that we're moving away\n            oldParentObj = self.doId2do.get(oldParentId)\n            if oldParentObj is not None:\n                oldParentObj.handleChildLeave(object, oldZoneId)\n            self.deleteObjectLocation(object, oldParentId, oldZoneId)\n\n        elif oldZoneId != zoneId:\n            # Remove old location\n            oldParentObj = self.doId2do.get(oldParentId)\n            if oldParentObj is not None:\n                oldParentObj.handleChildLeaveZone(object, oldZoneId)\n            self.deleteObjectLocation(object, oldParentId, oldZoneId)\n        else:\n            # object is already at that parent and zone\n            return\n\n        if parentId is None or zoneId is None or (parentId == zoneId == 0):\n            # Do not store null values\n            object.parentId = None\n            object.zoneId = None\n        else:\n            # Add to new location\n            self._doHierarchy.storeObjectLocation(object, parentId, zoneId)\n            # this check doesn't work because of global UD objects;\n            # should they have a location?\n            #assert len(self._doHierarchy) == len(self.doId2do)\n\n            # Set the new parent and zone on the object\n            object.parentId = parentId\n            object.zoneId = zoneId\n\n\n        if oldParentId != parentId:\n            # Give the parent a chance to run code when a new child\n            # sets location to it. For example, the parent may want to\n            # scene graph reparent the child to some subnode it owns.\n            parentObj = self.doId2do.get(parentId)\n            if parentObj is not None:\n                parentObj.handleChildArrive(object, zoneId)\n            elif parentId not in (None, 0, self.getGameDoId()):\n                self.notify.warning('storeObjectLocation(%s): parent %s not present' %\n                                    (object.doId, parentId))\n        elif oldZoneId != zoneId:\n            parentObj = self.doId2do.get(parentId)\n            if parentObj is not None:\n                parentObj.handleChildArriveZone(object, zoneId)\n            elif parentId not in (None, 0, self.getGameDoId()):\n                self.notify.warning('storeObjectLocation(%s): parent %s not present' %\n                                    (object.doId, parentId))\n\n    def deleteObjectLocation(self, object, parentId, zoneId):\n        # Do not worry about null values\n        if ((parentId is None) or (zoneId is None) or\n            (parentId == zoneId == 0)):\n            return\n\n        self._doHierarchy.deleteObjectLocation(object, parentId, zoneId)\n\n    def addDOToTables(self, do, location=None, ownerView=False):\n        assert self.notify.debugStateCall(self)\n        #assert not hasattr(do, \"isQueryAllResponse\") or not do.isQueryAllResponse\n        if not ownerView:\n            if location is None:\n                location = (do.parentId, do.zoneId)\n\n        doTable = self.getDoTable(ownerView)\n\n        # make sure the object is not already present\n        if do.doId in doTable:\n            if ownerView:\n                tableName = 'doId2ownerView'\n            else:\n                tableName = 'doId2do'\n            self.notify.error('doId %s already in %s [%s stomping %s]' % (\n                do.doId, tableName, do.__class__.__name__,\n                doTable[do.doId].__class__.__name__))\n\n        doTable[do.doId]=do\n\n        if not ownerView:\n            if self.isValidLocationTuple(location):\n                self.storeObjectLocation(do, location[0], location[1])\n                ##assert do.doId not in self.zoneId2doIds.get(location, {})\n                ##self.zoneId2doIds.setdefault(location, {})\n                ##self.zoneId2doIds[location][do.doId]=do\n\n    def isValidLocationTuple(self, location):\n        return (location is not None\n            and location != (0xffffffff, 0xffffffff)\n            and location != (0, 0))\n\n    if __debug__:\n        def isInDoTables(self, doId):\n            assert self.notify.debugStateCall(self)\n            return doId in self.doId2do\n\n    def removeDOFromTables(self, do):\n        assert self.notify.debugStateCall(self)\n        #assert not hasattr(do, \"isQueryAllResponse\") or not do.isQueryAllResponse\n        #assert do.doId in self.doId2do\n        location = do.getLocation()\n        if location:\n            oldParentId, oldZoneId = location\n            oldParentObj = self.doId2do.get(oldParentId)\n            if oldParentObj:\n                oldParentObj.handleChildLeave(do, oldZoneId)\n        self.deleteObjectLocation(do, do.parentId, do.zoneId)\n        ## location = do.getLocation()\n        ## if location is not None:\n        ##     if location not in self.zoneId2doIds:\n        ##         self.notify.warning(\n        ##             'dobj %s (%s) has invalid location: %s' %\n        ##             (do, do.doId, location))\n        ##     else:\n        ##         assert do.doId in self.zoneId2doIds[location]\n        ##         del self.zoneId2doIds[location][do.doId]\n        ##         if len(self.zoneId2doIds[location]) == 0:\n        ##             del self.zoneId2doIds[location]\n        if do.doId in self.doId2do:\n            del self.doId2do[do.doId]\n\n    ## def changeDOZoneInTables(self, do, newParentId, newZoneId, oldParentId, oldZoneId):\n    ##     if 1:\n    ##         self.storeObjectLocation(do.doId, newParentId, newZoneId)\n    ##     else:\n    ##         #assert not hasattr(do, \"isQueryAllResponse\") or not do.isQueryAllResponse\n    ##         oldLocation = (oldParentId, oldZoneId)\n    ##         newLocation = (newParentId, newZoneId)\n    ##         # HACK: DistributedGuildMemberUD starts in -1, -1, which isnt ever put in the\n    ##         # zoneId2doIds table\n    ##         if self.isValidLocationTuple(oldLocation):\n    ##             assert self.notify.debugStateCall(self)\n    ##             assert oldLocation in self.zoneId2doIds\n    ##             assert do.doId in self.zoneId2doIds[oldLocation]\n    ##             assert do.doId not in self.zoneId2doIds.get(newLocation, {})\n    ##             # remove from old zone\n    ##             del(self.zoneId2doIds[oldLocation][do.doId])\n    ##             if len(self.zoneId2doIds[oldLocation]) == 0:\n    ##                 del self.zoneId2doIds[oldLocation]\n    ##         if self.isValidLocationTuple(newLocation):\n    ##             # add to new zone\n    ##             self.zoneId2doIds.setdefault(newLocation, {})\n    ##             self.zoneId2doIds[newLocation][do.doId]=do\n\n    def getObjectsInZone(self, parentId, zoneId):\n        \"\"\"\n        returns dict of doId:distObj for a zone.\n        returned dict is safely mutable.\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        doDict = {}\n        for doId in self.getDoIdList(parentId, zoneId):\n            doDict[doId] = self.getDo(doId)\n        return doDict\n\n    def getObjectsOfClassInZone(self, parentId, zoneId, objClass):\n        \"\"\"\n        returns dict of doId:object for a zone, containing all objects\n        that inherit from 'class'. returned dict is safely mutable.\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        doDict = {}\n        for doId in self.getDoIdList(parentId, zoneId, objClass):\n            doDict[doId] = self.getDo(doId)\n        return doDict\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/DoCollectionManager.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/e16b9605_DoCollectionManager.json",
    "doc_id": "doc_314"
  }
}