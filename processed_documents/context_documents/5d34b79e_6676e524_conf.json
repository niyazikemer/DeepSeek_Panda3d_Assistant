{
  "content": "# -*- coding: utf-8 -*-\n#\n# Panda3D documentation build configuration file, created by\n# sphinx-quickstart on Thu Oct  1 01:31:55 2015.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys\nimport os\nimport types\nimport re\nfrom sphinx.ext import autodoc\nfrom docutils import nodes\n\nbuild_api_reference = True\n\ntry:\n    from panda3d.interrogatedb import *\n    from sphinx_interrogatedb import idb\nexcept ImportError as ex:\n    print(\"Could not import Panda3D modules:\")\n    print(ex)\n    print(\"Skipping building building the API reference.\")\n    build_api_reference = False\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.insert(0, os.path.abspath('.'))\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\nneeds_sphinx = '1.8'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.autosummary',\n    'sphinx_autopackagesummary',\n    'variations',\n    'sphinx.ext.graphviz',\n    'sphinx.ext.napoleon',\n    'sphinx.ext.inheritance_diagram',\n    'sphinx.ext.viewcode',\n    'sphinx.ext.intersphinx',\n]\n\nif build_api_reference:\n    extensions.append('sphinx_interrogatedb')\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix of source filenames.\nsource_suffix = '.rst'\n\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = u'Panda3D'\ncopyright = u'2019 Carnegie Mellon University'\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '1.10'\n\n# The full X.Y.Z version.\nrelease = '1.10.15'\n\n# Whether to generate Python or C++ documentation.  TODO:\ntags.add('python')\n\nvariations = [('python', 'Python'),\n              ('cpp', 'C++')]\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\n#pygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False\n\n# Set default settings for embedded graphviz diagrams.\ngraphviz_dot_args = [\n    \"-Gfontname='Lato','proxima-nova','Helvetica Neue',Arial,sans-serif\",\n    \"-Nfontname='Lato','proxima-nova','Helvetica Neue',Arial,sans-serif\",\n    \"-Efontname='Lato','proxima-nova','Helvetica Neue',Arial,sans-serif\",\n    \"-Gfontsize=12.00\",\n    \"-Nfontsize=12.00\",\n    \"-Efontsize=12.00\",\n    \"-Gfontcolor=#404040\",\n    \"-Nfontcolor=#404040\",\n    \"-Efontcolor=#404040\",\n    \"-Gcolor=#404040\",\n    \"-Ncolor=#404040\",\n    \"-Ecolor=#404040\",\n]\ngraphviz_output_format = \"svg\"\n\n\n# -- Options for HTML output ----------------------------------------------\n\nhtml_theme = \"sphinx_rtd_theme\"\nhtml_theme_options = {\n    'style_nav_header_background': '#735cdd',\n    'logo_only': True,\n    'collapse_navigation': False,\n    'prev_next_buttons_location': 'both',\n    'style_external_links': True,\n    'display_version': False,\n}\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\nhtml_title = \"Panda3D Manual\"\nhtml_logo = \"_static/logo.png\"\nhtml_js_files = ['versions.js']\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\nhtml_favicon = '_static/favicon.ico'\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\nhtml_context = {\n    'css_files': [\n        '_static/panda.css',  # override wide tables in RTD theme\n    ],\n    'display_github': True,\n    'github_user': 'panda3d',\n    'github_repo': 'panda3d-docs',\n    'github_version': version,\n    'conf_py_path': '/',\n    'version': version,\n}\n\n# Don't copy a _sources dir -- we already have a GitHub link\nhtml_copy_source = False\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'Panda3Ddoc'\n\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n  ('index', 'Panda3D.tex', u'Panda3D Documentation',\n   u'Panda3D', 'manual'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\nfrom sphinx.util import texescape\ntexescape.tex_replacements += [\n    ('\\ufe0f', ''), # unicode representation\n    ('\\u274c', r'\\(\\pmb{\\times}\\)'), # cross mark\n]\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('index', 'panda3d', u'Panda3D Documentation',\n     [u'Panda3D'], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  ('index', 'Panda3D', u'Panda3D Documentation',\n   u'Panda3D', 'Panda3D', 'One line description of project.',\n   'Miscellaneous'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#texinfo_no_detailmenu = False\n\n# When running the linkcheck, don't try any example.net/org/com domains.\nlinkcheck_ignore = [r'https?://(.+\\.)?example\\.(com|net|org)(/.*)?',\n                    'http://server:port/path']\nlinkcheck_anchors = False\n\n# Intersphinx config.\nintersphinx_mapping = {'python': ('https://docs.python.org/3', None)}\n\n# Set a list of modules that do bad things when imported, and should not be\n# considered for API generation.\n# It's fine to keep this list here; it should never grow, because we should not\n# introduce new modules that don't have proper __name__ == __main__ checks or\n# rely on builtins.\nautosummary_mock_imports = [\n    'direct.directbase.DirectStart',\n    'direct.directbase.TestStart',\n    'direct.directbase.ThreeUpStart',\n    'direct.directdevices.DirectFastrak',\n    'direct.directdevices.DirectJoybox',\n    'direct.directdevices.DirectRadamec',\n    'direct.directscripts',\n    'direct.directtools.DirectSession',\n    'direct.directutil.DirectMySQLdb',\n    'direct.directutil.DirectMySQLdbConnection',\n    'direct.directutil.MemoryLeakHelpers',\n    'direct.dist.pfreeze',\n    'direct.filter.filterBloomI',\n    'direct.filter.filterBloomX',\n    'direct.filter.filterBloomY',\n    'direct.filter.filterBlurX',\n    'direct.filter.filterBlurY',\n    'direct.filter.filterCopy',\n    'direct.filter.filterDown4',\n    'direct.leveleditor',\n    'direct.p3d.packp3d',\n    'direct.p3d.pdeploy',\n    'direct.p3d.pmerge',\n    'direct.p3d.ppackage',\n    'direct.p3d.ppatcher',\n    'direct.p3d.runp3d',\n    'direct.plugin_installer.make_installer',\n    'direct.plugin_installer.make_xpi',\n    'direct.plugin_npapi.make_osx_bundle',\n    'direct.plugin_standalone.make_osx_bundle',\n    'direct.showbase.VerboseImport',\n    'direct.wxwidgets.WxAppShell',\n    'direct.wxwidgets.WxPandaShell',\n    'direct.wxwidgets.WxPandaStart',\n]\n\nautodoc_default_options = {\n    \"members\": None,\n    \"show-inheritance\": None,\n}\nautodoc_inherit_docstrings = False\nnapoleon_custom_sections = [\"Usage\", \"Features\"]\nautosummary_generate = True\n# Prevent prepending module name to all classes/functions\nadd_module_names = False\n\n# Map to camel-case for now.\nautodoc_interrogatedb_mangle_type_names = False\nautodoc_interrogatedb_mangle_function_names = True\n\n# Set the directory where the .in files should be located.\ntry:\n    import pandac\nexcept ImportError:\n    pandac = None\nif pandac:\n    interrogatedb_search_path = [\n        os.path.join(os.path.dirname(pandac.__file__), \"input\")]\n\n# Set some default graphviz attributes for the inheritance diagrams.\ninheritance_graph_attrs = {\n    \"rankdir\": \"BT\",\n    #\"splines\": \"ortho\",\n}\ninheritance_node_attrs = {\n    \"fontsize\": 11,\n    \"style\": '\"\"',\n}\ninheritance_edge_attrs = {\n    \"arrowsize\": 0.75,\n    \"style\": '\"\"',\n}\n\n# Regex patterns.\nat_c_at_p_pattern = re.compile(r'@[cp]\\s+([^\\s]+)')\nmethod_class_ref_pattern = re.compile(r'([a-zA-Z_][a-zA-Z0-9_.:]*)\\(\\)|([a-zA-Z_][a-zA-Z0-9_]*::[a-zA-Z_][a-zA-Z0-9_.:]*)(\\(\\))?|([a-zA-Z_]+[A-Z0-9_][a-zA-Z0-9_.:]*)(\\(\\))?')\n\n# Built-in variables automatically resolved in references.\nbuiltins_types = {\n    'base': 'direct.showbase.ShowBase.ShowBase',\n    'render': 'panda3d.core.NodePath',\n    'render2d': 'panda3d.core.NodePath',\n    'aspect2d': 'panda3d.core.NodePath',\n    'pixel2d': 'panda3d.core.NodePath',\n    'hidden': 'panda3d.core.NodePath',\n    'loader': 'direct.showbase.Loader.Loader',\n    'taskMgr': 'direct.task.Task.TaskManager',\n    'jobMgr': 'direct.showbase.JobManager.JobManager',\n    'eventMgr': 'direct.showbase.EventManager.EventManager',\n    'messenger': 'direct.showbase.Messenger.Messenger',\n    'bboard': 'direct.showbase.BulletinBoard.BulletinBoard',\n    'ostream': 'panda3d.core.Ostream',\n    'globalClock': 'panda3d.core.ClockObject',\n    'vfs': 'panda3d.core.VirtualFileSystem',\n    'cpMgr': 'panda3d.core.ConfigPageManager',\n    'cvMgr': 'panda3d.core.ConfigVariableManager',\n    'pandaSystem': 'panda3d.core.PandaSystem',\n}\n\n\nclass ExcludeDocumenter(autodoc.Documenter):\n    \"\"\"Special documenter that excludes certain types from autosummary.\n\n    It works by matching our desired excluded types, but because it has a\n    special objtype not recognized by autosummary, it won't be included.\"\"\"\n\n    objtype = \"exclude\"\n\n    priority = 99\n\n    @classmethod\n    def can_document_member(cls, member, membername, isattr, parent):\n        # We only want to trigger autosummary, which always passes the empty\n        # string as membername.\n        if membername:\n            return False\n\n        if isinstance(member, type):\n            if member.__name__.startswith(\"PointerToBase_ReferenceCountedVector_\"):\n                return True\n\n        return False\n\n    def generate(self, *args, **kwargs):\n        # This should never even be invoked by autodoc.\n        return\n\n\ndef resolve_reference(ref, rel, domain='py'):\n    \"\"\"Looks up an interrogate symbol to its canonical name.  The second\n    argument is the fully qualified name it should be seen relative to, which\n    may be a module name, or a module name followed by an object name.\n\n    If found, returns a 2-tuple (type, fqname), else None.\"\"\"\n\n    if not build_api_reference:\n        return None\n\n    # Find out which module we should be looking in.\n    modname = None\n    relpath = None\n    rel_parts = rel.replace('::', '.').split('.')\n    for i in range(len(rel_parts), 0, -1):\n        try_modname = '.'.join(rel_parts[:i])\n        if idb.has_module(try_modname):\n            modname = try_modname\n            relpath = rel_parts[i:]\n            break\n\n    if not modname:\n        return None\n\n    refpath = ref.replace('::', '.').split('.')\n\n    # Say `rel` is \"panda3d.core.NodePath.node\",\n    # and `ref` is \"PandaNode.final\", then we will try these in this order:\n    # - panda3d.core::NodePath.node.PandaNode.final\n    # - panda3d.core::NodePath.PandaNode.final\n    # - panda3d.core::PandaNode.final\n\n    for i in range(len(relpath), -1, -1):\n        search = relpath[:i] + refpath\n\n        if len(refpath) == 1 and i > 0 and refpath[0] == relpath[i - 1]:\n            # If we are looking for a name equal to the parent scope, we are\n            # probably referencing a class name from within that very class.\n            # We don't want to find the constructor, so skip this.\n            continue\n\n        ifunc = idb.lookup_function(modname, search)\n        if ifunc:\n            if domain == 'cpp':\n                func_name = interrogate_function_scoped_name(ifunc)\n                return ('func', func_name)\n            elif domain == 'py':\n                # Grab the mangled function name.\n                func_name = idb.get_function_name(ifunc, scoped=False, mangle=True)\n                if interrogate_function_is_method(ifunc):\n                    outer = interrogate_function_class(ifunc)\n                    prefix = interrogate_type_module_name(outer)\n                    if prefix:\n                        prefix += '.'\n                    type_name = idb.get_type_name(outer, mangle=False, scoped=True)\n                    if len(refpath) == 1 and interrogate_function_name(ifunc).lstrip('~') == interrogate_type_name(outer):\n                        # This matches a constructor, but we want the class.\n                        return ('class', prefix + type_name)\n                    else:\n                        return ('meth', prefix + type_name + '.' + func_name)\n                else:\n                    prefix = interrogate_function_module_name(ifunc)\n                    if prefix:\n                        prefix += '.'\n                    return ('func', prefix + func_name)\n\n        itype = idb.lookup_type(modname, search)\n        if itype:\n            # Grab the original type name.\n            if domain == 'cpp':\n                type_name = interrogate_type_scoped_name(itype)\n                if interrogate_type_is_typedef(itype):\n                    return ('type', type_name)\n                elif interrogate_type_is_enum(itype):\n                    return ('enum', type_name)\n                elif interrogate_type_is_struct(itype):\n                    return ('struct', type_name)\n                elif interrogate_type_is_class(itype):\n                    return ('class', type_name)\n                elif interrogate_type_is_union(itype):\n                    return ('union', type_name)\n            elif domain == 'py':\n                type_name = idb.get_type_name(itype, mangle=False, scoped=True)\n                prefix = interrogate_type_module_name(itype)\n                if prefix:\n                    prefix += '.'\n                return ('class', prefix + type_name)\n\n    if len(rel_parts) >= 2 and rel_parts[0] == 'panda3d' and rel_parts[1] != 'core':\n        # Look in panda3d.core instead, prefix the result with the module name.\n        rel_parts[1] = 'core'\n        return resolve_reference(ref, '.'.join(rel_parts), domain=domain)\n\n\ndef convert_doxygen_format(line, name, domain='py'):\n    \"\"\"Converts a single line of Doxygen formatting to Sphinx.\n    The name argument is the fully qualified name of the current module, class\n    or function, and is used to resolve references.\"\"\"\n\n    line = line.replace('<b>', '**').replace('</b>', '**')\n\n    # Single backticks in doxygen map to doubles in Sphinx\n    line = line.replace('`', '``')\n\n    # But double backticks are literal backticks\n    line = line.replace('````', '\\\\`')\n\n    # @c and @p result in double backticks for the subsequent word\n    line = re.sub(at_c_at_p_pattern, r'``\\1``', line)\n\n    parent = name.rsplit('.', 1)[-1]\n\n    # Search for method and class references.  We pick them up either when they\n    # have a scoping operator, or when they end with (), or when they clearly\n    # look like a class/method, or we would match all the words in the text!\n    words = line.split(' ')\n    in_backticks = False\n    for i, word in enumerate(words):\n        if '``' in word:\n            if word.count('``') % 2 == 1:\n                # This opens/closes a backtick block spanning multiple words.\n                in_backticks = not in_backticks\n                continue\n\n        if in_backticks:\n            continue\n\n        if word.endswith('.') or word.endswith(',') or word.endswith(';'):\n            # Punctuation.\n            suffix = word[-1]\n            word = word[:-1]\n        else:\n            suffix = ''\n\n        if word.endswith(')') and word.count(')') > word.count('('):\n            # It could be the last word in a parenthesized statement.\n            word = word[:-1]\n            suffix = ')' + suffix\n\n        # Don't replace the class name on the page of the class itself, unless\n        # it's already in backticks.\n        if word.rstrip('()') == parent:\n            continue\n\n        word = word.strip('`')\n\n        m = re.fullmatch(method_class_ref_pattern, word)\n        if not m:\n            continue\n\n        plural = False\n\n        result = resolve_reference(word.rstrip('()'), name, domain=domain)\n        if not result and word.endswith('s') and '::' not in word and word[:-1] != parent:\n            # Detect use of plural in references to classes.\n            result = resolve_reference(word[:-1], name, domain=domain)\n            plural = True\n\n        if not result:\n            continue\n\n        typ, target = result\n\n        if word == target:\n            words[i] = ':{0}:{1}:`{2}`{3}'.format(domain, typ, target, suffix)\n        else:\n            if domain == 'py' and typ in ('meth', 'func'):\n                # Replace last part with mangled name if appropriate.\n                word = word.replace('::', '.')\n                oldpart = word.rsplit('.', 1)[-1]\n                newpart = target.rsplit('.', 1)[-1]\n                if oldpart.endswith('()'):\n                    newpart += '()'\n\n                if oldpart != newpart:\n                    if word == oldpart:\n                        word = newpart\n                    else:\n                        word = word.rsplit('.', 1)[0] + '.' + newpart\n\n            if '.' not in word and '::' not in word and target.endswith('.' + word):\n                words[i] = ':{0}:{1}:`~{2}`{3}'.format(domain, typ, target, suffix)\n            else:\n                words[i] = ':{0}:{1}:`{2} <{3}>`{4}'.format(domain, typ, word, target, suffix)\n\n        #print(\"replaced\", word, \"with\", words[i])\n\n    return ' '.join(words)\n\n\ndef convert_doxygen_docstring(lines, name, domain='py'):\n    \"\"\"Converts a doxygen-style C++ block comment to a Sphinx-style one.\n    The name argument is the fully qualified name of the current module, class\n    or function, and is used to resolve references.\"\"\"\n\n    lines = lines[:]\n    newlines = []\n    indent = 0\n    reading_desc = False\n\n    while lines:\n        line = lines.pop(0)\n        if line.startswith(\"////\"):\n            continue\n\n        line = line.rstrip()\n        if line.startswith('///<'):\n            strline = line[4:]\n        else:\n            strline = line\n\n        strline = strline.lstrip('/ \\t')\n\n        if strline == \"**\" or strline == \"*/\":\n            continue\n\n        if strline.startswith(\"** \"):\n            strline = strline[3:]\n        elif strline.startswith(\"* \"):\n            strline = strline[2:]\n        elif strline == \"*\":\n            strline = \"\"\n\n        strline = strline.lstrip(' \\t')\n\n        if strline.startswith('@'):\n            special = strline.split(' ', 1)[0][1:]\n            if special == 'par' and strline.endswith(':') and lines and '@code' in lines[0]:\n                newlines.append('   '*indent + strline[5:] + ':')\n                newlines.append('')\n                line = lines.pop(0)\n                offset = line.index('@code')\n                while lines:\n                    line = lines.pop(0)\n                    if '@endverbatim' in line or '@endcode' in line:\n                        break\n                    newlines.append('   ' + line[offset:])\n\n                newlines.append('')\n                continue\n            elif special == \"verbatim\" or special == \"code\":\n                if newlines and newlines[-1]:\n                    newlines.append('')\n\n                newlines.append('.. code-block:: guess')\n                newlines.append('')\n                offset = line.index('@' + special)\n                while lines:\n                    line = lines.pop(0)\n                    if '@endverbatim' in line or '@endcode' in line:\n                        break\n                    newlines.append('   ' + line[offset:])\n\n                newlines.append('')\n                continue\n            elif special == \"f[\":\n                if newlines and newlines[-1]:\n                    newlines.append('')\n\n                newlines.append('.. math::')\n                newlines.append('')\n                offset = line.index('@' + special)\n                while lines:\n                    line = lines.pop(0)\n                    if '@f]' in line:\n                        break\n                    newlines.append('   ' + line[offset:])\n\n                newlines.append('')\n                continue\n            elif special == 'param':\n                #TODO\n                #if extra is not None:\n                #    _, name, desc = strline.split(' ', 2)\n                #    extra['param:' + name] = desc\n                continue\n            elif special == 'deprecated':\n                if newlines and newlines[-1]:\n                    newlines.append('')\n\n                if ' ' in strline:\n                    _, value = strline.split(' ', 1)\n\n                    # I'd love to use the proper Sphinx deprecated tag, but it\n                    # requires a version number, whereas Doxygen doesn't.\n                    newlines.append('**Deprecated**: ' + convert_doxygen_format(value, name, domain))\n                else:\n                    newlines.append('**Deprecated**')\n\n                newlines.append('')\n                continue\n            elif special in ('brief', 'return', 'returns'):\n                #TODO\n                #if extra is not None:\n                #    _, value = strline.split(' ', 1)\n                #    extra[special] = value\n                continue\n            elif special == 'details':\n                strline = strline[9:]\n            elif special == 'sa' or special == 'see':\n                if newlines and newlines[-1]:\n                    newlines.append('')\n\n                _, value = strline.split(' ', 1)\n                values = value.split(',')\n\n                for i, value in enumerate(values):\n                    result = resolve_reference(value.partition('(')[0], name, domain=domain)\n                    if result:\n                        values[i] = ':{0}:{1}:`{2}`'.format(domain, *result)\n                    else:\n                        values[i] = ':{0}:obj:`{1}`'.format(domain, value)\n\n                if special == 'see':\n                    newlines.append('See {}.'.format(', '.join(values)))\n                else:\n                    newlines.append('See also {}.'.format(', '.join(values)))\n                newlines.append('')\n                continue\n            elif special in ('note', 'warning'):\n                if newlines and newlines[-1]:\n                    newlines.append('')\n\n                newlines.append('.. %s:: ' % (special))\n                newlines.append('')\n                newlines.append('   ' + convert_doxygen_format(strline[2 + len(special):], name, domain))\n                while lines and lines[0].strip(' *\\t/'):\n                    line = lines.pop(0).lstrip(' *\\t')\n                    newlines.append('   ' + convert_doxygen_format(line, name, domain))\n\n                newlines.append('')\n                continue\n            elif special == 'since':\n                if newlines and newlines[-1]:\n                    newlines.append('')\n\n                newlines.append('.. versionadded:: ' + strline[7:])\n                newlines.append('')\n                continue\n            elif special == 'li':\n                if newlines and newlines[-1]:\n                    newlines.append('')\n\n                newlines.append('* ' + convert_doxygen_format(strline[4:], name, domain))\n                newlines.append('')\n                continue\n            else:\n                print(\"Unhandled documentation tag: @\" + special)\n\n        if strline or len(newlines) > 0:\n            newlines.append('   '*indent + convert_doxygen_format(strline, name, domain))\n\n    return newlines\n\n\ndef on_autodoc_skip_member(app, what, name, obj, skip, options):\n    # Always document constructors.\n    if name == '__init__':\n        return False\n\n    # Don't document method aliases.  This also has the side-effect of\n    # excluding private members, which is OK.\n    if isinstance(obj, types.FunctionType) and obj.__name__ != name:\n        return True\n\n\ndef on_autodoc_process_docstring(app, what, name, obj, options, lines):\n    # This is a temporary hack for a particularly nasty docstring in\n    # direct.fsm.FourState and direct.fsm.FourStateAI that was badly\n    # formatted.  It can be removed once a new version of Panda3D is\n    # released with the offending docstring fixed.\n\n    if (name == 'direct.fsm.FourState.FourState.__init__' or\n        name == 'direct.fsm.FourStateAI.FourStateAI.__init__') \\\n       and 'are used:' in lines:\n        lines[lines.index('are used:')] = 'are used::'\n\n    if lines:\n        line0 = lines[0].lstrip()\n        if line0.startswith('/**') or line0.startswith('// '):\n            domain = app.env.temp_data.get('default_domain')\n            domain = domain.name if domain else 'py'\n            lines[:] = convert_doxygen_docstring(lines, name, domain)\n\n\ndef on_missing_reference(app, env, node, contnode):\n    # Resolver for interrogate classes that supports either snake case or camel\n    # case naming.  Depending on the variation that is active, it will link to\n    # either the Python or C++ reference as appropriate.\n\n    target = node['reftarget']\n\n    variation = getattr(env.app.builder, 'current_variation', None)\n    if variation and variation[0] == 'cpp':\n        domain = env.domains['cpp']\n    else:\n        domain = env.domains['py']\n\n    typ = node['reftype']\n    if domain.name == 'cpp' and typ == 'meth':\n        # C++ domain doesn't have \"meth\", everything is \"func\" there.\n        typ = 'func'\n\n    # Figure out which part is the module and which part is the class.\n    prefix = ''\n    module = 'panda3d.core'\n    if target.startswith('panda3d.'):\n        parts = target.split('.', 2)\n        if len(parts) == 2:\n            # It's trying to resolve a reference to a module; we can't help\n            # with that.\n            return\n\n        module = '.'.join(parts[:2])\n        prefix = module + '.'\n        target = '.'.join(parts[2:])\n    else:\n        # Something like .core.NodePath, perhaps?\n        modpart = target.split('.', 1)[0]\n        if '.' in target and modpart in builtins_types and domain.name == 'py':\n            # It's actually the name of a built-in.\n            target = builtins_types[modpart] + '.' + target.split('.', 1)[1]\n            if target.startswith('panda3d.'):\n                parts = target.split('.', 2)\n                module = '.'.join(parts[:2])\n                prefix = module + '.'\n                target = '.'.join(parts[2:])\n            else:\n                refdoc = node.get('refdoc', env.docname)\n                return domain.resolve_xref(env, refdoc, app.builder, typ, target, node, contnode)\n        elif build_api_reference and idb.has_module('panda3d.' + modpart):\n            module = 'panda3d.' + modpart\n            prefix = modpart + '.'\n            target = target.split('.', 1)[1]\n\n    resolved = target and resolve_reference(target, module, domain=domain.name)\n\n    if resolved and (resolved[0] == typ or typ == 'obj'):\n        refdoc = node.get('refdoc', env.docname)\n\n        # Try to match the original, but with the canonical mangling\n        # (depending on Python versus C++)\n        if len(contnode.children) and not node.get('refexplicit'):\n            oldtext = contnode.children[0].astext()\n\n            text = resolved[1]\n            if domain.name == 'cpp':\n                text = '::'.join(text.split('::')[-oldtext.replace('.', '::').count('.')-1:])\n            else:\n                text = '.'.join(text.split('.')[-oldtext.count('.')-1:])\n\n            if oldtext.endswith(\"()\"):\n                text += \"()\"\n\n            contnode.children[0] = nodes.Text(text)\n\n        elif domain.name == 'cpp':\n            # Work around a bug in the C++ resolver, which expects this\n            # text node to be the child of an Element.  I picked a\n            # decoration element since it happens not to translate to\n            # anything (not sure what its purpose is).\n            if isinstance(contnode, nodes.Text):\n                contnode = nodes.decoration('', contnode)\n\n        elif domain.name == 'py' and len(contnode.children) and node.get('refexplicit'):\n            # Custom text was used.  Replace snake_case with camelCase in it.\n            # This allows doing something like:\n            # :meth:`model.set_color() <.NodePath.set_color>`\n            # ..and still have it translate to the correct casing.\n            oldpart = target.rsplit('.', 1)[-1]\n            newpart = resolved[1].rsplit('.', 1)[-1]\n            if oldpart != newpart:\n                text = contnode.children[0].astext()\n                text = text.replace('::', '.')\n                text = text.replace('.' + oldpart + '(', '.' + newpart + '(')\n                if text.startswith(oldpart + '('):\n                    text = newpart + text[len(oldpart):]\n                contnode.children[0] = nodes.Text(text)\n\n        # C++ references don't have a module prefix and use :: for scoping\n        if domain.name == 'cpp':\n            target = resolved[1]\n            if typ == 'obj':\n                # Another bug workaround\n                typ = resolved[0]\n            if typ in ('enum', 'class', 'struct', 'union') and resolved[0] == 'type':\n                # Squelch warning\n                typ = resolved[0]\n        else:\n            target = resolved[1]\n\n        return domain.resolve_xref(env, refdoc, app.builder, typ, target, node, contnode)\n\n\ndef on_builder_inited(app):\n    app.builder.get_relative_uri = \\\n        lambda from_, to, typ=None: \\\n            app.config.html_absolute_url_root + app.config.version + '/' + app.builder.get_target_uri(to, typ)\n\n\ndef on_html_page_context(app, pagename, templatename, context, doctree):\n    def pathto(otheruri, resource=False, baseuri=None):\n        if resource and '://' in otheruri:\n            # allow non-local resources given by scheme\n            return otheruri\n\n        if not resource:\n            otheruri = app.builder.get_target_uri(otheruri)\n\n        if baseuri is None:\n            baseuri = app.config.html_absolute_url_root + version + '/'\n\n        if not baseuri.startswith('/'):\n            raise BaseURIError('\"baseuri\" must be absolute')\n\n        if not otheruri.startswith('/'):\n            otheruri = '/' + otheruri\n\n        if otheruri:\n            if baseuri.endswith('/'):\n                baseuri = baseuri[:-1]\n            otheruri = baseuri + otheruri\n\n        uri = otheruri or '#'\n        return uri\n\n    context['pathto'] = pathto\n\n\ndef on_config_inited(app, config):\n    if config.html_absolute_url_root:\n        app.connect('builder-inited', on_builder_inited)\n        app.connect('html-page-context', on_html_page_context)\n\n        # This normally runs before our hook, so it still picks up the old\n        # pathto, hence we need to register it again\n        from sphinx.builders.html import setup_js_tag_helper\n        app.connect('html-page-context', setup_js_tag_helper)\n\n    # Used in searchbox.html.\n    if config.html_link_suffix is not None:\n        config.html_context['link_suffix'] = config.html_link_suffix\n    elif config.html_file_suffix is not None:\n        config.html_context['link_suffix'] = config.html_file_suffix\n    else:\n        config.html_context['link_suffix'] = '.html'\n\n\n# This is an awful hack to get the inheritance graphs to incorporate the\n# current variation into the links properly, and, at the same time, not\n# generate the arrow connections inverted. :-/\ndef generate_dot(self, name, urls={}, env=None,\n                 graph_attrs={}, node_attrs={}, edge_attrs={}):\n    g_attrs = self.default_graph_attrs.copy()\n    n_attrs = self.default_node_attrs.copy()\n    e_attrs = self.default_edge_attrs.copy()\n    g_attrs.update(graph_attrs)\n    n_attrs.update(node_attrs)\n    e_attrs.update(edge_attrs)\n    if env:\n        g_attrs.update(env.config.inheritance_graph_attrs)\n        n_attrs.update(env.config.inheritance_node_attrs)\n        e_attrs.update(env.config.inheritance_edge_attrs)\n\n    res = []  # type: List[str]\n    res.append('strict digraph %s {\\n' % name)\n    res.append(self._format_graph_attrs(g_attrs))\n\n    for name, fullname, bases, tooltip in sorted(self.class_info):\n        if name == 'DTOOL_SUPER_BASE':\n            continue\n\n        # Write the node\n        this_node_attrs = n_attrs.copy()\n        if fullname in urls:\n            url = urls[fullname]\n            # Fix the URL reference to contain the current variation.\n            # Also strip off the # reference at the end, since our classes\n            # are defined near the top of each file anyway.\n            if env and env.config.graphviz_output_format.lower() == 'svg' and \\\n               getattr(env.app.builder, 'current_variation', None):\n                url = '../' \\\n                    + env.app.builder.current_variation[0] \\\n                    + '/reference/' \\\n                    + os.path.basename(url).split('#', 1)[0]\n\n            this_node_attrs['URL'] = '\"%s\"' % url\n            this_node_attrs['target'] = '\"_top\"'\n        if tooltip:\n            this_node_attrs['tooltip'] = tooltip\n        res.append('  \"%s\" [%s];\\n' %\n                   (name, self._format_node_attrs(this_node_attrs)))\n\n        # Write the edges\n        for base_name in bases:\n            if base_name == 'DTOOL_SUPER_BASE':\n                continue\n            res.append('  \"%s\" -> \"%s\" [%s];\\n' %\n                       (name, base_name,\n                        self._format_node_attrs(e_attrs)))\n    res.append('}\\n')\n    return ''.join(res)\n\n\ndef setup(app):\n    from sphinx.ext.inheritance_diagram import InheritanceGraph\n    InheritanceGraph.generate_dot = generate_dot\n\n    app.add_config_value('html_absolute_url_root', None, 'html')\n    app.connect('config-inited', on_config_inited)\n\n    app.connect('autodoc-skip-member', on_autodoc_skip_member)\n    app.connect('autodoc-process-docstring', on_autodoc_process_docstring)\n\n    app.connect('missing-reference', on_missing_reference, priority=901)\n\n    app.add_autodocumenter(ExcludeDocumenter)\n",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/6676e524_conf.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/5d34b79e_6676e524_conf.json",
    "doc_id": "doc_8"
  }
}