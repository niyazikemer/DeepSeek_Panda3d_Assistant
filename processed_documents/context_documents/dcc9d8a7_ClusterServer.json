{
  "content": "from panda3d.core import (\n    ClockObject,\n    Vec3,\n)\nfrom panda3d.net import (\n    ConnectionWriter,\n    NetAddress,\n    PointerToConnection,\n    QueuedConnectionListener,\n    QueuedConnectionManager,\n    QueuedConnectionReader,\n)\nfrom .ClusterMsgs import (\n    CLUSTER_CAM_FRUSTUM,\n    CLUSTER_CAM_MOVEMENT,\n    CLUSTER_CAM_OFFSET,\n    CLUSTER_COMMAND_STRING,\n    CLUSTER_DAEMON_PORT,\n    CLUSTER_EXIT,\n    CLUSTER_NAMED_MOVEMENT_DONE,\n    CLUSTER_NAMED_OBJECT_MOVEMENT,\n    CLUSTER_NONE,\n    CLUSTER_SELECTED_MOVEMENT,\n    CLUSTER_SERVER_PORT,\n    CLUSTER_SWAP_NOW,\n    CLUSTER_SWAP_READY,\n    CLUSTER_TIME_DATA,\n    ClusterMsgHandler,\n)\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.showbase import DirectObject\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nimport builtins\n\n# NOTE: This assumes the following variables are set via bootstrap command line\n# arguments on server startup:\n#     clusterServerPort\n#     clusterSyncFlag\n#     clusterDaemonClient\n#     clusterDaemonPort\n# Also, I'm not sure multiple camera-group configurations are working for the\n# cluster system.\n\n\nclass ClusterServer(DirectObject.DirectObject):\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"ClusterServer\")\n    MSG_NUM = 2000000\n\n    def __init__(self, cameraJig, camera):\n        global clusterServerPort, clusterSyncFlag\n        global clusterDaemonClient, clusterDaemonPort\n        # Store information about the cluster's camera\n        self.cameraJig = cameraJig\n        self.camera = camera\n        self.lens = camera.node().getLens()\n        self.lastConnection = None\n        self.fPosReceived = 0\n        # Create network layer objects\n        self.qcm = QueuedConnectionManager()\n        self.qcl = QueuedConnectionListener(self.qcm, 0)\n        self.qcr = QueuedConnectionReader(self.qcm, 0)\n        self.cw = ConnectionWriter(self.qcm, 0)\n        try:\n            port = clusterServerPort\n        except NameError:\n            port = CLUSTER_SERVER_PORT\n        self.tcpRendezvous = self.qcm.openTCPServerRendezvous(port, 1)\n        self.qcl.addConnection(self.tcpRendezvous)\n        self.msgHandler = ClusterMsgHandler(ClusterServer.MSG_NUM, self.notify)\n        # Start cluster tasks\n        self.startListenerPollTask()\n        self.startReaderPollTask()\n        # If synchronized server, start swap coordinator too\n        try:\n            clusterSyncFlag\n        except NameError:\n            clusterSyncFlag = 0\n        if clusterSyncFlag:\n            self.startSwapCoordinator()\n            base.graphicsEngine.setAutoFlip(0)\n        # Set global clock mode to slave mode\n        ClockObject.getGlobalClock().setMode(ClockObject.MSlave)\n        # Send verification of startup to client\n        self.daemon = DirectD()\n\n        self.objectMappings  = {}\n        self.objectHasColor  = {}\n        self.controlMappings = {}\n        self.controlPriorities = {}\n        self.controlOffsets  = {}\n        self.messageQueue    = []\n        self.sortedControlMappings   = []\n\n        # These must be passed in as bootstrap arguments and stored in\n        # the __builtins__ namespace\n        try:\n            clusterDaemonClient\n        except NameError:\n            clusterDaemonClient = 'localhost'\n        try:\n            clusterDaemonPort\n        except NameError:\n            clusterDaemonPort = CLUSTER_DAEMON_PORT\n        self.daemon.serverReady(clusterDaemonClient, clusterDaemonPort)\n\n    def startListenerPollTask(self):\n        # Run this task near the start of frame, sometime after the dataLoop\n        taskMgr.add(self.listenerPollTask, \"serverListenerPollTask\", -40)\n\n    def listenerPollTask(self, task):\n        \"\"\" Task to listen for a new connection from the client \"\"\"\n        # Run this task after the dataLoop\n        if self.qcl.newConnectionAvailable():\n            self.notify.info(\"New connection is available\")\n            rendezvous = PointerToConnection()\n            netAddress = NetAddress()\n            newConnection = PointerToConnection()\n            if self.qcl.getNewConnection(rendezvous, netAddress, newConnection):\n                # Crazy dereferencing\n                newConnection=newConnection.p()\n                self.qcr.addConnection(newConnection)\n                self.lastConnection = newConnection\n                self.notify.info(\"Got a connection!\")\n            else:\n                self.notify.warning(\"getNewConnection returned false\")\n        return Task.cont\n\n    def addNamedObjectMapping(self, object, name, hasColor = True,\n                              priority = 0):\n        if name not in self.objectMappings:\n            self.objectMappings[name] = object\n            self.objectHasColor[name] = hasColor\n        else:\n            self.notify.debug('attempt to add duplicate named object: '+name)\n\n    def removeObjectMapping(self, name):\n        if name in self.objectMappings:\n            self.objectMappings.pop(name)\n\n    def redoSortedPriorities(self):\n        self.sortedControlMappings = sorted(\n            [self.controlPriorities[key], key] for key in self.objectMappings\n        )\n\n    def addControlMapping(self, objectName, controlledName, offset = None,\n                          priority = 0):\n        if objectName not in self.controlMappings:\n            self.controlMappings[objectName] = controlledName\n            if offset is None:\n                offset = Vec3(0,0,0)\n            self.controlOffsets[objectName]  = offset\n            self.controlPriorities[objectName] = priority\n            self.redoSortedPriorities()\n        else:\n            self.notify.debug('attempt to add duplicate controlled object: ' + objectName)\n\n    def setControlMappingOffset(self, objectName, offset):\n        if objectName in self.controlMappings:\n            self.controlOffsets[objectName] = offset\n\n    def removeControlMapping(self, name):\n        if name in self.controlMappings:\n            self.controlMappings.pop(name)\n            self.controlPriorities.pop(name)\n        self.redoSortedPriorities()\n\n    def startControlObjectTask(self):\n        self.notify.debug(\"moving control objects\")\n        taskMgr.add(self.controlObjectTask,\"controlObjectTask\",50)\n\n    def controlObjectTask(self, task):\n        #print \"running control object task\"\n        for pair in self.sortedControlPriorities:\n            object = pair[1]\n            name   = self.controlMappings[object]\n            if object in self.objectMappings:\n                self.moveObject(self.objectMappings[object],name,self.controlOffsets[object],\n                                self.objectHasColor[object])\n\n        self.sendNamedMovementDone()\n        return Task.cont\n\n    def sendNamedMovementDone(self):\n        self.notify.debug(\"named movement done\")\n        datagram = self.msgHandler.makeNamedMovementDone()\n        self.cw.send(datagram,self.lastConnection)\n\n    def moveObject(self, nodePath, object, offset, hasColor):\n        self.notify.debug('moving object '+object)\n        #print \"moving object\",object\n        xyz = nodePath.getPos(render) + offset\n        hpr = nodePath.getHpr(render)\n        scale = nodePath.getScale(render)\n        if hasColor:\n            color = nodePath.getColor()\n        else:\n            color = [1,1,1,1]\n        hidden = nodePath.isHidden()\n        datagram = self.msgHandler.makeNamedObjectMovementDatagram(xyz,hpr,scale,color,hidden,object)\n        self.cw.send(datagram, self.lastConnection)\n\n    def startReaderPollTask(self):\n        \"\"\" Task to handle datagrams from client \"\"\"\n        # Run this task just after the listener poll task\n        if clusterSyncFlag:\n            # Sync version\n            taskMgr.add(self._syncReaderPollTask, \"serverReaderPollTask\", -39)\n        else:\n            # Asynchronous version\n            taskMgr.add(self._readerPollTask, \"serverReaderPollTask\", -39)\n\n    def _readerPollTask(self, state):\n        \"\"\" Non blocking task to read all available datagrams \"\"\"\n        while 1:\n            (datagram, dgi, type) = self.msgHandler.nonBlockingRead(self.qcr)\n            # Queue is empty, done for now\n            if type is CLUSTER_NONE:\n                break\n            else:\n                # Got a datagram, handle it\n                self.handleDatagram(dgi, type)\n        return Task.cont\n\n    def _syncReaderPollTask(self, task):\n        if self.lastConnection is None:\n            pass\n        elif self.qcr.isConnectionOk(self.lastConnection):\n            # Process datagrams till you get a postion update\n            type = CLUSTER_NONE\n            while type != CLUSTER_CAM_MOVEMENT:\n                # Block until you get a new datagram\n                (datagram, dgi, type) = self.msgHandler.blockingRead(self.qcr)\n                # Process datagram\n                self.handleDatagram(dgi, type)\n        return Task.cont\n\n    def startSwapCoordinator(self):\n        taskMgr.add(self.swapCoordinatorTask, \"serverSwapCoordinator\", 51)\n\n    def swapCoordinatorTask(self, task):\n        if self.fPosReceived:\n            self.fPosReceived = 0\n            # Alert client that this server is ready to swap\n            self.sendSwapReady()\n            # Wait for swap command (processing any intermediate datagrams)\n            while 1:\n                (datagram, dgi, type) = self.msgHandler.blockingRead(self.qcr)\n                self.handleDatagram(dgi, type)\n                if type == CLUSTER_SWAP_NOW:\n                    break\n        return Task.cont\n\n    def sendSwapReady(self):\n        self.notify.debug(\n            'send swap ready packet %d' % self.msgHandler.packetNumber)\n        datagram = self.msgHandler.makeSwapReadyDatagram()\n        self.cw.send(datagram, self.lastConnection)\n\n    def handleDatagram(self, dgi, type):\n        \"\"\" Process a datagram depending upon type flag \"\"\"\n        if type == CLUSTER_NONE:\n            pass\n        elif type == CLUSTER_EXIT:\n            print('GOT EXIT')\n            import sys\n            sys.exit()\n        elif type == CLUSTER_CAM_OFFSET:\n            self.handleCamOffset(dgi)\n        elif type == CLUSTER_CAM_FRUSTUM:\n            self.handleCamFrustum(dgi)\n        elif type == CLUSTER_CAM_MOVEMENT:\n            self.handleCamMovement(dgi)\n        elif type == CLUSTER_SELECTED_MOVEMENT:\n            self.handleSelectedMovement(dgi)\n        elif type == CLUSTER_COMMAND_STRING:\n            self.handleCommandString(dgi)\n        elif type == CLUSTER_SWAP_READY:\n            pass\n        elif type == CLUSTER_SWAP_NOW:\n            self.notify.debug('swapping')\n            base.graphicsEngine.flipFrame()\n        elif type == CLUSTER_TIME_DATA:\n            self.notify.debug('time data')\n            self.handleTimeData(dgi)\n        elif type == CLUSTER_NAMED_OBJECT_MOVEMENT:\n            self.messageQueue.append(self.msgHandler.parseNamedMovementDatagram(dgi))\n            #self.handleNamedMovement(dgi)\n        elif type == CLUSTER_NAMED_MOVEMENT_DONE:\n            #print \"got done\",self.messageQueue\n            #if (len(self.messageQueue) > 0):\n            #    print self.messageQueue[0]\n            #    print dir(self.messageQueue)\n            self.handleMessageQueue()\n        else:\n            self.notify.warning(\"Received unknown packet type:\" % type)\n        return type\n\n    # Server specific tasks\n    def handleCamOffset(self, dgi):\n        \"\"\" Set offset of camera from cameraJig \"\"\"\n        (x, y, z, h, p, r) = self.msgHandler.parseCamOffsetDatagram(dgi)\n        self.camera.setPos(x,y,z)\n        self.lens.setViewHpr(h, p, r)\n\n    def handleCamFrustum(self, dgi):\n        \"\"\" Adjust camera frustum based on parameters sent by client \"\"\"\n        (fl, fs, fo) = self.msgHandler.parseCamFrustumDatagram(dgi)\n        self.lens.setFocalLength(fl)\n        self.lens.setFilmSize(fs[0], fs[1])\n        self.lens.setFilmOffset(fo[0], fo[1])\n\n    def handleNamedMovement(self, data):\n        \"\"\" Update cameraJig position to reflect latest position \"\"\"\n        (name,x, y, z, h, p, r,sx,sy,sz, red, g, b, a, hidden) = data\n        if name in self.objectMappings:\n            self.objectMappings[name].setPosHpr(render, x, y, z, h, p, r)\n            self.objectMappings[name].setScale(render,sx,sy,sz)\n            self.objectMappings[name].setColor(red,g,b,a)\n            if hidden:\n                self.objectMappings[name].hide()\n            else:\n                self.objectMappings[name].show()\n        else:\n            self.notify.debug(\"recieved unknown named object command: \"+name)\n\n    def handleMessageQueue(self):\n        #print(self.messageQueue)\n        for data in self.messageQueue:\n            #print(\"in queue\", dgi)\n            self.handleNamedMovement(data)\n\n        self.messageQueue = []\n\n    def handleCamMovement(self, dgi):\n        \"\"\" Update cameraJig position to reflect latest position \"\"\"\n        (x, y, z, h, p, r) = self.msgHandler.parseCamMovementDatagram(dgi)\n        self.cameraJig.setPosHpr(render, x, y, z, h, p, r)\n        self.fPosReceived = 1\n\n    def handleSelectedMovement(self, dgi):\n        \"\"\" Update cameraJig position to reflect latest position \"\"\"\n        (x, y, z, h, p, r, sx, sy, sz) = self.msgHandler.parseSelectedMovementDatagram(\n            dgi)\n        if getattr(builtins, 'last', None):\n            builtins.last.setPosHprScale(x, y, z, h, p, r, sx, sy, sz)\n\n    def handleTimeData(self, dgi):\n        \"\"\" Update cameraJig position to reflect latest position \"\"\"\n        (frameCount, frameTime, dt) = self.msgHandler.parseTimeDataDatagram(dgi)\n        # Use frame time from client for both real and frame time\n        clock = ClockObject.getGlobalClock()\n        clock.setFrameCount(frameCount)\n        clock.setFrameTime(frameTime)\n        clock.dt = dt\n\n    def handleCommandString(self, dgi):\n        \"\"\" Handle arbitrary command string from client \"\"\"\n        command = self.msgHandler.parseCommandStringDatagram(dgi)\n        try:\n            exec(command, __builtins__)\n        except Exception:\n            pass\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/cluster/ClusterServer.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/dcc9d8a7_ClusterServer.json",
    "doc_id": "doc_109"
  }
}