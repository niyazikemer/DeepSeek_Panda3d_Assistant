{
  "content": "\n# This is built as a subclass instead of an extension so we can define the\n# class variable FuncDict and so we can import DCSubatomicType at the top\n# of the file rather than every time we call the putArg function.\n\nfrom panda3d.core import DatagramIterator\nfrom panda3d.direct import (\n    STInt8,\n    STInt16,\n    STInt32,\n    STInt64,\n    STUint8,\n    STUint16,\n    STUint32,\n    STUint64,\n    STFloat64,\n    STString,\n    STBlob,\n    STBlob32,\n    STInt16array,\n    STInt32array,\n    STUint16array,\n    STUint32array,\n    STInt8array,\n    STUint8array,\n    STUint32uint8array,\n)\n# Import the type numbers\n\n\nclass PyDatagramIterator(DatagramIterator):\n\n    # This is a little helper Dict to replace the huge <if> statement\n    # for trying to match up datagram subatomic types with add funtions\n    # If Python had an O(1) \"case\" statement we would use that instead\n    FuncDict = {\n        STInt8:  DatagramIterator.getInt8,\n        STInt16: DatagramIterator.getInt16,\n        STInt32: DatagramIterator.getInt32,\n        STInt64: DatagramIterator.getInt64,\n        STUint8:  DatagramIterator.getUint8,\n        STUint16: DatagramIterator.getUint16,\n        STUint32: DatagramIterator.getUint32,\n        STUint64: DatagramIterator.getUint64,\n        STFloat64: DatagramIterator.getFloat64,\n        STString: DatagramIterator.getString,\n        STBlob: DatagramIterator.getBlob,\n        STBlob32: DatagramIterator.getBlob32,\n    }\n\n    getChannel = DatagramIterator.getUint64\n\n    def __init__(self, datagram=None, offset=0):\n        if datagram is not None:\n            super().__init__(datagram, offset)\n\n            # Retain a reference to it so that it doesn't get deleted.\n            self.__initialDatagram = datagram\n        else:\n            super().__init__()\n\n    def assign(self, datagram, offset = 0):\n        super().assign(datagram, offset)\n        self.__initialDatagram = datagram\n\n    def getArg(self, subatomicType, divisor=1):\n        # Import the type numbers\n        if divisor == 1:\n            # See if it is in the handy dict\n            getFunc = self.FuncDict.get(subatomicType)\n            if getFunc:\n                retVal = getFunc(self)\n            # No division necessary\n            elif subatomicType == STInt8array:\n                len = self.getUint16()\n                retVal = []\n                for i in range(len):\n                    retVal.append(self.getInt8())\n            elif subatomicType == STInt16array:\n                len = self.getUint16() >> 1\n                retVal = []\n                for i in range(len):\n                    retVal.append(self.getInt16())\n            elif subatomicType == STInt32array:\n                len = self.getUint16() >> 2\n                retVal = []\n                for i in range(len):\n                    retVal.append(self.getInt32())\n            elif subatomicType == STUint8array:\n                len = self.getUint16()\n                retVal = []\n                for i in range(len):\n                    retVal.append(self.getUint8())\n            elif subatomicType == STUint16array:\n                len = self.getUint16() >> 1\n                retVal = []\n                for i in range(len):\n                    retVal.append(self.getUint16())\n            elif subatomicType == STUint32array:\n                len = self.getUint16() >> 2\n                retVal = []\n                for i in range(len):\n                    retVal.append(self.getUint32())\n            elif subatomicType == STUint32uint8array:\n                len = self.getUint16() / 5\n                retVal = []\n                for i in range(len):\n                    a = self.getUint32()\n                    b = self.getUint8()\n                    retVal.append((a, b))\n            else:\n                raise Exception(\"Error: No such type as: \" + str(subatomicType))\n        else:\n            # See if it is in the handy dict\n            getFunc = self.FuncDict.get(subatomicType)\n            if getFunc:\n                retVal = (getFunc(self)/float(divisor))\n            elif subatomicType == STInt8array:\n                len = self.getUint8() >> 1\n                retVal = []\n                for i in range(len):\n                    retVal.append(self.getInt8()/float(divisor))\n            elif subatomicType == STInt16array:\n                len = self.getUint16() >> 1\n                retVal = []\n                for i in range(len):\n                    retVal.append(self.getInt16()/float(divisor))\n            elif subatomicType == STInt32array:\n                len = self.getUint16() >> 2\n                retVal = []\n                for i in range(len):\n                    retVal.append(self.getInt32()/float(divisor))\n            elif subatomicType == STUint8array:\n                len = self.getUint8() >> 1\n                retVal = []\n                for i in range(len):\n                    retVal.append(self.getUint8()/float(divisor))\n            elif subatomicType == STUint16array:\n                len = self.getUint16() >> 1\n                retVal = []\n                for i in range(len):\n                    retVal.append(self.getUint16()/float(divisor))\n            elif subatomicType == STUint32array:\n                len = self.getUint16() >> 2\n                retVal = []\n                for i in range(len):\n                    retVal.append(self.getUint32()/float(divisor))\n            elif subatomicType == STUint32uint8array:\n                len = self.getUint16() / 5\n                retVal = []\n                for i in range(len):\n                    a = self.getUint32()\n                    b = self.getUint8()\n                    retVal.append((a / float(divisor), b / float(divisor)))\n            else:\n                raise Exception(\"Error: No such type as: \" + str(subatomicType))\n\n        return retVal\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/PyDatagramIterator.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/cf472b07_PyDatagramIterator.json",
    "doc_id": "doc_330"
  }
}