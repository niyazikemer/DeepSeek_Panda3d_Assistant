{
  "content": "from panda3d.core import TrueClock\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.showbase.PythonUtil import (\n    StdoutCapture, _installProfileCustomFuncs,_removeProfileCustomFuncs,\n    _getProfileResultFileInfo, _setProfileResultsFileInfo, Default)\nimport profile\nimport pstats\nimport builtins\n\n\nclass PercentStats(pstats.Stats):\n    # prints more useful output when sampled durations are shorter than a millisecond\n    # lots of this is copied from Python's pstats.py\n    def setTotalTime(self, tt):\n        # use this to set 'total time' to base time percentages on\n        # allows profiles to show timing based on percentages of duration of another profile\n        self._totalTime = tt\n\n    def add(self, *args, **kArgs):\n        pstats.Stats.add(self, *args, **kArgs)\n        # DCR -- don't need to record filenames\n        self.files = []\n\n    def print_stats(self, *amount):\n        for filename in self.files:\n            print(filename)\n        if self.files:\n            print()\n        indent = ' ' * 8\n        for func in self.top_level:\n            print(indent, pstats.func_get_function_name(func))\n\n        print(indent, self.total_calls, \"function calls\", end=' ')\n        if self.total_calls != self.prim_calls:\n            print(\"(%d primitive calls)\" % self.prim_calls, end=' ')\n        # DCR\n        #print \"in %.3f CPU seconds\" % self.total_tt\n        print(\"in %s CPU milliseconds\" % (self.total_tt * 1000.))\n        if self._totalTime != self.total_tt:\n            print(indent, 'percentages are of %s CPU milliseconds' % (self._totalTime * 1000))\n        print()\n        width, list = self.get_print_list(amount)\n        if list:\n            self.print_title()\n            for func in list:\n                self.print_line(func)\n            print()\n            # DCR\n            #print\n        return self\n\n    def f8(self, x):\n        if self._totalTime == 0.:\n            # profiling was too quick for clock resolution...\n            return '    Inf%'\n        return \"%7.2f%%\" % ((x*100.) / self._totalTime)\n\n    @staticmethod\n    def func_std_string(func_name): # match what old profile produced\n        return \"%s:%d(%s)\" % func_name\n\n    def print_line(self, func):\n        cc, nc, tt, ct, callers = self.stats[func]\n        c = str(nc)\n        # DCR\n        f8 = self.f8\n        if nc != cc:\n            c = c + '/' + str(cc)\n        print(c.rjust(9), end=' ')\n        print(f8(tt), end=' ')\n        if nc == 0:\n            print(' '*8, end=' ')\n        else:\n            print(f8(tt/nc), end=' ')\n        print(f8(ct), end=' ')\n        if cc == 0:\n            print(' '*8, end=' ')\n        else:\n            print(f8(ct/cc), end=' ')\n        # DCR\n        #print func_std_string(func)\n        print(PercentStats.func_std_string(func))\n\nclass ProfileSession:\n    # class that encapsulates a profile of a single callable using Python's standard\n    # 'profile' module\n    #\n    # defers formatting of profile results until they are requested\n    #\n    # implementation sidesteps memory leak in Python profile module,\n    # and redirects file output to RAM file for efficiency\n    TrueClock = TrueClock.getGlobalPtr()\n\n    notify = directNotify.newCategory(\"ProfileSession\")\n\n    def __init__(self, name, func=None, logAfterProfile=False):\n        self._func = func\n        self._name = name\n        self._logAfterProfile = logAfterProfile\n        self._filenameBase = 'profileData-%s-%s' % (self._name, id(self))\n        self._refCount = 0\n        # if true, accumulate profile results every time we run\n        # if false, throw out old results every time we run\n        self._aggregate = False\n        self._lines = 500\n        self._sorts = ['cumulative', 'time', 'calls']\n        self._callInfo = True\n        self._totalTime = None\n        self._reset()\n        self.acquire()\n\n    def getReference(self):\n        # call this when you want to store a new reference to this session that will\n        # manage its acquire/release reference count independently of an existing reference\n        self.acquire()\n        return self\n\n    def acquire(self):\n        self._refCount += 1\n    def release(self):\n        self._refCount -= 1\n        if not self._refCount:\n            self._destroy()\n\n    def _destroy(self):\n        del self._func\n        del self._name\n        del self._filenameBase\n        del self._filenameCounter\n        del self._filenames\n        del self._duration\n        del self._filename2ramFile\n        del self._resultCache\n        del self._successfulProfiles\n\n    def _reset(self):\n        self._filenameCounter = 0\n        self._filenames = []\n        # index of next file to be added to stats object\n        self._statFileCounter = 0\n        self._successfulProfiles = 0\n        self._duration = None\n        self._filename2ramFile = {}\n        self._stats = None\n        self._resultCache = {}\n\n    def _getNextFilename(self):\n        filename = '%s-%s' % (self._filenameBase, self._filenameCounter)\n        self._filenameCounter += 1\n        return filename\n\n    def run(self):\n        # make sure this instance doesn't get destroyed inside self._func\n        self.acquire()\n\n        if not self._aggregate:\n            self._reset()\n\n        # if we're already profiling, just run the func and don't profile\n        if 'globalProfileSessionFunc' in builtins.__dict__:\n            self.notify.warning('could not profile %s' % self._func)\n            result = self._func()\n            if self._duration is None:\n                self._duration = 0.\n        else:\n            # put the function in the global namespace so that profile can find it\n            assert hasattr(self._func, '__call__')\n            builtins.globalProfileSessionFunc = self._func\n            builtins.globalProfileSessionResult = [None]\n\n            # set up the RAM file\n            self._filenames.append(self._getNextFilename())\n            filename = self._filenames[-1]\n            _installProfileCustomFuncs(filename)\n\n            # do the profiling\n            Profile = profile.Profile\n            statement = 'globalProfileSessionResult[0]=globalProfileSessionFunc()'\n            sort = -1\n            retVal = None\n\n            # this is based on profile.run, the code is replicated here to allow us to\n            # eliminate a memory leak\n            prof = Profile()\n            try:\n                prof = prof.run(statement)\n            except SystemExit:\n                pass\n            # this has to be run immediately after profiling for the timings to be accurate\n            # tell the Profile object to generate output to the RAM file\n            prof.dump_stats(filename)\n\n            # eliminate the memory leak\n            del prof.dispatcher\n\n            # store the RAM file for later\n            profData = _getProfileResultFileInfo(filename)\n            self._filename2ramFile[filename] = profData\n            # calculate the duration (this is dependent on the internal Python profile data format.\n            # see profile.py and pstats.py, this was copied from pstats.Stats.strip_dirs)\n            maxTime = 0.\n            for cc, nc, tt, ct, callers in profData[1].values():\n                if ct > maxTime:\n                    maxTime = ct\n            self._duration = maxTime\n            # clean up the RAM file support\n            _removeProfileCustomFuncs(filename)\n\n            # clean up the globals\n            result = builtins.globalProfileSessionResult[0]\n            del builtins.globalProfileSessionFunc\n            del builtins.globalProfileSessionResult\n\n            self._successfulProfiles += 1\n\n            if self._logAfterProfile:\n                self.notify.info(self.getResults())\n\n        self.release()\n        return result\n\n    def getDuration(self):\n        return self._duration\n\n    def profileSucceeded(self):\n        return self._successfulProfiles > 0\n\n    def _restoreRamFile(self, filename):\n        # set up the RAM file\n        _installProfileCustomFuncs(filename)\n        # install the stored RAM file from self.run()\n        _setProfileResultsFileInfo(filename, self._filename2ramFile[filename])\n\n    def _discardRamFile(self, filename):\n        # take down the RAM file\n        _removeProfileCustomFuncs(filename)\n        # and discard it\n        del self._filename2ramFile[filename]\n\n    def setName(self, name):\n        self._name = name\n    def getName(self):\n        return self._name\n\n    def setFunc(self, func):\n        self._func = func\n    def getFunc(self):\n        return self._func\n\n    def setAggregate(self, aggregate):\n        self._aggregate = aggregate\n    def getAggregate(self):\n        return self._aggregate\n\n    def setLogAfterProfile(self, logAfterProfile):\n        self._logAfterProfile = logAfterProfile\n    def getLogAfterProfile(self):\n        return self._logAfterProfile\n\n    def setLines(self, lines):\n        self._lines = lines\n    def getLines(self):\n        return self._lines\n\n    def setSorts(self, sorts):\n        self._sorts = sorts\n    def getSorts(self):\n        return self._sorts\n\n    def setShowCallInfo(self, showCallInfo):\n        self._showCallInfo = showCallInfo\n    def getShowCallInfo(self):\n        return self._showCallInfo\n\n    def setTotalTime(self, totalTime=None):\n        self._totalTime = totalTime\n    def resetTotalTime(self):\n        self._totalTime = None\n    def getTotalTime(self):\n        return self._totalTime\n\n    def aggregate(self, other):\n        # pull in stats from another ProfileSession\n        other._compileStats()\n        self._compileStats()\n        self._stats.add(other._stats)\n\n    def _compileStats(self):\n        # make sure our stats object exists and is up-to-date\n        statsChanged = (self._statFileCounter < len(self._filenames))\n\n        if self._stats is None:\n            for filename in self._filenames:\n                self._restoreRamFile(filename)\n            self._stats = PercentStats(*self._filenames)\n            self._statFileCounter = len(self._filenames)\n            for filename in self._filenames:\n                self._discardRamFile(filename)\n        else:\n            while self._statFileCounter < len(self._filenames):\n                filename = self._filenames[self._statFileCounter]\n                self._restoreRamFile(filename)\n                self._stats.add(filename)\n                self._discardRamFile(filename)\n\n        if statsChanged:\n            self._stats.strip_dirs()\n            # throw out any cached result strings\n            self._resultCache = {}\n\n        return statsChanged\n\n    def getResults(self,\n                   lines=Default,\n                   sorts=Default,\n                   callInfo=Default,\n                   totalTime=Default):\n        if not self.profileSucceeded():\n            output = '%s: profiler already running, could not profile' % self._name\n        else:\n            if lines is Default:\n                lines = self._lines\n            if sorts is Default:\n                sorts = self._sorts\n            if callInfo is Default:\n                callInfo = self._callInfo\n            if totalTime is Default:\n                totalTime = self._totalTime\n\n            self._compileStats()\n\n            if totalTime is None:\n                totalTime = self._stats.total_tt\n\n            # make sure the arguments will hash efficiently if callers provide different types\n            lines = int(lines)\n            sorts = list(sorts)\n            callInfo = bool(callInfo)\n            totalTime = float(totalTime)\n            k = str((lines, sorts, callInfo, totalTime))\n            if k in self._resultCache:\n                # we've already created this output string, get it from the cache\n                output = self._resultCache[k]\n            else:\n                # now get human-readable output from the profile stats\n\n                # capture print output to a string\n                sc = StdoutCapture()\n\n                # print the info to stdout\n                s = self._stats\n                # make sure our percentages are relative to the correct total time\n                s.setTotalTime(totalTime)\n                for sort in sorts:\n                    s.sort_stats(sort)\n                    s.print_stats(lines)\n                    if callInfo:\n                        s.print_callees(lines)\n                        s.print_callers(lines)\n\n                # make a copy of the print output\n                output = sc.getString()\n\n                # restore stdout to what it was before\n                sc.destroy()\n\n                # cache this result\n                self._resultCache[k] = output\n\n        return output\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/ProfileSession.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/1629146a_ProfileSession.json",
    "doc_id": "doc_288"
  }
}