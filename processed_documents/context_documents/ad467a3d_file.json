{
  "content": "\"\"\" This module reimplements Python's file I/O mechanisms using Panda\nconstructs.  This enables Python to interface more easily with Panda's\nvirtual file system, and it also better-supports Panda's\nSIMPLE_THREADS model, by avoiding blocking all threads while waiting\nfor I/O to complete. \"\"\"\n\n__all__ = [\n    'open', 'listdir', 'walk', 'join',\n    'isfile', 'isdir', 'exists', 'lexists', 'getmtime', 'getsize',\n    'execfile',\n]\n\nfrom panda3d import core\nimport os\nimport io\nfrom posixpath import join\n\n_vfs = core.VirtualFileSystem.getGlobalPtr()\n\n\ndef open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True):\n    \"\"\"This function emulates the built-in Python open() function, additionally\n    providing support for Panda's virtual file system.  It takes the same\n    arguments as Python's built-in open() function.\n    \"\"\"\n\n    for ch in mode:\n        if ch not in 'rwxabt+U':\n            raise ValueError(\"invalid mode: '%s'\" % (mode))\n\n    creating = 'x' in mode\n    writing = 'w' in mode\n    appending = 'a' in mode\n    updating = '+' in mode\n    binary = 'b' in mode\n    universal = 'U' in mode\n    reading = universal or 'r' in mode\n\n    if binary and 't' in mode:\n        raise ValueError(\"can't have text and binary mode at once\")\n\n    if creating + reading + writing + appending > 1:\n        raise ValueError(\"must have exactly one of create/read/write/append mode\")\n\n    if binary:\n        if encoding:\n            raise ValueError(\"binary mode doesn't take an encoding argument\")\n        if errors:\n            raise ValueError(\"binary mode doesn't take an errors argument\")\n        if newline:\n            raise ValueError(\"binary mode doesn't take a newline argument\")\n\n    if isinstance(file, core.Istream) or isinstance(file, core.Ostream):\n        # If we were given a stream instead of a filename, assign\n        # it directly.\n        raw = StreamIOWrapper(file)\n        raw.mode = mode\n\n    else:\n        vfile = None\n\n        if isinstance(file, core.VirtualFile):\n            # We can also \"open\" a VirtualFile object for reading.\n            vfile = file\n            filename = vfile.getFilename()\n        elif isinstance(file, str):\n            # If a raw string is given, assume it's an os-specific\n            # filename.\n            filename = core.Filename.fromOsSpecificW(file)\n        else:\n            # It's either a Filename object or an os.PathLike.\n            # If a Filename is given, make a writable copy anyway.\n            filename = core.Filename(file)\n\n        filename.setBinary()\n\n        if not vfile:\n            vfile = _vfs.getFile(filename)\n\n        if not vfile:\n            if reading:\n                raise FileNotFoundError(\"No such file or directory: '%s'\" % (filename))\n\n            vfile = _vfs.createFile(filename)\n            if not vfile:\n                raise IOError(\"Failed to create file: '%s'\" % (filename))\n\n        elif creating:\n            # In 'creating' mode, we have to raise FileExistsError\n            # if the file already exists.  Otherwise, it's the same\n            # as 'writing' mode.\n            raise FileExistsError(\"File exists: '%s'\" % (filename))\n\n        elif vfile.isDirectory():\n            raise IsADirectoryError(\"Is a directory: '%s'\" % (filename))\n\n        # Actually open the streams.\n        if reading:\n            if updating:\n                stream = vfile.openReadWriteFile(False)\n            else:\n                stream = vfile.openReadFile(False)\n\n            if not stream:\n                raise IOError(\"Could not open %s for reading\" % (filename))\n\n        elif writing or creating:\n            if updating:\n                stream = vfile.openReadWriteFile(True)\n            else:\n                stream = vfile.openWriteFile(False, True)\n\n            if not stream:\n                raise IOError(\"Could not open %s for writing\" % (filename))\n\n        elif appending:\n            if updating:\n                stream = vfile.openReadAppendFile()\n            else:\n                stream = vfile.openAppendFile()\n\n            if not stream:\n                raise IOError(\"Could not open %s for appending\" % (filename))\n\n        else:\n            raise ValueError(\"Must have exactly one of create/read/write/append mode and at most one plus\")\n\n        raw = StreamIOWrapper(stream, needsVfsClose=True)\n        raw.mode = mode\n        raw.name = vfile.getFilename().toOsSpecific()\n\n    # If a binary stream was requested, return the stream we've created.\n    if binary:\n        return raw\n\n    line_buffering = False\n    if buffering == 1:\n        line_buffering = True\n    elif buffering == 0:\n        raise ValueError(\"can't have unbuffered text I/O\")\n\n    # Otherwise, create a TextIOWrapper object to wrap it.\n    wrapper = io.TextIOWrapper(raw, encoding, errors, newline, line_buffering)\n    wrapper.mode = mode\n    return wrapper\n\n\nclass StreamIOWrapper(io.IOBase):\n    \"\"\" This is a file-like object that wraps around a C++ istream and/or\n    ostream object.  It only deals with binary data; to work with text I/O,\n    create an io.TextIOWrapper object around this, or use the open()\n    function that is also provided with this module. \"\"\"\n\n    def __init__(self, stream, needsVfsClose=False):\n        self.__stream = stream\n        self.__needsVfsClose = needsVfsClose\n        self.__reader = None\n        self.__writer = None\n        self.__lastWrite = False\n\n        if isinstance(stream, core.Istream):\n            self.__reader = core.StreamReader(stream, False)\n\n        if isinstance(stream, core.Ostream):\n            self.__writer = core.StreamWriter(stream, False)\n            self.__lastWrite = True\n            self.__write = self.__writer.appendData\n\n    def __repr__(self):\n        s = \"<direct.stdpy.file.StreamIOWrapper\"\n        if hasattr(self, 'name'):\n            s += \" name='%s'\" % (self.name)\n        if hasattr(self, 'mode'):\n            s += \" mode='%s'\" % (self.mode)\n        s += \">\"\n        return s\n\n    def readable(self):\n        return self.__reader is not None\n\n    def writable(self):\n        return self.__writer is not None\n\n    def close(self):\n        if self.__needsVfsClose:\n            if self.__reader and self.__writer:\n                _vfs.closeReadWriteFile(self.__stream)\n            elif self.__reader:\n                _vfs.closeReadFile(self.__stream)\n            else:  # self.__writer:\n                _vfs.closeWriteFile(self.__stream)\n\n            self.__needsVfsClose = False\n\n        self.__stream = None\n        self.__reader = None\n        self.__writer = None\n\n    def flush(self):\n        if self.__writer:\n            self.__stream.clear()  # clear eof flag\n            self.__stream.flush()\n\n    def read(self, size=-1):\n        if not self.__reader:\n            if not self.__writer:\n                # The stream is not even open at all.\n                raise ValueError(\"I/O operation on closed file\")\n\n            # The stream is open only in write mode.\n            raise IOError(\"Attempt to read from write-only stream\")\n\n        self.__stream.clear()  # clear eof flag\n        self.__lastWrite = False\n        if size is not None and size >= 0:\n            return self.__reader.extractBytes(size)\n        else:\n            # Read to end-of-file.\n            result = bytearray()\n            while not self.__stream.eof():\n                result += self.__reader.extractBytes(4096)\n            return bytes(result)\n\n    read1 = read\n\n    def readline(self, size=-1):\n        if not self.__reader:\n            if not self.__writer:\n                # The stream is not even open at all.\n                raise ValueError(\"I/O operation on closed file\")\n\n            # The stream is open only in write mode.\n            raise IOError(\"Attempt to read from write-only stream\")\n\n        self.__stream.clear()  # clear eof flag\n        self.__lastWrite = False\n        return self.__reader.readline()\n\n    def seek(self, offset, whence = 0):\n        if self.__stream:\n            self.__stream.clear()  # clear eof flag\n        if self.__reader:\n            self.__stream.seekg(offset, whence)\n        if self.__writer:\n            self.__stream.seekp(offset, whence)\n\n    def tell(self):\n        if self.__lastWrite:\n            if self.__writer:\n                return self.__stream.tellp()\n        else:\n            if self.__reader:\n                return self.__stream.tellg()\n        raise ValueError(\"I/O operation on closed file\")\n\n    def write(self, b):\n        if not self.__writer:\n            if not self.__reader:\n                # The stream is not even open at all.\n                raise ValueError(\"I/O operation on closed file\")\n\n            # The stream is open only in read mode.\n            raise IOError(\"Attempt to write to read-only stream\")\n\n        self.__stream.clear()  # clear eof flag\n        self.__write(b)\n        self.__lastWrite = True\n        return len(b)\n\n    def writelines(self, lines):\n        if not self.__writer:\n            if not self.__reader:\n                # The stream is not even open at all.\n                raise ValueError(\"I/O operation on closed file\")\n\n            # The stream is open only in read mode.\n            raise IOError(\"Attempt to write to read-only stream\")\n\n        self.__stream.clear()  # clear eof flag\n        for line in lines:\n            self.__write(line)\n        self.__lastWrite = True\n\n\ndef listdir(path):\n    \"\"\" Implements os.listdir over vfs. \"\"\"\n    files = []\n    dirlist = _vfs.scanDirectory(core.Filename.fromOsSpecific(path))\n    if dirlist is None:\n        raise OSError(\"No such file or directory: '%s'\" % (path))\n\n    for file in dirlist:\n        files.append(file.getFilename().getBasename())\n    return files\n\n\ndef walk(top, topdown = True, onerror = None, followlinks = True):\n    \"\"\" Implements os.walk over vfs.\n\n    Note: we don't support onerror or followlinks; errors are ignored\n    and links are always followed. \"\"\"\n\n    dirnames = []\n    filenames = []\n\n    dirlist = _vfs.scanDirectory(top)\n    if dirlist:\n        for file in dirlist:\n            if file.isDirectory():\n                dirnames.append(file.getFilename().getBasename())\n            else:\n                filenames.append(file.getFilename().getBasename())\n\n    if topdown:\n        yield (top, dirnames, filenames)\n\n    for dir in dirnames:\n        next = join(top, dir)\n        for tuple in walk(next, topdown = topdown):\n            yield tuple\n\n    if not topdown:\n        yield (top, dirnames, filenames)\n\n\ndef isfile(path):\n    return _vfs.isRegularFile(core.Filename.fromOsSpecific(path))\n\n\ndef isdir(path):\n    return _vfs.isDirectory(core.Filename.fromOsSpecific(path))\n\n\ndef exists(path):\n    return _vfs.exists(core.Filename.fromOsSpecific(path))\n\n\ndef lexists(path):\n    return _vfs.exists(core.Filename.fromOsSpecific(path))\n\n\ndef getmtime(path):\n    file = _vfs.getFile(core.Filename.fromOsSpecific(path), True)\n    if not file:\n        raise os.error\n    return file.getTimestamp()\n\n\ndef getsize(path):\n    file = _vfs.getFile(core.Filename.fromOsSpecific(path), True)\n    if not file:\n        raise os.error\n    return file.getFileSize()\n\n\ndef execfile(path, globals=None, locals=None):\n    file = _vfs.getFile(core.Filename.fromOsSpecific(path), True)\n    if not file:\n        raise os.error\n\n    data = file.readFile(False)\n    exec(data, globals, locals)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/stdpy/file.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/ad467a3d_file.json",
    "doc_id": "doc_204"
  }
}