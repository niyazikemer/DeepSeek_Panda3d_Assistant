{
  "content": "MeshDrawer\n\n.MeshDrawer is a class with which you can draw geometry every frame as fast as possible. Common cases where you might want to use it include: projectiles such as bullets, trails, and laser beams; and UI elements such as health bars, labels, icons, and motion lines.\n\nYou create a MeshDrawer like this:\n\npython\n\ngenerator = MeshDrawer()\ngenerator.setBudget(1000)\ngeneratorNode = generator.getRoot()\ngeneratorNode.reparentTo(render)\n\ncpp\n\n#include \"meshDrawer.h\"\n...\nMeshDrawer generator = MeshDrawer();\ngenerator.set_budget(1000);\nNodePath generatorNode = generator.get_root();\ngeneratorNode.reparent_to(window->get_render());\n\nBasically this creates a MeshDrawer that will draw at most 1000 triangles or 500 billboarded quads on screen. Then it gets the root node inside the MeshDrawer that has the geom that will be morphed into any thing you like.\n\nYou might also disable depth write, enable transparency, set two sided, add a texture and re parent the geom to a fixed bin and render without lights. What this code does is outside the mesh drawer and is done strictly to the node and you probably had to do this to the special FX node's you have any ways.\n\npython\n\ngeneratorNode.setDepthWrite(False)\ngeneratorNode.setTransparency(True)\ngeneratorNode.setTwoSided(True)\ngeneratorNode.setTexture(loader.loadTexture(\"radarplate.png\"))\ngeneratorNode.setBin(\"fixed\",0)\ngeneratorNode.setLightOff(True)\n\ncpp\n\ngeneratorNode.set_depth_write(false);\ngeneratorNode.set_transparency(TransparencyAttrib::M_alpha);\ngeneratorNode.set_two_sided(true);\ngeneratorNode.set_texture(TexturePool::load_texture(\"radarplate.png\"));\ngeneratorNode.set_bin(\"fixed\",0);\ngeneratorNode.set_light_off();\n\nThe MeshDrawer is used in kind of an old style draw loop. I recommend creating a specific task for MeshDrawer so that you can see how much time it eats up using pstats. To the begin call you need to pass the render and base.cam so that mesh drawer can figure out correct facing for billboards. A lot of FX require billboards so it makes sense to precompute some of this facing stuff at the start.\n\npython\n\ndef drawtask(task):\n    generator.begin(base.cam,render)\n\n    ... your draw code ...\n\n    generator.end()\n    return task.cont\n\ntaskMgr.add(drawtask, \"meshdrawer task\")\n\ncpp\n\nvoid drawTask() {\n  // You'll need access to the window and the generator\n  // Call this method in your update or use a task.\n  generator.begin(window->get_camera_group(), window->get_render());\n\n  ... your draw code ...\n\n  generator.end()\n}\n\nSee the ~panda3d.core.MeshDrawer page in the API Reference to see a complete overview of the available methods.\n\nMany of the calls take a frame of Vec4() type. The frame is the Vec4(x,y,width,height) coordinates inside the texture. Frame of Vec4(0,0,1,1) would be the entire texture while Vec4(0,0,.5.5) would be NW quarter of the texture. Note that the Vec4 coordinates starts counting from the bottom left, counting to the top right. If you had a 16x16 plate, the 15th field in the 11th row would be: Vec4(14.0/16,5.0/16,1.0/16,1.0/16.)\n\nThis is use full to create palletized textures and show only small parts of the texture per billboard. For instance you might have a images of the entire forest in one texture and only render the trees you want by specifying their UV cords.\n\nMeshDrawer works by using calls similar to Panda3D's animation system and basically creates a buffer of undefined vertices which is then morphed into the shape you specify. Triangles which don't get used are turned into micro (0,0,0) triangles so that they will not be visible. Then those vertices are shipped to the GPU every frame, it's good to keep a low count of triangles in this buffer. This is also why the begin and end are needed to mark the vertex as being edited and then submit them back to Panda3D when finished.\n\nYou can also take a look at ~panda3d.core.MeshDrawer2D.\n\nIt follows a similar pattern as MeshDrawer but has stuff that is useful to draw in 2d. Major differences is that its begin() takes no arguments and it deals mostly with rectangles and borders around them. It also has a setClip function which clips rectangles as they are drawn. This is very useful to draw rectangles that appear to be inside other rectangles and be clipped by their parents. It has only the low level abstraction on which you would have to build your own UI components, or you can take a look at TreeGUI.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/7fe92637_meshdrawer.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/97490678_7fe92637_meshdrawer.json",
    "doc_id": "doc_460"
  }
}