{
  "content": "\"\"\"\n\nThe FilterManager is a convenience class that helps with the creation\nof render-to-texture buffers for image postprocessing applications.\n\nSee :ref:`generalized-image-filters` for information on how to use this class.\n\nStill need to implement:\n\n* Make sure sort-order of buffers is correct.\n* Matching buffer size to original region instead of original window.\n* Intermediate layer creation.\n* Handling of window clears.\n* Resizing of windows.\n* Do something about window-size roundoff problems.\n\n\"\"\"\n\nfrom panda3d.core import NodePath\nfrom panda3d.core import Texture\nfrom panda3d.core import CardMaker\nfrom panda3d.core import GraphicsPipe, GraphicsOutput\nfrom panda3d.core import WindowProperties, FrameBufferProperties\nfrom panda3d.core import Camera\nfrom panda3d.core import OrthographicLens\nfrom panda3d.core import AuxBitplaneAttrib\nfrom panda3d.core import LightRampAttrib\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.showbase.DirectObject import DirectObject\n\n__all__ = [\"FilterManager\"]\n\nclass FilterManager(DirectObject):\n\n    notify = None\n\n    def __init__(self, win, cam, forcex=0, forcey=0):\n\n        \"\"\" The FilterManager constructor requires you to provide\n        a window which is rendering a scene, and the camera which is\n        used by that window to render the scene.  These are henceforth\n        called the 'original window' and the 'original camera.' \"\"\"\n\n        # Create the notify category\n\n        if FilterManager.notify is None:\n            FilterManager.notify = directNotify.newCategory(\"FilterManager\")\n\n        # Find the appropriate display region.\n\n        region = None\n        for dr in win.getDisplayRegions():\n            drcam = dr.getCamera()\n            if drcam == cam:\n                region = dr\n\n        if region is None:\n            self.notify.error('Could not find appropriate DisplayRegion to filter')\n            return\n\n        # Instance Variables.\n\n        self.win = win\n        self.forcex = forcex\n        self.forcey = forcey\n        self.engine = win.getGsg().getEngine()\n        self.region = region\n        self.wclears = self.getClears(self.win)\n        self.rclears = self.getClears(self.region)\n        self.camera = cam\n        self.caminit = cam.node().getInitialState()\n        self.camstate = self.caminit\n        self.buffers = []\n        self.sizes = []\n        self.nextsort = self.win.getSort() - 9\n        self.basex = 0\n        self.basey = 0\n        self.accept(\"window-event\", self.windowEvent)\n\n\n    def getClears(self, region):\n        clears = []\n        for i in range(GraphicsOutput.RTPCOUNT):\n            clears.append((region.getClearActive(i), region.getClearValue(i)))\n        return clears\n\n    def setClears(self, region, clears):\n        for i in range(GraphicsOutput.RTPCOUNT):\n            (active, value) = clears[i]\n            region.setClearActive(i, active)\n            region.setClearValue(i, value)\n\n    def setStackedClears(self, region, clears0, clears1):\n        clears = []\n        for i in range(GraphicsOutput.RTPCOUNT):\n            (active, value) = clears0[i]\n            if not active:\n                (active, value) = clears1[i]\n            region.setClearActive(i, active)\n            region.setClearValue(i, value)\n        return clears\n\n    def isFullscreen(self):\n        return ((self.region.getLeft()   == 0.0) and\n                (self.region.getRight()  == 1.0) and\n                (self.region.getBottom() == 0.0) and\n                (self.region.getTop()    == 1.0))\n\n    def getScaledSize(self, mul, div, align):\n        \"\"\" Calculate the size of the desired window. Not public. \"\"\"\n\n        winx = self.forcex\n        winy = self.forcey\n        if winx == 0:\n            winx = self.win.getXSize()\n        if winy == 0:\n            winy = self.win.getYSize()\n\n        if div != 1:\n            winx = ((winx+align-1) // align) * align\n            winy = ((winy+align-1) // align) * align\n            winx = winx // div\n            winy = winy // div\n\n        if mul != 1:\n            winx = int(round(winx * mul))\n            winy = int(round(winy * mul))\n\n        return winx,winy\n\n    def renderSceneInto(self, depthtex=None, colortex=None, auxtex=None, auxbits=0, textures=None, fbprops=None, clamping=None):\n\n        \"\"\" Causes the scene to be rendered into the supplied textures\n        instead of into the original window.  Puts a fullscreen quad\n        into the original window to show the render-to-texture results.\n        Returns the quad.  Normally, the caller would then apply a\n        shader to the quad.\n\n        To elaborate on how this all works:\n\n        * An offscreen buffer is created.  It is set up to mimic\n          the original display region - it is the same size,\n          uses the same clear colors, and contains a DisplayRegion\n          that uses the original camera.\n\n        * A fullscreen quad and an orthographic camera to render\n          that quad are both created.  The original camera is\n          removed from the original window, and in its place, the\n          orthographic quad-camera is installed.\n\n        * The fullscreen quad is textured with the data from the\n          offscreen buffer.  A shader is applied that tints the\n          results pink.\n\n        * Automatic shader generation NOT enabled.\n          If you have a filter that depends on a render target from\n          the auto-shader, you either need to set an auto-shader\n          attrib on the main camera or scene, or, you need to provide\n          these outputs in your own shader.\n\n        * All clears are disabled on the original display region.\n          If the display region fills the whole window, then clears\n          are disabled on the original window as well.  It is\n          assumed that rendering the full-screen quad eliminates\n          the need to do clears.\n\n        Hence, the original window which used to contain the actual\n        scene, now contains a pink-tinted quad with a texture of the\n        scene.  It is assumed that the user will replace the shader\n        on the quad with a more interesting filter. \"\"\"\n\n        if textures:\n            colortex = textures.get(\"color\", None)\n            depthtex = textures.get(\"depth\", None)\n            auxtex = textures.get(\"aux\", None)\n            auxtex0 = textures.get(\"aux0\", auxtex)\n            auxtex1 = textures.get(\"aux1\", None)\n        else:\n            auxtex0 = auxtex\n            auxtex1 = None\n\n        if colortex is None:\n            colortex = Texture(\"filter-base-color\")\n            colortex.setWrapU(Texture.WMClamp)\n            colortex.setWrapV(Texture.WMClamp)\n\n        texgroup = (depthtex, colortex, auxtex0, auxtex1)\n\n        # Choose the size of the offscreen buffer.\n\n        (winx, winy) = self.getScaledSize(1,1,1)\n        if fbprops is not None:\n            buffer = self.createBuffer(\"filter-base\", winx, winy, texgroup, fbprops=fbprops)\n        else:\n            buffer = self.createBuffer(\"filter-base\", winx, winy, texgroup)\n\n        if buffer is None:\n            return None\n\n        cm = CardMaker(\"filter-base-quad\")\n        cm.setFrameFullscreenQuad()\n        quad = NodePath(cm.generate())\n        quad.setDepthTest(0)\n        quad.setDepthWrite(0)\n        quad.setTexture(colortex)\n        quad.setColor(1, 0.5, 0.5, 1)\n\n        cs = NodePath(\"dummy\")\n        cs.setState(self.camstate)\n        # Do we really need to turn on the Shader Generator?\n        #cs.setShaderAuto()\n        if auxbits:\n            cs.setAttrib(AuxBitplaneAttrib.make(auxbits))\n        if clamping is False:\n            # Disables clamping in the shader generator.\n            cs.setAttrib(LightRampAttrib.make_identity())\n        self.camera.node().setInitialState(cs.getState())\n\n        quadcamnode = Camera(\"filter-quad-cam\")\n        lens = OrthographicLens()\n        lens.setFilmSize(2, 2)\n        lens.setFilmOffset(0, 0)\n        lens.setNearFar(-1000, 1000)\n        quadcamnode.setLens(lens)\n        quadcam = quad.attachNewNode(quadcamnode)\n\n        self.region.setCamera(quadcam)\n\n        self.setStackedClears(buffer, self.rclears, self.wclears)\n        if auxtex0:\n            buffer.setClearActive(GraphicsOutput.RTPAuxRgba0, 1)\n            buffer.setClearValue(GraphicsOutput.RTPAuxRgba0, (0.5, 0.5, 1.0, 0.0))\n        if auxtex1:\n            buffer.setClearActive(GraphicsOutput.RTPAuxRgba1, 1)\n        self.region.disableClears()\n        if self.isFullscreen():\n            self.win.disableClears()\n\n        dr = buffer.makeDisplayRegion()\n        dr.disableClears()\n        dr.setCamera(self.camera)\n        dr.setActive(1)\n\n        self.buffers.append(buffer)\n        self.sizes.append((1, 1, 1))\n\n        return quad\n\n    def renderQuadInto(self, name=\"filter-stage\", mul=1, div=1, align=1, depthtex=None, colortex=None, auxtex0=None, auxtex1=None, fbprops=None):\n\n        \"\"\" Creates an offscreen buffer for an intermediate\n        computation. Installs a quad into the buffer.  Returns\n        the fullscreen quad.  The size of the buffer is initially\n        equal to the size of the main window.  The parameters 'mul',\n        'div', and 'align' can be used to adjust that size. \"\"\"\n\n        texgroup = (depthtex, colortex, auxtex0, auxtex1)\n\n        winx, winy = self.getScaledSize(mul, div, align)\n\n        depthbits = int(depthtex is not None)\n\n        if fbprops is not None:\n            buffer = self.createBuffer(name, winx, winy, texgroup, depthbits, fbprops=fbprops)\n        else:\n            buffer = self.createBuffer(name, winx, winy, texgroup, depthbits)\n\n        if buffer is None:\n            return None\n\n        cm = CardMaker(\"filter-stage-quad\")\n        cm.setFrameFullscreenQuad()\n        quad = NodePath(cm.generate())\n        quad.setDepthTest(0)\n        quad.setDepthWrite(0)\n        quad.setColor(1, 0.5, 0.5, 1)\n\n        quadcamnode = Camera(\"filter-quad-cam\")\n        lens = OrthographicLens()\n        lens.setFilmSize(2, 2)\n        lens.setFilmOffset(0, 0)\n        lens.setNearFar(-1000, 1000)\n        quadcamnode.setLens(lens)\n        quadcam = quad.attachNewNode(quadcamnode)\n\n        dr = buffer.makeDisplayRegion((0, 1, 0, 1))\n        dr.disableClears()\n        dr.setCamera(quadcam)\n        dr.setActive(True)\n        dr.setScissorEnabled(False)\n\n        # This clear stage is important if the buffer is padded, so that\n        # any pixels accidentally sampled in the padded region won't\n        # be reading from unititialised memory.\n        buffer.setClearColor((0, 0, 0, 1))\n        buffer.setClearColorActive(True)\n\n        self.buffers.append(buffer)\n        self.sizes.append((mul, div, align))\n\n        return quad\n\n    def createBuffer(self, name, xsize, ysize, texgroup, depthbits=True, fbprops=None):\n        \"\"\" Low-level buffer creation.  Not intended for public use. \"\"\"\n\n        winprops = WindowProperties()\n        winprops.setSize(xsize, ysize)\n        props = FrameBufferProperties(FrameBufferProperties.getDefault())\n        props.setBackBuffers(0)\n        props.setRgbColor(1)\n        if depthbits is True:\n            # Respect depth-bits from Config.prc\n            if props.getDepthBits() == 0:\n                props.setDepthBits(1)\n        else:\n            props.setDepthBits(depthbits)\n        props.setStereo(self.win.isStereo())\n        if fbprops is not None:\n            props.addProperties(fbprops)\n\n        depthtex, colortex, auxtex0, auxtex1 = texgroup\n        if auxtex0 is not None:\n            props.setAuxRgba(1)\n        if auxtex1 is not None:\n            props.setAuxRgba(2)\n        buffer=self.engine.makeOutput(\n            self.win.getPipe(), name, -1,\n            props, winprops, GraphicsPipe.BFRefuseWindow | GraphicsPipe.BFResizeable,\n            self.win.getGsg(), self.win)\n        if buffer is None:\n            return buffer\n        if depthtex:\n            buffer.addRenderTexture(depthtex, GraphicsOutput.RTMBindOrCopy, GraphicsOutput.RTPDepth)\n        if colortex:\n            buffer.addRenderTexture(colortex, GraphicsOutput.RTMBindOrCopy, GraphicsOutput.RTPColor)\n        if auxtex0:\n            buffer.addRenderTexture(auxtex0, GraphicsOutput.RTMBindOrCopy, GraphicsOutput.RTPAuxRgba0)\n        if auxtex1:\n            buffer.addRenderTexture(auxtex1, GraphicsOutput.RTMBindOrCopy, GraphicsOutput.RTPAuxRgba1)\n        buffer.setSort(self.nextsort)\n        buffer.disableClears()\n        self.nextsort += 1\n        return buffer\n\n    def windowEvent(self, win):\n        \"\"\" When the window changes size, automatically resize all buffers \"\"\"\n        self.resizeBuffers()\n\n    def resizeBuffers(self):\n        \"\"\" Resize all buffers to match the size of the window. \"\"\"\n        for i, buffer in enumerate(self.buffers):\n            (mul, div, align) = self.sizes[i]\n            (xsize, ysize) = self.getScaledSize(mul, div, align)\n            buffer.setSize(xsize, ysize)\n\n    def cleanup(self):\n        \"\"\" Restore everything to its original state, deleting any\n        new buffers in the process. \"\"\"\n\n        for buffer in self.buffers:\n            buffer.clearRenderTextures()\n            self.engine.removeWindow(buffer)\n        self.buffers = []\n        self.sizes = []\n        self.setClears(self.win, self.wclears)\n        self.setClears(self.region, self.rclears)\n        self.camstate = self.caminit\n        self.camera.node().setInitialState(self.caminit)\n        self.region.setCamera(self.camera)\n        if hasattr(self.region, 'clearCullResult'):\n            self.region.clearCullResult()\n        self.nextsort = self.win.getSort() - 9\n        self.basex = 0\n        self.basey = 0\n\n    #snake_case alias:\n    is_fullscreen = isFullscreen\n    resize_buffers = resizeBuffers\n    set_stacked_clears = setStackedClears\n    render_scene_into = renderSceneInto\n    get_scaled_size = getScaledSize\n    render_quad_into = renderQuadInto\n    get_clears = getClears\n    set_clears = setClears\n    create_buffer = createBuffer\n    window_event = windowEvent\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/filter/FilterManager.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/3cf0b482_FilterManager.json",
    "doc_id": "doc_221"
  }
}