{
  "content": "Bullet Continuous Collision Detection\n\nCCD is short for Continuous Collision Detection, which is a workaround for a common problem in game physics: a fast moving body might not collide with an obstacle if in one frame it is \"before\" the obstacle, and in the next one it is already \"behind\" the obstacle. At no frame the fast moving body overlaps with the obstacle, and thus no response is created. This is what CCD is for. CCD checks for collisions in between frames, and thus can prevent fast moving objects from passing through thin obstacles.\n\nBullet has built-in support for CCD, but bodies have to be configured properly to enable CCD checks.\n\nWhen checking for collision in between frames Bullet does not use the full collision shape (or shapes) of a body - this would make continuous collision detection too slow. Instead Bullet uses a sphere shape, the so-called \"swept sphere\". \"swept\" because the sphere is swept from the original position to the new position of the body. So, in order to enable CCD checks on a body we have to setup this sphere, and a CCD motion threshold:\n\npython\n\nbodyNP.node().setCcdMotionThreshold(1e-7)\nbodyNP.node().setCcdSweptSphereRadius(0.50)\n\ncpp\n\nTODO\n\nWe have to set up the swept sphere only on the fast moving dynamic bodies. There is no need to do anything for the static or slow moving obstacles.\n\nOne particular use for CCD is firing a bullet (bullet is lowercase here, indicating that a projectile is meant, not the Bullet physics engine). Below is a sample showing one way to implement shooting bullets.\n\npython\n\nbullets = []\n\ndef removeBullet(task):\n  if len(bullets) < 1: return\n\n  bulletNP = bullets.pop(0)\n  world.removeRigidBody(bulletNP.node())\n\n  return task.done\n\ndef shootBullet(ccd):\n  # Get from/to points from mouse click\n  pMouse = base.mouseWatcherNode.getMouse()\n  pFrom = Point3()\n  pTo = Point3()\n  base.camLens.extrude(pMouse, pFrom, pTo)\n\n  pFrom = render.getRelativePoint(base.cam, pFrom)\n  pTo = render.getRelativePoint(base.cam, pTo)\n\n  # Calculate initial velocity\n  v = pTo - pFrom\n  v.normalize()\n  v *= 10000.0\n\n  # Create bullet\n  shape = BulletBoxShape(Vec3(0.5, 0.5, 0.5))\n  body = BulletRigidBodyNode('Bullet')\n  bodyNP = render.attachNewNode(body)\n  bodyNP.node().addShape(shape)\n  bodyNP.node().setMass(2.0)\n  bodyNP.node().setLinearVelocity(v)\n  bodyNP.setPos(pFrom)\n  bodyNP.setCollideMask(BitMask32.allOn())\n\n  # Enable CCD\n  bodyNP.node().setCcdMotionThreshold(1e-7)\n  bodyNP.node().setCcdSweptSphereRadius(0.50)\n\n  world.attachRigidBody(bodyNP.node())\n\n  # Remove the bullet again after 1 second\n  bullets.append(bodyNP)\n  taskMgr.doMethodLater(1, removeBullet, 'removeBullet')\n\ncpp\n\nTODO\n\nMost of the code is related to finding the initial velocity vector for the bullet, which is calculated from the mouse position when shooting the bullet.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/1484f604_ccd.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/8223b26b_1484f604_ccd.json",
    "doc_id": "doc_656"
  }
}