{
  "content": "\"\"\"Extends setuptools with the ``build_apps`` and ``bdist_apps`` commands.\n\nSee the :ref:`distribution` section of the programming manual for information\non how to use these commands.\n\"\"\"\n\nimport os\nimport plistlib\nimport sys\nimport subprocess\nimport zipfile\nimport re\nimport shutil\nimport stat\nimport struct\nimport string\nimport tempfile\n\nimport setuptools\nimport distutils.log\n\nfrom . import FreezeTool\nfrom . import pefile\nfrom . import installers\nfrom .icon import Icon\nfrom ._dist_hooks import finalize_distribution_options\nimport panda3d.core as p3d\n\n\ndef _parse_list(input):\n    if isinstance(input, str):\n        input = input.strip().replace(',', '\\n')\n        if input:\n            return [item.strip() for item in input.split('\\n') if item.strip()]\n        else:\n            return []\n    else:\n        return input\n\n\ndef _parse_dict(input):\n    if isinstance(input, dict):\n        return input\n    d = {}\n    for item in _parse_list(input):\n        key, sep, value = item.partition('=')\n        d[key.strip()] = value.strip()\n    return d\n\n\ndef _register_python_loaders():\n    # We need this method so that we don't depend on direct.showbase.Loader.\n    if getattr(_register_python_loaders, 'done', None):\n        return\n\n    _register_python_loaders.done = True\n\n    from importlib.metadata import entry_points\n\n    eps = entry_points()\n    if isinstance(eps, dict): # Python 3.8 and 3.9\n        loaders = eps.get('panda3d.loaders', ())\n    else:\n        loaders = eps.select(group='panda3d.loaders')\n\n    registry = p3d.LoaderFileTypeRegistry.get_global_ptr()\n    for entry_point in loaders:\n        registry.register_deferred_type(entry_point)\n\n\ndef _model_to_bam(_build_cmd, srcpath, dstpath):\n    if dstpath.endswith('.gz') or dstpath.endswith('.pz'):\n        dstpath = dstpath[:-3]\n    dstpath = dstpath + '.bam'\n\n    src_fn = p3d.Filename.from_os_specific(srcpath)\n    dst_fn = p3d.Filename.from_os_specific(dstpath)\n    dst_fn.set_binary()\n\n    _register_python_loaders()\n\n    loader = p3d.Loader.get_global_ptr()\n    options = p3d.LoaderOptions(p3d.LoaderOptions.LF_report_errors |\n                                p3d.LoaderOptions.LF_no_ram_cache)\n    node = loader.load_sync(src_fn, options)\n    if not node:\n        raise IOError('Failed to load model: %s' % (srcpath))\n\n    stream = p3d.OFileStream()\n    if not dst_fn.open_write(stream):\n        raise IOError('Failed to open .bam file for writing: %s' % (dstpath))\n\n    # We pass it the source filename here so that texture files are made\n    # relative to the original pathname and don't point from the destination\n    # back into the source directory.\n    dout = p3d.DatagramOutputFile()\n    if not dout.open(stream, src_fn) or not dout.write_header(\"pbj\\0\\n\\r\"):\n        raise IOError('Failed to write to .bam file: %s' % (dstpath))\n\n    writer = p3d.BamWriter(dout)\n    writer.root_node = node\n    writer.init()\n    if _build_cmd.bam_embed_textures:\n        writer.set_file_texture_mode(p3d.BamEnums.BTM_rawdata)\n    else:\n        writer.set_file_texture_mode(p3d.BamEnums.BTM_relative)\n    writer.write_object(node)\n    writer.flush()\n    writer = None\n    dout.close()\n    dout = None\n    stream.close()\n\n\nmacosx_binary_magics = (\n    b'\\xFE\\xED\\xFA\\xCE', b'\\xCE\\xFA\\xED\\xFE',\n    b'\\xFE\\xED\\xFA\\xCF', b'\\xCF\\xFA\\xED\\xFE',\n    b'\\xCA\\xFE\\xBA\\xBE', b'\\xBE\\xBA\\xFE\\xCA',\n    b'\\xCA\\xFE\\xBA\\xBF', b'\\xBF\\xBA\\xFE\\xCA')\n\n# Some dependencies need data directories to be extracted. This dictionary maps\n# modules with data to extract. The values are lists of tuples of the form\n# (source_pattern, destination_pattern, flags). The flags is a set of strings.\n\nPACKAGE_DATA_DIRS = {\n    'matplotlib':  [('matplotlib/mpl-data/*', 'mpl-data', {})],\n    'jsonschema':  [('jsonschema/schemas/*', 'schemas', {})],\n    'cefpython3': [\n        ('cefpython3/*.pak', '', {}),\n        ('cefpython3/*.dat', '', {}),\n        ('cefpython3/*.bin', '', {}),\n        ('cefpython3/*.dll', '', {}),\n        ('cefpython3/libcef.so', '', {}),\n        ('cefpython3/LICENSE.txt', '', {}),\n        ('cefpython3/License', '', {}),\n        ('cefpython3/subprocess*', '', {'PKG_DATA_MAKE_EXECUTABLE'}),\n        ('cefpython3/locals/*', 'locals', {}),\n        ('cefpython3/Chromium Embedded Framework.framework/Resources', 'Chromium Embedded Framework.framework/Resources', {}),\n        ('cefpython3/Chromium Embedded Framework.framework/Chromium Embedded Framework', '', {'PKG_DATA_MAKE_EXECUTABLE'}),\n    ],\n    'pytz': [('pytz/zoneinfo/*', 'zoneinfo', ())],\n    'certifi': [('certifi/cacert.pem', '', {})],\n    '_tkinter_ext': [('_tkinter_ext/tcl/**', 'tcl', {})],\n}\n\n# Some dependencies have extra directories that need to be scanned for DLLs.\n# This dictionary maps wheel basenames (ie. the part of the .whl basename\n# before the first hyphen) to a list of tuples, the first value being the\n# directory inside the wheel, the second being which wheel to look in (or\n# None to look in its own wheel).\n\nPACKAGE_LIB_DIRS = {\n    'scipy':  [('scipy/extra-dll', None)],\n    'PyQt5':  [('PyQt5/Qt5/bin', 'PyQt5_Qt5')],\n}\n\nSITE_PY = \"\"\"\nimport sys\nfrom _frozen_importlib import _imp, FrozenImporter\n\nsys.frozen = True\n\nif sys.platform == 'win32' and sys.version_info < (3, 10):\n    # Make sure the preferred encoding is something we actually support.\n    import _bootlocale\n    enc = _bootlocale.getpreferredencoding().lower()\n    if enc != 'utf-8' and not _imp.is_frozen('encodings.%s' % (enc)):\n        def getpreferredencoding(do_setlocale=True):\n            return 'mbcs'\n        _bootlocale.getpreferredencoding = getpreferredencoding\n\n# Alter FrozenImporter to give a __file__ property to frozen modules.\n_find_spec = FrozenImporter.find_spec\n\ndef find_spec(fullname, path=None, target=None):\n    spec = _find_spec(fullname, path=path, target=target)\n    if spec:\n        spec.has_location = True\n        spec.origin = sys.executable\n    return spec\n\ndef get_data(path):\n    with open(path, 'rb') as fp:\n        return fp.read()\n\nFrozenImporter.find_spec = find_spec\nFrozenImporter.get_data = get_data\n\"\"\"\n\nSITE_PY_ANDROID = \"\"\"\n# Define this first, before we import anything that might import an extension\n# module.\nimport sys, os\nfrom importlib import _bootstrap, _bootstrap_external\n\nclass AndroidExtensionFinder:\n    @classmethod\n    def find_spec(cls, fullname, path=None, target=None):\n        soname = 'libpy.' + fullname + '.so'\n        path = os.path.join(sys.platlibdir, soname)\n\n        if os.path.exists(path):\n            loader = _bootstrap_external.ExtensionFileLoader(fullname, path)\n            return _bootstrap.ModuleSpec(fullname, loader, origin=path)\n\n\nsys.meta_path.append(AndroidExtensionFinder)\n\n\nfrom _frozen_importlib import _imp, FrozenImporter\nfrom io import RawIOBase, TextIOWrapper\n\nfrom android_log import write as android_log_write\n\n\nsys.frozen = True\n\n# Temporary hack for plyer to detect Android, see kivy/plyer#670\nos.environ['ANDROID_ARGUMENT'] = ''\n\n\n# Replace stdout/stderr with something that writes to the Android log.\nclass AndroidLogStream:\n    closed = False\n    encoding = 'utf-8'\n\n    def __init__(self, prio, tag):\n        self.prio = prio\n        self.tag = tag\n        self.buffer = ''\n\n    def isatty(self):\n        return False\n\n    def write(self, text):\n        self.writelines(text.split('\\\\n'))\n\n    def writelines(self, lines):\n        num_lines = len(lines)\n        if num_lines == 1:\n            self.buffer += lines[0]\n        elif num_lines > 1:\n            android_log_write(self.prio, self.tag, self.buffer + lines[0])\n            for line in lines[1:-1]:\n                android_log_write(self.prio, self.tag, line)\n            self.buffer = lines[-1]\n\n    def flush(self):\n        pass\n\n    def seekable(self):\n        return False\n\n    def readable(self):\n        return False\n\n    def writable(self):\n        return True\n\nif sys.version_info < (3, 13):\n    sys.stdout = AndroidLogStream(4, 'python.stdout')\n    sys.stderr = AndroidLogStream(5, 'python.stderr')\n\n\n# Alter FrozenImporter to give a __file__ property to frozen modules.\n_find_spec = FrozenImporter.find_spec\n\ndef find_spec(fullname, path=None, target=None):\n    spec = _find_spec(fullname, path=path, target=target)\n    if spec:\n        spec.has_location = True\n        spec.origin = sys.executable\n    return spec\n\ndef get_data(path):\n    with open(path, 'rb') as fp:\n        return fp.read()\n\nFrozenImporter.find_spec = find_spec\nFrozenImporter.get_data = get_data\n\"\"\"\n\n\nclass build_apps(setuptools.Command):\n    description = 'build Panda3D applications'\n    user_options = [\n        ('build-base=', None, 'directory to build applications in'),\n        ('requirements-path=', None, 'path to requirements.txt file for pip'),\n        ('platforms=', 'p', 'a list of platforms to build for'),\n    ]\n    default_file_handlers = {\n    }\n\n    def initialize_options(self):\n        self.build_base = os.path.join(os.getcwd(), 'build')\n        self.application_id = None\n        self.android_abis = None\n        self.android_debuggable = False\n        self.android_app_category = None\n        self.android_version_code = 1\n        self.android_min_sdk_version = 21\n        self.android_max_sdk_version = None\n        self.android_target_sdk_version = 30\n        self.gui_apps = {}\n        self.console_apps = {}\n        self.macos_main_app = None\n        self.rename_paths = {}\n        self.include_patterns = []\n        self.exclude_patterns = []\n        self.include_modules = {}\n        self.exclude_modules = {}\n        self.icons = {}\n        self.platforms = [\n            'manylinux2014_x86_64',\n            'macosx_10_9_x86_64',\n            'win_amd64',\n        ]\n\n        if sys.version_info >= (3, 13):\n            # This version of Python is only available for 10.13+.\n            self.platforms[1] = 'macosx_10_13_x86_64'\n\n        self.plugins = []\n        self.embed_prc_data = True\n        self.extra_prc_files = []\n        self.extra_prc_data = ''\n        self.default_prc_dir = None\n        self.log_filename = None\n        self.log_filename_strftime = True\n        self.log_append = False\n        self.prefer_discrete_gpu = False\n        self.requirements_path = os.path.join(os.getcwd(), 'requirements.txt')\n        self.strip_docstrings = True\n        self.use_optimized_wheels = True\n        self.optimized_wheel_index = ''\n        self.pypi_extra_indexes = [\n            'https://archive.panda3d.org/thirdparty',\n        ]\n        self.file_handlers = {}\n        self.bam_model_extensions = ['.egg', '.gltf', '.glb']\n        self.bam_embed_textures = False\n        self.exclude_dependencies = [\n            # Windows\n            'kernel32.dll', 'user32.dll', 'wsock32.dll', 'ws2_32.dll',\n            'advapi32.dll', 'opengl32.dll', 'glu32.dll', 'gdi32.dll',\n            'shell32.dll', 'ntdll.dll', 'ws2help.dll', 'rpcrt4.dll',\n            'imm32.dll', 'ddraw.dll', 'shlwapi.dll', 'secur32.dll',\n            'dciman32.dll', 'comdlg32.dll', 'comctl32.dll', 'ole32.dll',\n            'oleaut32.dll', 'gdiplus.dll', 'winmm.dll', 'iphlpapi.dll',\n            'msvcrt.dll', 'kernelbase.dll', 'msimg32.dll', 'msacm32.dll',\n            'setupapi.dll', 'version.dll', 'userenv.dll', 'netapi32.dll',\n            'crypt32.dll', 'bcrypt.dll',\n\n            # manylinux1/linux\n            'libdl.so.*', 'libstdc++.so.*', 'libm.so.*', 'libgcc_s.so.*',\n            'libpthread.so.*', 'libc.so.*',\n            'ld-linux-x86-64.so.*', 'ld-linux-aarch64.so.*',\n            'libgl.so.*', 'libx11.so.*', 'libncursesw.so.*', 'libz.so.*',\n            'librt.so.*', 'libutil.so.*', 'libnsl.so.1', 'libXext.so.6',\n            'libXrender.so.1', 'libICE.so.6', 'libSM.so.6', 'libEGL.so.1',\n            'libOpenGL.so.0', 'libGLdispatch.so.0', 'libGLX.so.0',\n            'libgobject-2.0.so.0', 'libgthread-2.0.so.0', 'libglib-2.0.so.0',\n\n            # macOS\n            '/usr/lib/libc++.1.dylib',\n            '/usr/lib/libstdc++.*.dylib',\n            '/usr/lib/libz.*.dylib',\n            '/usr/lib/libobjc.*.dylib',\n            '/usr/lib/libSystem.*.dylib',\n            '/usr/lib/libbz2.*.dylib',\n            '/usr/lib/libedit.*.dylib',\n            '/usr/lib/libffi.dylib',\n            '/usr/lib/libauditd.0.dylib',\n            '/usr/lib/libgermantok.dylib',\n            '/usr/lib/liblangid.dylib',\n            '/usr/lib/libarchive.2.dylib',\n            '/usr/lib/libipsec.A.dylib',\n            '/usr/lib/libpanel.5.4.dylib',\n            '/usr/lib/libiodbc.2.1.18.dylib',\n            '/usr/lib/libhunspell-1.2.0.0.0.dylib',\n            '/usr/lib/libsqlite3.dylib',\n            '/usr/lib/libpam.1.dylib',\n            '/usr/lib/libtidy.A.dylib',\n            '/usr/lib/libDHCPServer.A.dylib',\n            '/usr/lib/libpam.2.dylib',\n            '/usr/lib/libXplugin.1.dylib',\n            '/usr/lib/libxslt.1.dylib',\n            '/usr/lib/libiodbcinst.2.1.18.dylib',\n            '/usr/lib/libBSDPClient.A.dylib',\n            '/usr/lib/libsandbox.1.dylib',\n            '/usr/lib/libform.5.4.dylib',\n            '/usr/lib/libbsm.0.dylib',\n            '/usr/lib/libMatch.1.dylib',\n            '/usr/lib/libresolv.9.dylib',\n            '/usr/lib/libcharset.1.dylib',\n            '/usr/lib/libxml2.2.dylib',\n            '/usr/lib/libiconv.2.dylib',\n            '/usr/lib/libScreenReader.dylib',\n            '/usr/lib/libdtrace.dylib',\n            '/usr/lib/libicucore.A.dylib',\n            '/usr/lib/libsasl2.2.dylib',\n            '/usr/lib/libpcap.A.dylib',\n            '/usr/lib/libexslt.0.dylib',\n            '/usr/lib/libcurl.4.dylib',\n            '/usr/lib/libncurses.5.4.dylib',\n            '/usr/lib/libxar.1.dylib',\n            '/usr/lib/libmenu.5.4.dylib',\n            '/System/Library/**',\n\n            # Android\n            'libc.so', 'libm.so', 'liblog.so', 'libdl.so', 'libandroid.so',\n            'libGLESv1_CM.so', 'libGLESv2.so', 'libjnigraphics.so', 'libEGL.so',\n            'libOpenSLES.so', 'libandroid.so', 'libOpenMAXAL.so', 'libz.so',\n        ]\n\n        self.package_data_dirs = {}\n        self.hidden_imports = {}\n\n        # We keep track of the zip files we've opened.\n        self._zip_files = {}\n\n    def _get_zip_file(self, path):\n        if path in self._zip_files:\n            return self._zip_files[path]\n\n        zip = zipfile.ZipFile(path)\n        self._zip_files[path] = zip\n        return zip\n\n    def finalize_options(self):\n        # We need to massage the inputs a bit in case they came from a\n        # setup.cfg file.\n        self.gui_apps = _parse_dict(self.gui_apps)\n        self.console_apps = _parse_dict(self.console_apps)\n\n        self.rename_paths = _parse_dict(self.rename_paths)\n        self.include_patterns = _parse_list(self.include_patterns)\n        self.exclude_patterns = _parse_list(self.exclude_patterns)\n        self.include_modules = {\n            key: _parse_list(value)\n            for key, value in _parse_dict(self.include_modules).items()\n        }\n        self.exclude_modules = {\n            key: _parse_list(value)\n            for key, value in _parse_dict(self.exclude_modules).items()\n        }\n        self.icons = _parse_dict(self.icons)\n        self.platforms = _parse_list(self.platforms)\n        self.plugins = _parse_list(self.plugins)\n        self.extra_prc_files = _parse_list(self.extra_prc_files)\n        self.hidden_imports = {\n            key: _parse_list(value)\n            for key, value in _parse_dict(self.hidden_imports).items()\n        }\n\n        if self.default_prc_dir is None:\n            self.default_prc_dir = '<auto>etc' if not self.embed_prc_data else ''\n\n        num_gui_apps = len(self.gui_apps)\n        num_console_apps = len(self.console_apps)\n\n        if not self.macos_main_app:\n            if num_gui_apps > 1:\n                assert False, 'macos_main_app must be defined if more than one gui_app is defined'\n            elif num_gui_apps == 1:\n                self.macos_main_app = list(self.gui_apps.keys())[0]\n\n        use_pipenv = (\n            'Pipfile' in os.path.basename(self.requirements_path) or\n            not os.path.exists(self.requirements_path) and os.path.exists('Pipfile')\n        )\n        if use_pipenv:\n            reqspath = os.path.join(self.build_base, 'requirements.txt')\n            with open(reqspath, 'w') as reqsfile:\n                subprocess.check_call(['pipenv', 'lock', '--requirements'], stdout=reqsfile)\n            self.requirements_path = reqspath\n\n        if self.use_optimized_wheels:\n            if not self.optimized_wheel_index:\n                # Try to find an appropriate wheel index\n\n                # Start with the release index\n                self.optimized_wheel_index = 'https://archive.panda3d.org/simple/opt'\n\n                # See if a buildbot build is being used\n                with open(self.requirements_path) as reqsfile:\n                    reqsdata = reqsfile.read()\n                matches = re.search(r'--extra-index-url (https*://archive.panda3d.org/.*\\b)', reqsdata)\n                if matches and matches.group(1):\n                    self.optimized_wheel_index = matches.group(1)\n                    if not matches.group(1).endswith('opt'):\n                        self.optimized_wheel_index += '/opt'\n\n            assert self.optimized_wheel_index, 'An index for optimized wheels must be defined if use_optimized_wheels is set'\n\n        assert os.path.exists(self.requirements_path), 'Requirements.txt path does not exist: {}'.format(self.requirements_path)\n        assert num_gui_apps + num_console_apps != 0, 'Must specify at least one app in either gui_apps or console_apps'\n\n        self.exclude_dependencies = [p3d.GlobPattern(i) for i in self.exclude_dependencies]\n        for glob in self.exclude_dependencies:\n            glob.case_sensitive = False\n\n        # bam_model_extensions registers a 2bam handler for each given extension.\n        # They can override a default handler, but not a custom handler.\n        if self.bam_model_extensions:\n            for ext in self.bam_model_extensions:\n                ext = '.' + ext.lstrip('.')\n                handler = self.file_handlers.get(ext)\n                if handler != _model_to_bam:\n                    assert handler is None, \\\n                        'Extension {} occurs in both file_handlers and bam_model_extensions!'.format(ext)\n                self.file_handlers[ext] = _model_to_bam\n\n        tmp = self.default_file_handlers.copy()\n        tmp.update(self.file_handlers)\n        self.file_handlers = tmp\n\n        tmp = PACKAGE_DATA_DIRS.copy()\n        tmp.update(self.package_data_dirs)\n        self.package_data_dirs = tmp\n\n        if 'android' in self.platforms:\n            assert self.application_id, \\\n                'Must have a valid application_id when targeting Android!'\n\n            parts = self.application_id.split('.')\n            assert len(parts) >= 2, \\\n                'application_id must contain at least one \\'.\\' separator!'\n\n            for part in parts:\n                assert part.isidentifier(), \\\n                    'Each part of application_id must be a valid identifier!'\n\n        # Default to all supported ABIs (for the given Android version).\n        if self.android_max_sdk_version and self.android_max_sdk_version < 21:\n            assert self.android_max_sdk_version >= 19, \\\n                'Panda3D requires at least Android API level 19!'\n\n            if self.android_abis:\n                for abi in self.android_abis:\n                    assert abi not in ('mips64', 'x86_64', 'arm64-v8a'), \\\n                        f'{abi} was not a valid Android ABI before Android 21!'\n            else:\n                self.android_abis = ['armeabi-v7a', 'x86']\n\n        elif not self.android_abis:\n            self.android_abis = ['arm64-v8a', 'armeabi-v7a', 'x86_64', 'x86']\n\n        supported_abis = 'armeabi', 'armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64', 'mips', 'mips64'\n        unsupported_abis = set(self.android_abis) - set(supported_abis)\n        if unsupported_abis:\n            raise ValueError(f'Unrecognized value(s) for android_abis: {\", \".join(unsupported_abis)}\\n'\n                             f'Valid ABIs are: {\", \".join(supported_abis)}')\n\n        self.icon_objects = {}\n        for app, iconpaths in self.icons.items():\n            if not isinstance(iconpaths, list) and not isinstance(iconpaths, tuple):\n                iconpaths = (iconpaths,)\n\n            iconobj = Icon()\n            for iconpath in iconpaths:\n                iconobj.addImage(iconpath)\n\n            iconobj.generateMissingImages()\n            self.icon_objects[app] = iconobj\n\n    def run(self):\n        self.announce('Building platforms: {0}'.format(','.join(self.platforms)), distutils.log.INFO)\n\n        for platform in self.platforms:\n            # Create the build directory, or ensure it is empty.\n            build_dir = os.path.join(self.build_base, platform)\n\n            if os.path.exists(build_dir):\n                for entry in os.listdir(build_dir):\n                    path = os.path.join(build_dir, entry)\n                    if os.path.islink(path) or os.path.isfile(path):\n                        os.unlink(path)\n                    else:\n                        shutil.rmtree(path)\n            else:\n                os.makedirs(build_dir)\n\n            if platform == 'android':\n                # Make a multi-arch build for Android.\n                data_dir = os.path.join(build_dir, 'assets')\n                os.makedirs(data_dir, exist_ok=True)\n\n                for abi in self.android_abis:\n                    lib_dir = os.path.join(build_dir, 'lib', abi)\n                    os.makedirs(lib_dir, exist_ok=True)\n\n                    suffix = None\n                    if abi == 'arm64-v8a':\n                        suffix = '_arm64'\n                    elif abi == 'armeabi-v7a':\n                        suffix = '_armv7a'\n                    elif abi == 'armeabi':\n                        suffix = '_arm'\n                    else: # e.g. x86, x86_64, mips, mips64\n                        suffix = '_' + abi.replace('-', '_')\n\n                    # We end up copying the data multiple times to the same\n                    # directory, but that's probably fine for now.\n                    self.build_binaries(platform + suffix, lib_dir, data_dir)\n\n                # Write out the icons to the res directory.\n                for appname, icon in self.icon_objects.items():\n                    if appname == '*' or (appname == self.macos_main_app and '*' not in self.icon_objects):\n                        # Conventional name for icon on Android.\n                        basename = 'ic_launcher.png'\n                    else:\n                        basename = f'ic_{appname}.png'\n\n                    res_dir = os.path.join(build_dir, 'res')\n                    icon.writeSize(48, os.path.join(res_dir, 'mipmap-mdpi-v4', basename))\n                    icon.writeSize(72, os.path.join(res_dir, 'mipmap-hdpi-v4', basename))\n                    icon.writeSize(96, os.path.join(res_dir, 'mipmap-xhdpi-v4', basename))\n                    icon.writeSize(144, os.path.join(res_dir, 'mipmap-xxhdpi-v4', basename))\n\n                    if icon.getLargestSize() >= 192:\n                        icon.writeSize(192, os.path.join(res_dir, 'mipmap-xxxhdpi-v4', basename))\n\n                self.build_assets(platform, data_dir)\n\n                # Generate an AndroidManifest.xml\n                self.generate_android_manifest(os.path.join(build_dir, 'AndroidManifest.xml'))\n            else:\n                self.build_binaries(platform, build_dir, build_dir)\n                self.build_assets(platform, build_dir)\n\n            # Bundle into an .app on macOS\n            if self.macos_main_app and 'macosx' in platform:\n                self.bundle_macos_app(build_dir)\n\n    def download_wheels(self, platform):\n        \"\"\" Downloads wheels for the given platform using pip. This includes panda3d\n        wheels. These are special wheels that are expected to contain a deploy_libs\n        directory containing the Python runtime libraries, which will be added\n        to sys.path.\"\"\"\n\n        import pip\n\n        self.announce('Gathering wheels for platform: {}'.format(platform), distutils.log.INFO)\n\n        whlcache = os.path.join(self.build_base, '__whl_cache__')\n\n        pip_version = int(pip.__version__.split('.', 1)[0])\n        if pip_version < 9:\n            raise RuntimeError(\"pip 9.0 or greater is required, but found {}\".format(pip.__version__))\n\n        abi_tag = 'cp%d%d' % (sys.version_info[:2])\n        if sys.version_info < (3, 8):\n            abi_tag += 'm'\n\n        whldir = os.path.join(whlcache, '_'.join((platform, abi_tag)))\n        if not os.path.isdir(whldir):\n            os.makedirs(whldir)\n\n        # Remove any .zip files. These are built from a VCS and block for an\n        # interactive prompt on subsequent downloads.\n        if os.path.exists(whldir):\n            for whl in os.listdir(whldir):\n                if whl.endswith('.zip'):\n                    os.remove(os.path.join(whldir, whl))\n\n        pip_args = [\n            '--disable-pip-version-check',\n            'download',\n            '-d', whldir,\n            '-r', self.requirements_path,\n            '--only-binary', ':all:',\n            '--abi', abi_tag,\n            '--platform', platform,\n        ]\n\n        if platform.startswith('linux_'):\n            # Also accept manylinux.\n            arch = platform[6:]\n            pip_args += ['--platform', 'manylinux2014_' + arch]\n\n        if self.use_optimized_wheels:\n            pip_args += [\n                '--extra-index-url', self.optimized_wheel_index\n            ]\n\n        for index in self.pypi_extra_indexes:\n            pip_args += ['--extra-index-url', index]\n\n        try:\n            subprocess.check_call([sys.executable, '-m', 'pip'] + pip_args)\n        except:\n            # Display a more helpful message for these common issues.\n            if platform.startswith('macosx_10_9_') and sys.version_info >= (3, 13):\n                new_platform = platform.replace('macosx_10_9_', 'macosx_10_13_')\n                self.announce('This error likely occurs because {} is not a supported target as of Python 3.13.\\nChange the target platform to {} instead.'.format(platform, new_platform), distutils.log.ERROR)\n            elif platform.startswith('manylinux2010_') and sys.version_info >= (3, 11):\n                new_platform = platform.replace('manylinux2010_', 'manylinux2014_')\n                self.announce('This error likely occurs because {} is not a supported target as of Python 3.11.\\nChange the target platform to {} instead.'.format(platform, new_platform), distutils.log.ERROR)\n            elif platform.startswith('manylinux1_') and sys.version_info >= (3, 10):\n                new_platform = platform.replace('manylinux1_', 'manylinux2014_')\n                self.announce('This error likely occurs because {} is not a supported target as of Python 3.10.\\nChange the target platform to {} instead.'.format(platform, new_platform), distutils.log.ERROR)\n            elif platform.startswith('macosx_10_6_') and sys.version_info >= (3, 8):\n                if sys.version_info >= (3, 13):\n                    new_platform = platform.replace('macosx_10_6_', 'macosx_10_13_')\n                else:\n                    new_platform = platform.replace('macosx_10_6_', 'macosx_10_9_')\n                self.announce('This error likely occurs because {} is not a supported target as of Python 3.8.\\nChange the target platform to {} instead.'.format(platform, new_platform), distutils.log.ERROR)\n            raise\n\n        # Return a list of paths to the downloaded whls\n        return [\n            os.path.join(whldir, filename)\n            for filename in os.listdir(whldir)\n            if filename.endswith('.whl')\n        ]\n\n    def update_pe_resources(self, appname, runtime):\n        \"\"\"Update resources (e.g., icons) in windows PE file\"\"\"\n\n        icon = self.icon_objects.get(\n            appname,\n            self.icon_objects.get('*', None),\n        )\n\n        if icon is not None or self.prefer_discrete_gpu:\n            pef = pefile.PEFile()\n            pef.open(runtime, 'r+')\n            if icon is not None:\n                pef.add_icon(icon)\n                pef.add_resource_section()\n            if self.prefer_discrete_gpu:\n                if not pef.rename_export(\"SymbolPlaceholder___________________\", \"AmdPowerXpressRequestHighPerformance\") or \\\n                   not pef.rename_export(\"SymbolPlaceholder__\", \"NvOptimusEnablement\"):\n                    self.warn(\"Failed to apply prefer_discrete_gpu, newer target Panda3D version may be required\")\n            pef.write_changes()\n            pef.close()\n\n    def bundle_macos_app(self, builddir):\n        \"\"\"Bundle built runtime into a .app for macOS\"\"\"\n\n        appname = '{}.app'.format(self.macos_main_app)\n        appdir = os.path.join(builddir, appname)\n        contentsdir = os.path.join(appdir, 'Contents')\n        macosdir = os.path.join(contentsdir, 'MacOS')\n        fwdir = os.path.join(contentsdir, 'Frameworks')\n        resdir = os.path.join(contentsdir, 'Resources')\n\n        self.announce('Bundling macOS app into {}'.format(appdir), distutils.log.INFO)\n\n        # Create initial directory structure\n        os.makedirs(macosdir)\n        os.makedirs(fwdir)\n        os.makedirs(resdir)\n\n        # Move files over\n        for fname in os.listdir(builddir):\n            src = os.path.join(builddir, fname)\n            if appdir in src:\n                continue\n\n            if fname in self.gui_apps or self.console_apps:\n                dst = macosdir\n            elif os.path.isfile(src) and open(src, 'rb').read(4) in macosx_binary_magics:\n                dst = fwdir\n            else:\n                dst = resdir\n            shutil.move(src, dst)\n\n        # Write out Info.plist\n        plist = {\n            'CFBundleName': appname,\n            'CFBundleDisplayName': appname, #TODO use name from setup.py/cfg\n            'CFBundleIdentifier': '', #TODO\n            'CFBundleVersion': '0.0.0', #TODO get from setup.py\n            'CFBundlePackageType': 'APPL',\n            'CFBundleSignature': '', #TODO\n            'CFBundleExecutable': self.macos_main_app,\n            'NSHighResolutionCapable': 'True',\n        }\n\n        icon = self.icon_objects.get(\n            self.macos_main_app,\n            self.icon_objects.get('*', None)\n        )\n        if icon is not None:\n            plist['CFBundleIconFile'] = 'iconfile'\n            icon.makeICNS(os.path.join(resdir, 'iconfile.icns'))\n\n        with open(os.path.join(contentsdir, 'Info.plist'), 'wb') as f:\n            plistlib.dump(plist, f)\n\n    def generate_android_manifest(self, path):\n        import xml.etree.ElementTree as ET\n\n        name = self.distribution.get_name()\n        version = self.distribution.get_version()\n        classifiers = self.distribution.get_classifiers()\n\n        # If we have no app category, determine it based on the classifiers.\n        category = self.android_app_category\n        if not category:\n            for classifier in classifiers:\n                classifier = tuple(classifier.split(' :: '))\n                if len(classifier) < 2 or classifier[0] != 'Topic':\n                    continue\n\n                if classifier[:2] == ('Topic', 'Games/Entertainment'):\n                    category = 'game'\n                    break\n                elif classifier[:3] == ('Topic', 'Multimedia', 'Audio'):\n                    category = 'audio'\n                elif classifier[:4] == ('Topic', 'Multimedia', 'Graphics', 'Editors'):\n                    category = 'image'\n                elif classifier[:2] == ('Topic', 'Communications', 'Usenet News'):\n                    category = 'news'\n                elif classifier[:2] == ('Topic', 'Office/Business'):\n                    category = 'productivity'\n                elif classifier[:3] == ('Topic', 'Communications', 'Chat'):\n                    category = 'social'\n                elif classifier[:3] == ('Topic', 'Multimedia', 'Video'):\n                    category = 'video'\n\n        manifest = ET.Element('manifest')\n        manifest.set('xmlns:android', 'http://schemas.android.com/apk/res/android')\n        manifest.set('package', self.application_id)\n        manifest.set('android:versionCode', str(int(self.android_version_code)))\n        manifest.set('android:versionName', version)\n        manifest.set('android:installLocation', 'auto')\n\n        uses_sdk = ET.SubElement(manifest, 'uses-sdk')\n        uses_sdk.set('android:minSdkVersion', str(int(self.android_min_sdk_version)))\n        uses_sdk.set('android:targetSdkVersion', str(int(self.android_target_sdk_version)))\n        if self.android_max_sdk_version:\n            uses_sdk.set('android:maxSdkVersion', str(int(self.android_max_sdk_version)))\n\n        if 'pandagles2' in self.plugins:\n            uses_feature = ET.SubElement(manifest, 'uses-feature')\n            uses_feature.set('android:glEsVersion', '0x00020000')\n            uses_feature.set('android:required', 'false' if 'pandagles' in self.plugins else 'true')\n\n        if 'p3openal_audio' in self.plugins:\n            uses_feature = ET.SubElement(manifest, 'uses-feature')\n            uses_feature.set('android:name', 'android.hardware.audio.output')\n            uses_feature.set('android:required', 'false')\n\n        uses_feature = ET.SubElement(manifest, 'uses-feature')\n        uses_feature.set('android:name', 'android.hardware.gamepad')\n        uses_feature.set('android:required', 'false')\n\n        application = ET.SubElement(manifest, 'application')\n        application.set('android:label', name)\n        if category == 'game':\n            application.set('android:isGame', 'true')\n        if category:\n            application.set('android:appCategory', category)\n        application.set('android:debuggable', ('false', 'true')[self.android_debuggable])\n        application.set('android:extractNativeLibs', 'true')\n        application.set('android:hardwareAccelerated', 'true')\n\n        app_icon = self.icon_objects.get('*', self.icon_objects.get(self.macos_main_app))\n        if app_icon:\n            application.set('android:icon', '@mipmap/ic_launcher')\n\n        for appname in self.gui_apps:\n            activity = ET.SubElement(application, 'activity')\n            activity.set('android:name', 'org.panda3d.android.PythonActivity')\n            activity.set('android:label', appname)\n            activity.set('android:theme', '@android:style/Theme.NoTitleBar.Fullscreen')\n            activity.set('android:alwaysRetainTaskState', 'true')\n            activity.set('android:configChanges', 'layoutDirection|locale|grammaticalGender|fontScale|fontWeightAdjustment|orientation|uiMode|screenLayout|screenSize|smallestScreenSize|keyboard|keyboardHidden|navigation')\n            activity.set('android:launchMode', 'singleInstance')\n            activity.set('android:preferMinimalPostProcessing', 'true')\n\n            act_icon = self.icon_objects.get(appname)\n            if act_icon and act_icon is not app_icon:\n                activity.set('android:icon', '@mipmap/ic_' + appname)\n\n            meta_data = ET.SubElement(activity, 'meta-data')\n            meta_data.set('android:name', 'android.app.lib_name')\n            meta_data.set('android:value', appname)\n\n            intent_filter = ET.SubElement(activity, 'intent-filter')\n            ET.SubElement(intent_filter, 'action').set('android:name', 'android.intent.action.MAIN')\n            ET.SubElement(intent_filter, 'category').set('android:name', 'android.intent.category.LAUNCHER')\n            ET.SubElement(intent_filter, 'category').set('android:name', 'android.intent.category.LEANBACK_LAUNCHER')\n\n        tree = ET.ElementTree(manifest)\n        with open(path, 'wb') as fh:\n            tree.write(fh, encoding='utf-8', xml_declaration=True)\n\n    def build_binaries(self, platform, binary_dir, data_dir=None):\n        \"\"\" Builds the binary data for the given platform. \"\"\"\n\n        use_wheels = True\n        path = sys.path[:]\n        p3dwhl = None\n        wheelpaths = []\n        has_tkinter_wheel = False\n\n        if use_wheels:\n            wheelpaths = self.download_wheels(platform)\n\n            for whl in wheelpaths:\n                if os.path.basename(whl).startswith('panda3d-'):\n                    p3dwhlfn = whl\n                    p3dwhl = self._get_zip_file(p3dwhlfn)\n                    break\n                elif os.path.basename(whl).startswith('tkinter-'):\n                    has_tkinter_wheel = True\n            else:\n                raise RuntimeError(\"Missing panda3d wheel for platform: {}\".format(platform))\n\n            if self.use_optimized_wheels:\n                # Check to see if we have an optimized wheel\n                localtag = p3dwhlfn.split('+')[1].split('-')[0] if '+' in p3dwhlfn else ''\n                if not localtag.endswith('opt'):\n                    self.announce(\n                        'Could not find an optimized wheel (using index {}) for platform: {}'.format(self.optimized_wheel_index, platform),\n                        distutils.log.WARN\n                    )\n\n            for whl in wheelpaths:\n                if os.path.basename(whl).startswith('tkinter-'):\n                    has_tkinter_wheel = True\n                    break\n\n            #whlfiles = {whl: self._get_zip_file(whl) for whl in wheelpaths}\n\n            # Add whl files to the path so they are picked up by modulefinder\n            for whl in wheelpaths:\n                path.insert(0, whl)\n\n            # Add deploy_libs from panda3d whl to the path\n            path.insert(0, os.path.join(p3dwhlfn, 'deploy_libs'))\n\n\n        self.announce('Building runtime for platform: {}'.format(platform), distutils.log.INFO)\n\n        # Gather PRC data\n        prcstring = ''\n        if not use_wheels:\n            dtool_fn = p3d.Filename(p3d.ExecutionEnvironment.get_dtool_name())\n            libdir = os.path.dirname(dtool_fn.to_os_specific())\n            etcdir = os.path.join(libdir, '..', 'etc')\n\n            for fn in sorted(os.listdir(etcdir), reverse=True):\n                if fn.lower().endswith('.prc'):\n                    with open(os.path.join(etcdir, fn)) as f:\n                        prcstring += f.read()\n        else:\n            for fn in sorted((i for i in p3dwhl.namelist() if i.endswith('.prc')), reverse=True):\n                with p3dwhl.open(fn) as f:\n                    prcstring += f.read().decode('utf8')\n\n        user_prcstring = self.extra_prc_data\n        for fn in self.extra_prc_files:\n            with open(fn) as f:\n                user_prcstring += f.read()\n\n        # Clenup PRC data\n        check_plugins = [\n            #TODO find a better way to get this list\n            'pandaegg',\n            'p3ffmpeg',\n            'p3ptloader',\n            'p3assimp',\n        ]\n        def parse_prc(prcstr, warn_on_missing_plugin):\n            out = []\n            for ln in prcstr.split('\\n'):\n                ln = ln.strip()\n                useline = True\n\n                if ln.startswith('#') or not ln:\n                    continue\n\n                words = ln.split(None, 1)\n                if not words:\n                    continue\n                var = words[0]\n                value = words[1] if len(words) > 1 else ''\n\n                # Strip comment after value.\n                c = value.find(' #')\n                if c > 0:\n                    value = value[:c].rstrip()\n\n                if var == 'model-cache-dir' and value:\n                    if platform.startswith('android'):\n                        # Ignore on Android, where the cache dir is fixed.\n                        continue\n                    value = value.replace('/panda3d', '/{}'.format(self.distribution.get_name()))\n\n                if var == 'audio-library-name':\n                    # We have the default set to p3fmod_audio on macOS in 1.10,\n                    # but this can be unexpected as other platforms use OpenAL\n                    # by default.  Switch it up if FMOD is not included.\n                    if value not in self.plugins and value == 'p3fmod_audio' and 'p3openal_audio' in self.plugins:\n                        self.warn(\"Missing audio plugin p3fmod_audio referenced in PRC data, replacing with p3openal_audio\")\n                        value = 'p3openal_audio'\n\n                if var == 'aux-display':\n                    # Silently remove aux-display lines for missing plugins.\n                    if value not in self.plugins:\n                        continue\n\n                for plugin in check_plugins:\n                    if plugin in value and plugin not in self.plugins:\n                        useline = False\n                        if warn_on_missing_plugin:\n                            self.warn(\n                                \"Missing plugin ({0}) referenced in user PRC data\".format(plugin)\n                            )\n                        break\n                if useline:\n                    if value:\n                        out.append(var + ' ' + value)\n                    else:\n                        out.append(var)\n            return out\n        prcexport = parse_prc(prcstring, 0) + parse_prc(user_prcstring, 1)\n\n        # Export PRC data\n        prcexport = '\\n'.join(prcexport)\n        if not self.embed_prc_data:\n            prcdir = self.default_prc_dir.replace('<auto>', '')\n            prcdir = os.path.join(binary_dir, prcdir)\n            os.makedirs(prcdir)\n            with open(os.path.join(prcdir, '00-panda3d.prc'), 'w') as f:\n                f.write(prcexport)\n\n        # Create runtimes\n        freezer_extras = set()\n        freezer_modules = set()\n        ext_suffixes = set()\n\n        def get_search_path_for(source_path):\n            search_path = [os.path.dirname(source_path)]\n            if use_wheels:\n                search_path.append(os.path.join(p3dwhlfn, 'deploy_libs'))\n\n                # If the .whl containing this file has a .libs directory, add\n                # it to the path.  This is an auditwheel/numpy convention.\n                if '.whl' + os.sep in source_path:\n                    whl, wf = source_path.split('.whl' + os.path.sep)\n                    whl += '.whl'\n                    rootdir = wf.split(os.path.sep, 1)[0]\n                    search_path.append(os.path.join(whl, rootdir, '.libs'))\n\n                    # Also look for eg. numpy.libs or Pillow.libs in the root\n                    whl_name = os.path.basename(whl).split('-', 1)[0]\n                    search_path.append(os.path.join(whl, whl_name + '.libs'))\n\n                    # Also look for more specific per-package cases, defined in\n                    # PACKAGE_LIB_DIRS at the top of this file.\n                    extra_dirs = PACKAGE_LIB_DIRS.get(whl_name, [])\n                    for extra_dir, search_in in extra_dirs:\n                        if not search_in:\n                            search_path.append(os.path.join(whl, extra_dir.replace('/', os.path.sep)))\n                        else:\n                            for whl2 in wheelpaths:\n                                if os.path.basename(whl2).startswith(search_in + '-'):\n                                    search_path.append(os.path.join(whl2, extra_dir.replace('/', os.path.sep)))\n\n            return search_path\n\n        def create_runtime(platform, appname, mainscript, use_console):\n            freezer = FreezeTool.Freezer(\n                platform=platform,\n                path=path,\n                hiddenImports=self.hidden_imports,\n                optimize=2 if self.strip_docstrings else 1\n            )\n            freezer.addModule('__main__', filename=mainscript)\n            if platform.startswith('android'):\n                freezer.addModule('site', filename='site.py', text=SITE_PY_ANDROID)\n            else:\n                freezer.addModule('site', filename='site.py', text=SITE_PY)\n            for incmod in self.include_modules.get(appname, []) + self.include_modules.get('*', []):\n                freezer.addModule(incmod)\n            for exmod in self.exclude_modules.get(appname, []) + self.exclude_modules.get('*', []):\n                freezer.excludeModule(exmod)\n            freezer.done(addStartupModules=True)\n\n            stub_name = 'deploy-stub'\n            target_name = appname\n            if platform.startswith('win') or 'macosx' in platform:\n                if not use_console:\n                    stub_name = 'deploy-stubw'\n            elif platform.startswith('android'):\n                if not use_console:\n                    stub_name = 'libdeploy-stubw.so'\n                    target_name = 'lib' + target_name + '.so'\n\n            if platform.startswith('win'):\n                stub_name += '.exe'\n                target_name += '.exe'\n\n            if use_wheels:\n                if stub_name.endswith('.so'):\n                    stub_file = p3dwhl.open('deploy_libs/{0}'.format(stub_name))\n                else:\n                    stub_file = p3dwhl.open('panda3d_tools/{0}'.format(stub_name))\n            else:\n                dtool_path = p3d.Filename(p3d.ExecutionEnvironment.get_dtool_name()).to_os_specific()\n                stub_path = os.path.join(os.path.dirname(dtool_path), '..', 'bin', stub_name)\n                stub_file = open(stub_path, 'rb')\n\n            # Do we need an icon?  On Windows, we need to add this to the stub\n            # before we add the blob.\n            if 'win' in platform:\n                temp_file = tempfile.NamedTemporaryFile(suffix='-icon.exe', delete=False)\n                temp_file.write(stub_file.read())\n                stub_file.close()\n                temp_file.close()\n                self.update_pe_resources(appname, temp_file.name)\n                stub_file = open(temp_file.name, 'rb')\n            else:\n                temp_file = None\n\n            use_strftime = self.log_filename_strftime\n            if not self.log_filename or '%' not in self.log_filename:\n                use_strftime = False\n\n            target_path = os.path.join(binary_dir, target_name)\n            freezer.generateRuntimeFromStub(target_path, stub_file, use_console, {\n                'prc_data': prcexport if self.embed_prc_data else None,\n                'default_prc_dir': self.default_prc_dir,\n                'prc_dir_envvars': None,\n                'prc_path_envvars': None,\n                'prc_patterns': None,\n                'prc_encrypted_patterns': None,\n                'prc_encryption_key': None,\n                'prc_executable_patterns': None,\n                'prc_executable_args_envvar': None,\n                'main_dir': None,\n                'log_filename': self.expand_path(self.log_filename, platform),\n            }, self.log_append, use_strftime)\n            stub_file.close()\n\n            if temp_file:\n                os.unlink(temp_file.name)\n\n            # Copy the dependencies.\n            search_path = [binary_dir]\n            if use_wheels:\n                search_path.append(os.path.join(p3dwhlfn, 'panda3d'))\n                search_path.append(os.path.join(p3dwhlfn, 'deploy_libs'))\n            self.copy_dependencies(target_path, binary_dir, search_path, stub_name)\n\n            freezer_extras.update(freezer.extras)\n            freezer_modules.update(freezer.getAllModuleNames())\n            for suffix in freezer.mf.suffixes:\n                if suffix[2] == 3: # imp.C_EXTENSION:\n                    ext_suffixes.add(suffix[0])\n\n        for appname, scriptname in self.gui_apps.items():\n            create_runtime(platform, appname, scriptname, False)\n\n        for appname, scriptname in self.console_apps.items():\n            create_runtime(platform, appname, scriptname, True)\n\n        # Warn if tkinter is used but hasn't been added to requirements.txt\n        if not has_tkinter_wheel and '_tkinter' in freezer_modules:\n            self.warn(\"Detected use of tkinter, but tkinter is not specified in requirements.txt!\")\n\n        # Copy extension modules\n        whl_modules = {}\n        if use_wheels:\n            # Get the module libs\n            for i in p3dwhl.namelist():\n                if not i.startswith('deploy_libs/'):\n                    continue\n\n                if not any(i.endswith(suffix) for suffix in ext_suffixes):\n                    continue\n\n                if has_tkinter_wheel and i.startswith('deploy_libs/_tkinter.'):\n                    # Ignore this one, we have a separate tkinter package\n                    # nowadays that contains all the dependencies.\n                    continue\n\n                base = os.path.basename(i)\n                module, _, ext = base.partition('.')\n                whl_modules[module] = i\n\n        # Make sure to copy any builtins that have shared objects in the\n        # deploy libs, assuming they are not already in freezer_extras.\n        for mod, source_path in freezer_extras:\n            freezer_modules.discard(mod)\n\n        for mod in freezer_modules:\n            if mod in whl_modules:\n                freezer_extras.add((mod, None))\n\n        # Copy over necessary plugins\n        plugin_list = ['panda3d/lib{}'.format(i) for i in self.plugins]\n        for lib in p3dwhl.namelist():\n            plugname = lib.split('.', 1)[0]\n            if plugname in plugin_list:\n                source_path = os.path.join(p3dwhlfn, lib)\n                target_path = os.path.join(binary_dir, os.path.basename(lib))\n                search_path = [os.path.dirname(source_path)]\n                self.copy_with_dependencies(source_path, target_path, search_path)\n\n        # Copy any shared objects we need\n        for module, source_path in freezer_extras:\n            if source_path is not None:\n                # Rename panda3d/core.pyd to panda3d.core.pyd\n                source_path = os.path.normpath(source_path)\n                basename = os.path.basename(source_path)\n                if '.' in module:\n                    basename = module.rsplit('.', 1)[0] + '.' + basename\n\n                # Remove python version string\n                parts = basename.split('.')\n                if len(parts) >= 3 and ('-' in parts[-2] or parts[-2] == 'abi' + str(sys.version_info[0])):\n                    parts = parts[:-2] + parts[-1:]\n                    basename = '.'.join(parts)\n\n                # Was this not found in a wheel?  Then we may have a problem,\n                # since it may be for the current platform instead of the target\n                # platform.\n                if use_wheels:\n                    found_in_wheel = False\n                    for whl in wheelpaths:\n                        whl = os.path.normpath(whl)\n                        if source_path.lower().startswith(os.path.join(whl, '').lower()):\n                            found_in_wheel = True\n                            break\n\n                    if not found_in_wheel:\n                        self.warn('{} was not found in any downloaded wheel, is a dependency missing from requirements.txt?'.format(basename))\n            else:\n                # Builtin module, but might not be builtin in wheel libs, so double check\n                if module in whl_modules:\n                    source_path = os.path.join(p3dwhlfn, whl_modules[module])\n                    basename = os.path.basename(source_path)\n                    #XXX should we remove python version string here too?\n                else:\n                    continue\n\n            if platform.startswith('android'):\n                # Python modules on Android need a special prefix to be loadable\n                # as a library.\n                basename = 'libpy.' + basename\n\n            # If this is a dynamic library, search for dependencies.\n            target_path = os.path.join(binary_dir, basename)\n            search_path = get_search_path_for(source_path)\n            self.copy_with_dependencies(source_path, target_path, search_path)\n\n        # Copy classes.dex on Android\n        if use_wheels and platform.startswith('android'):\n            self.copy(os.path.join(p3dwhlfn, 'deploy_libs', 'classes.dex'),\n                      os.path.join(binary_dir, '..', '..', 'classes.dex'))\n\n        # Extract any other data files from dependency packages.\n        if data_dir is None:\n            return\n\n        for module, datadesc in self.package_data_dirs.items():\n            if module not in freezer_modules:\n                continue\n\n            self.announce('Copying data files for module: {}'.format(module), distutils.log.INFO)\n\n            # OK, find out in which .whl this occurs.\n            for whl in wheelpaths:\n                whlfile = self._get_zip_file(whl)\n                filenames = whlfile.namelist()\n                for source_pattern, target_dir, flags in datadesc:\n                    srcglob = p3d.GlobPattern(source_pattern.lower())\n                    source_dir = os.path.dirname(source_pattern)\n                    # Relocate the target dir to the build directory.\n                    target_dir = target_dir.replace('/', os.sep)\n                    target_dir = os.path.join(data_dir, target_dir)\n\n                    for wf in filenames:\n                        if wf.endswith('/'):\n                            # Skip directories.\n                            continue\n\n                        if wf.lower().startswith(source_dir.lower() + '/'):\n                            if not srcglob.matches(wf.lower()):\n                                continue\n\n                            wf = wf.replace('/', os.sep)\n                            relpath = wf[len(source_dir) + 1:]\n                            source_path = os.path.join(whl, wf)\n                            target_path = os.path.join(target_dir, relpath)\n\n                            if 'PKG_DATA_MAKE_EXECUTABLE' in flags:\n                                search_path = get_search_path_for(source_path)\n                                self.copy_with_dependencies(source_path, target_path, search_path)\n                                mode = os.stat(target_path).st_mode\n                                mode |= stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH\n                                os.chmod(target_path, mode)\n                            else:\n                                self.copy(source_path, target_path)\n\n    def build_assets(self, platform, data_dir):\n        \"\"\" Builds the data files for the given platform. \"\"\"\n\n        # Copy Game Files\n        self.announce('Copying assets for platform: {}'.format(platform), distutils.log.INFO)\n        ignore_copy_list = [\n            '**/__pycache__/**',\n            '**/*.pyc',\n            '**/*.py',\n            '{}/**'.format(self.build_base),\n        ]\n        ignore_copy_list += self.exclude_patterns\n        ignore_copy_list += self.extra_prc_files\n        ignore_copy_list = [p3d.GlobPattern(p3d.Filename.from_os_specific(i).get_fullpath()) for i in ignore_copy_list]\n\n        include_copy_list = [p3d.GlobPattern(i) for i in self.include_patterns]\n\n        def check_pattern(src, pattern_list):\n            # Normalize file paths across platforms\n            fn = p3d.Filename.from_os_specific(os.path.normpath(src))\n            path = fn.get_fullpath()\n            fn.make_absolute()\n            abspath = fn.get_fullpath()\n\n            for pattern in pattern_list:\n                # If the pattern is absolute, match against the absolute filename.\n                if pattern.pattern[0] == '/':\n                    #print('check ignore: {} {} {}'.format(pattern, src, pattern.matches_file(abspath)))\n                    if pattern.matches_file(abspath):\n                        return True\n                else:\n                    #print('check ignore: {} {} {}'.format(pattern, src, pattern.matches_file(path)))\n                    if pattern.matches_file(path):\n                        return True\n            return False\n\n        def check_file(fname):\n            return check_pattern(fname, include_copy_list) and \\\n                not check_pattern(fname, ignore_copy_list)\n\n        def skip_directory(src):\n            # Provides a quick-out for directory checks.  NOT recursive.\n            fn = p3d.Filename.from_os_specific(os.path.normpath(src))\n            path = fn.get_fullpath()\n            fn.make_absolute()\n            abspath = fn.get_fullpath()\n\n            for pattern in ignore_copy_list:\n                if not pattern.pattern.endswith('/*') and \\\n                   not pattern.pattern.endswith('/**'):\n                    continue\n\n                pattern_dir = p3d.Filename(pattern.pattern).get_dirname()\n                if abspath.startswith(pattern_dir + '/'):\n                    return True\n\n                if path.startswith(pattern_dir + '/'):\n                    return True\n\n            return False\n\n        def copy_file(src, dst):\n            src = os.path.normpath(src)\n            dst = os.path.normpath(dst)\n\n            if not check_file(src):\n                self.announce('skipping file {}'.format(src))\n                return\n\n            dst_dir = os.path.dirname(dst)\n            if not os.path.exists(dst_dir):\n                os.makedirs(dst_dir)\n\n            ext = os.path.splitext(src)[1]\n            # If the file ends with .gz/.pz, we strip this off.\n            if ext in ('.gz', '.pz'):\n                ext = os.path.splitext(src[:-3])[1]\n            if not ext:\n                ext = os.path.basename(src)\n\n            if ext in self.file_handlers:\n                buildscript = self.file_handlers[ext]\n                self.announce('running {} on src ({})'.format(buildscript.__name__, src))\n                try:\n                    dst = self.file_handlers[ext](self, src, dst)\n                except Exception as err:\n                    self.announce('{}'.format(err), distutils.log.ERROR)\n            else:\n                self.announce('copying {0} -> {1}'.format(src, dst))\n                shutil.copyfile(src, dst)\n\n        def update_path(path):\n            normpath = p3d.Filename.from_os_specific(os.path.normpath(src)).c_str()\n            for inputpath, outputpath in self.rename_paths.items():\n                if normpath.startswith(inputpath):\n                    normpath = normpath.replace(inputpath, outputpath, 1)\n            return p3d.Filename(normpath).to_os_specific()\n\n        rootdir = os.getcwd()\n        for dirname, subdirlist, filelist in os.walk(rootdir):\n            subdirlist.sort()\n            dirpath = os.path.relpath(dirname, rootdir)\n            if skip_directory(dirpath):\n                self.announce('skipping directory {}'.format(dirpath))\n                continue\n\n            for fname in filelist:\n                src = os.path.join(dirpath, fname)\n                dst = os.path.join(data_dir, update_path(src))\n\n                copy_file(src, dst)\n\n    def add_dependency(self, name, target_dir, search_path, referenced_by):\n        \"\"\" Searches for the given DLL on the search path.  If it exists,\n        copies it to the target_dir. \"\"\"\n\n        if os.path.exists(os.path.join(target_dir, name)):\n            # We've already added it earlier.\n            return\n\n        for dep in self.exclude_dependencies:\n            if dep.matches_file(name):\n                return\n\n        for dir in search_path:\n            source_path = os.path.join(dir, name)\n\n            if os.path.isfile(source_path):\n                target_path = os.path.join(target_dir, name)\n                self.copy_with_dependencies(source_path, target_path, search_path)\n                return\n\n            elif '.whl' in source_path:\n                # Check whether the file exists inside the wheel.\n                whl, wf = source_path.split('.whl' + os.path.sep)\n                whl += '.whl'\n                whlfile = self._get_zip_file(whl)\n\n                # Normalize the path separator\n                wf = os.path.normpath(wf).replace(os.path.sep, '/')\n\n                # Look case-insensitively.\n                namelist = whlfile.namelist()\n                namelist_lower = [file.lower() for file in namelist]\n\n                if wf.lower() in namelist_lower:\n                    # We have a match.  Change it to the correct case.\n                    wf = namelist[namelist_lower.index(wf.lower())]\n                    source_path = os.path.join(whl, wf)\n                    target_path = os.path.join(target_dir, os.path.basename(wf))\n                    self.copy_with_dependencies(source_path, target_path, search_path)\n                    return\n\n        # If we didn't find it, look again, but case-insensitively.\n        name_lower = name.lower()\n\n        for dir in search_path:\n            if os.path.isdir(dir):\n                files = os.listdir(dir)\n                files_lower = [file.lower() for file in files]\n\n                if name_lower in files_lower:\n                    name = files[files_lower.index(name_lower)]\n                    source_path = os.path.join(dir, name)\n                    target_path = os.path.join(target_dir, name)\n                    self.copy_with_dependencies(source_path, target_path, search_path)\n\n        # Warn if we can't find it, but only once.\n        self.warn(\"could not find dependency {0} (referenced by {1})\".format(name, referenced_by))\n        self.exclude_dependencies.append(p3d.GlobPattern(name.lower()))\n\n    def copy(self, source_path, target_path):\n        \"\"\" Copies source_path to target_path.\n\n        source_path may be located inside a .whl file. \"\"\"\n\n        try:\n            self.announce('copying {0} -> {1}'.format(os.path.relpath(source_path, self.build_base), os.path.relpath(target_path, self.build_base)))\n        except ValueError:\n            # No relative path (e.g., files on different drives in Windows), just print absolute paths instead\n            self.announce('copying {0} -> {1}'.format(source_path, target_path))\n\n        # Make the directory if it does not yet exist.\n        target_dir = os.path.dirname(target_path)\n        if not os.path.isdir(target_dir):\n            os.makedirs(target_dir)\n\n        # Copy the file, and open it for analysis.\n        if '.whl' in source_path:\n            # This was found in a wheel, extract it\n            whl, wf = source_path.split('.whl' + os.path.sep)\n            whl += '.whl'\n            whlfile = self._get_zip_file(whl)\n            data = whlfile.read(wf.replace(os.path.sep, '/'))\n            with open(target_path, 'wb') as f:\n                f.write(data)\n        else:\n            # Regular file, copy it\n            shutil.copyfile(source_path, target_path)\n\n    def copy_with_dependencies(self, source_path, target_path, search_path):\n        \"\"\" Copies source_path to target_path.  It also scans source_path for\n        any dependencies, which are located along the given search_path and\n        copied to the same directory as target_path.\n\n        source_path may be located inside a .whl file. \"\"\"\n\n        self.copy(source_path, target_path)\n\n        source_dir = os.path.dirname(source_path)\n        target_dir = os.path.dirname(target_path)\n        base = os.path.basename(target_path)\n\n        if source_dir not in search_path:\n            search_path = search_path + [source_dir]\n        self.copy_dependencies(target_path, target_dir, search_path, base)\n\n    def copy_dependencies(self, target_path, target_dir, search_path, referenced_by):\n        \"\"\" Copies the dependencies of target_path into target_dir. \"\"\"\n\n        fp = open(target_path, 'rb+')\n\n        # What kind of magic does the file contain?\n        deps = []\n        magic = fp.read(4)\n        if magic.startswith(b'MZ'):\n            # It's a Windows DLL or EXE file.\n            pe = pefile.PEFile()\n            pe.read(fp)\n            for lib in pe.imports:\n                deps.append(lib)\n\n        elif magic == b'\\x7FELF':\n            # Elf magic.  Used on (among others) Linux and FreeBSD.\n            deps = self._read_dependencies_elf(fp, target_dir, search_path)\n\n        elif magic in (b'\\xCE\\xFA\\xED\\xFE', b'\\xCF\\xFA\\xED\\xFE'):\n            # A Mach-O file, as used on macOS.\n            deps = self._read_dependencies_macho(fp, '<', flatten=True)\n\n        elif magic in (b'\\xFE\\xED\\xFA\\xCE', b'\\xFE\\xED\\xFA\\xCF'):\n            rel_dir = os.path.relpath(target_dir, os.path.dirname(target_path))\n            deps = self._read_dependencies_macho(fp, '>', flatten=True)\n\n        elif magic in (b'\\xCA\\xFE\\xBA\\xBE', b'\\xBE\\xBA\\xFE\\xCA'):\n            # A fat file, containing multiple Mach-O binaries.  In the future,\n            # we may want to extract the one containing the architecture we\n            # are building for.\n            deps = self._read_dependencies_fat(fp, False, flatten=True)\n\n        elif magic in (b'\\xCA\\xFE\\xBA\\xBF', b'\\xBF\\xBA\\xFE\\xCA'):\n            # A 64-bit fat file.\n            deps = self._read_dependencies_fat(fp, True, flatten=True)\n\n        # If we discovered any dependencies, recursively add those.\n        for dep in deps:\n            self.add_dependency(dep, target_dir, search_path, referenced_by)\n\n    def _read_dependencies_elf(self, elf, origin, search_path):\n        \"\"\" Having read the first 4 bytes of the ELF file, fetches the\n        dependent libraries and returns those as a list. \"\"\"\n\n        ident = elf.read(12)\n\n        # Make sure we read in the correct endianness and integer size\n        byte_order = \"<>\"[ord(ident[1:2]) - 1]\n        elf_class = ord(ident[0:1]) - 1 # 0 = 32-bits, 1 = 64-bits\n        header_struct = byte_order + (\"HHIIIIIHHHHHH\", \"HHIQQQIHHHHHH\")[elf_class]\n        section_struct = byte_order + (\"4xI8xIII8xI\", \"4xI16xQQI12xQ\")[elf_class]\n        dynamic_struct = byte_order + (\"iI\", \"qQ\")[elf_class]\n\n        type, machine, version, entry, phoff, shoff, flags, ehsize, phentsize, phnum, shentsize, shnum, shstrndx \\\n          = struct.unpack(header_struct, elf.read(struct.calcsize(header_struct)))\n        dynamic_sections = []\n        string_tables = {}\n\n        # Seek to the section header table and find the .dynamic section.\n        elf.seek(shoff)\n        for i in range(shnum):\n            type, offset, size, link, entsize = struct.unpack_from(section_struct, elf.read(shentsize))\n            if type == 6 and link != 0: # DYNAMIC type, links to string table\n                dynamic_sections.append((offset, size, link, entsize))\n                string_tables[link] = None\n\n        # Read the relevant string tables.\n        for idx in string_tables.keys():\n            elf.seek(shoff + idx * shentsize)\n            type, offset, size, link, entsize = struct.unpack_from(section_struct, elf.read(shentsize))\n            if type != 3:\n                continue\n            elf.seek(offset)\n            string_tables[idx] = elf.read(size)\n\n        # Loop through the dynamic sections and rewrite it if it has an rpath/runpath.\n        needed = []\n        rpath = []\n        for offset, size, link, entsize in dynamic_sections:\n            elf.seek(offset)\n            data = elf.read(entsize)\n            tag, val = struct.unpack_from(dynamic_struct, data)\n\n            # Read tags until we find a NULL tag.\n            while tag != 0:\n                if tag == 1: # A NEEDED entry.  Read it from the string table.\n                    string = string_tables[link][val : string_tables[link].find(b'\\0', val)]\n                    needed.append(string.decode('utf-8'))\n\n                elif tag == 15 or tag == 29:\n                    # An RPATH or RUNPATH entry.\n                    string = string_tables[link][val : string_tables[link].find(b'\\0', val)]\n                    rpath += [\n                        os.path.normpath(i.decode('utf-8').replace('$ORIGIN', origin))\n                        for i in string.split(b':')\n                    ]\n\n                data = elf.read(entsize)\n                tag, val = struct.unpack_from(dynamic_struct, data)\n        elf.close()\n\n        search_path += rpath\n        return needed\n\n    def _read_dependencies_macho(self, fp, endian, flatten=False):\n        \"\"\" Having read the first 4 bytes of the Mach-O file, fetches the\n        dependent libraries and returns those as a list.\n\n        If flatten is True, if the dependencies contain paths like\n        @loader_path/../.dylibs/libsomething.dylib, it will rewrite them to\n        instead contain @loader_path/libsomething.dylib if possible.\n        This requires the file pointer to be opened in rb+ mode. \"\"\"\n\n        cputype, cpusubtype, filetype, ncmds, sizeofcmds, flags = \\\n            struct.unpack(endian + 'IIIIII', fp.read(24))\n\n        is_64bit = (cputype & 0x1000000) != 0\n        if is_64bit:\n            fp.read(4)\n\n        # After the header, we get a series of linker commands.  We just\n        # iterate through them and gather up the LC_LOAD_DYLIB commands.\n        load_dylibs = []\n        for i in range(ncmds):\n            cmd, cmd_size = struct.unpack(endian + 'II', fp.read(8))\n            cmd_data = fp.read(cmd_size - 8)\n            cmd &= ~0x80000000\n\n            if cmd == 0x0c: # LC_LOAD_DYLIB\n                dylib = cmd_data[16:].decode('ascii').split('\\x00', 1)[0]\n                orig = dylib\n\n                if dylib.startswith('@loader_path/../Frameworks/'):\n                    dylib = dylib.replace('@loader_path/../Frameworks/', '')\n                elif dylib.startswith('@executable_path/../Frameworks/'):\n                    dylib = dylib.replace('@executable_path/../Frameworks/', '')\n                else:\n                    for prefix in ('@loader_path/', '@rpath/'):\n                        if dylib.startswith(prefix):\n                            dylib = dylib.replace(prefix, '')\n\n                            # Do we need to flatten the relative reference?\n                            if '/' in dylib and flatten:\n                                new_dylib = prefix + os.path.basename(dylib)\n                                str_size = len(cmd_data) - 16\n                                if len(new_dylib) < str_size:\n                                    fp.seek(-str_size, os.SEEK_CUR)\n                                    fp.write(new_dylib.encode('ascii').ljust(str_size, b'\\0'))\n                                else:\n                                    self.warn('Unable to rewrite dependency {}'.format(orig))\n\n                load_dylibs.append(dylib)\n\n        return load_dylibs\n\n    def _read_dependencies_fat(self, fp, is_64bit, flatten=False):\n        num_fat, = struct.unpack('>I', fp.read(4))\n\n        # After the header we get a table of executables in this fat file,\n        # each one with a corresponding offset into the file.\n        offsets = []\n        for i in range(num_fat):\n            if is_64bit:\n                cputype, cpusubtype, offset, size, align = \\\n                    struct.unpack('>QQQQQ', fp.read(40))\n            else:\n                cputype, cpusubtype, offset, size, align = \\\n                    struct.unpack('>IIIII', fp.read(20))\n            offsets.append(offset)\n\n        # Go through each of the binaries in the fat file.\n        deps = []\n        for offset in offsets:\n            # Add 4, since it expects we've already read the magic.\n            fp.seek(offset)\n            magic = fp.read(4)\n\n            if magic in (b'\\xCE\\xFA\\xED\\xFE', b'\\xCF\\xFA\\xED\\xFE'):\n                endian = '<'\n            elif magic in (b'\\xFE\\xED\\xFA\\xCE', b'\\xFE\\xED\\xFA\\xCF'):\n                endian = '>'\n            else:\n                # Not a Mach-O file we can read.\n                continue\n\n            for dep in self._read_dependencies_macho(fp, endian, flatten=flatten):\n                if dep not in deps:\n                    deps.append(dep)\n\n        return deps\n\n    def expand_path(self, path, platform):\n        \"Substitutes variables in the given path string.\"\n\n        if path is None:\n            return None\n\n        t = string.Template(path)\n        if platform.startswith('win'):\n            return t.substitute(HOME='~', USER_APPDATA='~/AppData/Local')\n        elif platform.startswith('macosx'):\n            return t.substitute(HOME='~', USER_APPDATA='~/Documents')\n        else:\n            return t.substitute(HOME='~', USER_APPDATA='~/.local/share')\n\n\nclass bdist_apps(setuptools.Command):\n    DEFAULT_INSTALLERS = {\n        'manylinux1_x86_64': ['gztar'],\n        'manylinux1_i686': ['gztar'],\n        'manylinux2010_x86_64': ['gztar'],\n        'manylinux2010_i686': ['gztar'],\n        'manylinux2014_x86_64': ['gztar'],\n        'manylinux2014_i686': ['gztar'],\n        'manylinux2014_aarch64': ['gztar'],\n        'manylinux2014_armv7l': ['gztar'],\n        'manylinux2014_ppc64': ['gztar'],\n        'manylinux2014_ppc64le': ['gztar'],\n        'manylinux2014_s390x': ['gztar'],\n        'manylinux_2_24_x86_64': ['gztar'],\n        'manylinux_2_24_i686': ['gztar'],\n        'manylinux_2_24_aarch64': ['gztar'],\n        'manylinux_2_24_armv7l': ['gztar'],\n        'manylinux_2_24_ppc64': ['gztar'],\n        'manylinux_2_24_ppc64le': ['gztar'],\n        'manylinux_2_24_s390x': ['gztar'],\n        'manylinux_2_28_x86_64': ['gztar'],\n        'manylinux_2_28_aarch64': ['gztar'],\n        'manylinux_2_28_ppc64le': ['gztar'],\n        'manylinux_2_28_s390x': ['gztar'],\n        'android': ['aab'],\n        # Everything else defaults to ['zip']\n    }\n\n    DEFAULT_INSTALLER_FUNCS = {\n        'zip': installers.create_zip,\n        'gztar': installers.create_gztar,\n        'bztar': installers.create_bztar,\n        'xztar': installers.create_xztar,\n        'nsis': installers.create_nsis,\n        'aab': installers.create_aab,\n    }\n\n    description = 'bundle built Panda3D applications into distributable forms'\n    user_options = build_apps.user_options + [\n        ('dist-dir=', 'd', 'directory to put final built distributions in'),\n        ('skip-build', None, 'skip rebuilding everything (for testing/debugging)'),\n    ]\n\n    def _build_apps_options(self):\n        return [opt[0].replace('-', '_').replace('=', '') for opt in build_apps.user_options]\n\n    def initialize_options(self):\n        self.installers = {}\n        self.dist_dir = os.path.join(os.getcwd(), 'dist')\n        self.skip_build = False\n        self.signing_certificate = None\n        self.signing_private_key = None\n        self.signing_passphrase = None\n        self.installer_functions = {}\n        self._current_platform = None\n        for opt in self._build_apps_options():\n            setattr(self, opt, None)\n\n    def finalize_options(self):\n        from importlib.metadata import entry_points\n\n        # We need to massage the inputs a bit in case they came from a\n        # setup.cfg file.\n        self.installers = {\n            key: _parse_list(value)\n            for key, value in _parse_dict(self.installers).items()\n        }\n\n        if self.signing_certificate:\n            assert self.signing_private_key, 'Missing signing_private_key'\n            self.signing_certificate = os.path.abspath(self.signing_certificate)\n            self.signing_private_key = os.path.abspath(self.signing_private_key)\n\n        eps = entry_points()\n        if isinstance(eps, dict): # Python 3.8 and 3.9\n            installer_eps = eps.get('panda3d.bdist_apps.installers', ())\n        else:\n            installer_eps = eps.select(group='panda3d.bdist_apps.installers')\n\n        tmp = self.DEFAULT_INSTALLER_FUNCS.copy()\n        tmp.update(self.installer_functions)\n        tmp.update({\n            entrypoint.name: entrypoint.load()\n            for entrypoint in installer_eps\n        })\n        self.installer_functions = tmp\n\n    def get_archive_basedir(self):\n        return self.distribution.get_name()\n\n    def get_current_platform(self):\n        return self._current_platform\n\n    def run(self):\n        build_cmd = self.distribution.get_command_obj('build_apps')\n        for opt in self._build_apps_options():\n            optval = getattr(self, opt)\n            if optval is not None:\n                setattr(build_cmd, opt, optval)\n        if not self.skip_build:\n            self.run_command('build_apps')\n        else:\n            build_cmd.finalize_options()\n\n        platforms = build_cmd.platforms\n        build_base = os.path.abspath(build_cmd.build_base)\n        if not os.path.exists(self.dist_dir):\n            os.makedirs(self.dist_dir)\n        os.chdir(self.dist_dir)\n\n        for platform in platforms:\n            build_dir = os.path.join(build_base, platform)\n            basename = '{}_{}'.format(self.distribution.get_fullname(), platform)\n            installers = self.installers.get(platform, self.DEFAULT_INSTALLERS.get(platform, ['zip']))\n            self._current_platform = platform\n\n            for installer in installers:\n                self.announce('\\nBuilding {} for platform: {}'.format(installer, platform), distutils.log.INFO)\n                if installer not in self.installer_functions:\n                    self.announce(\n                        '\\tUnknown installer: {}'.format(installer),\n                        distutils.log.ERROR\n                    )\n                    continue\n\n                self.installer_functions[installer](self, basename, build_dir)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/dist/commands.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/871bb042_commands.json",
    "doc_id": "doc_132"
  }
}