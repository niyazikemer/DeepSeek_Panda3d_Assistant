{
  "content": "Using memoryviews\n\nSince .GeomVertexArrayData supports the buffer protocol (as of Panda3D 1.9.0; see this blog post), an alternative to using GeomVertexWriter/Reader/Rewriter <more-about-geomvertexreader-geomvertexwriter-and-geomvertexrewriter> (as described in creating-and-filling-a-geomvertexdata) is to use memoryview objects to alter the contents of this structure directly. Other object types that implement the buffer protocol are bytearray and array.array in Python, as well as numpy arrays, so it's possible to seamlessly pass data between these and memoryviews.\n\nA memoryview can be used to change the values in a vertex array, but also to add values right after the creation of the array.\n\nCreating geometry\n\nLet's start with a very simple example, where a .GeomVertexData is created with the pre-defined format <pre-defined-vertex-formats> .GeomVertexFormat.get_v3(), such that the resulting data object will consist of only a single array, containing the model-space vertex coordinates. A memoryview of that array can be created as follows:\n\nv_format = GeomVertexFormat.get_v3()\nv_data = GeomVertexData('name', v_format, GeomEnums.UH_static)\nv_data.unclean_set_num_rows(4)\nv_array = v_data.modify_array(0)\n# create a memoryview that float values can be assigned to\nview = memoryview(v_array).cast('B').cast('f')\n\nOne important thing to note is that the size of a memoryview cannot be changed. So it is necessary to set the size of the vertex array before creating a view of it. In the code above, the number of vertex data rows is set to 4. This implicitly also sets the row count of all of its arrays to that same number.\n\nFilling in the newly created vertex data can be done like this:\n\nimport array\n\n# all of the coordinates can be put into a Python array...\ncoordinates = array.array('f', [\n    -1.0, 0.0, -1.0,  # the coordinates of the 1st vertex\n    1.0, 2.0, -1.0,   # the coordinates of the 2nd vertex\n    1.0, 0.0, 1.0,    # the coordinates of the 3rd vertex\n    -1.0, 0.0, 1.0    # the coordinates of the 4th vertex\n])\n# ...and assigned to the memoryview all at once\nview[:] = coordinates\n# it's also possible to assign a single float value to a particular element\n# of the memoryview:\nview[4] = 0.0  # modify the y-coordinate of the 2nd vertex\n\nSimilarly, the GeomPrimitive that combines the vertices into renderable geometry can be filled using a memoryview as well. After all, the return value of .GeomPrimitive.modify_vertices is also a .GeomVertexArrayData. Let's assume we want to render a square consisting of two triangles:\n\nindices = array.array('H', [\n    0, 1, 2,  # the vertex indices of the 1st triangle\n    0, 2, 3   # the vertex indices of the 2nd triangle\n])\ntris_prim = GeomTriangles(GeomEnums.UH_static)\ntris_array = tris_prim.modify_vertices()\n# note that `unclean_set_num_rows` fills the primitive with more or fewer\n# random integer values, which can be much larger than the number of vertices\n# in the associated vertex data object; this will cause an error when the\n# primitive is added to the scenegraph, so make sure the correct indices are\n# assigned before doing so, or call `set_num_rows` (slightly slower) instead\ntris_array.unclean_set_num_rows(len(indices))\nview = memoryview(tris_array).cast('B').cast('H')\nview[:] = indices\n\nNote that if the model is intended to contain a large amount of vertices (whether these are all added to the geometry at creation time or afterwards), an error will occur if that number exceeds 65535. This is because the index type of a GeomPrimitive is set to GeomEnums.NT_uint16 by default. To prevent this, set the index type to GeomEnums.NT_uint32 and cast values to the 'I' format:\n\n# use the 'I' format if values higher than 65535 are needed\nindices = array.array('I', [\n    0, 1, 2,  # the vertex indices of the 1st triangle\n    0, 2, 3   # the vertex indices of the 2nd triangle\n])\ntris_prim = GeomTriangles(GeomEnums.UH_static)\n# prepare the primitive to accept indices bigger than 65535, such that more\n# vertices can be added to the geometry later on\ntris_prim.set_index_type(GeomEnums.NT_uint32)\ntris_array = tris_prim.modify_vertices()\ntris_array.unclean_set_num_rows(len(indices))\n# cast to 'I' instead of 'H' if indices higher than 65535 are needed\nview = memoryview(tris_array).cast('B').cast('I')\nview[:] = indices\n\nUp till now, we've assumed that the vertex data contains only float values. However, the vertex format might support integer data as well. For instance, a custom column for storing indices might be required for a shader you want to apply to your model. More commonly, you will want the vertex format to support 8-bit integer color components. In this case, it is no longer possible to assign the values directly; they have to be converted to bytes.\n\nAs an example, here is some code that makes use of the .GeomVertexFormat.get_v3n3c4t2() format:\n\nimport struct\n\nv_format = GeomVertexFormat.get_v3n3c4t2()\nstride = v_format.arrays[0].stride  # the size of a data row, in bytes\nv_data = GeomVertexData('name', v_format, GeomEnums.UH_static)\nv_data.unclean_set_num_rows(4)\nv_array = v_data.modify_array(0)\nview = memoryview(v_array).cast('B')\nvalues = bytearray()\n# add the data of the 1st vertex to the bytearray\nvalues.extend(struct.pack(\n    '6f4B2f',  # the format corresponds to the GeomVertexFormat\n    -1.0, 0.0, -1.0,    # format: '3f'; the position of the 1st vertex\n    0.0, -1.0, 0.0,     # format: '3f'; the normal vector of the 1st vertex\n    255, 128, 64, 255,  # format: '4B'; the color of the 1st vertex\n    0.0, 0.0            # format: '2f'; the UVs of the 1st vertex\n))\n# add the data of the remaining vertices to the bytearray\n...\n# assign all of the values to the memoryview\nview[:] = values\n\nAltering geometry\n\nIf you require your model geometry to be dynamically altered at runtime, then the use of memoryviews is very efficient, as it can reduce or even avoid any unnecessary copy operations.\n\nAdding geometry\n\nConsider the square from the previous sample code to be a side of a cube. To add another side to that cube, you could use code like this:\n\nold_count = v_data.get_num_rows()\n# increase the number of data rows by 4 (since the new side has 4 vertices)\nvertex_data.set_num_rows(old_count + 4)\nv_array = vertex_data.modify_array(0)\nview = memoryview(v_array).cast('B')\nview[old_count * stride:] = values  # bytearray with new side values\n\ntris_array = tris_prim.modify_vertices()\nold_count = tris_array.get_num_rows()\n# increase the number of index rows by 6 (2 triangles, thus 6 vertex indices)\ntris_array.set_num_rows(old_count + 6)\nview = memoryview(tris_array).cast('B').cast('H')\nview[old_count:] = indices  # array.array filled with 6 new vertex indices\n\nRemoving geometry\n\nIf part of the geometry needs to be removed, e.g. a side from the cube in the previous example, this can be accomplished using code like the following:\n\nold_count = v_data.get_num_rows()\n# the size, in bytes, of the data associated with a cube side\nsize = 4 * stride  # 4 (vertices per side) times the size of a data row\n# in this case, the start index of the data to be removed can simply be\n# calculated as the index of the corresponding side (`n` if it was the `nth`\n# side to be added to the cube) multiplied by the size of that side\nstart = side_index * size\nv_array = v_data.modify_array(0)\nview = memoryview(v_array).cast('B')\n# instead of actually deleting the data, it is overwritten with the data that\n# follows it;\n# the end index of the data to overwrite equals the maximum index minus the\n# size of the side data, such that the subview (slice) of that data and the\n# subview of the data that follows the data to be overwritten have the exact\n# same size; only then can the latter be copied to the former\nview[start:-size] = view[start+size:]\n# now all that remains to be done is to update the number of data rows by\n# decreasing it by 4 (the number of vertices per side)\nv_data.set_num_rows(old_count - 4)\n\nold_count = tris_prim.get_num_vertices()\nstart = side_index * 6 # (2 triangles, thus 6 vertex indices)\n# just like the vertex data rows, the corresponding indices in the primitive\n# will be overwritten with those following them;\n# the latter additionally need to be offset, otherwise they would reference\n# vertices that are not in the vertex data table (since there are 4 fewer now)\ntris_prim.offset_vertices(-4, start + 6, old_count)\ntris_array = tris_prim.modify_vertices()\nview = memoryview(tris_array).cast('B').cast('H')\nview[start:-6] = view[start+6:]\ntris_array.set_num_rows(old_count - 6)",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/f2db4098_using-memoryviews.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/17d3a4e2_f2db4098_using-memoryviews.json",
    "doc_id": "doc_561"
  }
}