{
  "content": "Reference Counting\n\nReference Counts\n\nTo manage the lifetime of objects, Panda3D has a reference counting system for many objects. This means that for every object that uses this mechanism, a reference count is kept which counts the number of references exist to that object. Every time a new reference is made (eg. assigned to a new variable), the reference count is increased. When the reference count reaches zero, the object is deleted.\n\nThis is similar to Python's reference counting system, and in fact, the two systems interact when Panda3D is used with Python. However, since an object's lifetime may persist beyond the lifetime of an object in Python, Python's own reference counting system alone is not sufficient.\n\npython\n\nSince this system is entirely integrated with Python's own reference counting system, you generally do not need to be concerned with the details of this system. This page only exists for advanced users who need to manipulate the reference count for low-level integration with C++ code.\n\nThe class that manages the reference count is .ReferenceCount. To see if a class is reference counted, check if it inherits from ReferenceCount. C++ classes that are reference counted inherit from either .ReferenceCount or .TypedReferenceCount (if use of the typing system is desired), or another class that itself inherits from .ReferenceCount.\n\nManaging Reference Counts\n\nThere are several ways that the reference count can be manipulated in code. To get the number of references to an object, use the ~.ReferenceCount.get_ref_count() method.\n\nThe reference counted can be incremented and decremented manually using the ~.ReferenceCount.ref() and ~.ReferenceCount.unref() methods, but be careful! This messes up Panda's internal bookkeeping, and will likely cause crashes and memory leaks. Do not do this unless you know exactly what you're doing!\n\ncpp\n\nSmart Pointers\n\nTo correctly track references in C++ code, Panda3D needs to know whenever a new reference to the class is created. Therefore, Panda3D defines a template class PointerTo<T> which is just like the ordinary pointer T*, except that the reference count is incremented when it is created or assigned, and decremented when it goes out of scope. There is a convenience macro PT(T) to save typing.\n\nThere is also a macro ConstPointerTo<T>, shortened to CPT(T), which manages a pointer to a const object. This is similar to const T* in C++; the pointer can still be reassigned, but the object may not be modified.\n\nThis is a usage example:\n\nPT(TextNode) node = new TextNode(\"title\");\n\nnode->set_text(\"I am a reference counted TextNode!\");\n\nA PointerTo is functionally equivalent to a regular pointer, and it can cast implicitly to the appropriate pointer type. You can use ptr.p() to explicitly retrieve the underlying plain pointer.\n\nWhen they aren't necessary\n\nAlthough it is safest to use PT(T) to refer to an object in all cases, in some cases it is not strictly necessary and may be more efficient not to.\n\nThis can only be done, however, when you are absolutely sure that the reference count cannot decrease to zero during the time you might be using that reference. In particular, a getter or setter of a class storing a PointerTo need not take or return a PointerTo since the class object itself already holds a reference count.\n\nThe following code example highlights a case where it is not necessary:\n\nPT(TextNode) node;\nnode = new TextNode(\"title\");\n\nuse_text_node(node);\n\nvoid use_text_node(TextNode *node) {\n  node->do_something();\n}\n\nOne crucial example where the return value of a function has to be a PointerTo is where the function may return a new instance of the object:\n\nPT(TextNode) make_text_node() {\n  return new TextNode(\"title\");\n}\n\nPT(TextNode) node = make_text_node();\n\nManaging Reference Count\n\nAlthough it is recommended to use PointerTo for all references, it is possible to manage the reference count manually using the ref() and unref() methods, as already stated above.\n\nThis can not always work as an alternative, though, since an object returned from a function that returns a PointerTo may be destructed before you get a chance to call ref() to save it! This is why it's recommended to always use PointerTo except in very rare, low-level cases.\n\nWarning\n\nThe ~.ReferenceCount.unref() method should not be used if it may cause the reference count to reach zero. This is because a member function cannot destruct the object it is called on, so this will leak memory. Instead, you should use the unref_delete(pt) macro to decrease the reference count unless you are absolutely sure that it will not reach zero.\n\nWeak Pointer\n\nA weak pointer stores a reference to an object without incrementing its reference count. In this respect it is just like a regular C++ pointer, except that weak pointers have extra advantages: they can know when the underlying object has been destructed.\n\nWeak pointers are implemented by WeakPointerTo<T> and WeakConstPointerTo<T>, abbreviated to WPT(T) and WCPT(T), respectively. They work just like regular pointers, but be careful not to dereference it if it may have already been deleted! To see if it has been deleted, call ptr.was_deleted(). The only thread safe way to access its value is to call ptr.lock(), which returns nullptr if the pointer has been deleted (or is about to be), and otherwise returns a regular reference-counted PointerTo that ensures you can access it for as long as you hold it. This is a common idiom to access a weak pointer:\n\nif (auto ptr = weak_ptr.lock()) {\n  // Safely use ptr in here.\n} else {\n  // The pointer has been deleted.\n}\n\nCircular References\n\nWhen designing your class hierarchy, you should be particularly wary of circular references. This happens when object A stores a reference to object B, but object B also stores a reference to object A. Since each object will always retain a reference to the other object, the reference count will never reach zero and memory leaks may ensue.\n\nOne way to solve this problem is to store a regular, non-reference counted pointer to object A in object B, and let object A unset the reference to itself in its destructor. This is not a general solution, however, and the most optimal solution depends on the specific situation.\n\nStack Allocation\n\nIn some rare cases, it is desirable to create a temporary instance of the object on the stack. To achieve this, it is necessary to call ~ReferenceCount::local_object() on the object directly after allocation:\n\nTexture tex;\ntex.local_object();\n\nHowever, this should only be used for very temporary objects, since reference counted objects are not meant to be passed by value. Other code may assume it is safe to store a reference to it, causing the application to crash after the object goes out of scope.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/637658a3_reference-counting.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/34116fa8_637658a3_reference-counting.json",
    "doc_id": "doc_614"
  }
}