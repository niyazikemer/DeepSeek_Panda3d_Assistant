{
  "content": "\"\"\"ParentMgr module: contains the ParentMgr class\"\"\"\n\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.showbase.PythonUtil import isDefaultValue\n\n\nclass ParentMgr:\n    # This is now used on the AI as well.\n    \"\"\"ParentMgr holds a table of nodes that avatars may be parented to\n    in a distributed manner. All clients within a particular zone maintain\n    identical tables of these nodes, and the nodes are referenced by 'tokens'\n    which the clients can pass to each other to communicate distributed\n    reparenting information.\n\n    The functionality of ParentMgr used to be implemented with a simple\n    token->node dictionary. As distributed 'parent' objects were manifested,\n    they would add themselves to the dictionary. Problems occured when\n    distributed avatars were manifested before the objects to which they\n    were parented to.\n\n    Since the order of object manifestation depends on the order of the\n    classes in the DC file, we could maintain an ordering of DC definitions\n    that ensures that the necessary objects are manifested before avatars.\n    However, it's easy enough to keep a list of pending reparents and thus\n    support the general case without requiring any strict ordering in the DC.\n    \"\"\"\n\n    notify = DirectNotifyGlobal.directNotify.newCategory('ParentMgr')\n\n    def __init__(self):\n        self.token2nodepath = {}\n        # these are nodepaths that have requested to be parented to\n        # a node that has not yet registered as a parent\n        self.pendingParentToken2children = {}\n        # Multiple reparent requests may come in for a given child\n        # before that child can successfully be reparented. We need to\n        # make sure that each child is only scheduled to be parented to\n        # a single parent, at most.\n        # For efficient removal of pending children, we keep a dict\n        # of pending children to the token of the parent they're waiting for\n        self.pendingChild2parentToken = {}\n\n    def destroy(self):\n        del self.token2nodepath\n        del self.pendingParentToken2children\n        del self.pendingChild2parentToken\n\n    def privRemoveReparentRequest(self, child):\n        \"\"\" this internal function removes any currently-pending reparent\n        request for the given child nodepath \"\"\"\n        if child in self.pendingChild2parentToken:\n            self.notify.debug(\"cancelling pending reparent of %s to '%s'\" %\n                              (repr(child),\n                               self.pendingChild2parentToken[child]))\n            parentToken = self.pendingChild2parentToken[child]\n            del self.pendingChild2parentToken[child]\n            self.pendingParentToken2children[parentToken].remove(child)\n\n    def requestReparent(self, child, parentToken):\n        if parentToken in self.token2nodepath:\n            # this parent has registered\n            # this child may already be waiting on a different parent;\n            # make sure they aren't any more\n            self.privRemoveReparentRequest(child)\n            self.notify.debug(\"performing wrtReparent of %s to '%s'\" %\n                              (repr(child), parentToken))\n            child.wrtReparentTo(self.token2nodepath[parentToken])\n        else:\n            if isDefaultValue(parentToken):\n                self.notify.error('child %s requested reparent to default-value token: %s' % (repr(child), parentToken))\n            self.notify.debug(\n                \"child %s requested reparent to parent '%s' that is not (yet) registered\" %\n                (repr(child), parentToken))\n            # cancel any pending reparent on behalf of this child\n            self.privRemoveReparentRequest(child)\n            # make note of this pending parent request\n            self.pendingChild2parentToken[child] = parentToken\n            self.pendingParentToken2children.setdefault(parentToken, [])\n            self.pendingParentToken2children[parentToken].append(child)\n            # there is no longer any valid place for the child in the\n            # scenegraph; put it under hidden\n            child.reparentTo(hidden)\n\n    def registerParent(self, token, parent):\n        if token in self.token2nodepath:\n            self.notify.error(\n                \"registerParent: token '%s' already registered, referencing %s\" %\n                (token, repr(self.token2nodepath[token])))\n\n        if isDefaultValue(token):\n            self.notify.error('parent token (for %s) cannot be a default value (%s)' % (repr(parent), token))\n\n        if isinstance(token, int):\n            if token > 0xFFFFFFFF:\n                self.notify.error('parent token %s (for %s) is out of uint32 range' % (token, repr(parent)))\n\n        self.notify.debug(\"registering %s as '%s'\" % (repr(parent), token))\n        self.token2nodepath[token] = parent\n\n        # if we have any pending children, add them\n        if token in self.pendingParentToken2children:\n            children = self.pendingParentToken2children[token]\n            del self.pendingParentToken2children[token]\n            for child in children:\n                # NOTE: We do a plain-old reparentTo here (non-wrt)\n                # under the assumption that the node has been\n                # positioned as if it is already under the new parent.\n                #\n                # The only case that I can think of where the parent\n                # node would not have been registered at the time of\n                # the reparent request is when we're entering a new\n                # zone and manifesting remote toons along with\n                # other distributed objects, and a remote toon is\n                # requesting to be parented to geometry owned by a\n                # distributed object that has not yet been manifested.\n                #\n                # (The situation in the factory is a little different;\n                # the distributed toons of your companions are never\n                # disabled, since the toons are in the factory's uberzone.\n                # They send out requests to be parented to nodes that\n                # may be distributed objects, which may not be generated\n                # on your client)\n                #\n                # It is therefore important for that remote toon to\n                # have his position set as a required field, relative\n                # to the parent node, after the reparent request.\n                # If the node has already been registered, the toon will\n                # be in the correct position. Otherwise, the toon will\n                # have the correct position but the wrong parent node,\n                # until this code runs and corrects the toon's parent\n                # node. Since we don't start rendering until all objects\n                # in a new zone have been generated, all of that action\n                # will happen in a single frame, and the net result will\n                # be that the toon will be in the right place when\n                # rendering starts.\n                self.notify.debug(\"performing reparent of %s to '%s'\" %\n                                  (repr(child), token))\n                child.reparentTo(self.token2nodepath[token])\n                # remove this child from the child->parent table\n                assert self.pendingChild2parentToken[child] == token\n                del self.pendingChild2parentToken[child]\n\n    def unregisterParent(self, token):\n        if token not in self.token2nodepath:\n            self.notify.warning(\"unregisterParent: unknown parent token '%s'\" %\n                                token)\n            return\n        self.notify.debug(\"unregistering parent '%s'\" % (token))\n        del self.token2nodepath[token]\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/ParentMgr.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/b7c366d2_ParentMgr.json",
    "doc_id": "doc_316"
  }
}