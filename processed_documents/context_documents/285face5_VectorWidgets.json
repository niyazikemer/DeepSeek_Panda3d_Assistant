{
  "content": "\"\"\"Undocumented Module\"\"\"\n\n__all__ = ['VectorEntry', 'Vector2Entry', 'Vector3Entry', 'Vector4Entry', 'ColorEntry']\n\nfrom . import Valuator\nimport Pmw\nimport tkinter as tk\nfrom tkinter.colorchooser import askcolor\n\n\nclass VectorEntry(Pmw.MegaWidget):\n    def __init__(self, parent = None, **kw):\n\n        # Default vector size\n        DEFAULT_DIM = 3\n        # Default value depends on *actual* vector size, test for user input\n        DEFAULT_VALUE = [0.0] * kw.get('dim', DEFAULT_DIM)\n        DEFAULT_LABELS = ['v[%d]' % x for x in range(kw.get('dim', DEFAULT_DIM))]\n\n        # Process options\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            ('dim',                 DEFAULT_DIM,    INITOPT),\n            ('value',        DEFAULT_VALUE,  INITOPT),\n            ('resetValue',          DEFAULT_VALUE,  None),\n            ('label_width',         12,             None),\n            ('labelIpadx',          2,              None),\n            ('command',             None,           None),\n            ('entryWidth',          8,              self._updateEntryWidth),\n            ('relief',              tk.GROOVE,      self._updateRelief),\n            ('bd',                  2,              self._updateBorderWidth),\n            ('text',                'Vector:',      self._updateText),\n            ('min',                 None,           self._updateValidate),\n            ('max',                 None,           self._updateValidate),\n            ('numDigits',           2,              self._setSigDigits),\n            ('type',                'floater',      None),\n            ('state',               'normal',       self._setState),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Initialize superclass\n        Pmw.MegaWidget.__init__(self, parent)\n\n        # Initialize value\n        # Make sure its a list (and as a byproduct, make a distinct copy)\n        self._value = list(self['value'])\n        self['resetValue'] = self['value']\n        self._floaters = None\n        self.entryFormat = '%.2f'\n\n        # Get a handle on the parent container\n        interior = self.interior()\n\n        # This does double duty as a menu button\n        self._label = self.createcomponent('label', (), None,\n                                           tk.Menubutton, (interior,),\n                                           text = self['text'],\n                                           activebackground = '#909090')\n        self.menu = self._label['menu'] = tk.Menu(self._label)\n        self.menu.add_command(label = 'Reset', command = self.reset)\n        self.menu.add_command(label = 'Popup sliders', command = self.popupSliders)\n        self._label.pack(side = tk.LEFT, fill = tk.X, ipadx = self['labelIpadx'])\n\n        self.variableList = []\n        self.entryList = []\n        for index in range(self['dim']):\n            var = tk.StringVar()\n            self.variableList.append(var)\n            # To set the configuration of all entrys in a vector use:\n            # ve.configure(Entry_XXX = YYY)\n            # To configure an individual entryfield's entry use:\n            # ve.configure(entry0_XXX = YYY)\n            entry = self.createcomponent(\n                'entryField%d' % index,\n                (('entry%d' % index,\n                  'entryField%d_entry' % index),),\n                'Entry',\n                Pmw.EntryField, (interior,),\n                entry_justify = tk.RIGHT,\n                entry_textvariable = var,\n                command = lambda s = self, i = index: s._entryUpdateAt(i))\n            entry.pack(side = tk.LEFT, expand = 1, fill = tk.X)\n            self.entryList.append(entry)\n\n        # To configure the floaterGroup use:\n        # ve.configure(floaterGroup_XXX = YYY)\n        # ve.configure(fGroup_XXX = YYY) or\n        # To set the configuration all floaters in a group use:\n        # ve.configure(Valuator_XXX = YYY)\n        # To configure an individual floater in a group use:\n        # ve.configure(floaterGroup_floater0_XXX = YYY) or\n        # ve.configure(fGroup_floater0_XXX = YYY)\n        self._floaters = self.createcomponent(\n            'floaterGroup',\n            (('fGroup', 'floaterGroup'),\n             ('valuator', 'floaterGroup_valuator'),), None,\n            Valuator.ValuatorGroupPanel, (self.interior(),),\n            dim = self['dim'],\n            #title = self['text'],\n            type = self['type'],\n            command = self.set)\n        # Note: This means the 'X' on the menu bar doesn't really destroy\n        # the panel, just withdraws it.  This is to avoid problems which occur\n        # if the user kills the floaterGroup and then tries to pop it open again\n        self._floaters.userdeletefunc(self._floaters.withdraw)\n        self._floaters.withdraw()\n\n        # Make sure entries are updated\n        self.set(self['value'])\n\n        # Record entry color\n        self.entryBackground = self.cget('Entry_entry_background')\n\n        # Make sure input variables processed\n        self.initialiseoptions(VectorEntry)\n\n    def label(self):\n        return self._label\n\n    def entry(self, index):\n        return self.entryList[index]\n\n    def floaters(self):\n        return self._floaters\n\n    def _clearFloaters(self):\n        self._floaters.withdraw()\n\n    def _updateText(self):\n        self._label['text'] = self['text']\n\n    def _updateRelief(self):\n        self.interior()['relief'] = self['relief']\n\n    def _updateBorderWidth(self):\n        self.interior()['bd'] = self['bd']\n\n    def _updateEntryWidth(self):\n        self['Entry_entry_width'] = self['entryWidth']\n\n    def _setSigDigits(self):\n        sd = self['numDigits']\n        self.entryFormat = '%.' + '%d' % sd + 'f'\n        self.configure(valuator_numDigits = sd)\n        # And refresh value to reflect change\n        for index in range(self['dim']):\n            self._refreshEntry(index)\n\n    def _updateValidate(self):\n        # Update entry field to respect new limits\n        self.configure(Entry_validate = {\n            'validator': 'real',\n            'min': self['min'],\n            'max': self['max'],\n            'minstrict': 0,\n            'maxstrict': 0})\n        # Reflect changes in floaters\n        self.configure(valuator_min = self['min'],\n                       valuator_max = self['max'])\n\n    def get(self):\n        return self._value\n\n    def getAt(self, index):\n        return self._value[index]\n\n    def set(self, value, fCommand = 1):\n        if type(value) in (float, int):\n            value = [value] * self['dim']\n        for i in range(self['dim']):\n            self._value[i] = value[i]\n            self.variableList[i].set(self.entryFormat % value[i])\n        self.action(fCommand)\n\n    def setAt(self, index, value, fCommand = 1):\n        self.variableList[index].set(self.entryFormat % value)\n        self._value[index] = value\n        self.action(fCommand)\n\n    def _entryUpdateAt(self, index):\n        entryVar = self.variableList[index]\n        # Did we get a valid float?\n        try:\n            newVal = float(entryVar.get())\n        except ValueError:\n            return\n\n        # Clamp value\n        if self['min'] is not None:\n            if newVal < self['min']:\n                newVal = self['min']\n        if self['max'] is not None:\n            if newVal > self['max']:\n                newVal = self['max']\n\n        # Update vector's value\n        self._value[index] = newVal\n\n        # refresh entry to reflect formatted value\n        self._refreshEntry(index)\n\n        # Update the floaters and call the command\n        self.action()\n\n    def _refreshEntry(self, index):\n        self.variableList[index].set(self.entryFormat % self._value[index])\n        self.entryList[index].checkentry()\n\n    def _refreshFloaters(self):\n        if self._floaters:\n            self._floaters.set(self._value, 0)\n\n    def action(self, fCommand = 1):\n        self._refreshFloaters()\n        if fCommand and (self['command'] is not None):\n            self['command'](self._value)\n\n    def reset(self):\n        self.set(self['resetValue'])\n\n    def addMenuItem(self, label = '', command = None):\n        self.menu.add_command(label = label, command = command)\n\n    def popupSliders(self):\n        self._floaters.set(self.get()[:])\n        self._floaters.show()\n\n    def _setState(self):\n        if self['state'] == 'disabled':\n            # Disable entry\n            self.configure(Entry_entry_state = 'disabled')\n            self.configure(Entry_entry_background = '#C0C0C0')\n            # Disable floater Group scale\n            self.component('fGroup').configure(\n                valuator_state = 'disabled')\n            # Disable floater group entry\n            self.component('fGroup').configure(\n                valuator_entry_state = 'disabled')\n            self.component('fGroup').configure(\n                valuator_entry_background = '#C0C0C0')\n        else:\n            # Disable entry\n            self.configure(Entry_entry_state = 'normal')\n            self.configure(Entry_entry_background = self.entryBackground)\n            # Disable floater Group scale\n            self.component('fGroup').configure(\n                valuator_state = 'normal')\n            # Disable floater group entry\n            self.component('fGroup').configure(\n                valuator_entry_state = 'normal')\n            self.component('fGroup').configure(\n                valuator_entry_background = self.entryBackground)\n\n\nclass Vector2Entry(VectorEntry):\n    def __init__(self, parent = None, **kw):\n        # Initialize options for the class\n        optiondefs = (\n            ('dim',    2,       Pmw.INITOPT),\n            ('fGroup_labels',   ('X','Y','Z'),  None),\n        )\n        self.defineoptions(kw, optiondefs)\n        # Initialize the superclass, make sure dim makes it to superclass\n        VectorEntry.__init__(self, parent, dim = self['dim'])\n        # Needed because this method checks if self.__class__ is myClass\n        # where myClass is the argument passed into inialiseoptions\n        self.initialiseoptions(Vector2Entry)\n\n\nclass Vector3Entry(VectorEntry):\n    def __init__(self, parent = None, **kw):\n        # Initialize options for the class\n        optiondefs = (\n            ('dim',    3,       Pmw.INITOPT),\n            ('fGroup_labels',   ('X','Y','Z'),  None),\n        )\n        self.defineoptions(kw, optiondefs)\n        # Initialize the superclass, make sure dim makes it to superclass\n        VectorEntry.__init__(self, parent, dim = self['dim'])\n        # Needed because this method checks if self.__class__ is myClass\n        # where myClass is the argument passed into inialiseoptions\n        self.initialiseoptions(Vector3Entry)\n\n\nclass Vector4Entry(VectorEntry):\n    def __init__(self, parent = None, **kw):\n        # Initialize options for the class\n        optiondefs = (\n            ('dim',     4,      Pmw.INITOPT),\n            ('fGroup_labels',   ('X','Y','Z','W'),  None),\n        )\n        self.defineoptions(kw, optiondefs)\n        # Initialize the superclass, make sure dim makes it to superclass\n        VectorEntry.__init__(self, parent, dim = self['dim'])\n        # Needed because this method checks if self.__class__ is myClass\n        # where myClass is the argument passed into inialiseoptions\n        self.initialiseoptions(Vector4Entry)\n\n\nclass ColorEntry(VectorEntry):\n    def __init__(self, parent = None, **kw):\n        # Initialize options for the class (overriding some superclass options)\n        optiondefs = (\n            ('dim',                     4,                  Pmw.INITOPT),\n            ('type',                    'slider',           Pmw.INITOPT),\n            ('fGroup_labels',           ('R','G','B','A'),  None),\n            ('min',                     0.0,                None),\n            ('max',                     255.0,              None),\n            ('nuDigits',                0,                  None),\n            ('valuator_resolution',     1.0,                None),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Initialize the superclass, make sure dim makes it to superclass\n        VectorEntry.__init__(self, parent, dim = self['dim'])\n        # Add menu item to popup color picker\n        self.addMenuItem(\n            'Popup color picker',\n            command = lambda s = self: s.popupColorPicker())\n        # Needed because this method checks if self.__class__ is myClass\n        # where myClass is the argument passed into inialiseoptions\n        self.initialiseoptions(ColorEntry)\n\n    def popupColorPicker(self):\n        # Can pass in current color with: color = (255, 0, 0)\n        color = askcolor(\n            parent = self.interior(),\n            # Initialize it to current color\n            initialcolor = tuple(self.get()[:3]))[0]\n        if color:\n            self.set((color[0], color[1], color[2], self.getAt(3)))\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/tkwidgets/VectorWidgets.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/285face5_VectorWidgets.json",
    "doc_id": "doc_191"
  }
}