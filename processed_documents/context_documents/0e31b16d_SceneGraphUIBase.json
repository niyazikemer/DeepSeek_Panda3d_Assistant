{
  "content": "\"\"\"\nDefines Scene Graph tree UI Base\n\"\"\"\nimport wx\nfrom panda3d.core import NodePath\nfrom .ActionMgr import ActionChangeHierarchy, ActionDeleteObjById\n\nfrom . import ObjectGlobals as OG\n\n\nclass SceneGraphUIDropTarget(wx.TextDropTarget):\n    def __init__(self, editor):\n        print(\"in SceneGraphUIDropTarget::init...\")\n        wx.TextDropTarget.__init__(self)\n        self.editor = editor\n\n    def OnDropText(self, x, y, text):\n        print(\"in SceneGraphUIDropTarget::OnDropText...\")\n        self.editor.ui.sceneGraphUI.changeHierarchy(text, x, y)\n\n\nclass SceneGraphUIBase(wx.Panel):\n    def __init__(self, parent, editor):\n        wx.Panel.__init__(self, parent)\n\n        self.editor = editor\n        self.tree = wx.TreeCtrl(self, id=-1, pos=wx.DefaultPosition,\n                  size=wx.DefaultSize, style=wx.TR_MULTIPLE|wx.TR_DEFAULT_STYLE,\n                  validator=wx.DefaultValidator, name=\"treeCtrl\")\n        self.root = self.tree.AddRoot('render')\n        self.tree.SetItemData(self.root, \"render\")\n\n        self.shouldShowPandaObjChildren = False\n\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        sizer.Add(self.tree, 1, wx.EXPAND, 0)\n        self.SetSizer(sizer)\n        self.Layout()\n\n        parentSizer = wx.BoxSizer(wx.VERTICAL)\n        parentSizer.Add(self, 1, wx.EXPAND, 0)\n        parent.SetSizer(parentSizer)\n        parent.Layout()\n\n        parent.SetDropTarget(SceneGraphUIDropTarget(self.editor))\n\n        self.tree.Bind(wx.EVT_TREE_SEL_CHANGED, self.onSelected)\n        self.tree.Bind(wx.EVT_TREE_BEGIN_DRAG, self.onBeginDrag)\n\n        self.currItem = None\n        self.currObj = None\n        self.menu = wx.Menu()\n        self.populateMenu()\n        self.Bind(wx.EVT_CONTEXT_MENU, self.onShowPopup)\n\n    def reset(self):\n        #import pdb;set_trace()\n        itemList = list()\n        item, cookie = self.tree.GetFirstChild(self.root)\n        while item:\n            itemList.append(item)\n            item, cookie = self.tree.GetNextChild(self.root, cookie)\n\n        for item in itemList:\n            self.tree.Delete(item)\n\n    def traversePandaObjects(self, parent, objNodePath):\n        itemId = self.tree.GetItemData(parent)\n        i = 0\n        for child in objNodePath.getChildren():\n            if child.hasTag('OBJRoot'):\n                # since they are already shown in scene graph tree\n                continue\n            namestr = \"%s.%s\"%(child.node().getType(), child.node().getName())\n            newItem = self.tree.PrependItem(parent, namestr)\n            newItemId = \"%s.%s\"%(itemId, i)\n            self.tree.SetItemPyData(newItem, newItemId)\n\n            # recursing...\n            self.traversePandaObjects(newItem, child)\n            i = i + 1\n\n    def addPandaObjectChildren(self, parent):\n        # first, find Panda Object's NodePath of the item\n        itemId = self.tree.GetItemData(parent)\n        if itemId == \"render\":\n            return\n        obj = self.editor.objectMgr.findObjectById(itemId)\n        if obj is None:\n            return\n\n        objNodePath = obj[OG.OBJ_NP]\n        self.traversePandaObjects(parent, objNodePath)\n\n        item, cookie = self.tree.GetFirstChild(parent)\n        while item:\n            # recursing...\n            self.addPandaObjectChildren(item)\n            item, cookie = self.tree.GetNextChild(parent, cookie)\n\n    def removePandaObjectChildren(self, parent):\n        # first, find Panda Object's NodePath of the item\n        itemId = self.tree.GetItemData(parent)\n        if itemId == \"render\":\n            return\n        obj = self.editor.objectMgr.findObjectById(itemId)\n        if obj is None:\n            self.tree.Delete(parent)\n            return\n        item, cookie = self.tree.GetFirstChild(parent)\n        while item:\n            # recurse...\n            itemToRemove = item\n            # continue iteration to the next child\n            item, cookie = self.tree.GetNextChild(parent, cookie)\n            self.removePandaObjectChildren(itemToRemove)\n\n    def add(self, item, parentNP = None):\n        #import pdb;pdb.set_trace()\n        if item is None:\n            return\n        obj = self.editor.objectMgr.findObjectByNodePath(NodePath(item))\n        if obj is None:\n            return\n\n        if parentNP is None:\n            parentNP = obj[OG.OBJ_NP].getParent()\n        parentObj = self.editor.objectMgr.findObjectByNodePath(parentNP)\n\n        if parentObj is None:\n            parent = self.root\n        else:\n            parent = self.traverse(self.root, parentObj[OG.OBJ_UID])\n\n        name = NodePath(item).getName()\n        if not name:\n            name = ' '\n        namestr = \"%s_%s_%s\"%(obj[OG.OBJ_DEF].name, name, obj[OG.OBJ_UID])\n        newItem = self.tree.AppendItem(parent, namestr)\n        self.tree.SetItemPyData(newItem, obj[OG.OBJ_UID])\n\n        # adding children of PandaObj\n        if self.shouldShowPandaObjChildren:\n            self.addPandaObjectChildren(newItem)\n        self.tree.Expand(self.root)\n\n    def traverse(self, parent, itemId):\n        # prevent from traversing into self\n        if itemId == self.tree.GetItemData(parent):\n            return None\n\n        # main loop - serching for an item with an itemId\n        item, cookie = self.tree.GetFirstChild(parent)\n        while item:\n            # if the item was found - return it\n            if itemId == self.tree.GetItemData(item):\n                return item\n\n            # the tem was not found - checking if it has children\n            if self.tree.ItemHasChildren(item):\n                # item has children - delving into it\n                child = self.traverse(item, itemId)\n                if child is not None:\n                    return child\n\n            # continue iteration to the next child\n            item, cookie = self.tree.GetNextChild(parent, cookie)\n        return None\n\n    def reParentTree(self, parent, newParent):\n        # main loop - iterating over item's children\n        item, cookie = self.tree.GetFirstChild(parent)\n        while item:\n            data = self.tree.GetItemText(item)\n            itemId = self.tree.GetItemData(item)\n            newItem = self.tree.AppendItem(newParent, data)\n            self.tree.SetItemPyData(newItem, itemId)\n\n            # if an item had children, we need to re-parent them as well\n            if self.tree.ItemHasChildren(item):\n                # recursing...\n                self.reParentTree(item, newItem)\n\n            # continue iteration to the next child\n            item, cookie = self.tree.GetNextChild(parent, cookie)\n\n    def reParentData(self, parent, child):\n        child.wrtReparentTo(parent)\n\n    def reParent(self, oldParent, newParent, child):\n        if newParent is None:\n            newParent = self.root\n        itemId = self.tree.GetItemData(oldParent)\n        newItem = self.tree.AppendItem(newParent, child)\n        self.tree.SetItemPyData(newItem, itemId)\n        self.reParentTree(oldParent, newItem)\n\n        obj = self.editor.objectMgr.findObjectById(itemId)\n        itemId = self.tree.GetItemData(newParent)\n        if itemId != \"render\":\n            newParentObj = self.editor.objectMgr.findObjectById(itemId)\n            self.reParentData(newParentObj[OG.OBJ_NP], obj[OG.OBJ_NP])\n        else:\n            self.reParentData(render, obj[OG.OBJ_NP])\n\n        self.tree.Delete(oldParent)\n        if self.shouldShowPandaObjChildren:\n            self.removePandaObjectChildren(oldParent)\n            self.addPandaObjectChildren(oldParent)\n            self.removePandaObjectChildren(newParent)\n            self.addPandaObjectChildren(newParent)\n\n    def isChildOrGrandChild(self, parent, child):\n        childId = self.tree.GetItemData(child)\n        return self.traverse(parent, childId)\n\n    def changeHierarchy(self, data, x, y):\n        itemText = data.split('_')\n        itemId = itemText[-1] # uid is the last token\n        item = self.traverse(self.tree.GetRootItem(), itemId)\n        if item is None:\n            return\n\n        dragToItem, flags = self.tree.HitTest(wx.Point(x, y))\n        if dragToItem.IsOk():\n            # prevent draging into itself\n            if dragToItem == item:\n                return\n            if self.isChildOrGrandChild(item, dragToItem):\n                return\n\n            # undo function setup...\n            action = ActionChangeHierarchy(self.editor, self.tree.GetItemData(self.tree.GetItemParent(item)), self.tree.GetItemData(item), self.tree.GetItemData(dragToItem), data)\n            self.editor.actionMgr.push(action)\n            action()\n\n    def parent(self, oldParentId, newParentId, childName):\n        oldParent = self.traverse(self.tree.GetRootItem(), oldParentId)\n        newParent = self.traverse(self.tree.GetRootItem(), newParentId)\n        self.reParent(oldParent, newParent, childName)\n\n    def showPandaObjectChildren(self):\n        itemList = list()\n        self.shouldShowPandaObjChildren = not self.shouldShowPandaObjChildren\n\n        item, cookie = self.tree.GetFirstChild(self.root)\n        while item:\n            itemList.append(item)\n            item, cookie = self.tree.GetNextChild(self.root, cookie)\n\n        #import pdb;set_trace()\n        for item in itemList:\n            if self.shouldShowPandaObjChildren:\n                self.addPandaObjectChildren(item)\n            else:\n                self.removePandaObjectChildren(item)\n            # continue iteration to the next child\n\n    def delete(self, itemId):\n        item = self.traverse(self.root, itemId)\n        if item:\n            self.tree.Delete(item)\n\n    def select(self, itemId):\n        item = self.traverse(self.root, itemId)\n        if item:\n            if not self.tree.IsSelected(item):\n                self.tree.SelectItem(item)\n                self.tree.EnsureVisible(item)\n\n    def changeLabel(self, itemId, newName):\n        item = self.traverse(self.root, itemId)\n        if item:\n            obj = self.editor.objectMgr.findObjectById(itemId)\n            if obj is None:\n                return\n\n            obj[OG.OBJ_NP].setName(newName)\n            namestr = \"%s_%s_%s\"%(obj[OG.OBJ_DEF].name, newName, obj[OG.OBJ_UID])\n            self.tree.SetItemText(item, namestr)\n\n    def deSelect(self, itemId):\n        item =  self.traverse(self.root, itemId)\n        if item is not None:\n            self.tree.UnselectItem(item)\n\n    def onSelected(self, event):\n        item = event.GetItem()\n        if item:\n            itemId = self.tree.GetItemData(item)\n            if itemId:\n                obj = self.editor.objectMgr.findObjectById(itemId)\n                if obj:\n                    selections = self.tree.GetSelections()\n                    if len(selections) > 1:\n                        base.direct.select(obj[OG.OBJ_NP], fMultiSelect = 1, fLEPane = 0)\n                    else:\n                        base.direct.select(obj[OG.OBJ_NP], fMultiSelect = 0, fLEPane = 0)\n\n    def onBeginDrag(self, event):\n        item = event.GetItem()\n\n        if item != self.tree.GetRootItem(): # prevent dragging root item\n            text = self.tree.GetItemText(item)\n            print(\"Starting SceneGraphUI drag'n'drop with %s...\" % repr(text))\n\n            tdo = wx.TextDataObject(text)\n            tds = wx.DropSource(self.tree)\n            tds.SetData(tdo)\n            tds.DoDragDrop(True)\n\n    def onShowPopup(self, event):\n        pos = event.GetPosition()\n        pos = self.ScreenToClient(pos)\n\n        item, flags = self.tree.HitTest(pos)\n        if not item.IsOk():\n            return\n        self.currItem = item\n        itemId = self.tree.GetItemData(item)\n        if not itemId:\n            return\n        self.currObj = self.editor.objectMgr.findObjectById(itemId)\n        if self.currObj:\n            self.PopupMenu(self.menu, pos)\n\n    def populateMenu(self):\n        menuitem = self.menu.Append(-1, 'Expand All')\n        self.Bind(wx.EVT_MENU, self.onExpandAllChildren, menuitem)\n        menuitem = self.menu.Append(-1, 'Collapse All')\n        self.Bind(wx.EVT_MENU, self.onCollapseAllChildren, menuitem)\n        menuitem = self.menu.Append(-1, 'Delete')\n        self.Bind(wx.EVT_MENU, self.onDelete, menuitem)\n        menuitem = self.menu.Append(-1, 'Rename')\n        self.Bind(wx.EVT_MENU, self.onRename, menuitem)\n        self.populateExtraMenu()\n\n    def populateExtraMenu(self):\n        # You should implement this in subclass\n        raise NotImplementedError('populateExtraMenu() must be implemented in subclass')\n\n    def onCollapseAllChildren(self, evt=None):\n        if self.currItem:\n            self.tree.CollapseAllChildren(self.currItem)\n\n    def onExpandAllChildren(self, evt=None):\n        if self.currItem:\n            self.tree.ExpandAllChildren(self.currItem)\n\n    def onDelete(self, evt=None):\n        if self.currObj is None:\n            return\n\n        uid = self.currObj[OG.OBJ_UID]\n        action = ActionDeleteObjById(self.editor, uid)\n        self.editor.actionMgr.push(action)\n        action()\n        self.delete(uid)\n\n    def onRename(self, evt=None):\n        if self.currObj is None:\n            return\n\n        self.editor.ui.bindKeyEvents(False)\n        dialog = wx.TextEntryDialog(None, '', 'Input new name', defaultValue=self.currObj[OG.OBJ_NP].getName())\n        if dialog.ShowModal() == wx.ID_OK:\n            newName = dialog.GetValue()\n        dialog.Destroy()\n        self.editor.ui.bindKeyEvents(True)\n        self.currObj[OG.OBJ_NP].setName(newName)\n        self.changeLabel(self.currObj[OG.OBJ_UID], newName)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/leveleditor/SceneGraphUIBase.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/0e31b16d_SceneGraphUIBase.json",
    "doc_id": "doc_25"
  }
}