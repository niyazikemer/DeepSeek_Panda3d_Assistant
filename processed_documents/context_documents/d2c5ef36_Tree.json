{
  "content": "\"\"\"Defines tree widgets for the tkinter GUI system.\"\"\"\n\n__all__ = ['TreeNode', 'TreeItem']\n\n# ADAPTED FROM IDLE TreeWidget.py\n# XXX TO DO:\n# - popup menu\n# - support partial or total redisplay\n# - key bindings (instead of quick-n-dirty bindings on Canvas):\n#   - up/down arrow keys to move focus around\n#   - ditto for page up/down, home/end\n#   - left/right arrows to expand/collapse and move out/in\n# - more doc strings\n# - add icons for \"file\", \"module\", \"class\", \"method\"; better \"python\" icon\n# - callback for selection???\n# - multiple-item selection\n# - tooltips\n# - redo geometry without magic numbers\n# - keep track of object ids to allow more careful cleaning\n# - optimize tree redraw after expand of subnode\n\nfrom panda3d.core import Filename, getModelPath\nimport tkinter as tk\n\n\nclass TreeNode:\n\n    def __init__(self, canvas, parent, item, menuList = []):\n        self.canvas = canvas\n        self.parent = parent\n        self.item = item\n        self.state = 'collapsed'\n        self.selected = 0\n        self.children = {}\n        self.kidKeys = []\n        self.x = self.y = None\n        self.iconimages = {} # cache of PhotoImage instances for icons\n        self.menuList = menuList\n        if self.menuList:\n            if self.menuList[-1] == 'Separator':\n                self.menuList = self.menuList[:-1]\n        self.menuVar = tk.IntVar()\n        self.menuVar.set(0)\n        self._popupMenu = None\n        self.fSortChildren = False # [gjeon] flag for sorting children or not\n        self.fModeChildrenTag = 0 # [gjeon] flag for using filter or not\n        self.childrenTag = None # [gjeon] filter dictionary for\n        self.setAsTarget = 0 # [gjeon] to visualize reparent target\n\n    # [gjeon] to set fSortChildren\n    def setFSortChildren(self, fSortChildren):\n        self.fSortChildren = fSortChildren\n\n    def setChildrenTag(self, tag, fModeChildrenTag):\n        self.childrenTag = tag\n        self.fModeChildrenTag = fModeChildrenTag\n\n    def destroy(self):\n        if self._popupMenu:\n            self._popupMenu.destroy()\n        for key in self.kidKeys:\n            c = self.children[key]\n            del self.children[key]\n            c.destroy()\n        self.parent = None\n\n    def geticonimage(self, name):\n        if name in self.iconimages:\n            return self.iconimages[name]\n\n        fn = Filename(\"icons\", name)\n        if not fn.resolveFilename(getModelPath().value, \"gif\"):\n            raise FileNotFoundError(\"couldn't find \\\"%s\\\"\" % (fn))\n\n        image = tk.PhotoImage(master=self.canvas, file=fn.toOsSpecific())\n        self.iconimages[name] = image\n        return image\n\n    def select(self, event=None):\n        if self.selected:\n            return\n        self.deselectall()\n        self.selected = 1\n        self.canvas.delete(self.image_id)\n        self.drawicon()\n        self.drawtext()\n        self.item.OnSelect()\n\n    def deselect(self, event=None):\n        if not self.selected:\n            return\n        self.selected = 0\n        self.canvas.delete(self.image_id)\n        self.drawicon()\n        self.drawtext()\n\n    def deselectall(self):\n        if self.parent:\n            self.parent.deselectall()\n        else:\n            self.deselecttree()\n\n    def deselecttree(self):\n        if self.selected:\n            self.deselect()\n        for key in self.kidKeys:\n            child = self.children[key]\n            child.deselecttree()\n\n    def flip(self, event=None):\n        if self.state == 'expanded':\n            self.collapse()\n        else:\n            self.expand()\n        self.item.OnDoubleClick()\n        return \"break\"\n\n    def createPopupMenu(self):\n        if self.menuList:\n            self._popupMenu = tk.Menu(self.canvas, tearoff = 0)\n            for i, item in enumerate(self.menuList):\n                if item == 'Separator':\n                    self._popupMenu.add_separator()\n                else:\n                    self._popupMenu.add_radiobutton(\n                        label = item,\n                        variable = self.menuVar,\n                        value = i,\n                        indicatoron = 0,\n                        command = self.popupMenuCommand)\n\n    def popupMenu(self, event=None):\n        if not self._popupMenu:\n            self.createPopupMenu()\n        if self._popupMenu:\n            self._popupMenu.post(event.widget.winfo_pointerx(),\n                                 event.widget.winfo_pointery())\n            return \"break\"\n\n    def popupMenuCommand(self):\n        command = self.menuList[self.menuVar.get()]\n\n        if command == 'Expand All':\n            self.updateAll(1)\n        elif command == 'Collapse All':\n            self.updateAll(0)\n        else:\n            skipUpdate = self.item.MenuCommand(command)\n            if not skipUpdate and self.parent and (command != 'Update Explorer'):\n                # Update parent to try to keep explorer up to date\n                self.parent.update()\n\n    def expand(self, event=None):\n        if not self.item.IsExpandable():\n            return\n        if self.state != 'expanded':\n            self.state = 'expanded'\n            self.update()\n            self.view()\n\n    def collapse(self, event=None):\n        if self.state != 'collapsed':\n            self.state = 'collapsed'\n            self.update()\n\n    def view(self):\n        top = self.y - 2\n        bottom = self.lastvisiblechild().y + 17\n        height = bottom - top\n        visible_top = self.canvas.canvasy(0)\n        visible_height = self.canvas.winfo_height()\n        visible_bottom = self.canvas.canvasy(visible_height)\n        if visible_top <= top and bottom <= visible_bottom:\n            return\n        x0, y0, x1, y1 = self.canvas._getints(self.canvas['scrollregion'])\n        if top >= visible_top and height <= visible_height:\n            fraction = top + height - visible_height\n        else:\n            fraction = top\n        fraction = float(fraction) / y1\n        self.canvas.yview_moveto(fraction)\n\n    def reveal(self):\n        # Make sure all parent nodes are marked as expanded\n        parent = self.parent\n        while parent:\n            if parent.state == 'collapsed':\n                parent.state = 'expanded'\n                parent = parent.parent\n            else:\n                break\n        # Redraw tree accordingly\n        self.update()\n        # Bring this item into view\n        self.view()\n\n    def lastvisiblechild(self):\n        if self.kidKeys and self.state == 'expanded':\n            return self.children[self.kidKeys[-1]].lastvisiblechild()\n        else:\n            return self\n\n    # [gjeon] function to expand or collapse all the tree nodes\n    def updateAll(self, fMode, depth = 0, fUseCachedChildren = 1):\n        depth = depth + 1\n        if not self.item.IsExpandable():\n            return\n        if fMode:\n            self.state = 'expanded'\n        else:\n            if depth > 1:\n                self.state = 'collapsed'\n\n        sublist = self.item._GetSubList()\n        if not sublist:\n            return\n        self.kidKeys = []\n        for item in sublist:\n            key = item.GetKey()\n            if fUseCachedChildren and key in self.children:\n                child = self.children[key]\n            else:\n                child = TreeNode(self.canvas, self, item, self.menuList)\n\n            self.children[key] = child\n            self.kidKeys.append(key)\n\n        # Remove unused children\n        for key in list(self.children.keys()):\n            if key not in self.kidKeys:\n                del self.children[key]\n\n        for key in self.kidKeys:\n            child = self.children[key]\n            child.updateAll(fMode, depth=depth)\n\n        # [gjeon] to update the tree one time only\n        if depth == 1:\n            self.update()\n            self.view()\n\n    def update(self, fUseCachedChildren = 1, fExpandMode = 0):\n        if self.parent:\n            self.parent.update(fUseCachedChildren, fExpandMode = fExpandMode)\n        else:\n            oldcursor = self.canvas['cursor']\n            self.canvas['cursor'] = \"watch\"\n            self.canvas.update()\n            self.canvas.delete(tk.ALL)     # XXX could be more subtle\n            self.draw(7, 2, fUseCachedChildren)\n            x0, y0, x1, y1 = self.canvas.bbox(tk.ALL)\n            self.canvas.configure(scrollregion=(0, 0, x1, y1))\n            self.canvas['cursor'] = oldcursor\n\n    def draw(self, x, y, fUseCachedChildren = 1):\n        # XXX This hard-codes too many geometry constants!\n        self.x, self.y = x, y\n        self.drawicon()\n        self.drawtext()\n\n        if self.state != 'expanded':\n            return y+17\n        # draw children\n        sublist = self.item._GetSubList()\n        if not sublist:\n            # IsExpandable() was mistaken; that's allowed\n            return y+17\n        self.kidKeys = []\n\n        # [gjeon] to sort children\n        if self.fSortChildren:\n            def compareText(x, y):\n                textX = x.GetText()\n                textY = y.GetText()\n                if textX > textY:\n                    return 1\n                elif textX == textY:\n                    return 0\n                else: # textX < textY\n                    return -1\n            sublist.sort(compareText)\n        for item in sublist:\n            key = item.GetKey()\n            if fUseCachedChildren and key in self.children:\n                child = self.children[key]\n            else:\n                child = TreeNode(self.canvas, self, item, self.menuList)\n\n            # [gjeon] to set flag recursively\n            child.setFSortChildren(self.fSortChildren)\n            child.setChildrenTag(self.childrenTag, self.fModeChildrenTag)\n\n            self.children[key] = child\n            self.kidKeys.append(key)\n\n            # [gjeon] to filter by given tag\n            if self.fModeChildrenTag:\n                if self.childrenTag:\n                    showThisItem = False\n                    for tagKey in list(self.childrenTag.keys()):\n                        if item.nodePath.hasTag(tagKey):\n                            showThisItem = self.childrenTag[tagKey]\n                    if not showThisItem:\n                        self.kidKeys.remove(key)\n\n        # Remove unused children\n        for key in list(self.children.keys()):\n            if key not in self.kidKeys:\n                del self.children[key]\n        cx = x+20\n        cy = y+17\n        cylast = 0\n        for key in self.kidKeys:\n            child = self.children[key]\n            cylast = cy\n            self.canvas.create_line(x+9, cy+7, cx, cy+7, fill=\"gray50\")\n            cy = child.draw(cx, cy, fUseCachedChildren)\n            if child.item.IsExpandable():\n                if child.state == 'expanded':\n                    iconname = \"minusnode\"\n                    callback = child.collapse\n                else:\n                    iconname = \"plusnode\"\n                    callback = child.expand\n                image = self.geticonimage(iconname)\n                id = self.canvas.create_image(x+9, cylast+7, image=image)\n                # XXX This leaks bindings until canvas is deleted:\n                self.canvas.tag_bind(id, \"<1>\", callback)\n                self.canvas.tag_bind(id, \"<Double-1>\", lambda x: None)\n        id = self.canvas.create_line(x+9, y+10, x+9, cylast+7,\n            ##stipple=\"gray50\",     # XXX Seems broken in Tk 8.0.x\n            fill=\"gray50\")\n        self.canvas.tag_lower(id) # XXX .lower(id) before Python 1.5.2\n        return cy\n\n    def drawicon(self):\n        if self.selected:\n            imagename = (self.item.GetSelectedIconName() or\n                         self.item.GetIconName() or\n                         \"openfolder\")\n        else:\n            imagename = self.item.GetIconName() or \"folder\"\n        image = self.geticonimage(imagename)\n        id = self.canvas.create_image(self.x, self.y, anchor=\"nw\", image=image)\n        self.image_id = id\n        self.canvas.tag_bind(id, \"<1>\", self.select)\n        self.canvas.tag_bind(id, \"<Double-1>\", self.flip)\n        self.canvas.tag_bind(id, \"<3>\", self.popupMenu)\n\n    def drawtext(self):\n        textx = self.x+20-1\n        texty = self.y-1\n        labeltext = self.item.GetLabelText()\n        if labeltext:\n            id = self.canvas.create_text(textx, texty, anchor=\"nw\",\n                                         text=labeltext)\n            self.canvas.tag_bind(id, \"<1>\", self.select)\n            self.canvas.tag_bind(id, \"<Double-1>\", self.flip)\n            x0, y0, x1, y1 = self.canvas.bbox(id)\n            textx = max(x1, 200) + 10\n        text = self.item.GetText() or \"<no text>\"\n        try:\n            self.entry\n        except AttributeError:\n            pass\n        else:\n            self.edit_finish()\n        try:\n            label = self.label\n        except AttributeError:\n            # padding carefully selected (on Windows) to match Entry widget:\n            self.label = tk.Label(self.canvas, text=text, bd=0, padx=2, pady=2)\n        if self.selected:\n            self.label.configure(fg=\"white\", bg=\"darkblue\")\n        elif self.setAsTarget:\n            self.label.configure(fg=\"white\", bg=\"red\")\n        else:\n            fg = self.item.GetTextFg()\n            bg = self.item.GetTextBg()\n            self.label.configure(fg=fg, bg=bg)\n        id = self.canvas.create_window(textx, texty,\n                                       anchor=\"nw\", window=self.label)\n        self.label.bind(\"<1>\", self.select_or_edit)\n        self.label.bind(\"<Double-1>\", self.flip)\n        self.label.bind(\"<3>\", self.popupMenu)\n        # Update text if necessary\n        if text != self.label['text']:\n            self.label['text'] = text\n        self.text_id = id\n\n    def select_or_edit(self, event=None):\n        if self.selected and self.item.IsEditable():\n            self.edit(event)\n        else:\n            self.select(event)\n\n    def edit(self, event=None):\n        self.entry = tk.Entry(self.label, bd=0, highlightthickness=1, width=0)\n        self.entry.insert(0, self.label['text'])\n        self.entry.selection_range(0, tk.END)\n        self.entry.pack(ipadx=5)\n        self.entry.focus_set()\n        self.entry.bind(\"<Return>\", self.edit_finish)\n        self.entry.bind(\"<Escape>\", self.edit_cancel)\n\n    def edit_finish(self, event=None):\n        try:\n            entry = self.entry\n            del self.entry\n        except AttributeError:\n            return\n        text = entry.get()\n        entry.destroy()\n        if text and text != self.item.GetText():\n            self.item.SetText(text)\n        text = self.item.GetText()\n        self.label['text'] = text\n        self.drawtext()\n        self.canvas.focus_set()\n\n    def edit_cancel(self, event=None):\n        self.drawtext()\n        self.canvas.focus_set()\n\n    def find(self, searchKey):\n        # Search for a node who's key matches the given key\n        # Is it this node\n        if searchKey == self.item.GetKey():\n            # [gjeon] to filter by given tag\n            if self.fModeChildrenTag:\n                if self.childrenTag:\n                    showThisItem = False\n                    for tagKey in list(self.childrenTag.keys()):\n                        if self.item.nodePath.hasTag(tagKey):\n                            showThisItem = self.childrenTag[tagKey]\n                    if not showThisItem:\n                        return None\n            return self\n        # Nope, check the children\n        sublist = self.item._GetSubList()\n        for item in sublist:\n            key = item.GetKey()\n\n            # Use existing child or create new TreeNode if none exists\n            if key in self.children:\n                child = self.children[key]\n            else:\n                child = TreeNode(self.canvas, self, item, self.menuList)\n                # Update local list of children and keys\n                self.children[key] = child\n                self.kidKeys.append(key)\n            # [gjeon] to set flag recursively\n            child.setChildrenTag(self.childrenTag, self.fModeChildrenTag)\n\n            # See if node is child (or one of child's descendants)\n            retVal = child.find(searchKey)\n            if retVal:\n                return retVal\n        # Not here\n        return None\n\nclass TreeItem:\n\n    \"\"\"Abstract class representing tree items.\n\n    Methods should typically be overridden, otherwise a default action\n    is used.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor.  Do whatever you need to do.\"\"\"\n\n    def GetText(self):\n        \"\"\"Return text string to display.\"\"\"\n\n    def GetTextFg(self):\n        return \"black\"\n\n    def GetTextBg(self):\n        return \"white\"\n\n    def GetLabelText(self):\n        \"\"\"Return label text string to display in front of text (if any).\"\"\"\n\n    def IsExpandable(self):\n        \"\"\"Return whether there are subitems.\"\"\"\n        return 1\n\n    def _GetSubList(self):\n        \"\"\"Do not override!  Called by TreeNode.\"\"\"\n        if not self.IsExpandable():\n            return []\n        return self.GetSubList()\n\n    def IsEditable(self):\n        \"\"\"Return whether the item's text may be edited.\"\"\"\n\n    def SetText(self, text):\n        \"\"\"Change the item's text (if it is editable).\"\"\"\n\n    def GetIconName(self):\n        \"\"\"Return name of icon to be displayed normally.\"\"\"\n\n    def GetSelectedIconName(self):\n        \"\"\"Return name of icon to be displayed when selected.\"\"\"\n\n    def GetSubList(self):\n        \"\"\"Return list of items forming sublist.\"\"\"\n\n    def OnDoubleClick(self):\n        \"\"\"Called on a double-click on the item.\"\"\"\n\n    def OnSelect(self):\n        \"\"\"Called when item selected.\"\"\"\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/tkwidgets/Tree.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/d2c5ef36_Tree.json",
    "doc_id": "doc_197"
  }
}