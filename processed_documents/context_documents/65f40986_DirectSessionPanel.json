{
  "content": "\"\"\" DIRECT Session Main panel \"\"\"\n\n__all__ = ['DirectSessionPanel']\n\n# Import Tkinter, Pmw, and the dial code\nfrom panda3d.core import (\n    AmbientLight,\n    DirectionalLight,\n    LightAttrib,\n    NodePath,\n    PointLight,\n    Spotlight,\n    Vec4,\n)\nfrom direct.tkwidgets.AppShell import AppShell\nfrom direct.tkwidgets import Dial\nfrom direct.tkwidgets import Floater\nfrom direct.tkwidgets import Slider\nfrom direct.tkwidgets import VectorWidgets\nfrom direct.tkwidgets import SceneGraphExplorer\nfrom direct.tkwidgets import MemoryExplorer\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.showbase import ShowBaseGlobal\nfrom .TaskManagerPanel import TaskManagerWidget\nimport Pmw\nimport tkinter as tk\n\n\nclass DirectSessionPanel(AppShell):\n    # Override class variables here\n    appname = 'Direct Session Panel'\n    frameWidth      = 600\n    frameHeight     = 365\n    usecommandarea = 0\n    usestatusarea  = 0\n\n    def __init__(self, parent = None, **kw):\n        INITOPT = Pmw.INITOPT\n        optiondefs = (\n            ('title',       self.appname,       None),\n        )\n        self.defineoptions(kw, optiondefs)\n\n        # Call superclass initialization function\n        AppShell.__init__(self, parent)\n\n        # Active light\n        if len(ShowBaseGlobal.direct.lights) > 0:\n            name = ShowBaseGlobal.direct.lights.getNameList()[0]\n            self.lightMenu.selectitem(name)\n            self.selectLightNamed(name)\n        else:\n            self.activeLight = None\n        # Active display region\n        self.drMenu.selectitem('Display Region 0')\n        self.selectDisplayRegionNamed('Display Region 0')\n        # Make sure we've got valid initial values\n        self.updateInfo()\n\n        self.initialiseoptions(DirectSessionPanel)\n\n    def appInit(self):\n        # Initialize state\n        # Dictionary keeping track of all node paths selected so far\n        self.nodePathDict = {}\n        self.nodePathDict['widget'] = ShowBaseGlobal.direct.widget\n        self.nodePathNames = ['widget']\n\n        # Dictionary keeping track of all jb node paths selected so far\n        self.jbNodePathDict = {}\n        self.jbNodePathDict['none'] = 'No Node Path'\n        self.jbNodePathDict['widget'] = ShowBaseGlobal.direct.widget\n        self.jbNodePathDict['camera'] = ShowBaseGlobal.direct.camera\n        self.jbNodePathNames = ['camera', 'selected', 'none']\n\n        # Set up event hooks\n        self.actionEvents = [\n            ('DIRECT_undo', self.undoHook),\n            ('DIRECT_pushUndo', self.pushUndoHook),\n            ('DIRECT_undoListEmpty', self.undoListEmptyHook),\n            ('DIRECT_redo', self.redoHook),\n            ('DIRECT_pushRedo', self.pushRedoHook),\n            ('DIRECT_redoListEmpty', self.redoListEmptyHook),\n            ('DIRECT_selectedNodePath', self.selectedNodePathHook),\n            ('DIRECT_addLight', self.addLight),\n        ]\n        for event, method in self.actionEvents:\n            self.accept(event, method)\n\n    def createInterface(self):\n        # The interior of the toplevel panel\n        interior = self.interior()\n        # Add placer commands to menubar\n        self.menuBar.addmenu('DIRECT', 'Direct Session Panel Operations')\n\n        self.directEnabled = tk.BooleanVar()\n        self.directEnabled.set(True)\n        self.menuBar.addmenuitem('DIRECT', 'checkbutton',\n                                 'DIRECT Enabled',\n                                 label = 'Enable',\n                                 variable = self.directEnabled,\n                                 command = self.toggleDirect)\n\n        self.directGridEnabled = tk.BooleanVar()\n        self.directGridEnabled.set(ShowBaseGlobal.direct.grid.isEnabled())\n        self.menuBar.addmenuitem('DIRECT', 'checkbutton',\n                                 'DIRECT Grid Enabled',\n                                 label = 'Enable Grid',\n                                 variable = self.directGridEnabled,\n                                 command = self.toggleDirectGrid)\n\n        self.menuBar.addmenuitem('DIRECT', 'command',\n                                 'Toggle Object Handles Visability',\n                                 label = 'Toggle Widget Viz',\n                                 command = ShowBaseGlobal.direct.toggleWidgetVis)\n\n        self.menuBar.addmenuitem(\n            'DIRECT', 'command',\n            'Toggle Widget Move/COA Mode',\n            label = 'Toggle Widget Mode',\n            command = ShowBaseGlobal.direct.manipulationControl.toggleObjectHandlesMode)\n\n        self.directWidgetOnTop = tk.BooleanVar()\n        self.directWidgetOnTop.set(False)\n        self.menuBar.addmenuitem('DIRECT', 'checkbutton',\n                                 'DIRECT Widget On Top',\n                                 label = 'Widget On Top',\n                                 variable = self.directWidgetOnTop,\n                                 command = self.toggleWidgetOnTop)\n\n        self.menuBar.addmenuitem('DIRECT', 'command',\n                                 'Deselect All',\n                                 label = 'Deselect All',\n                                 command = ShowBaseGlobal.direct.deselectAll)\n\n        # Get a handle to the menu frame\n        menuFrame = self.menuFrame\n\n        # Widget to select node paths (and display list of selected node paths)\n        self.nodePathMenu = Pmw.ComboBox(\n            menuFrame, labelpos = tk.W, label_text = 'DIRECT Select:',\n            entry_width = 20,\n            selectioncommand = self.selectNodePathNamed,\n            scrolledlist_items = self.nodePathNames)\n        self.nodePathMenu.selectitem('widget')\n        self.nodePathMenuEntry = (\n            self.nodePathMenu.component('entryfield_entry'))\n        self.nodePathMenuBG = (\n            self.nodePathMenuEntry.configure('background')[3])\n        self.nodePathMenu.pack(side = tk.LEFT, fill = tk.X, expand = 1)\n        self.bind(self.nodePathMenu, 'Select node path to manipulate')\n\n        self.undoButton = tk.Button(menuFrame, text = 'Undo',\n                                    command = ShowBaseGlobal.direct.undo)\n        if ShowBaseGlobal.direct.undoList:\n            self.undoButton['state'] = 'normal'\n        else:\n            self.undoButton['state'] = 'disabled'\n        self.undoButton.pack(side = tk.LEFT, expand = 0)\n        self.bind(self.undoButton, 'Undo last operation')\n\n        self.redoButton = tk.Button(menuFrame, text = 'Redo',\n                                    command = ShowBaseGlobal.direct.redo)\n        if ShowBaseGlobal.direct.redoList:\n            self.redoButton['state'] = 'normal'\n        else:\n            self.redoButton['state'] = 'disabled'\n        self.redoButton.pack(side = tk.LEFT, expand = 0)\n        self.bind(self.redoButton, 'Redo last operation')\n\n        # The master frame for the dials\n        mainFrame = tk.Frame(interior)\n\n        # Paned widget for dividing two halves\n        framePane = Pmw.PanedWidget(mainFrame, orient = tk.HORIZONTAL)\n        sgeFrame = framePane.add('left', min = 250)\n        notebookFrame = framePane.add('right', min = 300)\n\n        # Scene Graph Explorer\n        self.SGE = SceneGraphExplorer.SceneGraphExplorer(\n            sgeFrame, nodePath = ShowBaseGlobal.base.render,\n            scrolledCanvas_hull_width = 250,\n            scrolledCanvas_hull_height = 300)\n        self.SGE.pack(fill = tk.BOTH, expand = 1)\n        sgeFrame.pack(side = tk.LEFT, fill = 'both', expand = 1)\n\n        # Create the notebook pages\n        notebook = Pmw.NoteBook(notebookFrame)\n        notebook.pack(fill = tk.BOTH, expand = 1)\n        self.createEnvPage(notebook.add('Environment'))\n        self.createLightsPage(notebook.add('Lights'))\n        self.createGridPage(notebook.add('Grid'))\n        self.createDevicePage(notebook.add('Devices'))\n        self.createTasksPage(notebook.add('Tasks'))\n        self.createMemPage(notebook.add('Memory'))\n\n        notebook.setnaturalsize()\n\n        framePane.pack(expand = 1, fill = tk.BOTH)\n        mainFrame.pack(fill = 'both', expand = 1)\n\n        # Put this here so it isn't called right away\n        notebook['raisecommand'] = self.updateInfo\n\n    def createEnvPage(self, envPage):\n        bkgrdFrame = tk.Frame(envPage, borderwidth = 2, relief = 'sunken')\n\n        tk.Label(bkgrdFrame, text = 'Background',\n                 font=('MSSansSerif', 14, 'bold')).pack(expand = 0)\n\n        self.backgroundColor = VectorWidgets.ColorEntry(\n            bkgrdFrame, text = 'Background Color')\n        self.backgroundColor['command'] = self.setBackgroundColorVec\n        self.backgroundColor.pack(fill = tk.X, expand = 0)\n        self.bind(self.backgroundColor, 'Set background color')\n        bkgrdFrame.pack(fill = tk.BOTH, expand = 0)\n\n        drFrame = tk.Frame(envPage, borderwidth = 2, relief = 'sunken')\n        tk.Label(drFrame, text = 'Display Region',\n                 font=('MSSansSerif', 14, 'bold')).pack(expand = 0)\n\n        nameList = ['Display Region ' + repr(x) for x in range(len(ShowBaseGlobal.direct.drList))]\n        self.drMenu = Pmw.ComboBox(\n            drFrame, labelpos = tk.W, label_text = 'Display Region:',\n            entry_width = 20,\n            selectioncommand = self.selectDisplayRegionNamed,\n            scrolledlist_items = nameList)\n        self.drMenu.pack(fill = tk.X, expand = 0)\n        self.bind(self.drMenu, 'Select display region to configure')\n\n        self.nearPlane = Floater.Floater(\n            drFrame,\n            text = 'Near Plane',\n            min = 0.01)\n        self.nearPlane['command'] = self.setNear\n        self.nearPlane.pack(fill = tk.X, expand = 0)\n        self.bind(self.nearPlane, 'Set near plane distance')\n\n        self.farPlane = Floater.Floater(\n            drFrame,\n            text = 'Far Plane',\n            min = 0.01)\n        self.farPlane['command'] = self.setFar\n        self.farPlane.pack(fill = tk.X, expand = 0)\n        self.bind(self.farPlane, 'Set far plane distance')\n\n        fovFrame = tk.Frame(drFrame)\n        fovFloaterFrame = tk.Frame(fovFrame)\n        self.hFov = Slider.Slider(\n            fovFloaterFrame,\n            text = 'Horizontal FOV',\n            min = 0.01, max = 170.0)\n        self.hFov['command'] = self.setHFov\n        self.hFov.pack(fill = tk.X, expand = 0)\n        self.bind(self.hFov, 'Set horizontal field of view')\n\n        self.vFov = Slider.Slider(\n            fovFloaterFrame,\n            text = 'Vertical FOV',\n            min = 0.01, max = 170.0)\n        self.vFov['command'] = self.setVFov\n        self.vFov.pack(fill = tk.X, expand = 0)\n        self.bind(self.vFov, 'Set vertical field of view')\n        fovFloaterFrame.pack(side = tk.LEFT, fill = tk.X, expand = 1)\n\n        frame = tk.Frame(fovFrame)\n        self.lockedFov = tk.BooleanVar()\n        self.lockedFov.set(True)\n        self.lockedFovButton = tk.Checkbutton(\n            frame,\n            text = 'Locked',\n            anchor = 'w', justify = tk.LEFT,\n            variable = self.lockedFov)\n        self.lockedFovButton.pack(fill = tk.X, expand = 0)\n\n        self.resetFovButton = tk.Button(\n            frame,\n            text = 'Reset',\n            command = self.resetFov)\n        self.resetFovButton.pack(fill = tk.X, expand = 0)\n        frame.pack(side = tk.LEFT, fill = tk.X, expand = 0)\n        fovFrame.pack(fill = tk.X, expand = 1)\n\n        drFrame.pack(fill = tk.BOTH, expand = 0)\n\n        ## Render Style ##\n        toggleFrame = tk.Frame(envPage, borderwidth = 2, relief = 'sunken')\n        tk.Label(toggleFrame, text = 'Toggle Render Style',\n                 font=('MSSansSerif', 14, 'bold')).pack(expand = 0)\n        self.toggleBackfaceButton = tk.Button(\n            toggleFrame,\n            text = 'Backface',\n            command = ShowBaseGlobal.base.toggleBackface)\n        self.toggleBackfaceButton.pack(side = tk.LEFT, fill = tk.X, expand = 1)\n\n        self.toggleLightsButton = tk.Button(\n            toggleFrame,\n            text = 'Lights',\n            command = ShowBaseGlobal.direct.lights.toggle)\n        self.toggleLightsButton.pack(side = tk.LEFT, fill = tk.X, expand = 1)\n\n        self.toggleTextureButton = tk.Button(\n            toggleFrame,\n            text = 'Texture',\n            command = ShowBaseGlobal.base.toggleTexture)\n        self.toggleTextureButton.pack(side = tk.LEFT, fill = tk.X, expand = 1)\n\n        self.toggleWireframeButton = tk.Button(\n            toggleFrame,\n            text = 'Wireframe',\n            command = ShowBaseGlobal.base.toggleWireframe)\n        self.toggleWireframeButton.pack(fill = tk.X, expand = 1)\n        toggleFrame.pack(side = tk.LEFT, fill = tk.X, expand = 1)\n\n    def createLightsPage(self, lightsPage):\n        # Lights #\n        lightFrame = tk.Frame(lightsPage, borderwidth = 2, relief = 'sunken')\n        self.lightsButton = tk.Menubutton(lightFrame, text = 'Lights',\n                                          font=('MSSansSerif', 14, 'bold'),\n                                          activebackground = '#909090')\n        lightsMenu = tk.Menu(self.lightsButton)\n        lightsMenu.add_command(label = 'Add Ambient Light',\n                            command = self.addAmbient)\n        lightsMenu.add_command(label = 'Add Directional Light',\n                            command = self.addDirectional)\n        lightsMenu.add_command(label = 'Add Point Light',\n                            command = self.addPoint)\n        lightsMenu.add_command(label = 'Add Spotlight',\n                            command = self.addSpot)\n\n        self.lightsButton.pack(expand = 0)\n        self.lightsButton['menu'] = lightsMenu\n\n        # Notebook pages for light specific controls\n        self.lightNotebook = Pmw.NoteBook(lightFrame, tabpos = None,\n                                          borderwidth = 0)\n        ambientPage = self.lightNotebook.add('Ambient')\n        directionalPage = self.lightNotebook.add('Directional')\n        pointPage = self.lightNotebook.add('Point')\n        spotPage = self.lightNotebook.add('Spot')\n        # Put this here so it isn't called right away\n        self.lightNotebook['raisecommand'] = self.updateLightInfo\n\n        # Main light switch\n        mainSwitchFrame = tk.Frame(lightFrame)\n        tk.Label(mainSwitchFrame,\n                 text = 'Lighting:').pack(side = tk.LEFT, expand = 0)\n        self.enableLights = tk.BooleanVar()\n        self.enableLightsButton = tk.Checkbutton(\n            mainSwitchFrame,\n            text = 'Enabled/Disabled',\n            variable = self.enableLights,\n            command = self.toggleLights)\n        self.enableLightsButton.pack(side = tk.LEFT, fill = tk.X, expand = 0)\n        mainSwitchFrame.pack(fill = tk.X, expand = 0)\n\n        # Widget to select a light to configure\n        nameList = ShowBaseGlobal.direct.lights.getNameList()\n        lightMenuFrame = tk.Frame(lightFrame)\n\n        self.lightMenu = Pmw.ComboBox(\n            lightMenuFrame, labelpos = tk.W, label_text = 'Light:',\n            entry_width = 20,\n            selectioncommand = self.selectLightNamed,\n            scrolledlist_items = nameList)\n        self.lightMenu.pack(side = tk.LEFT, fill = tk.X, expand = 0)\n        self.bind(self.lightMenu, 'Select light to configure')\n\n        self.lightActive = tk.BooleanVar()\n        self.lightActiveButton = tk.Checkbutton(\n            lightMenuFrame,\n            text = 'On/Off',\n            variable = self.lightActive,\n            command = self.toggleActiveLight)\n        self.lightActiveButton.pack(side = tk.LEFT, fill = tk.X, expand = 0)\n\n        # Pack light menu\n        lightMenuFrame.pack(fill = tk.X, expand = 0, padx = 2)\n\n        self.lightColor = VectorWidgets.ColorEntry(\n            lightFrame, text = 'Light Color')\n        self.lightColor['command'] = self.setLightColor\n        self.lightColor.pack(fill = tk.X, expand = 0, padx = 4)\n        self.bind(self.lightColor, 'Set active light color')\n\n        # Directional light controls\n        self.dSpecularColor = VectorWidgets.ColorEntry(\n            directionalPage, text = 'Specular Color')\n        self.dSpecularColor['command'] = self.setSpecularColor\n        self.dSpecularColor.pack(fill = tk.X, expand = 0)\n        self.bind(self.dSpecularColor,\n                  'Set directional light specular color')\n\n        # Point light controls\n        self.pSpecularColor = VectorWidgets.ColorEntry(\n            pointPage, text = 'Specular Color')\n        self.pSpecularColor['command'] = self.setSpecularColor\n        self.pSpecularColor.pack(fill = tk.X, expand = 0)\n        self.bind(self.pSpecularColor,\n                  'Set point light specular color')\n\n        self.pConstantAttenuation = Slider.Slider(\n            pointPage,\n            text = 'Constant Attenuation',\n            min = 0.0, max = 1.0, value = 1.0)\n        self.pConstantAttenuation['command'] = self.setConstantAttenuation\n        self.pConstantAttenuation.pack(fill = tk.X, expand = 0)\n        self.bind(self.pConstantAttenuation,\n                  'Set point light constant attenuation')\n\n        self.pLinearAttenuation = Slider.Slider(\n            pointPage,\n            text = 'Linear Attenuation',\n            min = 0.0, max = 1.0, value = 0.0)\n        self.pLinearAttenuation['command'] = self.setLinearAttenuation\n        self.pLinearAttenuation.pack(fill = tk.X, expand = 0)\n        self.bind(self.pLinearAttenuation,\n                  'Set point light linear attenuation')\n\n        self.pQuadraticAttenuation = Slider.Slider(\n            pointPage,\n            text = 'Quadratic Attenuation',\n            min = 0.0, max = 1.0, value = 0.0)\n        self.pQuadraticAttenuation['command'] = self.setQuadraticAttenuation\n        self.pQuadraticAttenuation.pack(fill = tk.X, expand = 0)\n        self.bind(self.pQuadraticAttenuation,\n                  'Set point light quadratic attenuation')\n\n        # Spot light controls\n        self.sSpecularColor = VectorWidgets.ColorEntry(\n            spotPage, text = 'Specular Color')\n        self.sSpecularColor['command'] = self.setSpecularColor\n        self.sSpecularColor.pack(fill = tk.X, expand = 0)\n        self.bind(self.sSpecularColor,\n                  'Set spot light specular color')\n\n        self.sConstantAttenuation = Slider.Slider(\n            spotPage,\n            text = 'Constant Attenuation',\n            min = 0.0, max = 1.0, value = 1.0)\n        self.sConstantAttenuation['command'] = self.setConstantAttenuation\n        self.sConstantAttenuation.pack(fill = tk.X, expand = 0)\n        self.bind(self.sConstantAttenuation,\n                  'Set spot light constant attenuation')\n\n        self.sLinearAttenuation = Slider.Slider(\n            spotPage,\n            text = 'Linear Attenuation',\n            min = 0.0, max = 1.0, value = 0.0)\n        self.sLinearAttenuation['command'] = self.setLinearAttenuation\n        self.sLinearAttenuation.pack(fill = tk.X, expand = 0)\n        self.bind(self.sLinearAttenuation,\n                  'Set spot light linear attenuation')\n\n        self.sQuadraticAttenuation = Slider.Slider(\n            spotPage,\n            text = 'Quadratic Attenuation',\n            min = 0.0, max = 1.0, value = 0.0)\n        self.sQuadraticAttenuation['command'] = self.setQuadraticAttenuation\n        self.sQuadraticAttenuation.pack(fill = tk.X, expand = 0)\n        self.bind(self.sQuadraticAttenuation,\n                  'Set spot light quadratic attenuation')\n\n        self.sExponent = Slider.Slider(\n            spotPage,\n            text = 'Exponent',\n            min = 0.0, max = 1.0, value = 0.0)\n        self.sExponent['command'] = self.setExponent\n        self.sExponent.pack(fill = tk.X, expand = 0)\n        self.bind(self.sExponent,\n                  'Set spot light exponent')\n\n        # MRM: Add frustum controls\n\n        self.lightNotebook.setnaturalsize()\n        self.lightNotebook.pack(expand = 1, fill = tk.BOTH)\n\n        lightFrame.pack(expand = 1, fill = tk.BOTH)\n\n    def createGridPage(self, gridPage):\n        tk.Label(gridPage, text = 'Grid',\n              font=('MSSansSerif', 14, 'bold')).pack(expand = 0)\n        self.enableGrid = tk.BooleanVar()\n        self.enableGridButton = tk.Checkbutton(\n            gridPage,\n            text = 'Enabled/Disabled',\n            anchor = 'w', justify = tk.LEFT,\n            variable = self.enableGrid,\n            command = self.toggleGrid)\n        self.enableGridButton.pack(fill = tk.X, expand = 0)\n\n        self.xyzSnap = tk.BooleanVar()\n        self.xyzSnapButton = tk.Checkbutton(\n            gridPage,\n            text = 'XYZ Snap',\n            anchor = 'w', justify = tk.LEFT,\n            variable = self.xyzSnap,\n            command = self.toggleXyzSnap)\n        self.xyzSnapButton.pack(fill = tk.X, expand = 0)\n\n        self.hprSnap = tk.BooleanVar()\n        self.hprSnapButton = tk.Checkbutton(\n            gridPage,\n            text = 'HPR Snap',\n            anchor = 'w', justify = tk.LEFT,\n            variable = self.hprSnap,\n            command = self.toggleHprSnap)\n        self.hprSnapButton.pack(fill = tk.X, expand = 0)\n\n        self.gridSpacing = Floater.Floater(\n            gridPage,\n            text = 'Grid Spacing',\n            min = 0.1,\n            value = ShowBaseGlobal.direct.grid.getGridSpacing())\n        self.gridSpacing['command'] = ShowBaseGlobal.direct.grid.setGridSpacing\n        self.gridSpacing.pack(fill = tk.X, expand = 0)\n\n        self.gridSize = Floater.Floater(\n            gridPage,\n            text = 'Grid Size',\n            min = 1.0,\n            value = ShowBaseGlobal.direct.grid.getGridSize())\n        self.gridSize['command'] = ShowBaseGlobal.direct.grid.setGridSize\n        self.gridSize.pack(fill = tk.X, expand = 0)\n\n        self.gridSnapAngle = Dial.AngleDial(\n            gridPage,\n            text = 'Snap Angle',\n            style = 'mini',\n            value = ShowBaseGlobal.direct.grid.getSnapAngle())\n        self.gridSnapAngle['command'] = ShowBaseGlobal.direct.grid.setSnapAngle\n        self.gridSnapAngle.pack(fill = tk.X, expand = 0)\n\n    def createDevicePage(self, devicePage):\n        tk.Label(devicePage, text = 'DEVICES',\n              font=('MSSansSerif', 14, 'bold')).pack(expand = 0)\n\n        if ShowBaseGlobal.direct.joybox is not None:\n            joyboxFrame = tk.Frame(devicePage, borderwidth = 2, relief = 'sunken')\n            tk.Label(joyboxFrame, text = 'Joybox',\n                     font=('MSSansSerif', 14, 'bold')).pack(expand = 0)\n            self.enableJoybox = tk.BooleanVar()\n            self.enableJoybox.set(True)\n            self.enableJoyboxButton = tk.Checkbutton(\n                joyboxFrame,\n                text = 'Enabled/Disabled',\n                anchor = 'w', justify = tk.LEFT,\n                variable = self.enableJoybox,\n                command = self.toggleJoybox)\n            self.enableJoyboxButton.pack(fill = tk.X, expand = 0)\n            joyboxFrame.pack(fill = tk.X, expand = 0)\n\n            self.jbModeMenu = Pmw.ComboBox(\n                joyboxFrame, labelpos = tk.W, label_text = 'Joybox Mode:',\n                label_width = 16, entry_width = 20,\n                selectioncommand = self.selectJBModeNamed,\n                scrolledlist_items = ['Joe Mode', 'Drive Mode', 'Orbit Mode',\n                                      'Look At Mode', 'Look Around Mode',\n                                      'Walkthru Mode', 'Demo Mode',\n                                      'HPRXYZ Mode'])\n            self.jbModeMenu.selectitem('Joe Mode')\n            self.jbModeMenu.pack(fill = tk.X, expand = 1)\n\n            self.jbNodePathMenu = Pmw.ComboBox(\n                joyboxFrame, labelpos = tk.W, label_text = 'Joybox Node Path:',\n                label_width = 16, entry_width = 20,\n                selectioncommand = self.selectJBNodePathNamed,\n                scrolledlist_items = self.jbNodePathNames)\n            self.jbNodePathMenu.selectitem('camera')\n            self.jbNodePathMenuEntry = (\n                self.jbNodePathMenu.component('entryfield_entry'))\n            self.jbNodePathMenuBG = (\n                self.jbNodePathMenuEntry.configure('background')[3])\n            self.jbNodePathMenu.pack(fill = tk.X, expand = 1)\n            self.bind(self.jbNodePathMenu,\n                      'Select node path to manipulate using the joybox')\n\n            self.jbXyzSF = Slider.Slider(\n                joyboxFrame,\n                text = 'XYZ Scale Factor',\n                value = 1.0,\n                hull_relief = tk.RIDGE, hull_borderwidth = 2,\n                min = 1.0, max = 100.0)\n            self.jbXyzSF['command'] = (\n                lambda v: ShowBaseGlobal.direct.joybox.setXyzMultiplier(v))\n            self.jbXyzSF.pack(fill = tk.X, expand = 0)\n            self.bind(self.jbXyzSF, 'Set joybox XYZ speed multiplier')\n\n            self.jbHprSF = Slider.Slider(\n                joyboxFrame,\n                text = 'HPR Scale Factor',\n                value = 1.0,\n                hull_relief = tk.RIDGE, hull_borderwidth = 2,\n                min = 1.0, max = 100.0)\n            self.jbHprSF['command'] = (\n                lambda v: ShowBaseGlobal.direct.joybox.setHprMultiplier(v))\n            self.jbHprSF.pack(fill = tk.X, expand = 0)\n            self.bind(self.jbHprSF, 'Set joybox HPR speed multiplier')\n\n    def createTasksPage(self, tasksPage):\n        tk.Label(tasksPage, text = 'TASKS',\n              font=('MSSansSerif', 14, 'bold')).pack(expand = 0)\n        self.taskMgrPanel = TaskManagerWidget(tasksPage, taskMgr)\n        self.taskMgrPanel.taskListBox['listbox_height'] = 10\n\n    def createMemPage(self, memPage):\n        self.MemExp = MemoryExplorer.MemoryExplorer(\n            memPage, nodePath = ShowBaseGlobal.base.render,\n            scrolledCanvas_hull_width = 250,\n            scrolledCanvas_hull_height = 250)\n        self.MemExp.pack(fill = tk.BOTH, expand = 1)\n\n    def toggleDirect(self):\n        if self.directEnabled.get():\n            ShowBaseGlobal.direct.enable()\n        else:\n            ShowBaseGlobal.direct.disable()\n\n    def toggleDirectGrid(self):\n        if self.directGridEnabled.get():\n            ShowBaseGlobal.direct.grid.enable()\n        else:\n            ShowBaseGlobal.direct.grid.disable()\n\n    def toggleWidgetOnTop(self):\n        if self.directWidgetOnTop.get():\n            ShowBaseGlobal.direct.widget.setBin('gui-popup', 0)\n            ShowBaseGlobal.direct.widget.setDepthTest(0)\n        else:\n            ShowBaseGlobal.direct.widget.clearBin()\n            ShowBaseGlobal.direct.widget.setDepthTest(1)\n\n    def selectedNodePathHook(self, nodePath):\n        # Make sure node path is in nodePathDict\n        # MRM: Do we need to truncate list?\n        if isinstance(nodePath, NodePath):\n            self.addNodePath(nodePath)\n\n    def selectNodePathNamed(self, name):\n        # See if node path has already been selected\n        nodePath = self.nodePathDict.get(name, None)\n        # If not, see if listbox evals into a node path\n        if nodePath is None:\n            # See if this evaluates into a node path\n            try:\n                nodePath = eval(name)\n                if isinstance(nodePath, NodePath):\n                    self.addNodePath(nodePath)\n                else:\n                    # Good eval but not a node path, give up\n                    nodePath = None\n            except Exception:\n                # Bogus eval\n                nodePath = None\n                # Clear bogus entry from listbox\n                listbox = self.nodePathMenu.component('scrolledlist')\n                listbox.setlist(self.nodePathNames)\n        # Did we finally get something?\n        if nodePath is not None:\n            # Yes, select it!\n            ShowBaseGlobal.direct.select(nodePath)\n\n    def addNodePath(self, nodePath):\n        self.addNodePathToDict(nodePath, self.nodePathNames,\n                               self.nodePathMenu, self.nodePathDict)\n\n    def selectJBModeNamed(self, name):\n        if name == 'Joe Mode':\n            ShowBaseGlobal.direct.joybox.joeMode()\n        elif name == 'Drive Mode':\n            ShowBaseGlobal.direct.joybox.driveMode()\n        elif name == 'Orbit Mode':\n            ShowBaseGlobal.direct.joybox.orbitMode()\n        elif name == 'Look At Mode':\n            ShowBaseGlobal.direct.joybox.lookAtMode()\n        elif name == 'Look Around Mode':\n            ShowBaseGlobal.direct.joybox.lookAroundMode()\n        elif name == 'Walkthru Mode':\n            ShowBaseGlobal.direct.joybox.walkthruMode()\n        elif name == 'Demo Mode':\n            ShowBaseGlobal.direct.joybox.demoMode()\n        elif name == 'HPRXYZ Mode':\n            ShowBaseGlobal.direct.joybox.hprXyzMode()\n\n    def selectJBNodePathNamed(self, name):\n        if name == 'selected':\n            nodePath = ShowBaseGlobal.direct.selected.last\n            # Add Combo box entry for this selected object\n            self.addJBNodePath(nodePath)\n        else:\n            # See if node path has already been selected\n            nodePath = self.jbNodePathDict.get(name, None)\n            if nodePath is None:\n                # If not, see if listbox evals into a node path\n                try:\n                    nodePath = eval(name)\n                    if isinstance(nodePath, NodePath):\n                        self.addJBNodePath(nodePath)\n                    else:\n                        # Good eval but not a node path, give up\n                        nodePath = None\n                except Exception:\n                    # Bogus eval\n                    nodePath = None\n                    # Clear bogus entry from listbox\n                    listbox = self.jbNodePathMenu.component('scrolledlist')\n                    listbox.setlist(self.jbNodePathNames)\n        # Did we finally get something?\n        if nodePath is not None:\n            # Yes, select it!\n            if nodePath == 'No Node Path':\n                ShowBaseGlobal.direct.joybox.setNodePath(None)\n            else:\n                ShowBaseGlobal.direct.joybox.setNodePath(nodePath)\n\n    def addJBNodePath(self, nodePath):\n        self.addNodePathToDict(nodePath, self.jbNodePathNames,\n                               self.jbNodePathMenu, self.jbNodePathDict)\n\n    def addNodePathToDict(self, nodePath, names, menu, dict):\n        if not nodePath:\n            return\n        # Get node path's name\n        name = nodePath.getName()\n        if name in ['parent', 'render', 'camera']:\n            dictName = name\n        else:\n            # Generate a unique name for the dict\n            dictName = name + '-' + repr(hash(nodePath))\n        if dictName not in dict:\n            # Update combo box to include new item\n            names.append(dictName)\n            listbox = menu.component('scrolledlist')\n            listbox.setlist(names)\n            # Add new item to dictionary\n            dict[dictName] = nodePath\n        menu.selectitem(dictName)\n\n    ## ENVIRONMENT CONTROLS ##\n    # Background #\n    def setBackgroundColor(self, r, g, b):\n        self.setBackgroundColorVec((r, g, b))\n\n    def setBackgroundColorVec(self, color):\n        ShowBaseGlobal.base.setBackgroundColor(\n            color[0] / 255.0, color[1] / 255.0, color[2] / 255.0)\n\n    def selectDisplayRegionNamed(self, name):\n        if name.find('Display Region ') >= 0:\n            drIndex = int(name[-1:])\n            self.activeDisplayRegion = ShowBaseGlobal.direct.drList[drIndex]\n        else:\n            self.activeDisplayRegion = None\n        # Make sure info is current\n        self.updateDisplayRegionInfo()\n\n    def setNear(self, near):\n        dr = self.activeDisplayRegion\n        if dr:\n            dr.camLens.setNear(near)\n            ShowBaseGlobal.direct.cluster('base.camLens.setNear(%f)' % near, 0)\n\n    def setFar(self, far):\n        dr = self.activeDisplayRegion\n        if dr:\n            dr.camLens.setFar(far)\n            ShowBaseGlobal.direct.cluster('base.camLens.setFar(%f)' % far, 0)\n\n    def setHFov(self, hFov):\n        dr = self.activeDisplayRegion\n        if dr:\n            if self.lockedFov.get():\n                sf = hFov/dr.getHfov()\n                vFov = min(dr.getVfov() * sf, 170.0)\n                dr.setFov(hFov, vFov)\n                # Update scale\n                self.vFov.set(vFov, 0)\n            else:\n                # Just set horizontal\n                dr.setHfov(hFov)\n\n    def setVFov(self, vFov):\n        dr = self.activeDisplayRegion\n        if dr:\n            if self.lockedFov.get():\n                sf = vFov/dr.getVfov()\n                hFov = min(dr.getHfov() * sf, 170.0)\n                dr.setFov(hFov, vFov)\n                # Update scale\n                self.hFov.set(hFov, 0)\n            else:\n                # Just set horizontal\n                dr.setVfov(vFov)\n\n    def resetFov(self):\n        dr = self.activeDisplayRegion\n        if dr:\n            dr.setFov(45.0, 33.75)\n            self.hFov.set(45.0, 0)\n            self.vFov.set(33.75, 0)\n\n    # Lights #\n    def selectLightNamed(self, name):\n        # See if light exists\n        self.activeLight = ShowBaseGlobal.direct.lights[name]\n        # If not...create new one\n        if self.activeLight is None:\n            self.activeLight = ShowBaseGlobal.direct.lights.create(name)\n        # Do we have a valid light at this point?\n        if self.activeLight:\n            light = self.activeLight.getLight()\n            if isinstance(light, AmbientLight):\n                self.lightNotebook.selectpage('Ambient')\n            elif isinstance(light, DirectionalLight):\n                self.lightNotebook.selectpage('Directional')\n            elif isinstance(light, PointLight):\n                self.lightNotebook.selectpage('Point')\n            elif isinstance(light, Spotlight):\n                self.lightNotebook.selectpage('Spot')\n        else:\n            # Restore valid data\n            listbox = self.lightMenu.component('scrolledlist')\n            listbox.setlist(ShowBaseGlobal.direct.lights.getNameList())\n            if len(ShowBaseGlobal.direct.lights) > 0:\n                self.lightMenu.selectitem(ShowBaseGlobal.direct.lights.getNameList()[0])\n        # Make sure info is current\n        self.updateLightInfo()\n\n    def addAmbient(self):\n        return ShowBaseGlobal.direct.lights.create('ambient')\n\n    def addDirectional(self):\n        return ShowBaseGlobal.direct.lights.create('directional')\n\n    def addPoint(self):\n        return ShowBaseGlobal.direct.lights.create('point')\n\n    def addSpot(self):\n        return ShowBaseGlobal.direct.lights.create('spot')\n\n    def addLight(self, light):\n        # Make list reflect current list of lights\n        listbox = self.lightMenu.component('scrolledlist')\n        listbox.setlist(ShowBaseGlobal.direct.lights.getNameList())\n        # Select the newly added light\n        self.lightMenu.selectitem(light.getName())\n        # And show corresponding page\n        self.selectLightNamed(light.getName())\n\n    def toggleLights(self):\n        if self.enableLights.get():\n            ShowBaseGlobal.direct.lights.allOn()\n        else:\n            ShowBaseGlobal.direct.lights.allOff()\n\n    def toggleActiveLight(self):\n        if self.activeLight:\n            if self.lightActive.get():\n                ShowBaseGlobal.direct.lights.setOn(self.activeLight)\n            else:\n                ShowBaseGlobal.direct.lights.setOff(self.activeLight)\n\n    def setLightColor(self, color):\n        if self.activeLight:\n            self.activeLight.getLight().setColor(Vec4(color[0]/255.0,\n                                                      color[1]/255.0,\n                                                      color[2]/255.0,\n                                                      color[3]/255.0))\n\n    def setSpecularColor(self, color):\n        if self.activeLight:\n            self.activeLight.getLight().setSpecularColor(Vec4(color[0]/255.0,\n                                                              color[1]/255.0,\n                                                              color[2]/255.0,\n                                                              color[3]/255.0))\n\n    def setConstantAttenuation(self, value):\n        if self.activeLight:\n            self.activeLight.getLight().setConstantAttenuation(value)\n\n    def setLinearAttenuation(self, value):\n        if self.activeLight:\n            self.activeLight.getLight().setLinearAttenuation(value)\n\n    def setQuadraticAttenuation(self, value):\n        if self.activeLight:\n            self.activeLight.getLight().setQuadraticAttenuation(value)\n\n    def setExponent(self, value):\n        if self.activeLight:\n            self.activeLight.getLight().setExponent(value)\n\n    ## GRID CONTROLS ##\n    def toggleGrid(self):\n        if self.enableGrid.get():\n            ShowBaseGlobal.direct.grid.enable()\n        else:\n            ShowBaseGlobal.direct.grid.disable()\n\n    def toggleXyzSnap(self):\n        ShowBaseGlobal.direct.grid.setXyzSnap(self.xyzSnap.get())\n\n    def toggleHprSnap(self):\n        ShowBaseGlobal.direct.grid.setHprSnap(self.hprSnap.get())\n\n    ## DEVICE CONTROLS\n    def toggleJoybox(self):\n        if self.enableJoybox.get():\n            ShowBaseGlobal.direct.joybox.enable()\n        else:\n            ShowBaseGlobal.direct.joybox.disable()\n\n    ## UPDATE INFO ##\n    def updateInfo(self, page = 'Environment'):\n        if page == 'Environment':\n            self.updateEnvironmentInfo()\n        elif page == 'Lights':\n            self.updateLightInfo()\n        elif page == 'Grid':\n            self.updateGridInfo()\n\n    def updateEnvironmentInfo(self):\n        bkgrdColor = ShowBaseGlobal.base.getBackgroundColor() * 255.0\n        self.backgroundColor.set([bkgrdColor[0],\n                                  bkgrdColor[1],\n                                  bkgrdColor[2],\n                                  bkgrdColor[3]], 0)\n        self.updateDisplayRegionInfo()\n\n    def updateDisplayRegionInfo(self):\n        if self.activeDisplayRegion:\n            self.nearPlane.set(self.activeDisplayRegion.near, 0)\n            self.farPlane.set(self.activeDisplayRegion.far, 0)\n            self.hFov.set(self.activeDisplayRegion.fovH, 0)\n            self.vFov.set(self.activeDisplayRegion.fovV, 0)\n\n    def updateLightInfo(self, page = None):\n        # Set main lighting button\n        render = ShowBaseGlobal.base.render\n        self.enableLights.set(\n            render.node().hasAttrib(LightAttrib.getClassType()))\n\n        # Set light specific info\n        if self.activeLight:\n            l = self.activeLight.getLight()\n            self.lightActive.set(render.hasLight(self.activeLight))\n            lightColor = l.getColor() * 255.0\n            self.lightColor.set([lightColor[0], lightColor[1],\n                                 lightColor[2], lightColor[3]], 0)\n            if isinstance(l, DirectionalLight):\n                specularColor = l.getSpecularColor() * 255.0\n                self.dSpecularColor.set([specularColor[0],\n                                         specularColor[1],\n                                         specularColor[2],\n                                         specularColor[3]], 0)\n            elif isinstance(l, PointLight):\n                specularColor = l.getSpecularColor() * 255.0\n                self.pSpecularColor.set([specularColor[0],\n                                         specularColor[1],\n                                         specularColor[2],\n                                         specularColor[3]], 0)\n                att = l.getAttenuation()\n                self.pConstantAttenuation.set(att[0], 0)\n                self.pLinearAttenuation.set(att[1], 0)\n                self.pQuadraticAttenuation.set(att[2], 0)\n            elif isinstance(l, Spotlight):\n                specularColor = l.getSpecularColor() * 255.0\n                self.sSpecularColor.set([specularColor[0],\n                                         specularColor[1],\n                                         specularColor[2],\n                                         specularColor[3]], 0)\n                att = l.getAttenuation()\n                self.pConstantAttenuation.set(att[0], 0)\n                self.pLinearAttenuation.set(att[1], 0)\n                self.pQuadraticAttenuation.set(att[2], 0)\n\n    def updateGridInfo(self):\n        self.enableGrid.set(ShowBaseGlobal.direct.grid.isEnabled())\n        self.xyzSnap.set(ShowBaseGlobal.direct.grid.getXyzSnap())\n        self.hprSnap.set(ShowBaseGlobal.direct.grid.getHprSnap())\n        self.gridSpacing.set(ShowBaseGlobal.direct.grid.getGridSpacing(), 0)\n        self.gridSize.set(ShowBaseGlobal.direct.grid.getGridSize(), 0)\n        self.gridSnapAngle.set(ShowBaseGlobal.direct.grid.getSnapAngle(), 0)\n\n    # UNDO/REDO\n    def pushUndo(self, fResetRedo = 1):\n        ShowBaseGlobal.direct.pushUndo([self['nodePath']])\n\n    def undoHook(self, nodePathList = []):\n        pass\n\n    def pushUndoHook(self):\n        # Make sure button is reactivated\n        self.undoButton.configure(state = 'normal')\n\n    def undoListEmptyHook(self):\n        # Make sure button is deactivated\n        self.undoButton.configure(state = 'disabled')\n\n    def pushRedo(self):\n        ShowBaseGlobal.direct.pushRedo([self['nodePath']])\n\n    def redoHook(self, nodePathList = []):\n        pass\n\n    def pushRedoHook(self):\n        # Make sure button is reactivated\n        self.redoButton.configure(state = 'normal')\n\n    def redoListEmptyHook(self):\n        # Make sure button is deactivated\n        self.redoButton.configure(state = 'disabled')\n\n    def onDestroy(self, event):\n        # Remove hooks\n        for event, method in self.actionEvents:\n            self.ignore(event)\n        # Destroy SGE hierarchy\n        self.SGE._node.destroy()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/tkpanels/DirectSessionPanel.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/65f40986_DirectSessionPanel.json",
    "doc_id": "doc_60"
  }
}