{
  "content": "Compute Shaders\n\nIntroduction\n\nCompute shaders, introduced in 1.9, are a type of general-purpose shader program that can be used to perform a wide variety of functions on the video card. They are fundamentally different from other types of shaders in that they aren't assigned to a node and modify how the node is rendered, but are executed (dispatched) in a standalone fashion and perform an operation on an arbitrary set of data. They may read from and write to texture images at will. This is particularly useful for image processing or GPU-based particle algorithms, to name a few examples.\n\nCompute shaders are only available on hardware supporting OpenGL 4.3, which includes NVIDIA GeForce 400 series and above and AMD Radeon HD 5000 series and above.\n\nIt is important to know that compute shaders are an advanced, low-level, and relatively recent feature. This means that it is very easy to get strange and unexplainable results, including garbled texture data, or even video card crashes and system freezes in some cases. Using them certainly requires a certain amount of expertise with graphics programming. In many cases, similar results can be achieved with render-to-texture processes.\n\nThis page only aims to give a cursory overview of compute shaders where it is relevant to Panda3D's interfaces. It is by no means a comprehensive manual covering everything about compute shaders. In particular, image access concurrency, shared or coherent variables, and memory barriers are not covered here at all. Please refer to the OpenGL documentation for more information.\n\nWork groups\n\nNormally, a regular shader is executed on a predetermined set of data (such as an amount of vertices or pixels), in which case the amount of shader invocations is known beforehand. However, since compute shaders can operate on an arbitrary set of data, the amount of invocations has to be explicitly specified.\n\nCompute shader invocations are divided up in batches called work groups, which specify how many invocations happen simultaneously. The different invocations in a work group may occur at the same time, but you should never rely on the different work groups being executed in a particular order or simultaneous to each other; this is up to the graphics driver to decide.\n\nAlthough the local size of a work group is typically relatively small (you can count on 1024 total invocations within a single work group), you may invoke any number of these work groups. The work group count is not hard-coded within the shader, but specified by the application. One common workflow for an image processing shader is to divide up the image into tiles of fixed size, and then to specify in the application how many tiles are in the image to be processed.\n\nThe work group size and count are specified using a three-dimensional size value, so that it is conveniently possible to use compute shaders on sets of data with up to three physical dimensions, such as 3-D textures or cube maps. However, the Z component of these values may be set to 1 if the shader is designed to operate on a 2-D set of data, and the Y component may be 1 if the shader is designed to work on a one-dimensional array. The way this is specified merely determines how the coordinates are provided to the shader; in the end, what counts is the total number of invocations in the work group, which is equal to the product of these three numbers.\n\nSo, if you have an image processing shader that operates on a 512x512 image, you may set the local work group size in your shader to 16x16x1, whereas in your application, you would specify a work group count of 32x32x1 since there are 32 of these tiles in each of the X and Y directions.\n\nExample shader\n\nA typical compute shader (GLSL) looks as follows. All that the shader does is copy the contents of one texture to another, except that it swaps two channels.\n\n#version 430\n\n// Set the number of invocations in the work group.\n// In this case, we operate on the image in 16x16 pixel tiles.\nlayout (local_size_x = 16, local_size_y = 16) in;\n\n// Declare the texture inputs\nuniform readonly image2D fromTex;\nuniform writeonly image2D toTex;\n\nvoid main() {\n  // Acquire the coordinates to the texel we are to process.\n  ivec2 texelCoords = ivec2(gl_GlobalInvocationID.xy);\n\n  // Read the pixel from the first texture.\n  vec4 pixel = imageLoad(fromTex, texelCoords);\n\n  // Swap the red and green channels.\n  pixel.rg = pixel.gr;\n\n  // Now write the modified pixel to the second texture.\n  imageStore(toTex, texelCoords, pixel);\n}\n\nThis page does not attempt to teach how to make GLSL compute shaders - please refer to the GLSL documentation for that information.\n\nLoading a compute shader\n\nA compute shader is typically never combined with other types of shaders, and therefore, loading a compute shader happens via a special call. At present, only GLSL compute shaders may be loaded.\n\npython\n\nshader = Shader.load_compute(Shader.SL_GLSL, \"compute_shader.glsl\")\n\ncpp\n\nPT(Shader) shader;\nshader = Shader::load_compute(Shader::SL_GLSL, \"compute_shader.glsl\");\n\nThe .Shader.make_compute() call can be used to load the shader from a string instead of a filename.\n\nDispatching a compute shader\n\nSince a compute shader is not applied to a model but may be invoked arbitrarily, there has to be a different interface for dispatching a compute shader. Usually, you would do this by creating a .ComputeNode object, which is inserted into the scene graph. When Panda3D encounters one of these nodes during the draw process, it will ask OpenGL to dispatch the compute shader assigned to that node for the given amount of work groups.\n\npython\n\n# Create the node\nnode = ComputeNode(\"compute\")\n\n# We want to call it on a 512x512 image, keeping in\n# mind that the shader has a work group size of 16x16.\nnode.add_dispatch(512 / 16, 512 / 16, 1)\n\n# Put the node into the scene graph.\nnode_path = render.attach_new_node(node)\n\n# Assign the shader and the shader inputs.\nshader = Shader.load_compute(Shader.SL_GLSL, \"compute_shader.glsl\")\nnode_path.set_shader(shader)\nnode_path.set_shader_input(\"fromTex\", myTex1)\nnode_path.set_shader_input(\"toTex\", myTex2)\n\ncpp\n\nPT(ComputeNode) node = new ComputeNode(\"compute\");\n\n// We want to call it on a 512x512 image, keeping in\n// mind that the shader has a work group size of 16x16.\nnode->add_dispatch(512 / 16, 512 / 16, 1);\n\n// Put the node into the scene graph.\nNodePath node_path = render.attach_new_node(node);\n\n// Assign the shader and the shader inputs.\nPT(Shader) shader = Shader::load_compute(Shader::SL_GLSL, \"compute_shader.glsl\");\nnode_path.set_shader(shader);\nnode_path.set_shader_input(\"fromTex\", myTex1);\nnode_path.set_shader_input(\"toTex\", myTex2);\n\nThe ordering of nodes becomes especially important; you may not want a procedural texture to be rendered on another node before it is first generated using a compute shader, for example. You may have to use cull bins or display regions in order to explicitly control when the .ComputeNode is encountered during the draw process.\n\nKeep in mind that a .ComputeNode is never culled away by default, since it is not associated with any geometry. You may override this behaviour by assigning a custom .BoundingVolume.\n\nHowever, whereas the .ComputeNode interface is useful for operations that are done every frame, it is not very useful for one-off calls, since it is cumbersome to add a node to the scene graph only to remove it again in the next frame. For these use cases, there is a more lower-level operation to dispatch a compute shader:\n\npython\n\n# Create a dummy node and apply the shader to it\nshader = Shader.load_compute(Shader.SL_GLSL, \"compute_shader.glsl\")\ndummy = NodePath(\"dummy\")\ndummy.set_shader(shader)\ndummy.set_shader_input(\"fromTex\", myTex1)\ndummy.set_shader_input(\"toTex\", myTex2)\n\n# Retrieve the underlying ShaderAttrib\nsattr = dummy.get_attrib(ShaderAttrib)\n\n# Dispatch the compute shader, right now!\nbase.graphicsEngine.dispatch_compute((32, 32, 1), sattr, base.win.get_gsg())\n\ncpp\n\n// Create a dummy node and apply the shader to it\nPT(Shader) shader = Shader::load_compute(Shader::SL_GLSL, \"compute_shader.glsl\");\nNodePath dummy(\"dummy\");\ndummy.set_shader(shader);\ndummy.set_shader_input(\"fromTex\", myTex1);\ndummy.set_shader_input(\"toTex\", myTex2);\n\n// Retrieve the underlying ShaderAttrib\nCPT(ShaderAttrib) sattr = DCAST(ShaderAttrib,\n  dummy.get_attrib(ShaderAttrib::get_class_type()));\n\n// Our image has 32x32 tiles\nLVecBase3i work_groups(512/16, 512/16, 1);\n\n// Dispatch the compute shader, right now!\nGraphicsEngine *engine = GraphicsEngine::get_global_ptr();\nengine->dispatch_compute(work_groups, sattr, win->get_gsg());\n\nKeep in mind that each call to ~.GraphicsEngine.dispatch_compute() causes Panda3D to wait for the current frame to finish rendering. This can be a very inefficient process, and you are not advised to use this method for operations that happen on a regular basis.\n\nImage access\n\nThough it is still possible to use regular texture samplers, these aren't very well suited for many types of image processing. Regular samplers take texture coordinates in a [0, 1] range, the extra filtering processes add an unnecessary overhead, and it is not possible to write back to textures using this interface.\n\nHowever, there is a lower level method to read from and write to texture images. As you have already seen in the example above, this can be done by using an image2D declaration instead of sampler2D, and instead of using the texture family of functions to sample them, you would use imageLoad and imageStore, which now take integer texel coordinates.\n\nOn the application side, however, telling the shader which image to use still happens in the same way as usual, using the ~.NodePath.set_shader_input() function. However, it is very important that the texture has a sized format, rather than a regular format:\n\npython\n\n# WRONG\ntex.set_format(Texture.F_rgba)\n\n# RIGHT\ntex.set_format(Texture.F_rgba8)\n\nnode_path.set_shader_input('fromTex', tex)\n\ncpp\n\n// WRONG\ntex->set_format(Texture::F_rgba);\n\n// RIGHT\ntex->set_format(Texture::F_rgba8);\n\nnode_path.set_shader_input(\"fromTex\", tex);\n\nAt time of writing, it is only possible to access the first mipmap level. It is not possible to automatically generate the other mipmap levels at the time of writing, so it is advised to turn mipmap filtering off for the relevant textures. This is a feature we still mean to add.\n\nAccessing depth textures is impossible via this interface. It is not possible to write to them, and reading from them has to be done using a sampler2D or sampler2DShadow object. You can use the texelFetch function with samplers so that you can still use integer texel coordinates.\n\nAtomic image access is only supported for textures with the integer F_r32i format. Atomic image operations are slower, but they come with an extra guarantee that no two invocations write or read from the image texel at the same time.\n\nIt should be noted that this low-level image interface is also supported for other types of shaders when write access to images is desired.\n\nTexture Clear\n\nWhen using a compute shader to operate on a texture image, such as in procedural texture generation, you may require the texture data to be cleared to an initial value before it is used. This is now possible using the ~.Texture.set_clear_color() function, which specifies the color that Panda3D will clear the texture to. This color is used in absence of actual image data.\n\npython\n\n# Set up a texture for procedural generation.\ntex = Texture(\"procedural-normal-map\")\ntex.setup_2d_texture(512, 512, Texture.T_unsigned_byte, Texture.F_rgb8)\n\n# Set the initial color of the texture.\ntex.set_clear_color((0.5, 0.5, 1.0, 0.0))\n\ncpp\n\n// Set up a texture for procedural generation.\nPT(Texture) tex = new Texture(\"procedural-normal-map\");\ntex->setup_2d_texture(512, 512, Texture::T_unsigned_byte, Texture::F_rgb8);\n\n// Set the initial color of the texture.\nLColor clear_color(0.5f, 0.5f, 1.0f, 0.0f);\ntex->set_clear_color(clear_color);\n\nThe initial clear is implicit, but clearing a texture in a later frame requires explicit use of the ~.Texture.clear_image() function, which instructs Panda3D to clear the texture the next time it is used. It also clears any RAM images that may have been associated with the texture (similar to ~.Texture.clear_ram_image()).\n\npython\n\n# Tell Panda to fill the texture with a red color on the GPU.\ntex.set_clear_color((1.0, 0.0, 0.0, 0.0))\ntex.clear_image()\n\ncpp\n\n// Tell Panda to fill the texture with a red color on the GPU.\nLColor clear_color(1.0f, 0.0f, 0.0f, 0.0f);\ntex->set_clear_color(clear_color);\ntex->clear_image();\n\nWhen doing this, it is recommended that you enable the use of immutable texture storage, which is an experimental feature that allows Panda3D to allocate the texture memory beforehand and perform more efficient initial clears. It can be activated using the following configuration variable:\n\ngl-immutable-texture-storage true\n\nMemory barriers\n\nWhenever you write to an image using an image2D uniform, Panda3D assumes that the image has been modified by the shader. Panda3D will automatically issue a memory barrier when the texture is used in a following operation, such as when the texture is used for rendering or bound to a different shader, to make sure that the reads and writes are synchronized.\n\nSince Panda3D does not know whether you have actually written to the image or whether you have declared an image variable as coherent, it may do this too often, causing slight performance degradation. If you are confident that you don't need this feature, you may set gl-enable-memory-barriers variable to false in your Config.prc to disable this behavior.\n\nKeep in mind that Panda3D's memory barriers only play a role when an image is modified by one shader and read by another; it does not affect reads and writes performed within the same shader. It is still necessary to use the appropriate GLSL qualifiers and memory barrier commands for these purposes.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/902376c6_compute-shaders.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/98f01149_902376c6_compute-shaders.json",
    "doc_id": "doc_599"
  }
}