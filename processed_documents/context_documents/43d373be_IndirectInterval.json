{
  "content": "\"\"\"IndirectInterval module: contains the IndirectInterval class\"\"\"\n\n__all__ = ['IndirectInterval']\n\nfrom panda3d.direct import CInterval\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom . import Interval\nfrom . import LerpBlendHelpers\n\nclass IndirectInterval(Interval.Interval):\n    \"\"\"\n    This class can be used to play samples of another interval, so\n    that only a subset of the interval is played, or the time is\n    compressed, or some such nonsense.\n\n    It keeps a reference to the interval itself and repeatedly calls\n    setT() on it, rather than actually starting the interval or\n    copying its members like Sequence() or Parallel().  This means two\n    IndirectIntervals that operate on the same nested interval may\n    have some interaction that you should be aware of.\n    \"\"\"\n\n    # Interval counter\n    indirectIntervalNum = 1\n\n    notify = directNotify.newCategory('IndirectInterval')\n\n    # Class methods\n    def __init__(self, interval,\n                 startT = 0, endT = None, playRate = 1,\n                 duration = None, blendType = 'noBlend', name = None):\n        self.interval = interval\n\n        self.startAtStart = (startT == 0)\n        self.endAtEnd = (endT is None or endT == interval.getDuration())\n\n        if endT is None:\n            endT = interval.getDuration()\n\n        if duration is None:\n            duration = abs(endT - startT) / playRate\n\n        if name is None:\n            name = ('IndirectInterval-%d' %\n                    IndirectInterval.indirectIntervalNum)\n            IndirectInterval.indirectIntervalNum += 1\n\n        self.startT = startT\n        self.endT = endT\n        self.deltaT = endT - startT\n        self.blendType = LerpBlendHelpers.getBlend(blendType)\n\n        Interval.Interval.__init__(self, name, duration)\n\n    def __calcT(self, t):\n        return self.startT + self.deltaT * self.blendType(t / self.duration)\n\n    def privInitialize(self, t):\n        state = self.interval.getState()\n        if state == CInterval.SInitial or state == CInterval.SFinal:\n            self.interval.privInitialize(self.__calcT(t))\n        else:\n            self.interval.privStep(self.__calcT(t))\n        self.currT = t\n        self.state = CInterval.SStarted\n        self.interval.privPostEvent()\n\n    def privInstant(self):\n        state = self.interval.getState()\n        if (state == CInterval.SInitial or state == CInterval.SFinal) and \\\n           self.endAtEnd:\n            self.interval.privInstant()\n            self.currT = self.getDuration()\n            self.interval.privPostEvent()\n            self.intervalDone()\n        else:\n            if state == CInterval.SInitial or state == CInterval.SFinal:\n                self.interval.privInitialize(self.startT)\n            else:\n                self.interval.privStep(self.startT)\n            self.privFinalize()\n\n    def privStep(self, t):\n        self.interval.privStep(self.__calcT(t))\n        self.currT = t\n        self.state = CInterval.SStarted\n        self.interval.privPostEvent()\n\n    def privFinalize(self):\n        if self.endAtEnd:\n            self.interval.privFinalize()\n        else:\n            self.interval.privStep(self.endT)\n            self.interval.privInterrupt()\n        self.currT = self.getDuration()\n        self.state = CInterval.SFinal\n        self.interval.privPostEvent()\n        self.intervalDone()\n\n    def privReverseInitialize(self, t):\n        state = self.interval.getState()\n        if state == CInterval.SInitial or state == CInterval.SFinal:\n            self.interval.privReverseInitialize(self.__calcT(t))\n        else:\n            self.interval.privStep(self.__calcT(t))\n        self.currT = t\n        self.state = CInterval.SStarted\n        self.interval.privPostEvent()\n\n    def privReverseInstant(self):\n        state = self.interval.getState()\n        if (state == CInterval.SInitial or state == CInterval.SFinal) and \\\n           self.startAtStart:\n            self.interval.privReverseInstant()\n            self.currT = 0\n            self.interval.privPostEvent()\n        else:\n            if state == CInterval.SInitial or state == CInterval.SFinal:\n                self.interval.privReverseInitialize(self.endT)\n            else:\n                self.interval.privStep(self.endT)\n            self.privReverseFinalize()\n\n    def privReverseFinalize(self):\n        if self.startAtStart:\n            self.interval.privReverseFinalize()\n        else:\n            self.interval.privStep(self.endT)\n            self.interval.privInterrupt()\n        self.currT = 0\n        self.state = CInterval.SInitial\n        self.interval.privPostEvent()\n\n    def privInterrupt(self):\n        self.interval.privInterrupt()\n        self.interval.privPostEvent()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/interval/IndirectInterval.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/43d373be_IndirectInterval.json",
    "doc_id": "doc_152"
  }
}