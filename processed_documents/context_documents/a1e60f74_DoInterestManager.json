{
  "content": "\"\"\"\nThe DoInterestManager keeps track of which parent/zones that we currently\nhave interest in.  When you want to \"look\" into a zone you add an interest\nto that zone.  When you want to get rid of, or ignore, the objects in that\nzone, remove interest in that zone.\n\np.s. A great deal of this code is just code moved from ClientRepository.py.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom panda3d.core import ConfigVariableBool\nfrom .MsgTypes import CLIENT_ADD_INTEREST, CLIENT_ADD_INTEREST_MULTIPLE, CLIENT_REMOVE_INTEREST\nfrom direct.showbase import DirectObject\nfrom direct.showbase.MessengerGlobal import messenger\nfrom .PyDatagram import PyDatagram\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nimport types\nfrom direct.showbase.PythonUtil import (\n    FrameDelayedCall,\n    ScratchPad,\n    SerialNumGen,\n    report,\n    serialNum,\n    uniqueElements,\n    uniqueName,\n)\n\nclass InterestState:\n    StateActive = 'Active'\n    StatePendingDel = 'PendingDel'\n    def __init__(self, desc, state, context, event, parentId, zoneIdList,\n                 eventCounter, auto=False):\n        self.desc = desc\n        self.state = state\n        self.context = context\n        # We must be ready to keep track of multiple events. If somebody\n        # requested an interest to be removed and we get a second request\n        # for removal of the same interest before we get a response for the\n        # first interest removal, we now have two parts of the codebase\n        # waiting for a response on the removal of a single interest.\n        self.events = []\n        self.eventCounter = eventCounter\n        if event:\n            self.addEvent(event)\n        self.parentId = parentId\n        self.zoneIdList = zoneIdList\n        self.auto = auto\n    def addEvent(self, event):\n        self.events.append(event)\n        self.eventCounter.num += 1\n    def getEvents(self):\n        return list(self.events)\n    def clearEvents(self):\n        self.eventCounter.num -= len(self.events)\n        assert self.eventCounter.num >= 0\n        self.events = []\n    def sendEvents(self):\n        for event in self.events:\n            messenger.send(event)\n        self.clearEvents()\n    def setDesc(self, desc):\n        self.desc = desc\n    def isPendingDelete(self):\n        return self.state == InterestState.StatePendingDel\n    def __repr__(self):\n        return 'InterestState(desc=%s, state=%s, context=%s, event=%s, parentId=%s, zoneIdList=%s)' % (\n            self.desc, self.state, self.context, self.events, self.parentId, self.zoneIdList)\n\nclass InterestHandle:\n    \"\"\"This class helps to ensure that valid handles get passed in to DoInterestManager funcs\"\"\"\n    def __init__(self, id):\n        self._id = id\n    def asInt(self):\n        return self._id\n    def __eq__(self, other):\n        if type(self) == type(other):\n            return self._id == other._id\n        return self._id == other\n    def __repr__(self):\n        return '%s(%s)' % (self.__class__.__name__, self._id)\n\n# context value for interest changes that have no complete event\nNO_CONTEXT = 0\n\nclass DoInterestManager(DirectObject.DirectObject):\n    \"\"\"\n    Top level Interest Manager\n    \"\"\"\n    notify = directNotify.newCategory(\"DoInterestManager\")\n    InterestDebug = ConfigVariableBool('interest-debug', False)\n\n    # 'handle' is a number that represents a single interest set that the\n    # client has requested; the interest set may be modified\n    _HandleSerialNum = 0\n    # high bit is reserved for server interests\n    _HandleMask = 0x7FFF\n\n    # 'context' refers to a single request to change an interest set\n    _ContextIdSerialNum = 100\n    _ContextIdMask = 0x3FFFFFFF # avoid making Python create a long\n\n    _interests: dict[int, InterestState] = {}\n    if __debug__:\n        _debug_interestHistory: list[tuple] = []\n        _debug_maxDescriptionLen = 40\n\n    _SerialGen = SerialNumGen()\n    _SerialNum = serialNum()\n\n    def __init__(self):\n        assert DoInterestManager.notify.debugCall()\n        DirectObject.DirectObject.__init__(self)\n        self._addInterestEvent = uniqueName('DoInterestManager-Add')\n        self._removeInterestEvent = uniqueName('DoInterestManager-Remove')\n        self._noNewInterests = False\n        self._completeDelayedCallback = None\n        # keep track of request contexts that have not completed\n        self._completeEventCount = ScratchPad(num=0)\n        self._allInterestsCompleteCallbacks = []\n\n    def __verbose(self):\n        return self.InterestDebug.getValue() or self.getVerbose()\n\n    def _getAnonymousEvent(self, desc):\n        return 'anonymous-%s-%s' % (desc, DoInterestManager._SerialGen.next())\n\n    def setNoNewInterests(self, flag):\n        self._noNewInterests = flag\n\n    def noNewInterests(self):\n        return self._noNewInterests\n\n    def setAllInterestsCompleteCallback(self, callback):\n        if ((self._completeEventCount.num == 0) and\n            (self._completeDelayedCallback is None)):\n            callback()\n        else:\n            self._allInterestsCompleteCallbacks.append(callback)\n\n    def getAllInterestsCompleteEvent(self):\n        return 'allInterestsComplete-%s' % DoInterestManager._SerialNum\n\n    def resetInterestStateForConnectionLoss(self):\n        DoInterestManager._interests.clear()\n        self._completeEventCount = ScratchPad(num=0)\n        if __debug__:\n            self._addDebugInterestHistory(\"RESET\", \"\", 0, 0, 0, [])\n\n    def isValidInterestHandle(self, handle):\n        # pass in a handle (or anything else) and this will return true if it is\n        # still a valid interest handle\n        if not isinstance(handle, InterestHandle):\n            return False\n        return handle.asInt() in DoInterestManager._interests\n\n    def updateInterestDescription(self, handle, desc):\n        iState = DoInterestManager._interests.get(handle.asInt())\n        if iState:\n            iState.setDesc(desc)\n\n    def addInterest(self, parentId, zoneIdList, description, event=None):\n        \"\"\"\n        Look into a (set of) zone(s).\n        \"\"\"\n        assert DoInterestManager.notify.debugCall()\n        handle = self._getNextHandle()\n        # print 'base.cr.addInterest(',description,',',handle,'):',base.clock.getFrameCount()\n        if self._noNewInterests:\n            DoInterestManager.notify.warning(\n                \"addInterest: addingInterests on delete: %s\" % (handle))\n            return\n\n        # make sure we've got parenting rules set in the DC\n        if parentId not in (self.getGameDoId(),):\n            parent = self.getDo(parentId)\n            if not parent:\n                DoInterestManager.notify.error(\n                    'addInterest: attempting to add interest under unknown object %s' % parentId)\n            else:\n                if not parent.hasParentingRules():\n                    DoInterestManager.notify.error(\n                        'addInterest: no setParentingRules defined in the DC for object %s (%s)'\n                        '' % (parentId, parent.__class__.__name__))\n\n\n\n        if event:\n            contextId = self._getNextContextId()\n        else:\n            contextId = 0\n            # event = self._getAnonymousEvent('addInterest')\n\n        DoInterestManager._interests[handle] = InterestState(\n            description, InterestState.StateActive, contextId, event, parentId, zoneIdList, self._completeEventCount)\n        if self.__verbose():\n            print('CR::INTEREST.addInterest(handle=%s, parentId=%s, zoneIdList=%s, description=%s, event=%s)' % (\n                handle, parentId, zoneIdList, description, event))\n        self._sendAddInterest(handle, contextId, parentId, zoneIdList, description)\n        if event:\n            messenger.send(self._getAddInterestEvent(), [event])\n        assert self.printInterestsIfDebug()\n        return InterestHandle(handle)\n\n    def addAutoInterest(self, parentId, zoneIdList, description):\n        \"\"\"\n        Look into a (set of) zone(s).\n        \"\"\"\n        assert DoInterestManager.notify.debugCall()\n        handle = self._getNextHandle()\n        if self._noNewInterests:\n            DoInterestManager.notify.warning(\n                \"addInterest: addingInterests on delete: %s\" % (handle))\n            return\n\n        # make sure we've got parenting rules set in the DC\n        if parentId not in (self.getGameDoId(),):\n            parent = self.getDo(parentId)\n            if not parent:\n                DoInterestManager.notify.error(\n                    'addInterest: attempting to add interest under unknown object %s' % parentId)\n            else:\n                if not parent.hasParentingRules():\n                    DoInterestManager.notify.error(\n                        'addInterest: no setParentingRules defined in the DC for object %s (%s)'\n                        '' % (parentId, parent.__class__.__name__))\n\n        DoInterestManager._interests[handle] = InterestState(\n            description, InterestState.StateActive, 0, None, parentId, zoneIdList, self._completeEventCount, True)\n        if self.__verbose():\n            print('CR::INTEREST.addInterest(handle=%s, parentId=%s, zoneIdList=%s, description=%s)' % (\n                handle, parentId, zoneIdList, description))\n        assert self.printInterestsIfDebug()\n        return InterestHandle(handle)\n\n    def removeInterest(self, handle, event = None):\n        \"\"\"\n        Stop looking in a (set of) zone(s)\n        \"\"\"\n        # print 'base.cr.removeInterest(',handle,'):',base.clock.getFrameCount()\n\n        assert DoInterestManager.notify.debugCall()\n        assert isinstance(handle, InterestHandle)\n        existed = False\n        if not event:\n            event = self._getAnonymousEvent('removeInterest')\n        handle = handle.asInt()\n        if handle in DoInterestManager._interests:\n            existed = True\n            intState = DoInterestManager._interests[handle]\n            if event:\n                messenger.send(self._getRemoveInterestEvent(),\n                               [event, intState.parentId, intState.zoneIdList])\n            if intState.isPendingDelete():\n                self.notify.warning(\n                    'removeInterest: interest %s already pending removal' %\n                    handle)\n                # this interest is already pending delete, so let's just tack this\n                # callback onto the list\n                if event is not None:\n                    intState.addEvent(event)\n            else:\n                if len(intState.events) > 0:\n                    # we're not pending a removal, but we have outstanding events?\n                    # probably we are waiting for an add/alter complete.\n                    # should we send those events now?\n                    assert self.notify.warning('removeInterest: abandoning events: %s' %\n                                               intState.events)\n                    intState.clearEvents()\n                intState.state = InterestState.StatePendingDel\n                contextId = self._getNextContextId()\n                intState.context = contextId\n                if event:\n                    intState.addEvent(event)\n                self._sendRemoveInterest(handle, contextId)\n                if not event:\n                    self._considerRemoveInterest(handle)\n                if self.__verbose():\n                    print('CR::INTEREST.removeInterest(handle=%s, event=%s)' % (\n                        handle, event))\n        else:\n            DoInterestManager.notify.warning(\n                \"removeInterest: handle not found: %s\" % (handle))\n        assert self.printInterestsIfDebug()\n        return existed\n\n    def removeAutoInterest(self, handle):\n        \"\"\"\n        Stop looking in a (set of) zone(s)\n        \"\"\"\n        assert DoInterestManager.notify.debugCall()\n        assert isinstance(handle, InterestHandle)\n        existed = False\n        handle = handle.asInt()\n        if handle in DoInterestManager._interests:\n            existed = True\n            intState = DoInterestManager._interests[handle]\n            if intState.isPendingDelete():\n                self.notify.warning(\n                    'removeInterest: interest %s already pending removal' %\n                    handle)\n                # this interest is already pending delete, so let's just tack this\n                # callback onto the list\n            else:\n                if len(intState.events) > 0:\n                    # we're not pending a removal, but we have outstanding events?\n                    # probably we are waiting for an add/alter complete.\n                    # should we send those events now?\n                    self.notify.warning('removeInterest: abandoning events: %s' %\n                                        intState.events)\n                    intState.clearEvents()\n                intState.state = InterestState.StatePendingDel\n                self._considerRemoveInterest(handle)\n                if self.__verbose():\n                    print('CR::INTEREST.removeAutoInterest(handle=%s)' % (handle))\n        else:\n            DoInterestManager.notify.warning(\n                \"removeInterest: handle not found: %s\" % (handle))\n        assert self.printInterestsIfDebug()\n        return existed\n\n    @report(types = ['args'], dConfigParam = 'guildmgr')\n    def removeAIInterest(self, handle):\n        \"\"\"\n        handle is NOT an InterestHandle.  It's just a bare integer representing an\n        AI opened interest. We're making the client close down this interest since\n        the AI has trouble removing interests(that its opened) when the avatar goes\n        offline.  See GuildManager(UD) for how it's being used.\n        \"\"\"\n        self._sendRemoveAIInterest(handle)\n\n    def alterInterest(self, handle, parentId, zoneIdList, description=None,\n                      event=None):\n        \"\"\"\n        Removes old interests and adds new interests.\n\n        Note that when an interest is changed, only the most recent\n        change's event will be triggered. Previous events are abandoned.\n        If this is a problem, consider opening multiple interests.\n        \"\"\"\n        assert DoInterestManager.notify.debugCall()\n        assert isinstance(handle, InterestHandle)\n        #assert not self._noNewInterests\n        handle = handle.asInt()\n        if self._noNewInterests:\n            DoInterestManager.notify.warning(\n                \"alterInterest: addingInterests on delete: %s\" % (handle))\n            return\n\n        exists = False\n        if event is None:\n            event = self._getAnonymousEvent('alterInterest')\n        if handle in DoInterestManager._interests:\n            if description is not None:\n                DoInterestManager._interests[handle].desc = description\n            else:\n                description = DoInterestManager._interests[handle].desc\n\n            # are we overriding an existing change?\n            if DoInterestManager._interests[handle].context != NO_CONTEXT:\n                DoInterestManager._interests[handle].clearEvents()\n\n            contextId = self._getNextContextId()\n            DoInterestManager._interests[handle].context = contextId\n            DoInterestManager._interests[handle].parentId = parentId\n            DoInterestManager._interests[handle].zoneIdList = zoneIdList\n            DoInterestManager._interests[handle].addEvent(event)\n\n            if self.__verbose():\n                print('CR::INTEREST.alterInterest(handle=%s, parentId=%s, zoneIdList=%s, description=%s, event=%s)' % (\n                    handle, parentId, zoneIdList, description, event))\n            self._sendAddInterest(handle, contextId, parentId, zoneIdList, description, action='modify')\n            exists = True\n            assert self.printInterestsIfDebug()\n        else:\n            DoInterestManager.notify.warning(\n                \"alterInterest: handle not found: %s\" % (handle))\n        return exists\n\n    def openAutoInterests(self, obj):\n        if hasattr(obj, '_autoInterestHandle'):\n            # must be multiple inheritance\n            self.notify.debug('openAutoInterests(%s): interests already open' % obj.__class__.__name__)\n            return\n        autoInterests = obj.getAutoInterests()\n        obj._autoInterestHandle = None\n        if len(autoInterests) == 0:\n            return\n        obj._autoInterestHandle = self.addAutoInterest(obj.doId, autoInterests, '%s-autoInterest' % obj.__class__.__name__)\n    def closeAutoInterests(self, obj):\n        if not hasattr(obj, '_autoInterestHandle'):\n            # must be multiple inheritance\n            self.notify.debug('closeAutoInterests(%s): interests already closed' % obj)\n            return\n        if obj._autoInterestHandle is not None:\n            self.removeAutoInterest(obj._autoInterestHandle)\n        del obj._autoInterestHandle\n\n    # events for InterestWatcher\n    def _getAddInterestEvent(self):\n        return self._addInterestEvent\n    def _getRemoveInterestEvent(self):\n        return self._removeInterestEvent\n\n    def _getInterestState(self, handle):\n        return DoInterestManager._interests[handle]\n\n    def _getNextHandle(self):\n        handle = DoInterestManager._HandleSerialNum\n        while True:\n            handle = (handle + 1) & DoInterestManager._HandleMask\n            # skip handles that are already in use\n            if handle not in DoInterestManager._interests:\n                break\n            DoInterestManager.notify.warning(\n                'interest %s already in use' % handle)\n        DoInterestManager._HandleSerialNum = handle\n        return DoInterestManager._HandleSerialNum\n    def _getNextContextId(self):\n        contextId = DoInterestManager._ContextIdSerialNum\n        while True:\n            contextId = (contextId + 1) & DoInterestManager._ContextIdMask\n            # skip over the 'no context' id\n            if contextId != NO_CONTEXT:\n                break\n        DoInterestManager._ContextIdSerialNum = contextId\n        return DoInterestManager._ContextIdSerialNum\n\n    def _considerRemoveInterest(self, handle):\n        \"\"\"\n        Consider whether we should cull the interest set.\n        \"\"\"\n        assert DoInterestManager.notify.debugCall()\n\n        if handle in DoInterestManager._interests:\n            if DoInterestManager._interests[handle].isPendingDelete():\n                # make sure there is no pending event for this interest\n                if DoInterestManager._interests[handle].context == NO_CONTEXT:\n                    assert len(DoInterestManager._interests[handle].events) == 0\n                    del DoInterestManager._interests[handle]\n\n    if __debug__:\n        def printInterestsIfDebug(self):\n            if DoInterestManager.notify.getDebug():\n                self.printInterests()\n            return 1 # for assert\n\n        def _addDebugInterestHistory(self, action, description, handle,\n                                     contextId, parentId, zoneIdList):\n            if description is None:\n                description = ''\n            DoInterestManager._debug_interestHistory.append(\n                (action, description, handle, contextId, parentId, zoneIdList))\n            DoInterestManager._debug_maxDescriptionLen = max(\n                DoInterestManager._debug_maxDescriptionLen, len(description))\n\n        def printInterestHistory(self):\n            print(\"***************** Interest History *************\")\n            format = '%9s %' + str(DoInterestManager._debug_maxDescriptionLen) + 's %6s %6s %9s %s'\n            print(format % (\n                \"Action\", \"Description\", \"Handle\", \"Context\", \"ParentId\",\n                \"ZoneIdList\"))\n            for i in DoInterestManager._debug_interestHistory:\n                print(format % tuple(i))\n            print(\"Note: interests with a Context of 0 do not get\" \\\n                \" done/finished notices.\")\n\n        def printInterestSets(self):\n            print(\"******************* Interest Sets **************\")\n            format = '%6s %' + str(DoInterestManager._debug_maxDescriptionLen) + 's %11s %11s %8s %8s %8s'\n            print(format % (\n                \"Handle\", \"Description\",\n                \"ParentId\", \"ZoneIdList\",\n                \"State\", \"Context\",\n                \"Event\"))\n            for id, state in DoInterestManager._interests.items():\n                if len(state.events) == 0:\n                    event = ''\n                elif len(state.events) == 1:\n                    event = state.events[0]\n                else:\n                    event = state.events\n                print(format % (id, state.desc,\n                                state.parentId, state.zoneIdList,\n                                state.state, state.context,\n                                event))\n            print(\"************************************************\")\n\n        def printInterests(self):\n            self.printInterestHistory()\n            self.printInterestSets()\n\n    def _sendAddInterest(self, handle, contextId, parentId, zoneIdList, description,\n                         action=None):\n        \"\"\"\n        Part of the new otp-server code.\n\n        handle is a client-side created number that refers to\n                a set of interests.  The same handle number doesn't\n                necessarily have any relationship to the same handle\n                on another client.\n        \"\"\"\n        assert DoInterestManager.notify.debugCall()\n        if __debug__:\n            if isinstance(zoneIdList, list):\n                zoneIdList.sort()\n            if action is None:\n                action = 'add'\n            self._addDebugInterestHistory(\n                action, description, handle, contextId, parentId, zoneIdList)\n        if parentId == 0:\n            DoInterestManager.notify.error(\n                'trying to set interest to invalid parent: %s' % parentId)\n        datagram = PyDatagram()\n        # Add message type\n        if isinstance(zoneIdList, list):\n            vzl = sorted(zoneIdList)\n            uniqueElements(vzl)\n            datagram.addUint16(CLIENT_ADD_INTEREST_MULTIPLE)\n            datagram.addUint32(contextId)\n            datagram.addUint16(handle)\n            datagram.addUint32(parentId)\n            datagram.addUint16(len(vzl))\n            for zone in vzl:\n                datagram.addUint32(zone)\n        else:\n            datagram.addUint16(CLIENT_ADD_INTEREST)\n            datagram.addUint32(contextId)\n            datagram.addUint16(handle)\n            datagram.addUint32(parentId)\n            datagram.addUint32(zoneIdList)\n        self.send(datagram)\n\n    def _sendRemoveInterest(self, handle, contextId):\n        \"\"\"\n        handle is a client-side created number that refers to\n                a set of interests.  The same handle number doesn't\n                necessarily have any relationship to the same handle\n                on another client.\n        \"\"\"\n        assert DoInterestManager.notify.debugCall()\n        assert handle in DoInterestManager._interests\n        datagram = PyDatagram()\n        # Add message type\n        datagram.addUint16(CLIENT_REMOVE_INTEREST)\n        datagram.addUint32(contextId)\n        datagram.addUint16(handle)\n        self.send(datagram)\n        if __debug__:\n            state = DoInterestManager._interests[handle]\n            self._addDebugInterestHistory(\n                \"remove\", state.desc, handle, contextId,\n                state.parentId, state.zoneIdList)\n\n    def _sendRemoveAIInterest(self, handle):\n        \"\"\"\n        handle is a bare int, NOT an InterestHandle.  Use this to\n        close an AI opened interest.\n        \"\"\"\n        datagram = PyDatagram()\n        # Add message type\n        datagram.addUint16(CLIENT_REMOVE_INTEREST)\n        datagram.addUint16((1<<15) + handle)\n        self.send(datagram)\n\n    def cleanupWaitAllInterestsComplete(self):\n        if self._completeDelayedCallback is not None:\n            self._completeDelayedCallback.destroy()\n            self._completeDelayedCallback = None\n\n    def queueAllInterestsCompleteEvent(self, frames=5):\n        # wait for N frames, if no new interests, send out all-done event\n        # calling this is OK even if there are no pending interest completes\n        def checkMoreInterests():\n            # if there are new interests, cancel this delayed callback, another\n            # will automatically be scheduled when all interests complete\n            # print 'checkMoreInterests(',self._completeEventCount.num,'):',base.clock.getFrameCount()\n            return self._completeEventCount.num > 0\n        def sendEvent():\n            messenger.send(self.getAllInterestsCompleteEvent())\n            for callback in self._allInterestsCompleteCallbacks:\n                callback()\n            self._allInterestsCompleteCallbacks = []\n        self.cleanupWaitAllInterestsComplete()\n        self._completeDelayedCallback = FrameDelayedCall(\n            'waitForAllInterestCompletes',\n            callback=sendEvent,\n            frames=frames,\n            cancelFunc=checkMoreInterests)\n        checkMoreInterests = None\n        sendEvent = None\n\n    def handleInterestDoneMessage(self, di):\n        \"\"\"\n        This handles the interest done messages and may dispatch an event\n        \"\"\"\n        assert DoInterestManager.notify.debugCall()\n        contextId = di.getUint32()\n        handle = di.getUint16()\n        if self.__verbose():\n            print('CR::INTEREST.interestDone(handle=%s)' % handle)\n        DoInterestManager.notify.debug(\n            \"handleInterestDoneMessage--> Received handle %s, context %s\" % (\n            handle, contextId))\n        if handle in DoInterestManager._interests:\n            eventsToSend = []\n            # if the context matches, send out the event\n            if contextId == DoInterestManager._interests[handle].context:\n                DoInterestManager._interests[handle].context = NO_CONTEXT\n                # the event handlers may call back into the interest manager. Send out\n                # the events after we're once again in a stable state.\n                #DoInterestManager._interests[handle].sendEvents()\n                eventsToSend = list(DoInterestManager._interests[handle].getEvents())\n                DoInterestManager._interests[handle].clearEvents()\n            else:\n                DoInterestManager.notify.debug(\n                    \"handleInterestDoneMessage--> handle: %s: Expecting context %s, got %s\" % (\n                    handle, DoInterestManager._interests[handle].context, contextId))\n            if __debug__:\n                state = DoInterestManager._interests[handle]\n                self._addDebugInterestHistory(\n                    \"finished\", state.desc, handle, contextId, state.parentId,\n                    state.zoneIdList)\n            self._considerRemoveInterest(handle)\n            for event in eventsToSend:\n                messenger.send(event)\n        else:\n            DoInterestManager.notify.warning(\n                \"handleInterestDoneMessage: handle not found: %s\" % (handle))\n        # if there are no more outstanding interest-completes, send out global all-done event\n        if self._completeEventCount.num == 0:\n            self.queueAllInterestsCompleteEvent()\n        assert self.printInterestsIfDebug()\n\nif __debug__:\n    import unittest\n    import time\n\n    class AsyncTestCase(unittest.TestCase):\n        def setCompleted(self):\n            self._async_completed = True\n        def isCompleted(self):\n            return getattr(self, '_async_completed', False)\n\n    class AsyncTestSuite(unittest.TestSuite):\n        pass\n\n    class AsyncTestLoader(unittest.TestLoader):\n        suiteClass = AsyncTestSuite\n\n    class AsyncTextTestRunner(unittest.TextTestRunner):\n        def run(self, test):\n            result = self._makeResult()\n            startTime = time.time()\n            test(result)\n            stopTime = time.time()\n            timeTaken = stopTime - startTime\n            result.printErrors()\n            self.stream.writeln(result.separator2)\n            run = result.testsRun\n            self.stream.writeln(\"Ran %d test%s in %.3fs\" %\n                                (run, run != 1 and \"s\" or \"\", timeTaken))\n            self.stream.writeln()\n            if not result.wasSuccessful():\n                self.stream.write(\"FAILED (\")\n                failed, errored = map(len, (result.failures, result.errors))\n                if failed:\n                    self.stream.write(\"failures=%d\" % failed)\n                if errored:\n                    if failed:\n                        self.stream.write(\", \")\n                    self.stream.write(\"errors=%d\" % errored)\n                self.stream.writeln(\")\")\n            else:\n                self.stream.writeln(\"OK\")\n            return result\n\n    class TestInterestAddRemove(AsyncTestCase, DirectObject.DirectObject):\n        def testInterestAdd(self):\n            event = uniqueName('InterestAdd')\n            self.acceptOnce(event, self.gotInterestAddResponse)\n            self.handle = base.cr.addInterest(base.cr.GameGlobalsId, 100, 'TestInterest', event=event)\n        def gotInterestAddResponse(self):\n            event = uniqueName('InterestRemove')\n            self.acceptOnce(event, self.gotInterestRemoveResponse)\n            base.cr.removeInterest(self.handle, event=event)\n        def gotInterestRemoveResponse(self):\n            self.setCompleted()\n\n    def runTests():\n        suite = unittest.makeSuite(TestInterestAddRemove)\n        unittest.AsyncTextTestRunner(verbosity=2).run(suite)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/DoInterestManager.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/a1e60f74_DoInterestManager.json",
    "doc_id": "doc_294"
  }
}