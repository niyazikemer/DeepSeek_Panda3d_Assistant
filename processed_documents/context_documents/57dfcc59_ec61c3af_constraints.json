{
  "content": "Bullet Constraints\n\nConstraints limit the movement of two rigid bodies in relation to each other, or the movement of one body in relation to the global world space. Another often used term word for constraints is joint.\n\nConstraint Types\n\nThe following different types of constraints are supported by Bullet:\n\nHinge Constraint\n\nThe hinge constraint has restricts movement of two bodies by means of a shared axis. The axis is defined by a pivot point on each body (within the body's local space). Hinge constraints can be used for example to model doors or chests.\n\nSlider Constraint\n\nThe slider constraint allows the two bodies to move along a shared piston. Rotation around the piston can be limited, if this is required.\n\nSpherical Constraint\n\nThe spherical constraint models a ball-and-socket connection between two rigid bodies.\n\nCone Twist Constraint\n\nThe cone twist constraint is a specialized version of the spherical constraint. It allows to limit the rotation and the swing (in both perpendicular directions).\n\nGeneric Constraint\n\nThe generic constraint allows movement in all six degrees of freedom, and it allows to limit this movement as desired.\n\nConstraint between two rigid bodies\n\nAll constraints can be created and used in similar ways, so we will explain only one constraint in detail, the .BulletConeTwistConstraint. For other constraints, please refer to the API documentation.\n\nWe assume that we already have created two rigid body nodes, and npA and npB are NodePaths for these rigid body nodes. For example like the two boxes created in the following snippet\n\npython\n\nshape = BulletBoxShape(Vec3(0.5, 0.5, 0.5))\n\nnpA = self.worldNP.attachNewNode(BulletRigidBodyNode('A'))\nnpA.node().setMass(1.0)\nnpA.node().addShape(shape)\nnpA.setPos(10, 0, 5)\nworld.attachRigidBody(npA.node())\n\nnpB = self.worldNP.attachNewNode(BulletRigidBodyNode('B'))\nnpB.node().addShape(shape)\nnpB.setPos(10, 0, -5)\nself.world.attachRigidBody(npB.node())\n\ncpp\n\nPT(BulletShape) shape = new BulletBoxShape(LVector3(0.5, 0.5, 0.5));\n\nNodePath np_a = world.attach_new_node(new BulletRigidBodyNode(\"A\");\nnp_a.node()->set_mass(1.0);\nnp_a.node()->add_shape(shape);\nnp_a.set_pos(10, 0, 5);\nworld->attach_rigid_body(np_a.node());\n\nNodePath np_b = world.attach_new_node(new BulletRigidBodyNode(\"B\");\nnp_b.node()->add_shape(shape);\nnp_b.set_pos(10, 0, -5);\nworld->attach_rigid_body(np_b.node());\n\nIn the above example body A is dynamic, and body B is static. This means body A will fall down since it is affected by gravity, but body B will always stay where it is. Neither can body B be pushed by dynamic bodies.\n\nUsing a cone/twist constraint we can connect body A to body B. The cone/twist constraint will allow body A to move within a cone fixed to body B. Body A will also be able to rotate around the axis from the cone's vertex point to body A ('twist' around this axis).\n\nIn order to create the cone/twist constraint we have to define the spatial frames of the cone/twist connector point, as seen from body A and from body B. Then we need to create a new instance of .BulletConeTwistConstraint, by passing both bodies and both transforms to the constructor. Once created, we can set properties like the scale of the debug visualization of this constraint, as well as limits. Finally, we add the new constraint to the physics world.\n\npython\n\nframeA = TransformState.makePosHpr(Point3(0, 0, -5), Vec3(0, 0, -90))\nframeB = TransformState.makePosHpr(Point3(0, 0, 5), Vec3(0, 0, -90))\n\nswing1 = 60 # degrees\nswing2 = 36 # degrees\ntwist = 120 # degrees\n\ncs = BulletConeTwistConstraint(npA.node(), npB.node(), frameA, frameB)\ncs.setDebugDrawSize(2.0)\ncs.setLimit(swing1, swing2, twist)\nworld.attachConstraint(cs)\n\nIn this case we have set the following limits:\n\nAngle of the cone opening in first direction (swing span 1)\n\nAngle of the cone opening in second direction (swing span 2)\n\nMaximum twist angle (twist)\n\nIn addition we could also add the following parameters: softness, bias factor, relaxation factor.\n\nWhich limits are available depends on the constraint type. Please refer to the API documentation.\n\nConstraint between one rigid body and the world\n\nAdding a constraint between a single body and a fixed point in the global world is similar to adding a constraint between two rigid bodies. The difference is that you pass only one body and one frame to the constructor of the constraint, for example like in the following snippet\n\npython\n\nframeA = TransformState.makePosHpr(Point3(0, 0, -5), Vec3(0, 0, -90))\n\ncs = BulletConeTwistConstraint(npA.node(), frameA)\nworld.attachConstraint(cs)\n\ncpp\n\nCPT(TransformState) frame_a = TransformState::make_pos_hpr(LPoint3(0, 0, -5), LVector3(0, 0, -90));\n\nPT(BulletConeTwistConstraint) cs = new BulletConeTwistConstraint(np_a.node(), frame_a);\nworld->attach_constraint(cs);",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/ec61c3af_constraints.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/57dfcc59_ec61c3af_constraints.json",
    "doc_id": "doc_685"
  }
}