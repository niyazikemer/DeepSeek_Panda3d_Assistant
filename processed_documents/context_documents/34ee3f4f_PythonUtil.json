{
  "content": "\"\"\"Contains miscellaneous utility functions and classes.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n\n    'indent', 'doc', 'adjust', 'difference', 'intersection', 'union',\n    'sameElements', 'makeList', 'makeTuple', 'list2dict', 'invertDict',\n    'invertDictLossless', 'uniqueElements', 'disjoint', 'contains', 'replace',\n    'reduceAngle', 'fitSrcAngle2Dest', 'fitDestAngle2Src', 'closestDestAngle2',\n    'closestDestAngle', 'getSetterName', 'getSetter', 'Functor', 'Stack',\n    'Queue', 'bound', 'clamp', 'lerp', 'average', 'addListsByValue',\n    'boolEqual', 'lineupPos', 'formatElapsedSeconds', 'solveQuadratic',\n    'findPythonModule', 'mostDerivedLast', 'clampScalar', 'weightedChoice',\n    'randFloat', 'normalDistrib', 'weightedRand', 'randUint31', 'randInt32',\n    'SerialNumGen', 'SerialMaskedGen', 'serialNum', 'uniqueName', 'Singleton',\n    'SingletonError', 'printListEnum', 'safeRepr', 'fastRepr',\n    'isDefaultValue', 'ScratchPad', 'Sync', 'itype', 'getNumberedTypedString',\n    'getNumberedTypedSortedString', 'printNumberedTyped', 'DelayedCall',\n    'DelayedFunctor', 'FrameDelayedCall', 'SubframeCall', 'getBase',\n    'GoldenRatio', 'GoldenRectangle', 'rad90', 'rad180', 'rad270', 'rad360',\n    'nullGen', 'loopGen', 'makeFlywheelGen', 'flywheel', 'listToIndex2item',\n    'listToItem2index', 'formatTimeCompact', 'deeptype', 'StdoutCapture',\n    'StdoutPassthrough', 'Averager', 'getRepository', 'formatTimeExact',\n    'typeName', 'safeTypeName', 'histogramDict', 'unescapeHtmlString',\n]\n\nif __debug__:\n    __all__ += ['StackTrace', 'traceFunctionCall', 'traceParentCall',\n                'printThisCall', 'stackEntryInfo', 'lineInfo', 'callerInfo',\n                'lineTag', 'profileFunc', 'profiled', 'startProfile',\n                'printProfile', 'getProfileResultString', 'printStack',\n                'printReverseStack']\n\nimport types\nimport math\nimport os\nimport sys\nimport random\nimport time\nimport builtins\nimport importlib\nimport functools\nfrom typing import Callable\n\n__report_indent = 3\n\nfrom panda3d.core import ConfigVariableBool, ConfigVariableString, ConfigFlags\nfrom panda3d.core import ClockObject\n\n\n## with one integer positional arg, this uses about 4/5 of the memory of the Functor class below\n#def Functor(function, *args, **kArgs):\n#    argsCopy = args[:]\n#    def functor(*cArgs, **ckArgs):\n#        kArgs.update(ckArgs)\n#        return function(*(argsCopy + cArgs), **kArgs)\n#    return functor\n\nclass Functor:\n    def __init__(self, function, *args, **kargs):\n        assert callable(function), \"function should be a callable obj\"\n        self._function = function\n        self._args = args\n        self._kargs = kargs\n        if hasattr(self._function, '__name__'):\n            self.__name__ = self._function.__name__\n        else:\n            self.__name__ = str(itype(self._function))\n        if hasattr(self._function, '__doc__'):\n            self.__doc__ = self._function.__doc__\n        else:\n            self.__doc__ = self.__name__\n\n    def destroy(self):\n        del self._function\n        del self._args\n        del self._kargs\n        del self.__name__\n        del self.__doc__\n\n    def _do__call__(self, *args, **kargs):\n        _kargs = self._kargs.copy()\n        _kargs.update(kargs)\n        return self._function(*(self._args + args), **_kargs)\n\n    __call__ = _do__call__\n\n    def __repr__(self):\n        s = 'Functor(%s' % self._function.__name__\n        for arg in self._args:\n            try:\n                argStr = repr(arg)\n            except Exception:\n                argStr = 'bad repr: %s' % arg.__class__\n            s += ', %s' % argStr\n        for karg, value in list(self._kargs.items()):\n            s += ', %s=%s' % (karg, repr(value))\n        s += ')'\n        return s\n\n\nclass Stack:\n    def __init__(self):\n        self.__list = []\n\n    def push(self, item):\n        self.__list.append(item)\n\n    def top(self):\n        # return the item on the top of the stack without popping it off\n        return self.__list[-1]\n\n    def pop(self):\n        return self.__list.pop()\n\n    def clear(self):\n        self.__list = []\n\n    def isEmpty(self):\n        return len(self.__list) == 0\n\n    def __len__(self):\n        return len(self.__list)\n\n\nclass Queue:\n    # FIFO queue\n    # interface is intentionally identical to Stack (LIFO)\n    def __init__(self):\n        self.__list = []\n\n    def push(self, item):\n        self.__list.append(item)\n\n    def top(self):\n        # return the next item at the front of the queue without popping it off\n        return self.__list[0]\n\n    def front(self):\n        return self.__list[0]\n\n    def back(self):\n        return self.__list[-1]\n\n    def pop(self):\n        return self.__list.pop(0)\n\n    def clear(self):\n        self.__list = []\n\n    def isEmpty(self):\n        return len(self.__list) == 0\n\n    def __len__(self):\n        return len(self.__list)\n\n\ndef indent(stream, numIndents, str):\n    \"\"\"\n    Write str to stream with numIndents in front of it\n    \"\"\"\n    # To match emacs, instead of a tab character we will use 4 spaces\n    stream.write('    ' * numIndents + str)\n\n\nif __debug__:\n    import traceback\n    import marshal\n\n    class StackTrace:\n        def __init__(self, label=\"\", start=0, limit=None):\n            \"\"\"\n            label is a string (or anything that be be a string)\n            that is printed as part of the trace back.\n            This is just to make it easier to tell what the\n            stack trace is referring to.\n            start is an integer number of stack frames back\n            from the most recent.  (This is automatically\n            bumped up by one to skip the __init__ call\n            to the StackTrace).\n            limit is an integer number of stack frames\n            to record (or None for unlimited).\n            \"\"\"\n            self.label = label\n            if limit is not None:\n                self.trace = traceback.extract_stack(sys._getframe(1+start),\n                                                     limit=limit)\n            else:\n                self.trace = traceback.extract_stack(sys._getframe(1+start))\n\n        def compact(self):\n            r = ''\n            comma = ','\n            for filename, lineNum, funcName, text in self.trace:\n                r += '%s.%s:%s%s' % (filename[:filename.rfind('.py')][filename.rfind('\\\\')+1:], funcName, lineNum, comma)\n            if len(r) > 0:\n                r = r[:-len(comma)]\n            return r\n\n        def reverseCompact(self):\n            r = ''\n            comma = ','\n            for filename, lineNum, funcName, text in self.trace:\n                r = '%s.%s:%s%s%s' % (filename[:filename.rfind('.py')][filename.rfind('\\\\')+1:], funcName, lineNum, comma, r)\n            if len(r) > 0:\n                r = r[:-len(comma)]\n            return r\n\n        def __str__(self):\n            r = \"Debug stack trace of %s (back %s frames):\\n\"%(\n                self.label, len(self.trace),)\n            for i in traceback.format_list(self.trace):\n                r+=i\n            r+=\"***** NOTE: This is not a crash. This is a debug stack trace. *****\"\n            return r\n\n    def printStack():\n        print(StackTrace(start=1).compact())\n        return True\n\n    def printReverseStack():\n        print(StackTrace(start=1).reverseCompact())\n        return True\n\n    def printVerboseStack():\n        print(StackTrace(start=1))\n        return True\n\n    #-----------------------------------------------------------------------------\n\n    def traceFunctionCall(frame):\n        \"\"\"\n        return a string that shows the call frame with calling arguments.\n        e.g.\n        foo(x=234, y=135)\n        \"\"\"\n        f = frame\n        co = f.f_code\n        dict = f.f_locals\n        n = co.co_argcount\n        if co.co_flags & 4:\n            n = n + 1\n        if co.co_flags & 8:\n            n = n + 1\n        r = ''\n        if 'self' in dict:\n            r = '%s.' % (dict['self'].__class__.__name__,)\n        r += \"%s(\" % (f.f_code.co_name,)\n        comma=0 # formatting, whether we should type a comma.\n        for i in range(n):\n            name = co.co_varnames[i]\n            if name == 'self':\n                continue\n            if comma:\n                r+=', '\n            else:\n                # ok, we skipped the first one, the rest get commas:\n                comma=1\n            r+=name\n            r+='='\n            if name in dict:\n                v=safeRepr(dict[name])\n                if len(v)>2000:\n                    # r+=\"<too big for debug>\"\n                    r += (v[:2000] + \"...\")\n                else:\n                    r+=v\n            else:\n                r+=\"*** undefined ***\"\n        return r+')'\n\n    def traceParentCall():\n        return traceFunctionCall(sys._getframe(2))\n\n    def printThisCall():\n        print(traceFunctionCall(sys._getframe(1)))\n        return 1 # to allow \"assert printThisCall()\"\n\n# Magic numbers: These are the bit masks in func_code.co_flags that\n# reveal whether or not the function has a *arg or **kw argument.\n_POS_LIST = 4\n_KEY_DICT = 8\n\n\ndef doc(obj):\n    if (isinstance(obj, types.MethodType)) or \\\n       (isinstance(obj, types.FunctionType)):\n        print(obj.__doc__)\n\n\ndef adjust(command = None, dim = 1, parent = None, **kw):\n    \"\"\"\n    adjust(command = None, parent = None, **kw)\n    Popup and entry scale to adjust a parameter\n\n    Accepts any Slider keyword argument.  Typical arguments include:\n    command: The one argument command to execute\n    min: The min value of the slider\n    max: The max value of the slider\n    resolution: The resolution of the slider\n    text: The label on the slider\n\n    These values can be accessed and/or changed after the fact\n    >>> vg = adjust()\n    >>> vg['min']\n    0.0\n    >>> vg['min'] = 10.0\n    >>> vg['min']\n    10.0\n    \"\"\"\n    # Make sure we enable Tk\n    # Don't use a regular import, to prevent ModuleFinder from picking\n    # it up as a dependency when building a .p3d package.\n    Valuator = importlib.import_module('direct.tkwidgets.Valuator')\n    # Set command if specified\n    if command:\n        kw['command'] = lambda x: command(*x)\n        if parent is None:\n            kw['title'] = command.__name__\n    kw['dim'] = dim\n    # Create toplevel if needed\n    if not parent:\n        vg = Valuator.ValuatorGroupPanel(parent, **kw)\n    else:\n        vg = Valuator.ValuatorGroup(parent, **kw)\n        vg.pack(expand = 1, fill = 'x')\n    return vg\n\n\ndef difference(a, b):\n    \"\"\"\n    difference(list, list):\n    \"\"\"\n    if not a:\n        return b\n    if not b:\n        return a\n    d = []\n    for i in a:\n        if (i not in b) and (i not in d):\n            d.append(i)\n    for i in b:\n        if (i not in a) and (i not in d):\n            d.append(i)\n    return d\n\n\ndef intersection(a, b):\n    \"\"\"\n    intersection(list, list):\n    \"\"\"\n    if not a or not b:\n        return []\n    d = []\n    for i in a:\n        if (i in b) and (i not in d):\n            d.append(i)\n    for i in b:\n        if (i in a) and (i not in d):\n            d.append(i)\n    return d\n\n\ndef union(a, b):\n    \"\"\"\n    union(list, list):\n    \"\"\"\n    # Copy a\n    c = a[:]\n    for i in b:\n        if i not in c:\n            c.append(i)\n    return c\n\n\ndef sameElements(a, b):\n    if len(a) != len(b):\n        return 0\n    for elem in a:\n        if elem not in b:\n            return 0\n    for elem in b:\n        if elem not in a:\n            return 0\n    return 1\n\n\ndef makeList(x):\n    \"\"\"returns x, converted to a list\"\"\"\n    if isinstance(x, list):\n        return x\n    elif isinstance(x, tuple):\n        return list(x)\n    else:\n        return [x,]\n\n\ndef makeTuple(x):\n    \"\"\"returns x, converted to a tuple\"\"\"\n    if isinstance(x, list):\n        return tuple(x)\n    elif isinstance(x, tuple):\n        return x\n    else:\n        return (x,)\n\n\ndef list2dict(L, value=None):\n    \"\"\"creates dict using elements of list, all assigned to same value\"\"\"\n    return dict([(k, value) for k in L])\n\n\ndef listToIndex2item(L):\n    \"\"\"converts list to dict of list index->list item\"\"\"\n    d = {}\n    for i, item in enumerate(L):\n        d[i] = item\n    return d\n\n\nassert listToIndex2item(['a','b']) == {0: 'a', 1: 'b',}\n\n\ndef listToItem2index(L):\n    \"\"\"converts list to dict of list item->list index\n    This is lossy if there are duplicate list items\"\"\"\n    d = {}\n    for i, item in enumerate(L):\n        d[item] = i\n    return d\n\n\nassert listToItem2index(['a','b']) == {'a': 0, 'b': 1,}\n\n\ndef invertDict(D, lossy=False):\n    \"\"\"creates a dictionary by 'inverting' D; keys are placed in the new\n    dictionary under their corresponding value in the old dictionary.\n    It is an error if D contains any duplicate values.\n\n    >>> old = {'key1':1, 'key2':2}\n    >>> invertDict(old)\n    {1: 'key1', 2: 'key2'}\n    \"\"\"\n    n = {}\n    for key, value in D.items():\n        if not lossy and value in n:\n            raise Exception('duplicate key in invertDict: %s' % value)\n        n[value] = key\n    return n\n\n\ndef invertDictLossless(D):\n    \"\"\"similar to invertDict, but values of new dict are lists of keys from\n    old dict. No information is lost.\n\n    >>> old = {'key1':1, 'key2':2, 'keyA':2}\n    >>> invertDictLossless(old)\n    {1: ['key1'], 2: ['key2', 'keyA']}\n    \"\"\"\n    n = {}\n    for key, value in D.items():\n        n.setdefault(value, [])\n        n[value].append(key)\n    return n\n\n\ndef uniqueElements(L):\n    \"\"\"are all elements of list unique?\"\"\"\n    return len(L) == len(list2dict(L))\n\n\ndef disjoint(L1, L2):\n    \"\"\"returns non-zero if L1 and L2 have no common elements\"\"\"\n    used = dict([(k, None) for k in L1])\n    for k in L2:\n        if k in used:\n            return 0\n    return 1\n\n\ndef contains(whole, sub):\n    \"\"\"\n    Return 1 if whole contains sub, 0 otherwise\n    \"\"\"\n    if whole == sub:\n        return 1\n    for elem in sub:\n        # The first item you find not in whole, return 0\n        if elem not in whole:\n            return 0\n    # If you got here, whole must contain sub\n    return 1\n\n\ndef replace(list, old, new, all=0):\n    \"\"\"\n    replace 'old' with 'new' in 'list'\n    if all == 0, replace first occurrence\n    otherwise replace all occurrences\n    returns the number of items replaced\n    \"\"\"\n    if old not in list:\n        return 0\n\n    if not all:\n        i = list.index(old)\n        list[i] = new\n        return 1\n    else:\n        numReplaced = 0\n        for i in range(len(list)):\n            if list[i] == old:\n                numReplaced += 1\n                list[i] = new\n        return numReplaced\n\n\nrad90 = math.pi / 2.\nrad180 = math.pi\nrad270 = 1.5 * math.pi\nrad360 = 2. * math.pi\n\n\ndef reduceAngle(deg):\n    \"\"\"\n    Reduces an angle (in degrees) to a value in [-180..180)\n    \"\"\"\n    return ((deg + 180.) % 360.) - 180.\n\n\ndef fitSrcAngle2Dest(src, dest):\n    \"\"\"\n    given a src and destination angle, returns an equivalent src angle\n    that is within [-180..180) of dest\n    examples:\n    fitSrcAngle2Dest(30, 60) == 30\n    fitSrcAngle2Dest(60, 30) == 60\n    fitSrcAngle2Dest(0, 180) == 0\n    fitSrcAngle2Dest(-1, 180) == 359\n    fitSrcAngle2Dest(-180, 180) == 180\n    \"\"\"\n    return dest + reduceAngle(src - dest)\n\n\ndef fitDestAngle2Src(src, dest):\n    \"\"\"\n    given a src and destination angle, returns an equivalent dest angle\n    that is within [-180..180) of src\n    examples:\n    fitDestAngle2Src(30, 60) == 60\n    fitDestAngle2Src(60, 30) == 30\n    fitDestAngle2Src(0, 180) == -180\n    fitDestAngle2Src(1, 180) == 180\n    \"\"\"\n    return src + (reduceAngle(dest - src))\n\n\ndef closestDestAngle2(src, dest):\n    # The function above didn't seem to do what I wanted. So I hacked\n    # this one together. I can't really say I understand it. It's more\n    # from impirical observation... GRW\n    diff = src - dest\n    if diff > 180:\n        # if the difference is greater that 180 it's shorter to go the other way\n        return dest - 360\n    elif diff < -180:\n        # or perhaps the OTHER other way...\n        return dest + 360\n    else:\n        # otherwise just go to the original destination\n        return dest\n\n\ndef closestDestAngle(src, dest):\n    # The function above didn't seem to do what I wanted. So I hacked\n    # this one together. I can't really say I understand it. It's more\n    # from impirical observation... GRW\n    diff = src - dest\n    if diff > 180:\n        # if the difference is greater that 180 it's shorter to go the other way\n        return src - (diff - 360)\n    elif diff < -180:\n        # or perhaps the OTHER other way...\n        return src - (360 + diff)\n    else:\n        # otherwise just go to the original destination\n        return dest\n\n\nclass StdoutCapture:\n    # redirects stdout to a string\n    def __init__(self):\n        self._oldStdout = sys.stdout\n        sys.stdout = self\n        self._string = ''\n\n    def destroy(self):\n        sys.stdout = self._oldStdout\n        del self._oldStdout\n\n    def getString(self):\n        return self._string\n\n    # internal\n    def write(self, string):\n        self._string = ''.join([self._string, string])\n\n\nclass StdoutPassthrough(StdoutCapture):\n    # like StdoutCapture but also allows output to go through to the OS as normal\n\n    # internal\n    def write(self, string):\n        self._string = ''.join([self._string, string])\n        self._oldStdout.write(string)\n\n\n# constant profile defaults\nif __debug__:\n    from io import StringIO\n\n    PyUtilProfileDefaultFilename = 'profiledata'\n    PyUtilProfileDefaultLines = 80\n    PyUtilProfileDefaultSorts = ['cumulative', 'time', 'calls']\n\n    _ProfileResultStr = ''\n\n    def getProfileResultString():\n        # if you called profile with 'log' not set to True,\n        # you can call this function to get the results as\n        # a string\n        return _ProfileResultStr\n\n    def profileFunc(callback, name, terse, log=True):\n        global _ProfileResultStr\n        if 'globalProfileFunc' in builtins.__dict__:\n            # rats. Python profiler is not re-entrant...\n            base.notify.warning(\n                'PythonUtil.profileStart(%s): aborted, already profiling %s'\n                #'\\nStack Trace:\\n%s'\n                % (name, builtins.globalProfileFunc,\n                #StackTrace()\n                ))\n            return\n        builtins.globalProfileFunc = callback\n        builtins.globalProfileResult = [None]\n        prefix = '***** START PROFILE: %s *****' % name\n        if log:\n            print(prefix)\n        startProfile(cmd='globalProfileResult[0]=globalProfileFunc()', callInfo=(not terse), silent=not log)\n        suffix = '***** END PROFILE: %s *****' % name\n        if log:\n            print(suffix)\n        else:\n            _ProfileResultStr = '%s\\n%s\\n%s' % (prefix, _ProfileResultStr, suffix)\n        result = builtins.globalProfileResult[0]\n        del builtins.globalProfileFunc\n        del builtins.globalProfileResult\n        return result\n\n    def profiled(category=None, terse=False):\n        \"\"\" decorator for profiling functions\n        turn categories on and off via \"want-profile-categoryName 1\"\n\n        e.g.::\n\n            @profiled('particles')\n            def loadParticles():\n                ...\n\n        ::\n\n            want-profile-particles 1\n        \"\"\"\n        assert type(category) in (str, type(None)), \"must provide a category name for @profiled\"\n\n        # allow profiling in published versions\n        #try:\n        #    null = not __dev__\n        #except Exception:\n        #    null = not __debug__\n        #if null:\n        #    # if we're not in __dev__, just return the function itself. This\n        #    # results in zero runtime overhead, since decorators are evaluated\n        #    # at module-load.\n        #    def nullDecorator(f):\n        #        return f\n        #    return nullDecorator\n\n        def profileDecorator(f):\n            def _profiled(*args, **kArgs):\n                name = '(%s) %s from %s' % (category, f.__name__, f.__module__)\n\n                if category is None or ConfigVariableBool('want-profile-%s' % category, False).value:\n                    return profileFunc(Functor(f, *args, **kArgs), name, terse)\n                else:\n                    return f(*args, **kArgs)\n            _profiled.__doc__ = f.__doc__\n            return _profiled\n        return profileDecorator\n\n    # intercept profile-related file operations to avoid disk access\n    movedOpenFuncs: list[Callable] = []\n    movedDumpFuncs: list[Callable] = []\n    movedLoadFuncs: list[Callable] = []\n    profileFilenames = set()\n    profileFilenameList = Stack()\n    profileFilename2file = {}\n    profileFilename2marshalData = {}\n\n    def _profileOpen(filename, *args, **kArgs):\n        # this is a replacement for the file open() builtin function\n        # for use during profiling, to intercept the file open\n        # operation used by the Python profiler and profile stats\n        # systems\n        if filename in profileFilenames:\n            # if this is a file related to profiling, create an\n            # in-RAM file object\n            if filename not in profileFilename2file:\n                file = StringIO()\n                file._profFilename = filename\n                profileFilename2file[filename] = file\n            else:\n                file = profileFilename2file[filename]\n        else:\n            file = movedOpenFuncs[-1](filename, *args, **kArgs)\n        return file\n\n    def _profileMarshalDump(data, file):\n        # marshal.dump doesn't work with StringIO objects\n        # simulate it\n        if isinstance(file, StringIO) and hasattr(file, '_profFilename'):\n            if file._profFilename in profileFilenames:\n                profileFilename2marshalData[file._profFilename] = data\n                return None\n        return movedDumpFuncs[-1](data, file)\n\n    def _profileMarshalLoad(file):\n        # marshal.load doesn't work with StringIO objects\n        # simulate it\n        if isinstance(file, StringIO) and hasattr(file, '_profFilename'):\n            if file._profFilename in profileFilenames:\n                return profileFilename2marshalData[file._profFilename]\n        return movedLoadFuncs[-1](file)\n\n    def _installProfileCustomFuncs(filename):\n        assert filename not in profileFilenames\n        profileFilenames.add(filename)\n        profileFilenameList.push(filename)\n        movedOpenFuncs.append(builtins.open)\n        builtins.open = _profileOpen\n        movedDumpFuncs.append(marshal.dump)\n        marshal.dump = _profileMarshalDump\n        movedLoadFuncs.append(marshal.load)\n        marshal.load = _profileMarshalLoad\n\n    def _getProfileResultFileInfo(filename):\n        return (profileFilename2file.get(filename, None),\n                profileFilename2marshalData.get(filename, None))\n\n    def _setProfileResultsFileInfo(filename, info):\n        f, m = info\n        if f:\n            profileFilename2file[filename] = f\n        if m:\n            profileFilename2marshalData[filename] = m\n\n    def _clearProfileResultFileInfo(filename):\n        profileFilename2file.pop(filename, None)\n        profileFilename2marshalData.pop(filename, None)\n\n    def _removeProfileCustomFuncs(filename):\n        assert profileFilenameList.top() == filename\n        marshal.load = movedLoadFuncs.pop()\n        marshal.dump = movedDumpFuncs.pop()\n        builtins.open = movedOpenFuncs.pop()\n        profileFilenames.remove(filename)\n        profileFilenameList.pop()\n        profileFilename2file.pop(filename, None)\n        # don't let marshalled data pile up\n        profileFilename2marshalData.pop(filename, None)\n\n    # call this from the prompt, and break back out to the prompt\n    # to stop profiling\n    #\n    # OR to do inline profiling, you must make a globally-visible\n    # function to be profiled, i.e. to profile 'self.load()', do\n    # something like this:\n    #\n    #        def func(self=self):\n    #            self.load()\n    #        import builtins\n    #        builtins.func = func\n    #        PythonUtil.startProfile(cmd='func()', filename='profileData')\n    #        del builtins.func\n    #\n\n    def _profileWithoutGarbageLeak(cmd, filename):\n        # The profile module isn't necessarily installed on every Python\n        # installation, so we import it here, instead of in the module\n        # scope.\n        import profile\n        # this is necessary because the profile module creates a memory leak\n        Profile = profile.Profile\n        statement = cmd\n        sort = -1\n        #### COPIED FROM profile.run ####\n        prof = Profile()\n        try:\n            prof = prof.run(statement)\n        except SystemExit:\n            pass\n        if filename is not None:\n            prof.dump_stats(filename)\n        else:\n            #return prof.print_stats(sort)  #DCR\n            prof.print_stats(sort) #DCR\n        #################################\n        # eliminate the garbage leak\n        del prof.dispatcher\n\n    def startProfile(filename=PyUtilProfileDefaultFilename,\n                     lines=PyUtilProfileDefaultLines,\n                     sorts=PyUtilProfileDefaultSorts,\n                     silent=0,\n                     callInfo=1,\n                     useDisk=False,\n                     cmd='run()'):\n        # uniquify the filename to allow multiple processes to profile simultaneously\n        filename = '%s.%s%s' % (filename, randUint31(), randUint31())\n        if not useDisk:\n            # use a RAM file\n            _installProfileCustomFuncs(filename)\n        _profileWithoutGarbageLeak(cmd, filename)\n        if silent:\n            extractProfile(filename, lines, sorts, callInfo)\n        else:\n            printProfile(filename, lines, sorts, callInfo)\n        if not useDisk:\n            # discard the RAM file\n            _removeProfileCustomFuncs(filename)\n        else:\n            os.remove(filename)\n\n    # call these to see the results again, as a string or in the log\n    def printProfile(filename=PyUtilProfileDefaultFilename,\n                     lines=PyUtilProfileDefaultLines,\n                     sorts=PyUtilProfileDefaultSorts,\n                     callInfo=1):\n        import pstats\n        s = pstats.Stats(filename)\n        s.strip_dirs()\n        for sort in sorts:\n            s.sort_stats(sort)\n            s.print_stats(lines)\n            if callInfo:\n                s.print_callees(lines)\n                s.print_callers(lines)\n\n    # same args as printProfile\n    def extractProfile(*args, **kArgs):\n        global _ProfileResultStr\n        # capture print output\n        sc = StdoutCapture()\n        # print the profile output, redirected to the result string\n        printProfile(*args, **kArgs)\n        # make a copy of the print output\n        _ProfileResultStr = sc.getString()\n        # restore stdout to what it was before\n        sc.destroy()\n\n\ndef getSetterName(valueName, prefix='set'):\n    # getSetterName('color') -> 'setColor'\n    # getSetterName('color', 'get') -> 'getColor'\n    return '%s%s%s' % (prefix, valueName[0].upper(), valueName[1:])\n\n\ndef getSetter(targetObj, valueName, prefix='set'):\n    # getSetter(smiley, 'pos') -> smiley.setPos\n    return getattr(targetObj, getSetterName(valueName, prefix))\n\n\ndef mostDerivedLast(classList):\n    \"\"\"pass in list of classes. sorts list in-place, with derived classes\n    appearing after their bases\"\"\"\n\n    class ClassSortKey(object):\n        __slots__ = 'classobj',\n\n        def __init__(self, classobj):\n            self.classobj = classobj\n\n        def __lt__(self, other):\n            return issubclass(other.classobj, self.classobj)\n\n    classList.sort(key=ClassSortKey)\n\n\ndef bound(value, bound1, bound2):\n    \"\"\"\n    returns value if value is between bound1 and bound2\n    otherwise returns bound that is closer to value\n    \"\"\"\n    if bound1 > bound2:\n        return min(max(value, bound2), bound1)\n    else:\n        return min(max(value, bound1), bound2)\n\n\nclamp = bound\n\n\ndef lerp(v0, v1, t):\n    \"\"\"\n    returns a value lerped between v0 and v1, according to t\n    t == 0 maps to v0, t == 1 maps to v1\n    \"\"\"\n    return v0 + ((v1 - v0) * t)\n\n\ndef getShortestRotation(start, end):\n    \"\"\"\n    Given two heading values, return a tuple describing\n    the shortest interval from 'start' to 'end'.  This tuple\n    can be used to lerp a camera between two rotations\n    while avoiding the 'spin' problem.\n    \"\"\"\n    start, end = start % 360, end % 360\n    if abs(end - start) > 180:\n        if end < start:\n            end += 360\n        else:\n            start += 360\n    return (start, end)\n\n\ndef average(*args):\n    \"\"\" returns simple average of list of values \"\"\"\n    val = 0.\n    for arg in args:\n        val += arg\n    return val / len(args)\n\n\nclass Averager:\n    def __init__(self, name):\n        self._name = name\n        self.reset()\n\n    def reset(self):\n        self._total = 0.\n        self._count = 0\n\n    def addValue(self, value):\n        self._total += value\n        self._count += 1\n\n    def getAverage(self):\n        return self._total / self._count\n\n    def getCount(self):\n        return self._count\n\n\ndef addListsByValue(a, b):\n    \"\"\"\n    returns a new array containing the sums of the two array arguments\n    (c[0] = a[0 + b[0], etc.)\n    \"\"\"\n    c = []\n    for x, y in zip(a, b):\n        c.append(x + y)\n    return c\n\n\ndef boolEqual(a, b):\n    \"\"\"\n    returns true if a and b are both true or both false.\n    returns false otherwise\n    (a.k.a. xnor -- eXclusive Not OR).\n    \"\"\"\n    return (a and b) or not (a or b)\n\n\ndef lineupPos(i, num, spacing):\n    \"\"\"\n    use to line up a series of 'num' objects, in one dimension,\n    centered around zero\n    'i' is the index of the object in the lineup\n    'spacing' is the amount of space between objects in the lineup\n    \"\"\"\n    assert num >= 1\n    assert i >= 0 and i < num\n    pos = float(i) * spacing\n    return pos - ((float(spacing) * (num-1))/2.)\n\n\ndef formatElapsedSeconds(seconds):\n    \"\"\"\n    Returns a string of the form \"mm:ss\" or \"hh:mm:ss\" or \"n days\",\n    representing the indicated elapsed time in seconds.\n    \"\"\"\n    sign = ''\n    if seconds < 0:\n        seconds = -seconds\n        sign = '-'\n\n    # We use math.floor() instead of casting to an int, so we avoid\n    # problems with numbers that are too large to represent as\n    # type int.\n    seconds = math.floor(seconds)\n    hours = math.floor(seconds / (60 * 60))\n    if hours > 36:\n        days = math.floor((hours + 12) / 24)\n        return \"%s%d days\" % (sign, days)\n\n    seconds -= hours * (60 * 60)\n    minutes = (int)(seconds / 60)\n    seconds -= minutes * 60\n    if hours != 0:\n        return \"%s%d:%02d:%02d\" % (sign, hours, minutes, seconds)\n    else:\n        return \"%s%d:%02d\" % (sign, minutes, seconds)\n\n\ndef solveQuadratic(a, b, c):\n    # quadratic equation: ax^2 + bx + c = 0\n    # quadratic formula:  x = [-b +/- sqrt(b^2 - 4ac)] / 2a\n    # returns None, root, or [root1, root2]\n\n    # a cannot be zero.\n    if a == 0.:\n        return None\n\n    # calculate the determinant (b^2 - 4ac)\n    D = (b * b) - (4. * a * c)\n\n    if D < 0:\n        # there are no solutions (sqrt(negative number) is undefined)\n        return None\n    elif D == 0:\n        # only one root\n        return (-b) / (2. * a)\n    else:\n        # OK, there are two roots\n        sqrtD = math.sqrt(D)\n        twoA = 2. * a\n        root1 = ((-b) - sqrtD) / twoA\n        root2 = ((-b) + sqrtD) / twoA\n        return [root1, root2]\n\n\nif __debug__:\n    def stackEntryInfo(depth=0, baseFileName=1):\n        \"\"\"\n        returns the sourcefilename, line number, and function name of\n        an entry in the stack.\n        'depth' is how far back to go in the stack; 0 is the caller of this\n        function, 1 is the function that called the caller of this function, etc.\n        by default, strips off the path of the filename; override with baseFileName\n        returns (fileName, lineNum, funcName) --> (string, int, string)\n        returns (None, None, None) on error\n        \"\"\"\n        import inspect\n\n        try:\n            stack = None\n            frame = None\n            try:\n                stack = inspect.stack()\n                # add one to skip the frame associated with this function\n                frame = stack[depth+1]\n                filename = frame[1]\n                if baseFileName:\n                    filename = os.path.basename(filename)\n                lineNum = frame[2]\n                funcName = frame[3]\n                result = (filename, lineNum, funcName)\n            finally:\n                del stack\n                del frame\n        except Exception:\n            result = (None, None, None)\n\n        return result\n\n    def lineInfo(baseFileName=1):\n        \"\"\"\n        returns the sourcefilename, line number, and function name of the\n        code that called this function\n        (answers the question: 'hey lineInfo, where am I in the codebase?')\n        see stackEntryInfo, above, for info on 'baseFileName' and return types\n        \"\"\"\n        return stackEntryInfo(1, baseFileName)\n\n    def callerInfo(baseFileName=1, howFarBack=0):\n        \"\"\"\n        returns the sourcefilename, line number, and function name of the\n        caller of the function that called this function\n        (answers the question: 'hey callerInfo, who called me?')\n        see stackEntryInfo, above, for info on 'baseFileName' and return types\n        \"\"\"\n        return stackEntryInfo(2+howFarBack, baseFileName)\n\n    def lineTag(baseFileName=1, verbose=0, separator=':'):\n        \"\"\"\n        returns a string containing the sourcefilename and line number\n        of the code that called this function\n        (equivalent to lineInfo, above, with different return type)\n        see stackEntryInfo, above, for info on 'baseFileName'\n\n        if 'verbose' is false, returns a compact string of the form\n        'fileName:lineNum:funcName'\n        if 'verbose' is true, returns a longer string that matches the\n        format of Python stack trace dumps\n\n        returns empty string on error\n        \"\"\"\n        fileName, lineNum, funcName = callerInfo(baseFileName)\n        if fileName is None:\n            return ''\n        if verbose:\n            return 'File \"%s\", line %s, in %s' % (fileName, lineNum, funcName)\n        else:\n            return '%s%s%s%s%s' % (fileName, separator, lineNum, separator,\n                                   funcName)\n\n\ndef findPythonModule(module):\n    # Look along the python load path for the indicated filename.\n    # Returns the located pathname, or None if the filename is not\n    # found.\n    filename = module + '.py'\n    for dir in sys.path:\n        pathname = os.path.join(dir, filename)\n        if os.path.exists(pathname):\n            return pathname\n\n    return None\n\n\ndef clampScalar(value, a, b):\n    # calling this ought to be faster than calling both min and max\n    if a < b:\n        if value < a:\n            return a\n        elif value > b:\n            return b\n        else:\n            return value\n    else:\n        if value < b:\n            return b\n        elif value > a:\n            return a\n        else:\n            return value\n\n\ndef weightedChoice(choiceList, rng=random.random, sum=None):\n    \"\"\"given a list of (weight, item) pairs, chooses an item based on the\n    weights. rng must return 0..1. if you happen to have the sum of the\n    weights, pass it in 'sum'.\"\"\"\n    # Throw an IndexError if we got an empty list.\n    if not choiceList:\n        raise IndexError('Cannot choose from an empty sequence')\n\n    # TODO: add support for dicts\n    if sum is None:\n        sum = 0.\n        for weight, item in choiceList:\n            sum += weight\n\n    rand = rng()\n    accum = rand * sum\n    item = None\n    for weight, item in choiceList:\n        accum -= weight\n        if accum <= 0.:\n            return item\n    # rand is ~1., and floating-point error prevented accum from hitting 0.\n    # Or you passed in a 'sum' that was was too large.\n    # Return the last item.\n    return item\n\n\ndef randFloat(a, b=0., rng=random.random):\n    \"\"\"returns a random float in [a, b]\n    call with single argument to generate random float between arg and zero\n    \"\"\"\n    return lerp(a, b, rng())\n\n\ndef normalDistrib(a, b, gauss=random.gauss):\n    \"\"\"\n    NOTE: assumes a < b\n\n    Returns random number between a and b, using gaussian distribution, with\n    mean=avg(a, b), and a standard deviation that fits ~99.7% of the curve\n    between a and b.\n\n    For ease of use, outlying results are re-computed until result is in [a, b]\n    This should fit the remaining .3% of the curve that lies outside [a, b]\n    uniformly onto the curve inside [a, b]\n\n    ------------------------------------------------------------------------\n    The 68-95-99.7% Rule\n    ====================\n    All normal density curves satisfy the following property which is often\n      referred to as the Empirical Rule:\n    68% of the observations fall within 1 standard deviation of the mean.\n    95% of the observations fall within 2 standard deviations of the mean.\n    99.7% of the observations fall within 3 standard deviations of the mean.\n\n    Thus, for a normal distribution, almost all values lie within 3 standard\n      deviations of the mean.\n    ------------------------------------------------------------------------\n\n    In calculating our standard deviation, we divide (b-a) by 6, since the\n    99.7% figure includes 3 standard deviations _on_either_side_ of the mean.\n    \"\"\"\n    while True:\n        r = gauss((a+b)*.5, (b-a)/6.)\n        if (r >= a) and (r <= b):\n            return r\n\n\ndef weightedRand(valDict, rng=random.random):\n    \"\"\"\n    pass in a dictionary with a selection -> weight mapping.  E.g.::\n\n        {\"Choice 1\": 10,\n         \"Choice 2\": 30,\n         \"bear\":     100}\n\n    - Weights need not add up to any particular value.\n    - The actual selection will be returned.\n    \"\"\"\n    selections = list(valDict.keys())\n    weights = list(valDict.values())\n\n    totalWeight = 0\n    for weight in weights:\n        totalWeight += weight\n\n    # get a random value between 0 and the total of the weights\n    randomWeight = rng() * totalWeight\n\n    # find the index that corresponds with this weight\n    for i in range(len(weights)):\n        totalWeight -= weights[i]\n        if totalWeight <= randomWeight:\n            return selections[i]\n\n    assert True, \"Should never get here\"\n    return selections[-1]\n\n\ndef randUint31(rng=random.random):\n    \"\"\"returns a random integer in [0..2^31).\n    rng must return float in [0..1]\"\"\"\n    return int(rng() * 0x7FFFFFFF)\n\n\ndef randInt32(rng=random.random):\n    \"\"\"returns a random integer in [-2147483648..2147483647].\n    rng must return float in [0..1]\n    \"\"\"\n    i = int(rng() * 0x7FFFFFFF)\n    if rng() < .5:\n        i *= -1\n    return i\n\n\nclass SerialNumGen:\n    \"\"\"generates serial numbers\"\"\"\n\n    def __init__(self, start=None):\n        if start is None:\n            start = 0\n        self.__counter = start-1\n\n    def next(self):\n        self.__counter += 1\n        return self.__counter\n\n    __next__ = next\n\n\nclass SerialMaskedGen(SerialNumGen):\n    def __init__(self, mask, start=None):\n        self._mask = mask\n        SerialNumGen.__init__(self, start)\n\n    def next(self):\n        v = SerialNumGen.next(self)\n        return v & self._mask\n\n    __next__ = next\n\n\n_serialGen = SerialNumGen()\n\n\ndef serialNum():\n    return _serialGen.next()\n\n\ndef uniqueName(name):\n    return f'{name}-{serialNum()}'\n\n\n############################################################\n# class: Singleton\n# Purpose: This provides a base metaclass for all classes\n#          that require one and only one instance.\n#\n# Example: class mySingleton:\n#              __metaclass__ = PythonUtil.Singleton\n#              def __init__(self, ...):\n#                  ...\n#\n# Note: This class is based on Python's New-Style Class\n#       design. An error will occur if a defined class\n#       attemps to inherit from a Classic-Style Class only,\n#       ie: class myClassX:\n#               def __init__(self, ...):\n#                   ...\n#\n#           class myNewClassX(myClassX):\n#               __metaclass__ = PythonUtil.Singleton\n#               def __init__(self, ...):\n#                   myClassX.__init__(self, ...)\n#                   ...\n#\n#           This causes problems because myNewClassX is a\n#           New-Style class that inherits from only a\n#           Classic-Style base class. There are two ways\n#           simple ways to resolve this issue.\n#\n#           First, if possible, make myClassX a\n#           New-Style class by inheriting from object\n#           object. IE:  class myClassX(object):\n#\n#           If for some reason that is not an option, make\n#           myNewClassX inherit from object and myClassX.\n#           IE: class myNewClassX(object, myClassX):\n############################################################\nclass Singleton(type):\n    def __init__(cls, name, bases, dic):\n        super(Singleton, cls).__init__(name, bases, dic)\n        cls.instance=None\n\n    def __call__(cls, *args, **kw):\n        if cls.instance is None:\n            cls.instance=super(Singleton, cls).__call__(*args, **kw)\n        return cls.instance\n\n\nclass SingletonError(ValueError):\n    \"\"\" Used to indicate an inappropriate value for a Singleton.\"\"\"\n\n\ndef printListEnumGen(l):\n    # log each individual item with a number in front of it\n    digits = 0\n    n = len(l)\n    while n > 0:\n        digits += 1\n        n //= 10\n    format = '%0' + '%s' % digits + 'i:%s'\n    for i in range(len(l)):\n        print(format % (i, l[i]))\n        yield None\n\n\ndef printListEnum(l):\n    for result in printListEnumGen(l):\n        pass\n\n\n# base class for all Panda C++ objects\n# libdtoolconfig doesn't seem to have this, grab it off of TypedObject\ndtoolSuperBase = None\n\n\ndef _getDtoolSuperBase():\n    global dtoolSuperBase\n    from panda3d.core import TypedObject\n    dtoolSuperBase = TypedObject.__bases__[0]\n    assert dtoolSuperBase.__name__ == 'DTOOL_SUPER_BASE'\n\n\nsafeReprNotify = None\n\n\ndef _getSafeReprNotify():\n    global safeReprNotify\n    from direct.directnotify.DirectNotifyGlobal import directNotify\n    safeReprNotify = directNotify.newCategory(\"safeRepr\")\n    return safeReprNotify\n\n\ndef safeRepr(obj):\n    global dtoolSuperBase\n    if dtoolSuperBase is None:\n        _getDtoolSuperBase()\n\n    global safeReprNotify\n    if safeReprNotify is None:\n        _getSafeReprNotify()\n\n    if isinstance(obj, dtoolSuperBase):\n        # repr of C++ object could crash, particularly if the object has been deleted\n        # log that we're calling repr\n        safeReprNotify.info('calling repr on instance of %s.%s' % (obj.__class__.__module__, obj.__class__.__name__))\n        sys.stdout.flush()\n\n    try:\n        return repr(obj)\n    except Exception:\n        return '<** FAILED REPR OF %s instance at %s **>' % (obj.__class__.__name__, hex(id(obj)))\n\n\ndef safeReprTypeOnFail(obj):\n    global dtoolSuperBase\n    if dtoolSuperBase is None:\n        _getDtoolSuperBase()\n\n    global safeReprNotify\n    if safeReprNotify is None:\n        _getSafeReprNotify()\n\n    if isinstance(obj, dtoolSuperBase):\n        return type(obj)\n\n    try:\n        return repr(obj)\n    except Exception:\n        return '<** FAILED REPR OF %s instance at %s **>' % (obj.__class__.__name__, hex(id(obj)))\n\n\ndef fastRepr(obj, maxLen=200, strFactor=10, _visitedIds=None):\n    \"\"\" caps the length of iterable types, so very large objects will print faster.\n    also prevents infinite recursion \"\"\"\n    try:\n        if _visitedIds is None:\n            _visitedIds = set()\n        if id(obj) in _visitedIds:\n            return '<ALREADY-VISITED %s>' % itype(obj)\n        if type(obj) in (tuple, list):\n            s = ''\n            s += {tuple: '(',\n                  list:  '[',}[type(obj)]\n            if maxLen is not None and len(obj) > maxLen:\n                o = obj[:maxLen]\n                ellips = '...'\n            else:\n                o = obj\n                ellips = ''\n            _visitedIds.add(id(obj))\n            for item in o:\n                s += fastRepr(item, maxLen, _visitedIds=_visitedIds)\n                s += ', '\n            _visitedIds.remove(id(obj))\n            s += ellips\n            s += {tuple: ')',\n                  list:  ']',}[type(obj)]\n            return s\n        elif type(obj) is dict:\n            s = '{'\n            if maxLen is not None and len(obj) > maxLen:\n                o = list(obj.keys())[:maxLen]\n                ellips = '...'\n            else:\n                o = list(obj.keys())\n                ellips = ''\n            _visitedIds.add(id(obj))\n            for key in o:\n                value = obj[key]\n                s += '%s: %s, ' % (fastRepr(key, maxLen, _visitedIds=_visitedIds),\n                                   fastRepr(value, maxLen, _visitedIds=_visitedIds))\n            _visitedIds.remove(id(obj))\n            s += ellips\n            s += '}'\n            return s\n        elif type(obj) is str:\n            if maxLen is not None:\n                maxLen *= strFactor\n            if maxLen is not None and len(obj) > maxLen:\n                return safeRepr(obj[:maxLen])\n            else:\n                return safeRepr(obj)\n        else:\n            r = safeRepr(obj)\n            maxLen *= strFactor\n            if len(r) > maxLen:\n                r = r[:maxLen]\n            return r\n    except Exception:\n        return '<** FAILED REPR OF %s **>' % obj.__class__.__name__\n\n\ndef convertTree(objTree, idList):\n    newTree = {}\n    for key in list(objTree.keys()):\n        obj = (idList[key],)\n        newTree[obj] = {}\n        r_convertTree(objTree[key], newTree[obj], idList)\n    return newTree\n\n\ndef r_convertTree(oldTree, newTree, idList):\n    for key in list(oldTree.keys()):\n        obj = idList.get(key)\n        if not obj:\n            continue\n        obj = str(obj)[:100]\n\n        newTree[obj] = {}\n        r_convertTree(oldTree[key], newTree[obj], idList)\n\n\ndef pretty_print(tree):\n    for name in tree.keys():\n        print(name)\n        r_pretty_print(tree[name], 0)\n\n\ndef r_pretty_print(tree, num):\n    num += 1\n    for name in tree.keys():\n        print(\"  \" * num, name)\n        r_pretty_print(tree[name], num)\n\n\ndef isDefaultValue(x):\n    return x == type(x)()\n\n\ndef appendStr(obj, st):\n    \"\"\"adds a string onto the __str__ output of an instance\"\"\"\n    def appendedStr(oldStr, st, self):\n        return oldStr() + st\n    oldStr = getattr(obj, '__str__', None)\n    if oldStr is None:\n        def stringer(s):\n            return s\n        oldStr = Functor(stringer, str(obj))\n        stringer = None\n    obj.__str__ = types.MethodType(Functor(appendedStr, oldStr, st), obj)\n    appendedStr = None\n    return obj\n\n\nclass ScratchPad:\n    \"\"\"empty class to stick values onto\"\"\"\n\n    def __init__(self, **kArgs):\n        for key, value in kArgs.items():\n            setattr(self, key, value)\n        self._keys = set(kArgs.keys())\n\n    def add(self, **kArgs):\n        for key, value in kArgs.items():\n            setattr(self, key, value)\n        self._keys.update(list(kArgs.keys()))\n\n    def destroy(self):\n        for key in self._keys:\n            delattr(self, key)\n\n    # allow dict [] syntax\n    def __getitem__(self, itemName):\n        return getattr(self, itemName)\n\n    def get(self, itemName, default=None):\n        return getattr(self, itemName, default)\n    # allow 'in'\n\n    def __contains__(self, itemName):\n        return itemName in self._keys\n\n\nclass Sync:\n    _SeriesGen = SerialNumGen()\n\n    def __init__(self, name, other=None):\n        self._name = name\n        if other is None:\n            self._series = self._SeriesGen.next()\n            self._value = 0\n        else:\n            self._series = other._series\n            self._value = other._value\n\n    def invalidate(self):\n        self._value = None\n\n    def change(self):\n        self._value += 1\n\n    def sync(self, other):\n        if (self._series != other._series) or (self._value != other._value):\n            self._series = other._series\n            self._value = other._value\n            return True\n        else:\n            return False\n\n    def isSynced(self, other):\n        return ((self._series == other._series) and\n                (self._value == other._value))\n\n    def __repr__(self):\n        return '%s(%s)<family=%s,value=%s>' % (self.__class__.__name__,\n                              self._name, self._series, self._value)\n\n\ndef itype(obj):\n    # version of type that gives more complete information about instance types\n    global dtoolSuperBase\n    t = type(obj)\n    # C++ object instances appear to be types via type()\n    # check if this is a C++ object\n    if dtoolSuperBase is None:\n        _getDtoolSuperBase()\n    if isinstance(obj, dtoolSuperBase):\n        return \"<type 'instance' of %s>\" % (obj.__class__)\n    return t\n\n\ndef deeptype(obj, maxLen=100, _visitedIds=None):\n    if _visitedIds is None:\n        _visitedIds = set()\n    if id(obj) in _visitedIds:\n        return '<ALREADY-VISITED %s>' % itype(obj)\n    t = type(obj)\n    if t in (tuple, list):\n        s = ''\n        s += {tuple: '(',\n              list:  '[',}[type(obj)]\n        if maxLen is not None and len(obj) > maxLen:\n            o = obj[:maxLen]\n            ellips = '...'\n        else:\n            o = obj\n            ellips = ''\n        _visitedIds.add(id(obj))\n        for item in o:\n            s += deeptype(item, maxLen, _visitedIds=_visitedIds)\n            s += ', '\n        _visitedIds.remove(id(obj))\n        s += ellips\n        s += {tuple: ')',\n              list:  ']',}[type(obj)]\n        return s\n    elif type(obj) is dict:\n        s = '{'\n        if maxLen is not None and len(obj) > maxLen:\n            o = list(obj.keys())[:maxLen]\n            ellips = '...'\n        else:\n            o = list(obj.keys())\n            ellips = ''\n        _visitedIds.add(id(obj))\n        for key in o:\n            value = obj[key]\n            s += '%s: %s, ' % (deeptype(key, maxLen, _visitedIds=_visitedIds),\n                               deeptype(value, maxLen, _visitedIds=_visitedIds))\n        _visitedIds.remove(id(obj))\n        s += ellips\n        s += '}'\n        return s\n    else:\n        return str(itype(obj))\n\n\ndef getNumberedTypedString(items, maxLen=5000, numPrefix=''):\n    \"\"\"get a string that has each item of the list on its own line,\n    and each item is numbered on the left from zero\"\"\"\n    digits = 0\n    n = len(items)\n    while n > 0:\n        digits += 1\n        n //= 10\n    format = numPrefix + '%0' + '%s' % digits + 'i:%s \\t%s'\n    first = True\n    s = ''\n    snip = '<SNIP>'\n    for i in range(len(items)):\n        if not first:\n            s += '\\n'\n        first = False\n        objStr = fastRepr(items[i])\n        if len(objStr) > maxLen:\n            objStr = '%s%s' % (objStr[:(maxLen-len(snip))], snip)\n        s += format % (i, itype(items[i]), objStr)\n    return s\n\n\ndef getNumberedTypedSortedString(items, maxLen=5000, numPrefix=''):\n    \"\"\"get a string that has each item of the list on its own line,\n    the items are stringwise-sorted, and each item is numbered on\n    the left from zero\"\"\"\n    digits = 0\n    n = len(items)\n    while n > 0:\n        digits += 1\n        n //= 10\n    format = numPrefix + '%0' + '%s' % digits + 'i:%s \\t%s'\n    snip = '<SNIP>'\n    strs = []\n    for item in items:\n        objStr = fastRepr(item)\n        if len(objStr) > maxLen:\n            objStr = '%s%s' % (objStr[:(maxLen-len(snip))], snip)\n        strs.append(objStr)\n    first = True\n    s = ''\n    strs.sort()\n    for i in range(len(strs)):\n        if not first:\n            s += '\\n'\n        first = False\n        objStr = strs[i]\n        s += format % (i, itype(items[i]), strs[i])\n    return s\n\n\ndef printNumberedTyped(items, maxLen=5000):\n    \"\"\"print out each item of the list on its own line,\n    with each item numbered on the left from zero\"\"\"\n    digits = 0\n    n = len(items)\n    while n > 0:\n        digits += 1\n        n //= 10\n    format = '%0' + '%s' % digits + 'i:%s \\t%s'\n    for i in range(len(items)):\n        objStr = fastRepr(items[i])\n        if len(objStr) > maxLen:\n            snip = '<SNIP>'\n            objStr = '%s%s' % (objStr[:(maxLen-len(snip))], snip)\n        print(format % (i, itype(items[i]), objStr))\n\n\ndef printNumberedTypesGen(items, maxLen=5000):\n    digits = 0\n    n = len(items)\n    while n > 0:\n        digits += 1\n        n //= 10\n    format = '%0' + '%s' % digits + 'i:%s'\n    for i in range(len(items)):\n        print(format % (i, itype(items[i])))\n        yield None\n\n\ndef printNumberedTypes(items, maxLen=5000):\n    \"\"\"print out the type of each item of the list on its own line,\n    with each item numbered on the left from zero\"\"\"\n    for result in printNumberedTypesGen(items, maxLen):\n        yield result\n\n\nclass DelayedCall:\n    \"\"\" calls a func after a specified delay \"\"\"\n\n    def __init__(self, func, name=None, delay=None):\n        if name is None:\n            name = 'anonymous'\n        if delay is None:\n            delay = .01\n        self._func = func\n        self._taskName = 'DelayedCallback-%s' % name\n        self._delay = delay\n        self._finished = False\n        self._addDoLater()\n\n    def destroy(self):\n        self._finished = True\n        self._removeDoLater()\n\n    def finish(self):\n        if not self._finished:\n            self._doCallback(None)\n        self.destroy()\n\n    def _addDoLater(self):\n        taskMgr.doMethodLater(self._delay, self._doCallback, self._taskName)\n\n    def _removeDoLater(self):\n        taskMgr.remove(self._taskName)\n\n    def _doCallback(self, task):\n        self._finished = True\n        func = self._func\n        del self._func\n        func()\n\n\nclass FrameDelayedCall:\n    \"\"\" calls a func after N frames \"\"\"\n\n    def __init__(self, name, callback, frames=None, cancelFunc=None):\n        # checkFunc is optional; called every frame, if returns True, FrameDelay is cancelled\n        # and callback is not called\n        if frames is None:\n            frames = 1\n        self._name = name\n        self._frames = frames\n        self._callback = callback\n        self._cancelFunc = cancelFunc\n        self._taskName = uniqueName('%s-%s' % (self.__class__.__name__, self._name))\n        self._finished = False\n        self._startTask()\n\n    def destroy(self):\n        self._finished = True\n        self._stopTask()\n\n    def finish(self):\n        if not self._finished:\n            self._finished = True\n            self._callback()\n        self.destroy()\n\n    def _startTask(self):\n        taskMgr.add(self._frameTask, self._taskName)\n        self._counter = 0\n\n    def _stopTask(self):\n        taskMgr.remove(self._taskName)\n\n    def _frameTask(self, task):\n        if self._cancelFunc and self._cancelFunc():\n            self.destroy()\n            return task.done\n        self._counter += 1\n        if self._counter >= self._frames:\n            self.finish()\n            return task.done\n        return task.cont\n\n\nclass DelayedFunctor:\n    \"\"\" Waits for this object to be called, then calls supplied functor after a delay.\n    Effectively inserts a time delay between the caller and the functor. \"\"\"\n\n    def __init__(self, functor, name=None, delay=None):\n        self._functor = functor\n        self._name = name\n        # FunctionInterval requires __name__\n        self.__name__ = self._name\n        self._delay = delay\n\n    def _callFunctor(self):\n        cb = Functor(self._functor, *self._args, **self._kwArgs)\n        del self._functor\n        del self._name\n        del self._delay\n        del self._args\n        del self._kwArgs\n        del self._delayedCall\n        del self.__name__\n        cb()\n\n    def __call__(self, *args, **kwArgs):\n        self._args = args\n        self._kwArgs = kwArgs\n        self._delayedCall = DelayedCall(self._callFunctor, self._name, self._delay)\n\n\nclass SubframeCall:\n    \"\"\"Calls a callback at a specific time during the frame using the\n    task system\"\"\"\n\n    def __init__(self, functor, taskPriority, name=None):\n        self._functor = functor\n        self._name = name\n        self._taskName = uniqueName('SubframeCall-%s' % self._name)\n        taskMgr.add(self._doCallback,\n                    self._taskName,\n                    priority=taskPriority)\n\n    def _doCallback(self, task):\n        functor = self._functor\n        del self._functor\n        functor()\n        del self._name\n        self._taskName = None\n        return task.done\n\n    def cleanup(self):\n        if self._taskName:\n            taskMgr.remove(self._taskName)\n            self._taskName = None\n\n\nclass PStatScope:\n    collectors: dict = {}\n\n    def __init__(self, level = None):\n        self.levels = []\n        if level:\n            self.levels.append(level)\n\n    def copy(self, push = None):\n        c = PStatScope()\n        c.levels = self.levels[:]\n        if push:\n            c.push(push)\n        return c\n\n    def __repr__(self):\n        return 'PStatScope - \\'%s\\'' % (self,)\n\n    def __str__(self):\n        return ':'.join(self.levels)\n\n    def push(self, level):\n        self.levels.append(level.replace('_',''))\n\n    def pop(self):\n        return self.levels.pop()\n\n    def start(self, push = None):\n        if push:\n            self.push(push)\n        self.getCollector().start()\n\n    def stop(self, pop = False):\n        self.getCollector().stop()\n        if pop:\n            self.pop()\n\n    def getCollector(self):\n        label = str(self)\n        if label not in self.collectors:\n            from panda3d.core import PStatCollector\n            self.collectors[label] = PStatCollector(label)\n        # print '  ',self.collectors[label]\n        return self.collectors[label]\n\n\ndef pstatcollect(scope, level = None):\n    def decorator(f):\n        return f\n\n    try:\n        if not (__dev__ or ConfigVariableBool('force-pstatcollect', False)) or \\\n           not scope:\n            return decorator\n\n        def decorator(f):\n            def wrap(*args, **kw):\n                scope.start(push = (level or f.__name__))\n                val = f(*args, **kw)\n                scope.stop(pop = True)\n                return val\n            return wrap\n    except Exception:\n        pass\n\n    return decorator\n\n\n__report_indent = 0\n\n\ndef report(types = [], prefix = '', xform = None, notifyFunc = None, dConfigParam = []):\n    \"\"\"\n    This is a decorator generating function.  Use is similar to\n    a @decorator, except you must be sure to call it as a function.\n    It actually returns the decorator which is then used to transform\n    your decorated function. Confusing at first, I know.\n\n    Decoration occurs at function definition time.\n\n    If __dev__ is not defined, or resolves to False, this function\n    has no effect and no wrapping/transform occurs.  So in production,\n    it's as if the report has been asserted out.\n\n    Parameters:\n        types: A subset list of ['timeStamp', 'frameCount', 'avLocation']\n            This allows you to specify certain useful bits of info:\n\n              - *module*: Prints the module that this report statement\n                can be found in.\n              - *args*: Prints the arguments as they were passed to this\n                function.\n              - *timeStamp*: Adds the current frame time to the output.\n              - *deltaStamp*: Adds the current AI synched frame time to\n                the output\n              - *frameCount*: Adds the current frame count to the output.\n                Usually cleaner than the timeStamp output.\n              - *avLocation*: Adds the localAvatar's network location to\n                the output.  Useful for interest debugging.\n              - *interests*: Prints the current interest state after the\n                report.\n              - *stackTrace*: Prints a stack trace after the report.\n\n        prefix: Optional string to prepend to output, just before the\n            function.  Allows for easy grepping and is useful when\n            merging AI/Client reports into a single file.\n\n        xform:  Optional callback that accepts a single parameter:\n            argument 0 to the decorated function. (assumed to be 'self')\n            It should return a value to be inserted into the report\n            output string.\n\n        notifyFunc: A notify function such as info, debug, warning, etc.\n            By default the report will be printed to stdout. This will\n            allow you send the report to a designated 'notify' output.\n\n        dConfigParam: A list of Config.prc string variables.\n            By default the report will always print.  If you specify\n            this param, it will only print if one of the specified\n            config strings resolve to True.\n    \"\"\"\n\n    def indent(str):\n        global __report_indent\n        return ' '*__report_indent+str\n\n    def decorator(f):\n        return f\n\n    try:\n        if not __dev__ and not ConfigVariableBool('force-reports', False):\n            return decorator\n\n        # determine whether we should use the decorator\n        # based on the value of dConfigParam.\n        dConfigParamList = []\n        doPrint = False\n        if not dConfigParam:\n            doPrint = True\n        else:\n            if not isinstance(dConfigParam, (list,tuple)):\n                dConfigParams = (dConfigParam,)\n            else:\n                dConfigParams = dConfigParam\n\n            dConfigParamList = [param for param in dConfigParams \\\n                                if ConfigVariableBool('want-%s-report' % (param,), False)]\n\n            doPrint = bool(dConfigParamList)\n\n        if not doPrint:\n            return decorator\n\n        # Determine any prefixes defined in our Config.prc.\n        if prefix:\n            prefixes = set([prefix])\n        else:\n            prefixes = set()\n\n        for param in dConfigParamList:\n            prefix = ConfigVariableString(f\"prefix-{param}-report\", \"\", \"DConfig\", ConfigFlags.F_dconfig).value\n            if prefix:\n                prefixes.add(prefix)\n\n    except NameError as e:\n        return decorator\n\n    globalClockDelta = importlib.import_module(\"direct.distributed.ClockDelta\").globalClockDelta\n\n    def decorator(f):\n        def wrap(*args, **kwargs):\n            if args:\n                rArgs = [args[0].__class__.__name__ + ', ']\n            else:\n                rArgs = []\n\n            if 'args' in types:\n                rArgs += [repr(x) + ', ' for x in args[1:]] + \\\n                         [x + ' = ' + '%s, ' % repr(y) for x, y in kwargs.items()]\n\n            if not rArgs:\n                rArgs = '()'\n            else:\n                rArgs = '(' + functools.reduce(str.__add__, rArgs)[:-2] + ')'\n\n            outStr = '%s%s' % (f.__name__, rArgs)\n\n            # Insert prefix place holder, if needed\n            if prefixes:\n                outStr = '%%s %s' % (outStr,)\n\n            globalClock = ClockObject.getGlobalClock()\n\n            if 'module' in types:\n                outStr = '%s {M:%s}' % (outStr, f.__module__.split('.')[-1])\n\n            if 'frameCount' in types:\n                outStr = '%-8d : %s' % (globalClock.getFrameCount(), outStr)\n\n            if 'timeStamp' in types:\n                outStr = '%-8.3f : %s' % (globalClock.getFrameTime(), outStr)\n\n            if 'deltaStamp' in types:\n                outStr = '%-8.2f : %s' % (globalClock.getRealTime() - \\\n                                         globalClockDelta.delta, outStr)\n            if 'avLocation' in types:\n                outStr = '%s : %s' % (outStr, str(localAvatar.getLocation()))\n\n            if xform:\n                outStr = '%s : %s' % (outStr, xform(args[0]))\n\n            if prefixes:\n                # This will print the same report once for each prefix\n                for prefix in prefixes:\n                    if notifyFunc:\n                        notifyFunc(outStr % (prefix,))\n                    else:\n                        print(indent(outStr % (prefix,)))\n            else:\n                if notifyFunc:\n                    notifyFunc(outStr)\n                else:\n                    print(indent(outStr))\n\n            if 'interests' in types:\n                base.cr.printInterestSets()\n\n            if 'stackTrace' in types:\n                print(StackTrace())\n\n            global __report_indent\n            rVal = None\n            try:\n                __report_indent += 1\n                rVal = f(*args, **kwargs)\n            finally:\n                __report_indent -= 1\n                if rVal is not None:\n                    print(indent(' -> ' + repr(rVal)))\n            return rVal\n\n        wrap.__name__ = f.__name__\n        wrap.__dict__ = f.__dict__\n        wrap.__doc__ = f.__doc__\n        wrap.__module__ = f.__module__\n        return wrap\n    return decorator\n\n\ndef getBase():\n    try:\n        return base\n    except Exception:\n        return simbase\n\n\ndef getRepository():\n    try:\n        return base.cr\n    except Exception:\n        return simbase.air\n\n\nexceptionLoggedNotify = None\nif __debug__:\n    def exceptionLogged(append=True):\n        \"\"\"decorator that outputs the function name and all arguments\n        if an exception passes back through the stack frame\n        if append is true, string is appended to the __str__ output of\n        the exception. if append is false, string is printed to the log\n        directly. If the output will take up many lines, it's recommended\n        to set append to False so that the exception stack is not hidden\n        by the output of this decorator.\n        \"\"\"\n        try:\n            null = not __dev__\n        except Exception:\n            null = not __debug__\n        if null:\n            # if we're not in __dev__, just return the function itself. This\n            # results in zero runtime overhead, since decorators are evaluated\n            # at module-load.\n            def nullDecorator(f):\n                return f\n            return nullDecorator\n\n        def _decoratorFunc(f, append=append):\n            global exceptionLoggedNotify\n            if exceptionLoggedNotify is None:\n                from direct.directnotify.DirectNotifyGlobal import directNotify\n                exceptionLoggedNotify = directNotify.newCategory(\"ExceptionLogged\")\n\n            def _exceptionLogged(*args, **kArgs):\n                try:\n                    return f(*args, **kArgs)\n                except Exception as e:\n                    try:\n                        s = '%s(' % f.__name__\n                        for arg in args:\n                            s += '%s, ' % arg\n                        for key, value in list(kArgs.items()):\n                            s += '%s=%s, ' % (key, value)\n                        if len(args) > 0 or len(kArgs) > 0:\n                            s = s[:-2]\n                        s += ')'\n                        if append:\n                            appendStr(e, '\\n%s' % s)\n                        else:\n                            exceptionLoggedNotify.info(s)\n                    except Exception:\n                        exceptionLoggedNotify.info(\n                            '%s: ERROR IN PRINTING' % f.__name__)\n                    raise\n            _exceptionLogged.__doc__ = f.__doc__\n            return _exceptionLogged\n        return _decoratorFunc\n\n# http://en.wikipedia.org/wiki/Golden_ratio\nGoldenRatio = (1. + math.sqrt(5.)) / 2.\n\n\nclass GoldenRectangle:\n    @staticmethod\n    def getLongerEdge(shorter):\n        return shorter * GoldenRatio\n\n    @staticmethod\n    def getShorterEdge(longer):\n        return longer / GoldenRatio\n\n\ndef nullGen():\n    # generator that ends immediately\n    if False:\n        # yield that never runs but still exists, making this func a generator\n        yield None\n\n\ndef loopGen(l):\n    # generator that yields the items of an iterable object forever\n    def _gen(l):\n        while True:\n            for item in l:\n                yield item\n    gen = _gen(l)\n    # don't leak\n    _gen = None\n    return gen\n\n\ndef makeFlywheelGen(objects, countList=None, countFunc=None, scale=None):\n    # iterates and finally yields a flywheel generator object\n    # the number of appearances for each object is controlled by passing in\n    # a list of counts, or a functor that returns a count when called with\n    # an object from the 'objects' list.\n    # if scale is provided, all counts are scaled by the scale value and then int()'ed.\n    def flywheel(index2objectAndCount):\n        # generator to produce a sequence whose elements appear a specific number of times\n        while len(index2objectAndCount) > 0:\n            keyList = list(index2objectAndCount.keys())\n            for key in keyList:\n                if index2objectAndCount[key][1] > 0:\n                    yield index2objectAndCount[key][0]\n                    index2objectAndCount[key][1] -= 1\n                if index2objectAndCount[key][1] <= 0:\n                    del index2objectAndCount[key]\n    # if we were not given a list of counts, create it by calling countFunc\n    if countList is None:\n        countList = []\n        for object in objects:\n            yield None\n            countList.append(countFunc(object))\n    if scale is not None:\n        # scale the counts if we've got a scale factor\n        for i in range(len(countList)):\n            yield None\n            if countList[i] > 0:\n                countList[i] = max(1, int(countList[i] * scale))\n    # create a dict for the flywheel to use during its iteration to efficiently select\n    # the objects for the sequence\n    index2objectAndCount = {}\n    for i in range(len(countList)):\n        yield None\n        index2objectAndCount[i] = [objects[i], countList[i]]\n    # create the flywheel generator\n    yield flywheel(index2objectAndCount)\n\n\ndef flywheel(*args, **kArgs):\n    # create a flywheel generator\n    # see arguments and comments in flywheelGen above\n    # example usage:\n    \"\"\"\n    >>> for i in flywheel([1,2,3], countList=[10, 5, 1]):\n    ...   print i,\n    ...\n    1 2 3 1 2 1 2 1 2 1 2 1 1 1 1 1\n    \"\"\"\n    for flywheel in makeFlywheelGen(*args, **kArgs):\n        pass\n    return flywheel\n\n\nif __debug__:\n    def quickProfile(name=\"unnamed\"):\n        import pstats\n\n        def profileDecorator(f):\n            if not ConfigVariableBool(\"use-profiler\", False):\n                return f\n\n            def _profiled(*args, **kArgs):\n                # must do this in here because we don't have base/simbase\n                # at the time that PythonUtil is loaded\n                if not ConfigVariableBool(\"profile-debug\", False):\n                    #dumb timings\n                    clock = ClockObject.getGlobalClock()\n                    st = clock.getRealTime()\n                    f(*args, **kArgs)\n                    s = clock.getRealTime() - st\n                    print(\"Function %s.%s took %s seconds\"%(f.__module__, f.__name__,s))\n                else:\n                    import profile as prof\n\n                    #detailed profile, stored in base.stats under (\n                    if not hasattr(base, \"stats\"):\n                        base.stats = {}\n                    if not base.stats.get(name):\n                        base.stats[name] = []\n\n                    prof.runctx('f(*args, **kArgs)', {'f':f,'args':args,'kArgs':kArgs},None,\"t.prof\")\n                    s=pstats.Stats(\"t.prof\")\n                    #p=hotshot.Profile(\"t.prof\")\n                    #p.runctx('f(*args, **kArgs)', {'f':f,'args':args,'kArgs':kArgs},None)\n                    #s = hotshot.stats.load(\"t.prof\")\n                    s.strip_dirs()\n                    s.sort_stats(\"cumulative\")\n                    base.stats[name].append(s)\n\n            _profiled.__doc__ = f.__doc__\n            return _profiled\n        return profileDecorator\n\n\ndef getTotalAnnounceTime():\n    td=0\n    for objs in base.stats.values():\n        for stat in objs:\n            td+=getAnnounceGenerateTime(stat)\n    return td\n\n\ndef getAnnounceGenerateTime(stat):\n    val=0\n    stats=stat.stats\n    for i in list(stats.keys()):\n        if i[2] == \"announceGenerate\":\n            newVal = stats[i][3]\n            if newVal > val:\n                val = newVal\n    return val\n\n\nclass MiniLog:\n    def __init__(self, name):\n        self.indent = 1\n        self.name = name\n        self.lines = []\n\n    def __str__(self):\n        return '%s\\nMiniLog: %s\\n%s\\n%s\\n%s' % \\\n               ('*'*50, self.name, '-'*50, '\\n'.join(self.lines), '*'*50)\n\n    def enterFunction(self, funcName, *args, **kw):\n        rArgs = [repr(x) + ', ' for x in args] + \\\n                [x + ' = ' + '%s, ' % repr(y) for x, y in kw.items()]\n\n        if not rArgs:\n            rArgs = '()'\n        else:\n            rArgs = '(' + functools.reduce(str.__add__, rArgs)[:-2] + ')'\n\n        line = '%s%s' % (funcName, rArgs)\n        self.appendFunctionCall(line)\n        self.indent += 1\n\n        return line\n\n    def exitFunction(self):\n        self.indent -= 1\n        return self.indent\n\n    def appendFunctionCall(self, line):\n        self.lines.append(' '*(self.indent*2) + line)\n        return line\n\n    def appendLine(self, line):\n        self.lines.append(' '*(self.indent*2) + '<< ' + line + ' >>')\n        return line\n\n    def flush(self):\n        outStr = str(self)\n        self.indent = 0\n        self.lines = []\n        return outStr\n\n\nclass MiniLogSentry:\n    def __init__(self, log, funcName, *args, **kw):\n        self.log = log\n        if self.log:\n            self.log.enterFunction(funcName, *args, **kw)\n\n    def __del__(self):\n        if self.log:\n            self.log.exitFunction()\n        del self.log\n\n\ndef logBlock(id, msg):\n    print('<< LOGBLOCK(%03d)' % id)\n    print(str(msg))\n    print('/LOGBLOCK(%03d) >>' % id)\n\n\nclass HierarchyException(Exception):\n    JOSWILSO = 0\n\n    def __init__(self, owner, description):\n        self.owner = owner\n        self.desc = description\n\n    def __str__(self):\n        return '(%s): %s' % (self.owner, self.desc)\n\n    def __repr__(self):\n        return 'HierarchyException(%s)' % (self.owner, )\n\n\ndef formatTimeCompact(seconds):\n    # returns string in format '1d3h22m43s'\n    result = ''\n    a = int(seconds)\n    seconds = a % 60\n    a //= 60\n    if a > 0:\n        minutes = a % 60\n        a //= 60\n        if a > 0:\n            hours = a % 24\n            a //= 24\n            if a > 0:\n                days = a\n                result += '%sd' % days\n            result += '%sh' % hours\n        result += '%sm' % minutes\n    result += '%ss' % seconds\n    return result\n\n\ndef formatTimeExact(seconds):\n    # like formatTimeCompact but leaves off '0 seconds', '0 minutes' etc. for\n    # times that are e.g. 1 hour, 3 days etc.\n    # returns string in format '1d3h22m43s'\n    result = ''\n    a = int(seconds)\n    seconds = a % 60\n    a //= 60\n    if a > 0:\n        minutes = a % 60\n        a //= 60\n        if a > 0:\n            hours = a % 24\n            a //= 24\n            if a > 0:\n                days = a\n                result += '%sd' % days\n            if hours or minutes or seconds:\n                result += '%sh' % hours\n        if minutes or seconds:\n            result += '%sm' % minutes\n    if seconds or result == '':\n        result += '%ss' % seconds\n    return result\n\n\nclass AlphabetCounter:\n    # object that produces 'A', 'B', 'C', ... 'AA', 'AB', etc.\n    def __init__(self):\n        self._curCounter = ['A']\n\n    def next(self):\n        result = ''.join([c for c in self._curCounter])\n        index = -1\n        while True:\n            curChar = self._curCounter[index]\n            if curChar == 'Z':\n                nextChar = 'A'\n                carry = True\n            else:\n                nextChar = chr(ord(self._curCounter[index])+1)\n                carry = False\n            self._curCounter[index] = nextChar\n            if carry:\n                if (-index) == len(self._curCounter):\n                    self._curCounter = ['A',] + self._curCounter\n                    break\n                else:\n                    index -= 1\n                carry = False\n            else:\n                break\n        return result\n\n    __next__ = next\n\n\nclass Default:\n    # represents 'use the default value'\n    # useful for keyword arguments to virtual methods\n    pass\n\n\ndef configIsToday(configName):\n    # TODO: replace usage of strptime with something else\n    # returns true if config string is a valid representation of today's date\n    today = time.localtime()\n    confStr = ConfigVariableString(configName, \"\", \"DConfig\", ConfigFlags.F_dconfig).value\n    for format in ('%m/%d/%Y', '%m-%d-%Y', '%m.%d.%Y'):\n        try:\n            confDate = time.strptime(confStr, format)\n        except ValueError:\n            pass\n        else:\n            if (confDate.tm_year == today.tm_year and\n                confDate.tm_mon == today.tm_mon and\n                confDate.tm_mday == today.tm_mday):\n                return True\n    return False\n\n\ndef typeName(o):\n    if hasattr(o, '__class__'):\n        return o.__class__.__name__\n    else:\n        return o.__name__\n\n\ndef safeTypeName(o):\n    try:\n        return typeName(o)\n    except Exception:\n        pass\n    try:\n        return type(o)\n    except Exception:\n        pass\n    return '<failed safeTypeName()>'\n\n\ndef histogramDict(l):\n    d = {}\n    for e in l:\n        d.setdefault(e, 0)\n        d[e] += 1\n    return d\n\n\ndef unescapeHtmlString(s):\n    # converts %## to corresponding character\n    # replaces '+' with ' '\n    result = ''\n    i = 0\n    while i < len(s):\n        char = s[i]\n        if char == '+':\n            char = ' '\n        elif char == '%':\n            if i < (len(s)-2):\n                num = int(s[i+1:i+3], 16)\n                char = chr(num)\n                i += 2\n        i += 1\n        result += char\n    return result\n\n\nclass PriorityCallbacks:\n    \"\"\" manage a set of prioritized callbacks, and allow them to be invoked in order of priority \"\"\"\n\n    def __init__(self):\n        self._callbacks = []\n\n    def clear(self):\n        del self._callbacks[:]\n\n    def add(self, callback, priority=None):\n        if priority is None:\n            priority = 0\n        callbacks = self._callbacks\n        lo = 0\n        hi = len(callbacks)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if priority < callbacks[mid][0]:\n                hi = mid\n            else:\n                lo = mid + 1\n        item = (priority, callback)\n        callbacks.insert(lo, item)\n        return item\n\n    def remove(self, item):\n        self._callbacks.remove(item)\n\n    def __call__(self):\n        for priority, callback in self._callbacks:\n            callback()\n\n\nbuiltins.Functor = Functor  # type: ignore[attr-defined]\nbuiltins.Stack = Stack  # type: ignore[attr-defined]\nbuiltins.Queue = Queue  # type: ignore[attr-defined]\nbuiltins.SerialNumGen = SerialNumGen  # type: ignore[attr-defined]\nbuiltins.SerialMaskedGen = SerialMaskedGen  # type: ignore[attr-defined]\nbuiltins.ScratchPad = ScratchPad  # type: ignore[attr-defined]\nbuiltins.uniqueName = uniqueName  # type: ignore[attr-defined]\nbuiltins.serialNum = serialNum  # type: ignore[attr-defined]\nif __debug__:\n    builtins.profiled = profiled  # type: ignore[attr-defined]\n    builtins.exceptionLogged = exceptionLogged  # type: ignore[attr-defined]\nbuiltins.itype = itype  # type: ignore[attr-defined]\nbuiltins.appendStr = appendStr  # type: ignore[attr-defined]\nbuiltins.bound = bound  # type: ignore[attr-defined]\nbuiltins.clamp = clamp  # type: ignore[attr-defined]\nbuiltins.lerp = lerp  # type: ignore[attr-defined]\nbuiltins.makeList = makeList  # type: ignore[attr-defined]\nbuiltins.makeTuple = makeTuple  # type: ignore[attr-defined]\nif __debug__:\n    builtins.printStack = printStack  # type: ignore[attr-defined]\n    builtins.printReverseStack = printReverseStack  # type: ignore[attr-defined]\n    builtins.printVerboseStack = printVerboseStack  # type: ignore[attr-defined]\nbuiltins.DelayedCall = DelayedCall  # type: ignore[attr-defined]\nbuiltins.DelayedFunctor = DelayedFunctor  # type: ignore[attr-defined]\nbuiltins.FrameDelayedCall = FrameDelayedCall  # type: ignore[attr-defined]\nbuiltins.SubframeCall = SubframeCall  # type: ignore[attr-defined]\nbuiltins.invertDict = invertDict  # type: ignore[attr-defined]\nbuiltins.invertDictLossless = invertDictLossless  # type: ignore[attr-defined]\nbuiltins.getBase = getBase  # type: ignore[attr-defined]\nbuiltins.getRepository = getRepository  # type: ignore[attr-defined]\nbuiltins.safeRepr = safeRepr  # type: ignore[attr-defined]\nbuiltins.fastRepr = fastRepr  # type: ignore[attr-defined]\nbuiltins.nullGen = nullGen  # type: ignore[attr-defined]\nbuiltins.flywheel = flywheel  # type: ignore[attr-defined]\nbuiltins.loopGen = loopGen  # type: ignore[attr-defined]\nif __debug__:\n    builtins.StackTrace = StackTrace  # type: ignore[attr-defined]\nbuiltins.report = report  # type: ignore[attr-defined]\nbuiltins.pstatcollect = pstatcollect  # type: ignore[attr-defined]\nbuiltins.MiniLog = MiniLog  # type: ignore[attr-defined]\nbuiltins.MiniLogSentry = MiniLogSentry  # type: ignore[attr-defined]\nbuiltins.logBlock = logBlock  # type: ignore[attr-defined]\nbuiltins.HierarchyException = HierarchyException  # type: ignore[attr-defined]\nbuiltins.deeptype = deeptype  # type: ignore[attr-defined]\nbuiltins.Default = Default  # type: ignore[attr-defined]\nbuiltins.configIsToday = configIsToday  # type: ignore[attr-defined]\nbuiltins.typeName = typeName  # type: ignore[attr-defined]\nbuiltins.safeTypeName = safeTypeName  # type: ignore[attr-defined]\nbuiltins.histogramDict = histogramDict  # type: ignore[attr-defined]\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/PythonUtil.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/34ee3f4f_PythonUtil.json",
    "doc_id": "doc_263"
  }
}