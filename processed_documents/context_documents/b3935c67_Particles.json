{
  "content": "\"\"\"The Python specialization of the particle system.\n\nSee the :ref:`particle-effects` section in the manual for an explanation\nof the particle system.\n\"\"\"\n\nfrom panda3d.core import ColorBlendAttrib, NodePath\n\nfrom panda3d.physics import PhysicalNode\nfrom panda3d.physics import ParticleSystem\nfrom panda3d.physics import PointParticleFactory\nfrom panda3d.physics import ZSpinParticleFactory\n#from panda3d.physics import OrientedParticleFactory\nfrom panda3d.physics import BaseParticleRenderer\nfrom panda3d.physics import PointParticleRenderer\nfrom panda3d.physics import LineParticleRenderer\nfrom panda3d.physics import GeomParticleRenderer\nfrom panda3d.physics import SparkleParticleRenderer\n#from panda3d.physics import SpriteParticleRenderer\nfrom panda3d.physics import BaseParticleEmitter\nfrom panda3d.physics import ArcEmitter\nfrom panda3d.physics import BoxEmitter\nfrom panda3d.physics import DiscEmitter\nfrom panda3d.physics import LineEmitter\nfrom panda3d.physics import PointEmitter\nfrom panda3d.physics import RectangleEmitter\nfrom panda3d.physics import RingEmitter\nfrom panda3d.physics import SphereSurfaceEmitter\nfrom panda3d.physics import SphereVolumeEmitter\nfrom panda3d.physics import TangentRingEmitter\nfrom panda3d.physics import SpriteAnim\n\nfrom . import SpriteParticleRendererExt\n\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nimport sys\n\n\nclass Particles(ParticleSystem):\n    notify = directNotify.newCategory('Particles')\n    id = 1\n\n    def __init__(self, name=None, poolSize=1024):\n        if name is None:\n            self.name = 'particles-%d' % Particles.id\n            Particles.id += 1\n        else:\n            self.name = name\n        ParticleSystem.__init__(self, poolSize)\n        # self.setBirthRate(0.02)\n        # self.setLitterSize(10)\n        # self.setLitterSpread(0)\n\n        # Set up a physical node\n        self.node = PhysicalNode(self.name)\n        self.nodePath = NodePath(self.node)\n        self.setRenderParent(self.node)\n        self.node.addPhysical(self)\n\n        self.factory = None\n        self.factoryType = \"undefined\"\n        # self.setFactory(\"PointParticleFactory\")\n        self.renderer = None\n        self.rendererType = \"undefined\"\n        # self.setRenderer(\"PointParticleRenderer\")\n        self.emitter = None\n        self.emitterType = \"undefined\"\n        # self.setEmitter(\"SphereVolumeEmitter\")\n\n        # Enable particles by default\n        self.fEnabled = 0\n        #self.enable()\n        self.geomReference = \"\"\n\n    def cleanup(self):\n        self.disable()\n        self.clearLinearForces()\n        self.clearAngularForces()\n        self.setRenderParent(self.node)\n        self.node.removePhysical(self)\n        self.nodePath.removeNode()\n        del self.node\n        del self.nodePath\n        del self.factory\n        del self.renderer\n        del self.emitter\n\n    def enable(self):\n        if self.fEnabled == 0:\n            base.physicsMgr.attachPhysical(self)\n            base.particleMgr.attachParticlesystem(self)\n            self.fEnabled = 1\n\n    def disable(self):\n        if self.fEnabled == 1:\n            base.physicsMgr.removePhysical(self)\n            base.particleMgr.removeParticlesystem(self)\n            self.fEnabled = 0\n\n    def isEnabled(self):\n        return self.fEnabled\n\n    def getNode(self):\n        return self.node\n\n    def setFactory(self, type):\n        if self.factoryType == type:\n            return None\n        if self.factory:\n            self.factory = None\n        self.factoryType = type\n        if type == \"PointParticleFactory\":\n            self.factory = PointParticleFactory()\n        elif type == \"ZSpinParticleFactory\":\n            self.factory = ZSpinParticleFactory()\n        #elif type == \"OrientedParticleFactory\":\n        #    self.factory = OrientedParticleFactory()\n        else:\n            print(\"unknown factory type: %s\" % type)\n            return None\n        self.factory.setLifespanBase(0.5)\n        ParticleSystem.setFactory(self, self.factory)\n\n    def setRenderer(self, type):\n        if self.rendererType == type:\n            return None\n        if self.renderer:\n            self.renderer = None\n        self.rendererType = type\n        if type == \"PointParticleRenderer\":\n            self.renderer = PointParticleRenderer()\n            self.renderer.setPointSize(1.0)\n        elif type == \"LineParticleRenderer\":\n            self.renderer = LineParticleRenderer()\n        elif type == \"GeomParticleRenderer\":\n            self.renderer = GeomParticleRenderer()\n            # This was moved here because we do not want to download\n            # the direct tools with toontown.\n            if __dev__:\n                from direct.directtools import DirectSelection\n                npath = NodePath('default-geom')\n                bbox = DirectSelection.DirectBoundingBox(npath)\n                self.renderer.setGeomNode(bbox.lines.node())\n        elif type == \"SparkleParticleRenderer\":\n            self.renderer = SparkleParticleRenderer()\n        elif type == \"SpriteParticleRenderer\":\n            self.renderer = SpriteParticleRendererExt.SpriteParticleRendererExt()\n            # self.renderer.setTextureFromFile()\n        else:\n            print(\"unknown renderer type: %s\" % type)\n            return None\n        ParticleSystem.setRenderer(self, self.renderer)\n\n    def setEmitter(self, type):\n        if self.emitterType == type:\n            return None\n        if self.emitter:\n            self.emitter = None\n        self.emitterType = type\n        if type == \"ArcEmitter\":\n            self.emitter = ArcEmitter()\n        elif type == \"BoxEmitter\":\n            self.emitter = BoxEmitter()\n        elif type == \"DiscEmitter\":\n            self.emitter = DiscEmitter()\n        elif type == \"LineEmitter\":\n            self.emitter = LineEmitter()\n        elif type == \"PointEmitter\":\n            self.emitter = PointEmitter()\n        elif type == \"RectangleEmitter\":\n            self.emitter = RectangleEmitter()\n        elif type == \"RingEmitter\":\n            self.emitter = RingEmitter()\n        elif type == \"SphereSurfaceEmitter\":\n            self.emitter = SphereSurfaceEmitter()\n        elif type == \"SphereVolumeEmitter\":\n            self.emitter = SphereVolumeEmitter()\n            self.emitter.setRadius(1.0)\n        elif type == \"TangentRingEmitter\":\n            self.emitter = TangentRingEmitter()\n        else:\n            print(\"unknown emitter type: %s\" % type)\n            return None\n        ParticleSystem.setEmitter(self, self.emitter)\n\n    def addForce(self, force):\n        if force.isLinear():\n            self.addLinearForce(force)\n        else:\n            self.addAngularForce(force)\n\n    def removeForce(self, force):\n        if force is None:\n            self.notify.warning('removeForce() - force is None!')\n            return\n        if force.isLinear():\n            self.removeLinearForce(force)\n        else:\n            self.removeAngularForce(force)\n\n    def setRenderNodePath(self, nodePath):\n        self.setRenderParent(nodePath.node())\n\n    ## Getters ##\n    def getName(self):\n        return self.name\n\n    def getFactory(self):\n        return self.factory\n\n    def getEmitter(self):\n        return self.emitter\n\n    def getRenderer(self):\n        return self.renderer\n\n    def printParams(self, file = sys.stdout, targ = 'self'):\n        file.write('# Particles parameters\\n')\n        file.write(targ + '.setFactory(\\\"' + self.factoryType + '\\\")\\n')\n        file.write(targ + '.setRenderer(\\\"' + self.rendererType + '\\\")\\n')\n        file.write(targ + '.setEmitter(\\\"' + self.emitterType + '\\\")\\n')\n\n        # System parameters\n        file.write(targ + ('.setPoolSize(%d)\\n' %\n                           int(self.getPoolSize())))\n        file.write(targ + ('.setBirthRate(%.4f)\\n' %\n                           self.getBirthRate()))\n        file.write(targ + ('.setLitterSize(%d)\\n' %\n                           int(self.getLitterSize())))\n        file.write(targ + ('.setLitterSpread(%d)\\n' %\n                           self.getLitterSpread()))\n        file.write(targ + ('.setSystemLifespan(%.4f)\\n' %\n                           self.getSystemLifespan()))\n        file.write(targ + ('.setLocalVelocityFlag(%d)\\n' %\n                           self.getLocalVelocityFlag()))\n        file.write(targ + ('.setSystemGrowsOlderFlag(%d)\\n' %\n                           self.getSystemGrowsOlderFlag()))\n        file.write('# Factory parameters\\n')\n        file.write(targ + ('.factory.setLifespanBase(%.4f)\\n' %\n                           self.factory.getLifespanBase()))\n        file.write(targ + '.factory.setLifespanSpread(%.4f)\\n' % \\\n                                self.factory.getLifespanSpread())\n        file.write(targ + '.factory.setMassBase(%.4f)\\n' % \\\n                                self.factory.getMassBase())\n        file.write(targ + '.factory.setMassSpread(%.4f)\\n' % \\\n                                self.factory.getMassSpread())\n        file.write(targ + '.factory.setTerminalVelocityBase(%.4f)\\n' % \\\n                                self.factory.getTerminalVelocityBase())\n        file.write(targ + '.factory.setTerminalVelocitySpread(%.4f)\\n' % \\\n                                self.factory.getTerminalVelocitySpread())\n        if self.factoryType == \"PointParticleFactory\":\n            file.write('# Point factory parameters\\n')\n        elif self.factoryType == \"ZSpinParticleFactory\":\n            file.write('# Z Spin factory parameters\\n')\n            file.write(targ + '.factory.setInitialAngle(%.4f)\\n' % \\\n                                        self.factory.getInitialAngle())\n            file.write(targ + '.factory.setInitialAngleSpread(%.4f)\\n' % \\\n                                        self.factory.getInitialAngleSpread())\n            file.write(targ + '.factory.enableAngularVelocity(%d)\\n' % \\\n                                        self.factory.getAngularVelocityEnabled())\n            if self.factory.getAngularVelocityEnabled():\n                file.write(targ + '.factory.setAngularVelocity(%.4f)\\n' % \\\n                                            self.factory.getAngularVelocity())\n                file.write(targ + '.factory.setAngularVelocitySpread(%.4f)\\n' % \\\n                                            self.factory.getAngularVelocitySpread())\n            else:\n                file.write(targ + '.factory.setFinalAngle(%.4f)\\n' % \\\n                                            self.factory.getFinalAngle())\n                file.write(targ + '.factory.setFinalAngleSpread(%.4f)\\n' % \\\n                                        self.factory.getFinalAngleSpread())\n\n        elif self.factoryType == \"OrientedParticleFactory\":\n            file.write('# Oriented factory parameters\\n')\n            file.write(targ + '.factory.setInitialOrientation(%.4f)\\n' % \\\n                                        self.factory.getInitialOrientation())\n            file.write(targ + '.factory.setFinalOrientation(%.4f)\\n' % \\\n                                        self.factory.getFinalOrientation())\n\n        file.write('# Renderer parameters\\n')\n        alphaMode = self.renderer.getAlphaMode()\n        aMode = \"PRALPHANONE\"\n        if alphaMode == BaseParticleRenderer.PRALPHANONE:\n            aMode = \"PRALPHANONE\"\n        elif alphaMode == BaseParticleRenderer.PRALPHAOUT:\n            aMode = \"PRALPHAOUT\"\n        elif alphaMode == BaseParticleRenderer.PRALPHAIN:\n            aMode = \"PRALPHAIN\"\n        elif alphaMode == BaseParticleRenderer.PRALPHAINOUT:\n            aMode = \"PRALPHAINOUT\"\n        elif alphaMode == BaseParticleRenderer.PRALPHAUSER:\n            aMode = \"PRALPHAUSER\"\n        file.write(targ + '.renderer.setAlphaMode(BaseParticleRenderer.' + aMode + ')\\n')\n        file.write(targ + '.renderer.setUserAlpha(%.2f)\\n' % \\\n                                        self.renderer.getUserAlpha())\n        if self.rendererType == \"PointParticleRenderer\":\n            file.write('# Point parameters\\n')\n            file.write(targ + '.renderer.setPointSize(%.2f)\\n' % \\\n                                        self.renderer.getPointSize())\n            sColor = self.renderer.getStartColor()\n            file.write((targ + '.renderer.setStartColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3])))\n            sColor = self.renderer.getEndColor()\n            file.write((targ + '.renderer.setEndColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3])))\n            blendType = self.renderer.getBlendType()\n            bType = \"PPONECOLOR\"\n            if blendType == PointParticleRenderer.PPONECOLOR:\n                bType = \"PPONECOLOR\"\n            elif blendType == PointParticleRenderer.PPBLENDLIFE:\n                bType = \"PPBLENDLIFE\"\n            elif blendType == PointParticleRenderer.PPBLENDVEL:\n                bType = \"PPBLENDVEL\"\n            file.write(targ + '.renderer.setBlendType(PointParticleRenderer.' + bType + ')\\n')\n            blendMethod = self.renderer.getBlendMethod()\n            bMethod = \"PPNOBLEND\"\n            if blendMethod == BaseParticleRenderer.PPNOBLEND:\n                bMethod = \"PPNOBLEND\"\n            elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n                bMethod = \"PPBLENDLINEAR\"\n            elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n                bMethod = \"PPBLENDCUBIC\"\n            file.write(targ + '.renderer.setBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n        elif self.rendererType == \"LineParticleRenderer\":\n            file.write('# Line parameters\\n')\n            sColor = self.renderer.getHeadColor()\n            file.write((targ + '.renderer.setHeadColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3])))\n            sColor = self.renderer.getTailColor()\n            file.write((targ + '.renderer.setTailColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3])))\n            sf = self.renderer.getLineScaleFactor()\n            file.write((targ + '.renderer.setLineScaleFactor(%.2f)\\n' % (sf)))\n        elif self.rendererType == \"GeomParticleRenderer\":\n            file.write('# Geom parameters\\n')\n            node = self.renderer.getGeomNode()\n            file.write('geomRef = loader.loadModel(\"' + self.geomReference + '\")\\n')\n            file.write(targ + '.renderer.setGeomNode(geomRef.node())\\n')\n            file.write(targ + '.geomReference = \"' + self.geomReference + '\"\\n')\n            cbmLut = ('MNone','MAdd','MSubtract','MInvSubtract','MMin','MMax')\n            cboLut = ('OZero','OOne','OIncomingColor','OOneMinusIncomingColor','OFbufferColor',\n                      'OOneMinusFbufferColor','OIncomingAlpha','OOneMinusIncomingAlpha',\n                      'OFbufferAlpha','OOneMinusFbufferAlpha','OConstantColor',\n                      'OOneMinusConstantColor','OConstantAlpha','OOneMinusConstantAlpha',\n                      'OIncomingColorSaturate')\n            file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n            file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n            file.write(targ + '.renderer.setZScaleFlag(%d)\\n' % self.renderer.getZScaleFlag())\n            file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n            file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n            file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n            file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n            file.write(targ + '.renderer.setInitialZScale(%.4f)\\n' % self.renderer.getInitialZScale())\n            file.write(targ + '.renderer.setFinalZScale(%.4f)\\n' % self.renderer.getFinalZScale())\n\n            cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n            if cbAttrib:\n                cbMode = cbAttrib.getMode()\n                if cbMode > 0:\n                    if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                        cboa = cbAttrib.getOperandA()\n                        cbob = cbAttrib.getOperandB()\n                        file.write(targ+'.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' %\n                                (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                    else:\n                        file.write(targ+'.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n            cim = self.renderer.getColorInterpolationManager()\n            segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n            for sid in segIdList:\n                seg = cim.getSegment(sid)\n                if seg.isEnabled():\n                    t_b = seg.getTimeBegin()\n                    t_e = seg.getTimeEnd()\n                    mod = seg.isModulated()\n                    fun = seg.getFunction()\n                    typ = type(fun).__name__\n                    if typ == 'ColorInterpolationFunctionConstant':\n                        c_a = fun.getColorA()\n                        file.write(targ+'.renderer.getColorInterpolationManager().addConstant('+repr(t_b)+','+repr(t_e)+','+ \\\n                                   'Vec4('+repr(c_a[0])+','+repr(c_a[1])+','+repr(c_a[2])+','+repr(c_a[3])+'),'+repr(mod)+')\\n')\n                    elif typ == 'ColorInterpolationFunctionLinear':\n                        c_a = fun.getColorA()\n                        c_b = fun.getColorB()\n                        file.write(targ+'.renderer.getColorInterpolationManager().addLinear('+repr(t_b)+','+repr(t_e)+','+ \\\n                                   'Vec4('+repr(c_a[0])+','+repr(c_a[1])+','+repr(c_a[2])+','+repr(c_a[3])+'),' + \\\n                                   'Vec4('+repr(c_b[0])+','+repr(c_b[1])+','+repr(c_b[2])+','+repr(c_b[3])+'),'+repr(mod)+')\\n')\n                    elif typ == 'ColorInterpolationFunctionStepwave':\n                        c_a = fun.getColorA()\n                        c_b = fun.getColorB()\n                        w_a = fun.getWidthA()\n                        w_b = fun.getWidthB()\n                        file.write(targ+'.renderer.getColorInterpolationManager().addStepwave('+repr(t_b)+','+repr(t_e)+','+ \\\n                                   'Vec4('+repr(c_a[0])+','+repr(c_a[1])+','+repr(c_a[2])+','+repr(c_a[3])+'),' + \\\n                                   'Vec4('+repr(c_b[0])+','+repr(c_b[1])+','+repr(c_b[2])+','+repr(c_b[3])+'),' + \\\n                                   repr(w_a)+','+repr(w_b)+','+repr(mod)+')\\n')\n                    elif typ == 'ColorInterpolationFunctionSinusoid':\n                        c_a = fun.getColorA()\n                        c_b = fun.getColorB()\n                        per = fun.getPeriod()\n                        file.write(targ+'.renderer.getColorInterpolationManager().addSinusoid('+repr(t_b)+','+repr(t_e)+','+ \\\n                                   'Vec4('+repr(c_a[0])+','+repr(c_a[1])+','+repr(c_a[2])+','+repr(c_a[3])+'),' + \\\n                                   'Vec4('+repr(c_b[0])+','+repr(c_b[1])+','+repr(c_b[2])+','+repr(c_b[3])+'),' + \\\n                                   repr(per)+','+repr(mod)+')\\n')\n\n        elif self.rendererType == \"SparkleParticleRenderer\":\n            file.write('# Sparkle parameters\\n')\n            sColor = self.renderer.getCenterColor()\n            file.write((targ + '.renderer.setCenterColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3])))\n            sColor = self.renderer.getEdgeColor()\n            file.write((targ + '.renderer.setEdgeColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3])))\n            file.write(targ + '.renderer.setBirthRadius(%.4f)\\n' % self.renderer.getBirthRadius())\n            file.write(targ + '.renderer.setDeathRadius(%.4f)\\n' % self.renderer.getDeathRadius())\n            lifeScale = self.renderer.getLifeScale()\n            lScale = \"SPNOSCALE\"\n            if lifeScale == SparkleParticleRenderer.SPSCALE:\n                lScale = \"SPSCALE\"\n            file.write(targ + '.renderer.setLifeScale(SparkleParticleRenderer.' + lScale + ')\\n')\n        elif self.rendererType == \"SpriteParticleRenderer\":\n            file.write('# Sprite parameters\\n')\n            if self.renderer.getAnimateFramesEnable():\n                file.write(targ + '.renderer.setAnimateFramesEnable(True)\\n')\n                rate = self.renderer.getAnimateFramesRate()\n                if rate:\n                    file.write(targ + '.renderer.setAnimateFramesRate(%.3f)\\n'%rate)\n            animCount = self.renderer.getNumAnims()\n            for x in range(animCount):\n                anim = self.renderer.getAnim(x)\n                if anim.getSourceType() == SpriteAnim.STTexture:\n                    file.write(targ + '.renderer.addTextureFromFile(\\'%s\\')\\n' % (anim.getTexSource(),))\n                else:\n                    file.write(targ + '.renderer.addTextureFromNode(\\'%s\\',\\'%s\\')\\n' % (anim.getModelSource(), anim.getNodeSource()))\n            sColor = self.renderer.getColor()\n            file.write((targ + '.renderer.setColor(Vec4(%.2f, %.2f, %.2f, %.2f))\\n' % (sColor[0], sColor[1], sColor[2], sColor[3])))\n            file.write(targ + '.renderer.setXScaleFlag(%d)\\n' % self.renderer.getXScaleFlag())\n            file.write(targ + '.renderer.setYScaleFlag(%d)\\n' % self.renderer.getYScaleFlag())\n            file.write(targ + '.renderer.setAnimAngleFlag(%d)\\n' % self.renderer.getAnimAngleFlag())\n            file.write(targ + '.renderer.setInitialXScale(%.4f)\\n' % self.renderer.getInitialXScale())\n            file.write(targ + '.renderer.setFinalXScale(%.4f)\\n' % self.renderer.getFinalXScale())\n            file.write(targ + '.renderer.setInitialYScale(%.4f)\\n' % self.renderer.getInitialYScale())\n            file.write(targ + '.renderer.setFinalYScale(%.4f)\\n' % self.renderer.getFinalYScale())\n            file.write(targ + '.renderer.setNonanimatedTheta(%.4f)\\n' % self.renderer.getNonanimatedTheta())\n            blendMethod = self.renderer.getAlphaBlendMethod()\n            bMethod = \"PPNOBLEND\"\n            if blendMethod == BaseParticleRenderer.PPNOBLEND:\n                bMethod = \"PPNOBLEND\"\n            elif blendMethod == BaseParticleRenderer.PPBLENDLINEAR:\n                bMethod = \"PPBLENDLINEAR\"\n            elif blendMethod == BaseParticleRenderer.PPBLENDCUBIC:\n                bMethod = \"PPBLENDCUBIC\"\n            file.write(targ + '.renderer.setAlphaBlendMethod(BaseParticleRenderer.' + bMethod + ')\\n')\n            file.write(targ + '.renderer.setAlphaDisable(%d)\\n' % self.renderer.getAlphaDisable())\n            # Save the color blending to file\n            cbmLut = ('MNone','MAdd','MSubtract','MInvSubtract','MMin','MMax')\n            cboLut = ('OZero','OOne','OIncomingColor','OOneMinusIncomingColor','OFbufferColor',\n                      'OOneMinusFbufferColor','OIncomingAlpha','OOneMinusIncomingAlpha',\n                      'OFbufferAlpha','OOneMinusFbufferAlpha','OConstantColor',\n                      'OOneMinusConstantColor','OConstantAlpha','OOneMinusConstantAlpha',\n                      'OIncomingColorSaturate')\n            cbAttrib = self.renderer.getRenderNode().getAttrib(ColorBlendAttrib.getClassType())\n            if cbAttrib:\n                cbMode = cbAttrib.getMode()\n                if cbMode > 0:\n                    if cbMode in (ColorBlendAttrib.MAdd, ColorBlendAttrib.MSubtract, ColorBlendAttrib.MInvSubtract):\n                        cboa = cbAttrib.getOperandA()\n                        cbob = cbAttrib.getOperandB()\n                        file.write(targ+'.renderer.setColorBlendMode(ColorBlendAttrib.%s, ColorBlendAttrib.%s, ColorBlendAttrib.%s)\\n' %\n                                (cbmLut[cbMode], cboLut[cboa], cboLut[cbob]))\n                    else:\n                        file.write(targ+'.renderer.setColorBlendMode(ColorBlendAttrib.%s)\\n' % cbmLut[cbMode])\n            cim = self.renderer.getColorInterpolationManager()\n            segIdList = [int(seg) for seg in cim.getSegmentIdList().split()]\n            for sid in segIdList:\n                seg = cim.getSegment(sid)\n                if seg.isEnabled():\n                    t_b = seg.getTimeBegin()\n                    t_e = seg.getTimeEnd()\n                    mod = seg.isModulated()\n                    fun = seg.getFunction()\n                    typ = type(fun).__name__\n                    if typ == 'ColorInterpolationFunctionConstant':\n                        c_a = fun.getColorA()\n                        file.write(targ+'.renderer.getColorInterpolationManager().addConstant('+repr(t_b)+','+repr(t_e)+','+ \\\n                                   'Vec4('+repr(c_a[0])+','+repr(c_a[1])+','+repr(c_a[2])+','+repr(c_a[3])+'),'+repr(mod)+')\\n')\n                    elif typ == 'ColorInterpolationFunctionLinear':\n                        c_a = fun.getColorA()\n                        c_b = fun.getColorB()\n                        file.write(targ+'.renderer.getColorInterpolationManager().addLinear('+repr(t_b)+','+repr(t_e)+','+ \\\n                                   'Vec4('+repr(c_a[0])+','+repr(c_a[1])+','+repr(c_a[2])+','+repr(c_a[3])+'),' + \\\n                                   'Vec4('+repr(c_b[0])+','+repr(c_b[1])+','+repr(c_b[2])+','+repr(c_b[3])+'),'+repr(mod)+')\\n')\n                    elif typ == 'ColorInterpolationFunctionStepwave':\n                        c_a = fun.getColorA()\n                        c_b = fun.getColorB()\n                        w_a = fun.getWidthA()\n                        w_b = fun.getWidthB()\n                        file.write(targ+'.renderer.getColorInterpolationManager().addStepwave('+repr(t_b)+','+repr(t_e)+','+ \\\n                                   'Vec4('+repr(c_a[0])+','+repr(c_a[1])+','+repr(c_a[2])+','+repr(c_a[3])+'),' + \\\n                                   'Vec4('+repr(c_b[0])+','+repr(c_b[1])+','+repr(c_b[2])+','+repr(c_b[3])+'),' + \\\n                                   repr(w_a)+','+repr(w_b)+','+repr(mod)+')\\n')\n                    elif typ == 'ColorInterpolationFunctionSinusoid':\n                        c_a = fun.getColorA()\n                        c_b = fun.getColorB()\n                        per = fun.getPeriod()\n                        file.write(targ+'.renderer.getColorInterpolationManager().addSinusoid('+repr(t_b)+','+repr(t_e)+','+ \\\n                                   'Vec4('+repr(c_a[0])+','+repr(c_a[1])+','+repr(c_a[2])+','+repr(c_a[3])+'),' + \\\n                                   'Vec4('+repr(c_b[0])+','+repr(c_b[1])+','+repr(c_b[2])+','+repr(c_b[3])+'),' + \\\n                                   repr(per)+','+repr(mod)+')\\n')\n\n        file.write('# Emitter parameters\\n')\n        emissionType = self.emitter.getEmissionType()\n        eType = \"ETEXPLICIT\"\n        if emissionType == BaseParticleEmitter.ETEXPLICIT:\n            eType = \"ETEXPLICIT\"\n        elif emissionType == BaseParticleEmitter.ETRADIATE:\n            eType = \"ETRADIATE\"\n        elif emissionType == BaseParticleEmitter.ETCUSTOM:\n            eType = \"ETCUSTOM\"\n        file.write(targ + '.emitter.setEmissionType(BaseParticleEmitter.' + eType + ')\\n')\n        file.write(targ + '.emitter.setAmplitude(%.4f)\\n' % self.emitter.getAmplitude())\n        file.write(targ + '.emitter.setAmplitudeSpread(%.4f)\\n' % self.emitter.getAmplitudeSpread())\n        oForce = self.emitter.getOffsetForce()\n        file.write((targ + '.emitter.setOffsetForce(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2])))\n        oForce = self.emitter.getExplicitLaunchVector()\n        file.write((targ + '.emitter.setExplicitLaunchVector(Vec3(%.4f, %.4f, %.4f))\\n' % (oForce[0], oForce[1], oForce[2])))\n        orig = self.emitter.getRadiateOrigin()\n        file.write((targ + '.emitter.setRadiateOrigin(Point3(%.4f, %.4f, %.4f))\\n' % (orig[0], orig[1], orig[2])))\n        if self.emitterType == \"BoxEmitter\":\n            file.write('# Box parameters\\n')\n            bound = self.emitter.getMinBound()\n            file.write((targ + '.emitter.setMinBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2])))\n            bound = self.emitter.getMaxBound()\n            file.write((targ + '.emitter.setMaxBound(Point3(%.4f, %.4f, %.4f))\\n' % (bound[0], bound[1], bound[2])))\n        elif self.emitterType == \"DiscEmitter\":\n            file.write('# Disc parameters\\n')\n            file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n            if eType == \"ETCUSTOM\":\n                file.write(targ + '.emitter.setOuterAngle(%.4f)\\n' % self.emitter.getOuterAngle())\n                file.write(targ + '.emitter.setInnerAngle(%.4f)\\n' % self.emitter.getInnerAngle())\n                file.write(targ + '.emitter.setOuterMagnitude(%.4f)\\n' % self.emitter.getOuterMagnitude())\n                file.write(targ + '.emitter.setInnerMagnitude(%.4f)\\n' % self.emitter.getInnerMagnitude())\n                file.write(targ + '.emitter.setCubicLerping(%d)\\n' % self.emitter.getCubicLerping())\n\n        elif self.emitterType == \"LineEmitter\":\n            file.write('# Line parameters\\n')\n            point = self.emitter.getEndpoint1()\n            file.write((targ + '.emitter.setEndpoint1(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2])))\n            point = self.emitter.getEndpoint2()\n            file.write((targ + '.emitter.setEndpoint2(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2])))\n        elif self.emitterType == \"PointEmitter\":\n            file.write('# Point parameters\\n')\n            point = self.emitter.getLocation()\n            file.write((targ + '.emitter.setLocation(Point3(%.4f, %.4f, %.4f))\\n' % (point[0], point[1], point[2])))\n        elif self.emitterType == \"RectangleEmitter\":\n            file.write('# Rectangle parameters\\n')\n            point = self.emitter.getMinBound()\n            file.write((targ + '.emitter.setMinBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1])))\n            point = self.emitter.getMaxBound()\n            file.write((targ + '.emitter.setMaxBound(Point2(%.4f, %.4f))\\n' % (point[0], point[1])))\n        elif self.emitterType == \"RingEmitter\":\n            file.write('# Ring parameters\\n')\n            file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n            file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())\n            if eType == \"ETCUSTOM\":\n                file.write(targ + '.emitter.setAngle(%.4f)\\n' % self.emitter.getAngle())\n        elif self.emitterType == \"SphereSurfaceEmitter\":\n            file.write('# Sphere Surface parameters\\n')\n            file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        elif self.emitterType == \"SphereVolumeEmitter\":\n            file.write('# Sphere Volume parameters\\n')\n            file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n        elif self.emitterType == \"TangentRingEmitter\":\n            file.write('# Tangent Ring parameters\\n')\n            file.write(targ + '.emitter.setRadius(%.4f)\\n' % self.emitter.getRadius())\n            file.write(targ + '.emitter.setRadiusSpread(%.4f)\\n' % self.emitter.getRadiusSpread())\n\n    def getPoolSizeRanges(self):\n        litterRange = [max(1,self.getLitterSize()-self.getLitterSpread()),\n                       self.getLitterSize(),\n                       self.getLitterSize()+self.getLitterSpread()]\n        lifespanRange = [self.factory.getLifespanBase()-self.factory.getLifespanSpread(),\n                         self.factory.getLifespanBase(),\n                         self.factory.getLifespanBase()+self.factory.getLifespanSpread()]\n        birthRateRange = [self.getBirthRate()] * 3\n\n        print('Litter Ranges:    %s' % litterRange)\n        print('LifeSpan Ranges:  %s' % lifespanRange)\n        print('BirthRate Ranges: %s' % birthRateRange)\n\n        return dict(zip(('min','median','max'),[l*s/b for l,s,b in zip(litterRange,lifespanRange,birthRateRange)]))\n\n    def accelerate(self,time,stepCount = 1,stepTime=0.0):\n        if time > 0.0:\n            if stepTime == 0.0:\n                stepTime = float(time)/stepCount\n                remainder = 0.0\n            else:\n                stepCount = int(float(time)/stepTime)\n                remainder = time-stepCount*stepTime\n\n            for step in range(stepCount):\n                base.particleMgr.doParticles(stepTime,self,False)\n                base.physicsMgr.doPhysics(stepTime,self)\n\n            if remainder:\n                base.particleMgr.doParticles(remainder,self,False)\n                base.physicsMgr.doPhysics(remainder,self)\n\n            self.render()\n\n    # Snake-case aliases.\n    is_enabled = isEnabled\n    set_factory = setFactory\n    set_renderer = setRenderer\n    set_emitter = setEmitter\n    add_force = addForce\n    remove_force = removeForce\n    set_render_node_path = setRenderNodePath\n    get_factory = getFactory\n    get_emitter = getEmitter\n    get_renderer = getRenderer\n    print_params = printParams\n    get_pool_size_ranges = getPoolSizeRanges\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/particles/Particles.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/b3935c67_Particles.json",
    "doc_id": "doc_69"
  }
}