{
  "content": "# PandAI Author: Srinavin Nair\n# Original Author: Ryan Myers\n# Models: Jeff Styers, Reagan Heller\n\n# Last Updated: 6/13/2005\n#\n# This tutorial provides an example of creating a character and having it walk\n# around on uneven terrain, as well as implementing a fully rotatable camera.\n# It uses PandAI pathfinding to move the character.\n\nfrom direct.showbase.ShowBase import ShowBase\nfrom panda3d.core import CollisionTraverser, CollisionNode\nfrom panda3d.core import CollisionHandlerQueue, CollisionRay\nfrom panda3d.core import Filename\nfrom panda3d.core import PandaNode, NodePath, TextNode\nfrom panda3d.core import Vec3, BitMask32\nfrom direct.gui.OnscreenText import OnscreenText\nfrom direct.actor.Actor import Actor\nfrom direct.task.Task import Task\nfrom direct.showbase.DirectObject import DirectObject\nimport sys\nimport os\n\nfrom panda3d.ai import *\n\nbase = ShowBase()\n\nSPEED = 0.5\n\n# Figure out what directory this program is in.\nMYDIR = os.path.abspath(sys.path[0])\nMYDIR = Filename.fromOsSpecific(MYDIR).getFullpath()\n\nfont = loader.loadFont(\"cmss12\")\n\n\n# Function to put instructions on the screen.\ndef addInstructions(pos, msg):\n    return OnscreenText(text=msg, style=1, fg=(1, 1, 1, 1), font=font,\n                        pos=(-1.3, pos), align=TextNode.ALeft, scale=.05)\n\n\n# Function to put title on the screen.\ndef addTitle(text):\n    return OnscreenText(text=text, style=1, fg=(1, 1, 1, 1), font=font,\n                        pos=(1.3, -0.95), align=TextNode.ARight, scale=.07)\n\n\nclass World(DirectObject):\n\n    def __init__(self):\n        self.switchState = True\n        self.switchCam = False\n        self.path_no = 1\n        self.keyMap = {\n            \"left\": 0,\n            \"right\": 0,\n            \"forward\": 0,\n            \"cam-left\": 0,\n            \"cam-right\": 0\n        }\n        base.win.setClearColor((0, 0, 0, 1))\n        base.cam.setPosHpr(17.79, -87.64, 90.16, 38.66, 325.36, 0)\n        # Post the instructions\n\n        addTitle(\"Pandai Tutorial: Roaming Ralph (Walking on Uneven Terrain) \"\n                 \"working with pathfinding\")\n        addInstructions(0.95, \"[ESC]: Quit\")\n        addInstructions(0.90, \"[Space - do Only once]: Start Pathfinding\")\n        addInstructions(0.85, \"[Enter]: Change camera view\")\n        addInstructions(0.80, \"[Up Arrow]: Run Ralph Forward\")\n        addInstructions(0.70, \"[A]: Rotate Camera Left\")\n        addInstructions(0.65, \"[S]: Rotate Camera Right\")\n\n        # Set up the environment\n        #\n        # This environment model contains collision meshes.  If you look\n        # in the egg file, you will see the following:\n        #\n        #    <Collide> { Polyset keep descend }\n        #\n        # This tag causes the following mesh to be converted to a collision\n        # mesh -- a mesh which is optimized for collision, not rendering.\n        # It also keeps the original mesh, so there are now two copies ---\n        # one optimized for rendering, one for collisions.\n\n        self.environ = loader.loadModel(\"models/world\")\n        self.environ.reparentTo(render)\n        self.environ.setPos(12, 0, 0)\n\n        self.box = loader.loadModel(\"models/box\")\n        self.box.reparentTo(render)\n        self.box.setPos(-29.83, 0, 0)\n        self.box.setScale(1)\n\n        self.box1 = loader.loadModel(\"models/box\")\n        self.box1.reparentTo(render)\n        self.box1.setPos(-51.14, -17.90, 0)\n        self.box1.setScale(1)\n\n        # Create the main character, Ralph\n\n        #ralphStartPos = self.environ.find(\"**/start_point\").getPos()\n        ralphStartPos = Vec3(-98.64, -20.60, 0)\n        self.ralph = Actor(\"models/ralph\",\n                           {\"run\": \"models/ralph-run\",\n                            \"walk\": \"models/ralph-walk\"})\n        self.ralph.reparentTo(render)\n        self.ralph.setScale(1)\n        self.ralph.setPos(ralphStartPos)\n\n        self.ralphai = Actor(\"models/ralph\",\n                             {\"run\": \"models/ralph-run\",\n                              \"walk\": \"models/ralph-walk\"})\n\n        self.pointer = loader.loadModel(\"models/arrow\")\n        self.pointer.setColor(1, 0, 0)\n        self.pointer.setPos(-7.5, -1.2, 0)\n        self.pointer.setScale(3)\n        self.pointer.reparentTo(render)\n\n        self.pointer1 = loader.loadModel(\"models/arrow\")\n        self.pointer1.setColor(1, 0, 0)\n        self.pointer1.setPos(-98.64, -20.60, 0)\n        self.pointer1.setScale(3)\n        #self.pointer.reparentTo(render)\n\n        # Create a floater object.  We use the \"floater\" as a temporary\n        # variable in a variety of calculations.\n\n        self.floater = NodePath(PandaNode(\"floater\"))\n        self.floater.reparentTo(render)\n\n        # Accept the control keys for movement and rotation\n\n        self.accept(\"escape\", sys.exit)\n        self.accept(\"enter\", self.activateCam)\n        self.accept(\"arrow_left\", self.setKey, [\"left\", 1])\n        self.accept(\"arrow_right\", self.setKey, [\"right\", 1])\n        self.accept(\"arrow_up\", self.setKey, [\"forward\", 1])\n        self.accept(\"a\", self.setKey, [\"cam-left\", 1])\n        self.accept(\"s\", self.setKey, [\"cam-right\", 1])\n        self.accept(\"arrow_left-up\", self.setKey, [\"left\", 0])\n        self.accept(\"arrow_right-up\", self.setKey, [\"right\", 0])\n        self.accept(\"arrow_up-up\", self.setKey, [\"forward\", 0])\n        self.accept(\"a-up\", self.setKey, [\"cam-left\", 0])\n        self.accept(\"s-up\", self.setKey, [\"cam-right\", 0])\n\n        #taskMgr.add(self.move,\"moveTask\")\n\n        # Game state variables\n        self.isMoving = False\n\n        # Set up the camera\n\n        #base.disableMouse()\n        #base.camera.setPos(self.ralph.getX(), self.ralph.getY() + 10, 2)\n\n        # We will detect the height of the terrain by creating a collision\n        # ray and casting it downward toward the terrain.  One ray will\n        # start above ralph's head, and the other will start above the camera.\n        # A ray may hit the terrain, or it may hit a rock or a tree.  If it\n        # hits the terrain, we can detect the height.  If it hits anything\n        # else, we rule that the move is illegal.\n\n        self.cTrav = CollisionTraverser()\n\n        self.ralphGroundRay = CollisionRay()\n        self.ralphGroundRay.setOrigin(0, 0, 1000)\n        self.ralphGroundRay.setDirection(0, 0, -1)\n        self.ralphGroundCol = CollisionNode('ralphRay')\n        self.ralphGroundCol.addSolid(self.ralphGroundRay)\n        self.ralphGroundCol.setFromCollideMask(BitMask32.bit(0))\n        self.ralphGroundCol.setIntoCollideMask(BitMask32.allOff())\n        self.ralphGroundColNp = self.ralph.attachNewNode(self.ralphGroundCol)\n        self.ralphGroundHandler = CollisionHandlerQueue()\n        self.cTrav.addCollider(self.ralphGroundColNp, self.ralphGroundHandler)\n\n        self.camGroundRay = CollisionRay()\n        self.camGroundRay.setOrigin(0, 0, 1000)\n        self.camGroundRay.setDirection(0, 0, -1)\n        self.camGroundCol = CollisionNode('camRay')\n        self.camGroundCol.addSolid(self.camGroundRay)\n        self.camGroundCol.setFromCollideMask(BitMask32.bit(0))\n        self.camGroundCol.setIntoCollideMask(BitMask32.allOff())\n        self.camGroundColNp = base.camera.attachNewNode(self.camGroundCol)\n        self.camGroundHandler = CollisionHandlerQueue()\n        self.cTrav.addCollider(self.camGroundColNp, self.camGroundHandler)\n\n        # Uncomment this line to see the collision rays\n        #self.ralphGroundColNp.show()\n        #self.camGroundColNp.show()\n\n        #Uncomment this line to show a visual representation of the\n        #collisions occuring\n        #self.cTrav.showCollisions(render)\n\n        self.setAI()\n\n    def activateCam(self):\n        self.switchCam = not self.switchCam\n        if self.switchCam is True:\n            base.cam.setPosHpr(0, 0, 0, 0, 0, 0)\n            base.cam.reparentTo(self.ralph)\n            base.cam.setY(base.cam.getY() + 30)\n            base.cam.setZ(base.cam.getZ() + 10)\n            base.cam.setHpr(180, -15, 0)\n        else:\n            base.cam.reparentTo(render)\n            base.cam.setPosHpr(17.79, -87.64, 90.16, 38.66, 325.36, 0)\n            #base.camera.setPos(self.ralph.getX(),self.ralph.getY()+10,2)\n\n    # Records the state of the arrow keys\n    def setKey(self, key, value):\n        self.keyMap[key] = value\n\n    # Accepts arrow keys to move either the player or the menu cursor,\n    # Also deals with grid checking and collision detection\n    def move(self):\n\n        # Get the time elapsed since last frame. We need this\n        # for framerate-independent movement.\n        elapsed = globalClock.getDt()\n\n        # If the camera-left key is pressed, move camera left.\n        # If the camera-right key is pressed, move camera right.\n        if self.switchState is False:\n            base.camera.lookAt(self.ralph)\n            if self.keyMap[\"cam-left\"] != 0:\n                base.camera.setX(base.camera, -(elapsed * 20))\n            if self.keyMap[\"cam-right\"] != 0:\n                base.camera.setX(base.camera, +(elapsed * 20))\n\n        # save ralph's initial position so that we can restore it,\n        # in case he falls off the map or runs into something.\n\n        startpos = self.ralph.getPos()\n\n        # If a move-key is pressed, move ralph in the specified direction.\n\n        if self.keyMap[\"left\"] != 0:\n            self.ralph.setH(self.ralph.getH() + elapsed * 300)\n        if self.keyMap[\"right\"] != 0:\n            self.ralph.setH(self.ralph.getH() - elapsed * 300)\n        if self.keyMap[\"forward\"] != 0:\n            self.ralph.setY(self.ralph, -(elapsed * 25))\n\n        # If ralph is moving, loop the run animation.\n        # If he is standing still, stop the animation.\n\n        if self.keyMap[\"forward\"] != 0 or self.keyMap[\"left\"] != 0 or self.keyMap[\"right\"] != 0:\n            if self.isMoving is False:\n                self.ralph.loop(\"run\")\n                self.isMoving = True\n        else:\n            if self.isMoving:\n                self.ralph.stop()\n                self.ralph.pose(\"walk\", 5)\n                self.isMoving = False\n\n        # If the camera is too far from ralph, move it closer.\n        # If the camera is too close to ralph, move it farther.\n        if self.switchState is False:\n            camvec = self.ralph.getPos() - base.camera.getPos()\n            camvec.setZ(0)\n            camdist = camvec.length()\n            camvec.normalize()\n            if camdist > 10.0:\n                base.camera.setPos(base.camera.getPos() + camvec * (camdist - 10))\n                camdist = 10.0\n            if camdist < 5.0:\n                base.camera.setPos(base.camera.getPos() - camvec * (5 - camdist))\n                camdist = 5.0\n\n        # Now check for collisions.\n\n        self.cTrav.traverse(render)\n\n        # Adjust ralph's Z coordinate.  If ralph's ray hit terrain,\n        # update his Z. If it hit anything else, or didn't hit anything, put\n        # him back where he was last frame.\n\n        #print(self.ralphGroundHandler.getNumEntries())\n\n        entries = []\n        for i in range(self.ralphGroundHandler.getNumEntries()):\n            entry = self.ralphGroundHandler.getEntry(i)\n            entries.append(entry)\n        entries.sort(lambda x, y: cmp(y.getSurfacePoint(render).z,\n                                      x.getSurfacePoint(render).z))\n        if entries and entries[0].getIntoNode().getName() == \"terrain\":\n            self.ralph.setZ(entries[0].getSurfacePoint(render).z)\n        else:\n            self.ralph.setPos(startpos)\n\n        # Keep the camera at one foot above the terrain,\n        # or two feet above ralph, whichever is greater.\n\n        if self.switchState is False:\n            entries = []\n            for i in range(self.camGroundHandler.getNumEntries()):\n                entry = self.camGroundHandler.getEntry(i)\n                entries.append(entry)\n            entries.sort(lambda x, y: cmp(y.getSurfacePoint(render).z,\n                                          x.getSurfacePoint(render).z))\n            if entries and entries[0].getIntoNode().getName() == \"terrain\":\n                base.camera.setZ(entries[0].getSurfacePoint(render).z + 1.0)\n            if base.camera.getZ() < self.ralph.getZ() + 2.0:\n                base.camera.setZ(self.ralph.getZ() + 2.0)\n\n            # The camera should look in ralph's direction,\n            # but it should also try to stay horizontal, so look at\n            # a floater which hovers above ralph's head.\n\n            self.floater.setPos(self.ralph.getPos())\n            self.floater.setZ(self.ralph.getZ() + 2.0)\n            base.camera.setZ(base.camera.getZ())\n            base.camera.lookAt(self.floater)\n\n        self.ralph.setP(0)\n        return Task.cont\n\n    def setAI(self):\n        # Creating AI World\n        self.AIworld = AIWorld(render)\n\n        self.accept(\"space\", self.setMove)\n        self.AIchar = AICharacter(\"ralph\", self.ralph, 60, 0.05, 25)\n        self.AIworld.addAiChar(self.AIchar)\n        self.AIbehaviors = self.AIchar.getAiBehaviors()\n\n        self.AIbehaviors.initPathFind(\"models/navmesh.csv\")\n\n        # AI World update\n        taskMgr.add(self.AIUpdate, \"AIUpdate\")\n\n    def setMove(self):\n        self.AIbehaviors.addStaticObstacle(self.box)\n        self.AIbehaviors.addStaticObstacle(self.box1)\n        self.AIbehaviors.pathFindTo(self.pointer)\n        self.ralph.loop(\"run\")\n\n    # To update the AIWorld\n    def AIUpdate(self, task):\n        self.AIworld.update()\n        self.move()\n\n        if self.path_no == 1 and self.AIbehaviors.behaviorStatus(\"pathfollow\") == \"done\":\n            self.path_no = 2\n            self.AIbehaviors.pathFindTo(self.pointer1, \"addPath\")\n            print(\"inside\")\n\n        if self.path_no == 2 and self.AIbehaviors.behaviorStatus(\"pathfollow\") == \"done\":\n            print(\"inside2\")\n            self.path_no = 1\n            self.AIbehaviors.pathFindTo(self.pointer, \"addPath\")\n\n        return Task.cont\n\n\nw = World()\nbase.run()\n",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/e3690e85_uneven-terrain.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/22fb6b37_e3690e85_uneven-terrain.json",
    "doc_id": "doc_1"
  }
}