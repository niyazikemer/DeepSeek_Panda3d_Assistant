{
  "content": "\"\"\" This module contains `.ShowBase`, an application framework responsible\nfor opening a graphical display, setting up input devices and creating\nthe scene graph.\n\nThe simplest way to open a ShowBase instance is to execute this code:\n\n.. code-block:: python\n\n   from direct.showbase.ShowBase import ShowBase\n\n   base = ShowBase()\n   base.run()\n\nA common approach is to create your own subclass inheriting from ShowBase.\n\nBuilt-in global variables\n-------------------------\n\nSome key variables used in all Panda3D scripts are actually attributes of the\nShowBase instance.  When creating an instance of this class, it will write many\nof these variables to the built-in scope of the Python interpreter, so that\nthey are accessible to any Python module, without the need for extra imports.\nFor example, the ShowBase instance itself is accessible anywhere through the\n:data:`~builtins.base` variable.\n\nWhile these are handy for prototyping, we do not recommend using them in bigger\nprojects, as it can make the code confusing to read to other Python developers,\nto whom it may not be obvious where these variables are originating.\n\nRefer to the :mod:`builtins` page for a listing of the variables written to the\nbuilt-in scope.\n\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = ['ShowBase', 'WindowControls']\n\n# This module redefines the builtin import function with one\n# that prints out every import it does in a hierarchical form\n# Annoying and very noisy, but sometimes useful\n#import VerboseImport\n\nfrom panda3d.core import (\n    AntialiasAttrib,\n    AudioManager,\n    AudioSound,\n    BitMask32,\n    ButtonThrower,\n    Camera,\n    ClockObject,\n    CollisionTraverser,\n    ColorBlendAttrib,\n    ConfigPageManager,\n    ConfigVariableBool,\n    ConfigVariableDouble,\n    ConfigVariableFilename,\n    ConfigVariableInt,\n    ConfigVariableManager,\n    ConfigVariableString,\n    DataGraphTraverser,\n    DepthTestAttrib,\n    DepthWriteAttrib,\n    DriveInterface,\n    ExecutionEnvironment,\n    Filename,\n    FisheyeMaker,\n    FrameBufferProperties,\n    FrameRateMeter,\n    GeomNode,\n    GraphicsEngine,\n    GraphicsOutput,\n    GraphicsPipe,\n    GraphicsPipeSelection,\n    GraphicsWindow,\n    InputDevice,\n    InputDeviceManager,\n    InputDeviceNode,\n    KeyboardButton,\n    Lens,\n    LensNode,\n    Mat4,\n    ModelNode,\n    ModifierButtons,\n    MouseAndKeyboard,\n    MouseRecorder,\n    MouseWatcher,\n    NodePath,\n    Notify,\n    OrthographicLens,\n    PandaNode,\n    PandaSystem,\n    PerspectiveLens,\n    PGMouseWatcherBackground,\n    PGTop,\n    PNMImage,\n    PStatClient,\n    PythonCallbackObject,\n    RecorderController,\n    RenderModeAttrib,\n    RenderState,\n    RescaleNormalAttrib,\n    SceneGraphAnalyzerMeter,\n    TexGenAttrib,\n    Texture,\n    TextureStage,\n    Thread,\n    Trackball,\n    Transform2SG,\n    TransformState,\n    TrueClock,\n    VBase4,\n    VirtualFileSystem,\n    WindowProperties,\n    getModelPath,\n)\nfrom panda3d.direct import throw_new_frame, init_app_for_gui\nfrom panda3d.direct import storeAccessibilityShortcutKeys, allowAccessibilityShortcutKeys\nfrom . import DConfig\n\n# Register the extension methods for NodePath.\nfrom direct.extensions_native import NodePath_extensions # pylint: disable=unused-import\n\n# This needs to be available early for DirectGUI imports\nfrom typing import Any\nbuiltins: Any  # Tell mypy not to worry about us setting attributes on builtins\nimport sys\nimport builtins\nbuiltins.config = DConfig\n\nfrom direct.directnotify.DirectNotifyGlobal import directNotify, giveNotify\nfrom direct.directnotify.Notifier import Notifier\nfrom .MessengerGlobal import messenger\nfrom .BulletinBoardGlobal import bulletinBoard\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom .JobManagerGlobal import jobMgr\nfrom .EventManagerGlobal import eventMgr\nfrom .PythonUtil import Stack\n#from PythonUtil import *\nfrom direct.interval import IntervalManager\nfrom direct.showbase.BufferViewer import BufferViewer\nfrom direct.task import Task\nfrom . import Loader\nimport time\nimport atexit\nimport importlib\nfrom direct.showbase import ExceptionVarDump\nfrom . import DirectObject\nfrom . import SfxPlayer\nfrom typing import Callable, ClassVar, Literal, NoReturn\nif __debug__:\n    from direct.showbase import GarbageReport\n    from direct.directutil import DeltaProfiler\n    from . import OnScreenDebug\n    import warnings\n\n\n@atexit.register\ndef exitfunc() -> None:\n    base = getattr(builtins, 'base', None)\n    if base is not None:\n        base.destroy()\n\n# Now ShowBase is a DirectObject.  We need this so ShowBase can hang\n# hooks on messages, particularly on window-event.  This doesn't\n# *seem* to cause anyone any problems.\n\n\nclass ShowBase(DirectObject.DirectObject):\n\n    #: The deprecated `.DConfig` interface for accessing config variables.\n    config: ClassVar = DConfig\n    notify: ClassVar[Notifier] = directNotify.newCategory(\"ShowBase\")\n    guiItems: ClassVar[dict]\n\n    render2d: NodePath\n    aspect2d: NodePath\n    pixel2d: NodePath\n\n    def __init__(self, fStartDirect: bool = True, windowType: str | None = None) -> None:\n        \"\"\"Opens a window, sets up a 3-D and several 2-D scene graphs, and\n        everything else needed to render the scene graph to the window.\n\n        To prevent a window from being opened, set windowType to the string\n        'none' (or 'offscreen' to create an offscreen buffer).  If this is not\n        specified, the default value is taken from the 'window-type'\n        configuration variable.\n\n        This constructor will add various things to the Python builtins scope,\n        including this instance itself (under the name ``base``).\n        \"\"\"\n\n        from . import ShowBaseGlobal\n\n        #: Set if the want-dev Config.prc variable is enabled.  By default, it\n        #: is set to True except when using Python with the -O flag.\n        self.__dev__ = ShowBaseGlobal.__dev__\n        builtins.__dev__ = self.__dev__\n\n        logStackDump = (ConfigVariableBool('log-stack-dump', False).value or\n                        ConfigVariableBool('client-log-stack-dump', False).value)\n        uploadStackDump = ConfigVariableBool('upload-stack-dump', False).value\n        if logStackDump or uploadStackDump:\n            ExceptionVarDump.install(logStackDump, uploadStackDump)\n\n        if __debug__:\n            self.__autoGarbageLogging = self.__dev__ and ConfigVariableBool('auto-garbage-logging', False)\n\n        #: The directory containing the main Python file of this application.\n        self.mainDir = ExecutionEnvironment.getEnvironmentVariable(\"MAIN_DIR\")\n        self.main_dir = self.mainDir\n\n        # This contains the global appRunner instance, as imported from\n        # `.AppRunnerGlobal`.  This is deprecated and always None nowadays.\n        self.appRunner = None\n        self.app_runner = self.appRunner\n\n        #debug running multiplier\n        self.debugRunningMultiplier = 4\n\n        # [gjeon] to disable sticky keys\n        if ConfigVariableBool('disable-sticky-keys', False):\n            storeAccessibilityShortcutKeys()\n            allowAccessibilityShortcutKeys(False)\n            self.__disabledStickyKeys = True\n        else:\n            self.__disabledStickyKeys = False\n\n        self.printEnvDebugInfo()\n        vfs = VirtualFileSystem.getGlobalPtr()\n\n        self.nextWindowIndex = 1\n        self.__directStarted = False\n        self.__deadInputs = 0\n\n        # Store dconfig variables\n        self.sfxActive = ConfigVariableBool('audio-sfx-active', True).value\n        self.musicActive = ConfigVariableBool('audio-music-active', True).value\n        self.wantFog = ConfigVariableBool('want-fog', True).value\n        self.wantRender2dp = ConfigVariableBool('want-render2dp', True).value\n\n        self.screenshotExtension = ConfigVariableString('screenshot-extension', 'jpg').value\n        self.musicManager: AudioManager | None = None\n        self.musicManagerIsValid: bool | None = None\n        self.sfxManagerList: list[AudioManager] = []\n        self.sfxManagerIsValidList: list[bool] = []\n\n        self.wantStats = ConfigVariableBool('want-pstats', False).value\n        self.wantTk = False\n        self.wantWx = False\n        self.wantDirect = False\n\n        #: Fill this in with a function to invoke when the user \"exits\"\n        #: the program by closing the main window.\n        self.exitFunc: Callable[[], object] | None = None\n\n        #: Add final-exit callbacks to this list.  These will be called\n        #: when sys.exit() is called, after Panda has unloaded, and\n        #: just before Python is about to shut down.\n        self.finalExitCallbacks: list[Callable[[], object]] = []\n\n        # Set up the TaskManager to reset the PStats clock back\n        # whenever we resume from a pause.  This callback function is\n        # a little hacky, but we can't call it directly from within\n        # the TaskManager because he doesn't know about PStats (and\n        # has to run before libpanda is even loaded).\n        taskMgr.resumeFunc = PStatClient.resumeAfterPause\n\n        if self.__dev__:\n            self.__setupProfile()\n\n        # If the aspect ratio is 0 or None, it means to infer the\n        # aspect ratio from the window size.\n        # If you need to know the actual aspect ratio call base.getAspectRatio()\n        self.__configAspectRatio = ConfigVariableDouble('aspect-ratio', 0).value\n        # This variable is used to see if the aspect ratio has changed when\n        # we get a window-event.\n        self.__oldAspectRatio: float | None = None\n\n        #: This is set to the value of the window-type config variable, but may\n        #: optionally be overridden in the Showbase constructor.  Should either\n        #: be 'onscreen' (the default), 'offscreen' or 'none'.\n        self.windowType = windowType\n        if self.windowType is None:\n            self.windowType = ConfigVariableString('window-type', 'onscreen').value\n        self.requireWindow = ConfigVariableBool('require-window', True).value\n\n        #: This is the main, or only window; see `winList` for a list of *all* windows.\n        self.win: GraphicsOutput | None = None\n        self.frameRateMeter: FrameRateMeter | None = None\n        self.sceneGraphAnalyzerMeter: SceneGraphAnalyzerMeter | None = None\n        #: A list of all windows opened via `openWindow()`.\n        self.winList: list[GraphicsEngine] = []\n        self.winControls: list[WindowControls] = []\n        self.mainWinMinimized = False\n        self.mainWinForeground = False\n        #: Contains the :class:`~panda3d.core.GraphicsPipe` object created by\n        #: `makeDefaultPipe()`.\n        self.pipe: GraphicsPipe | None = None\n        #: The full list of :class:`~panda3d.core.GraphicsPipe` objects,\n        #: including any auxiliary pipes.  Filled by `makeAllPipes()`.\n        self.pipeList: list[GraphicsPipe] = []\n        self.mouse2cam: NodePath | None = None\n        self.buttonThrowers: list[ButtonThrower] | None = None\n        self.mouseWatcher: NodePath | None = None\n        #: The :class:`~panda3d.core.MouseWatcher` object, created by\n        #: `setupMouse()`.\n        self.mouseWatcherNode: MouseWatcher | None = None\n        self.pointerWatcherNodes: list[MouseWatcher] | None = None\n        self.mouseInterface: NodePath | None = None\n        self.drive: NodePath | None = None\n        self.trackball: NodePath | None = None\n        self.texmem: Any | None = None\n        self.showVertices: NodePath | None = None\n        self.deviceButtonThrowers: list[NodePath] = []\n\n        #: This is a :class:`~panda3d.core.NodePath` pointing to the\n        #: :class:`~panda3d.core.Camera` object set up for the 3D scene.\n        #: Usually a child of `camera`.\n        self.cam: NodePath | None = None\n        #: Same as `cam`, but for the 2D scene graph.\n        self.cam2d: NodePath | None = None\n        #: Same as `cam2d`, but for the 2D overlay scene graph.\n        self.cam2dp: NodePath | None = None\n\n        #: This is the :class:`~panda3d.core.NodePath` that should be used to\n        #: manipulate the camera.  It points at the node to which the default\n        #: camera (`cam`, `camNode`) is attached.\n        self.camera: NodePath | None = None\n        #: Same as `camera`, but for the 2D scene graph.  Parent of `cam2d`.\n        self.camera2d: NodePath | None = None\n        #: Same as `camera2d`, but for the 2D overlay scene graph.  Parent of\n        #: `cam2dp`.\n        self.camera2dp: NodePath | None = None\n\n        #: A list of all cameras created with `makeCamera()`, including `cam`.\n        self.camList: list[NodePath] = []\n        #: Convenience accessor for base.cam.node(), containing a\n        #: :class:`~panda3d.core.Camera` object.\n        self.camNode: Camera | None = None\n        #: Convenience accessor for base.camNode.get_lens(), containing a\n        #: :class:`~panda3d.core.Lens` object.\n        self.camLens: Lens | None = None\n        self.camFrustumVis: NodePath | None = None\n        self.direct = None\n        #: This is used to store the wx.Application object used when want-wx is\n        #: set or `startWx()` is called.\n        self.wxApp: Any | None = None\n        self.wxAppCreated = False\n        self.tkRoot: Any | None = None\n        self.tkRootCreated = False\n\n        # This is used for syncing multiple PCs in a distributed cluster\n        if hasattr(builtins, 'clusterSyncFlag'):\n            # Has the cluster sync variable been set externally?\n            self.clusterSyncFlag = builtins.clusterSyncFlag\n        else:\n            # Has the clusterSyncFlag been set via a config variable\n            self.clusterSyncFlag = ConfigVariableBool('cluster-sync', False)\n\n        # We've already created aspect2d in ShowBaseGlobal, for the\n        # benefit of creating DirectGui elements before ShowBase.\n        self.hidden = ShowBaseGlobal.hidden\n\n        #: The global :class:`~panda3d.core.GraphicsEngine`, as returned by\n        #: GraphicsEngine.getGlobalPtr()\n        self.graphicsEngine = GraphicsEngine.getGlobalPtr()\n        self.graphics_engine = self.graphicsEngine\n        self.setupRender()\n        self.setupRender2d()\n        self.setupDataGraph()\n\n        if self.wantRender2dp:\n            self.setupRender2dp()\n\n        #: A placeholder for a :class:`~panda3d.core.CollisionTraverser`.  If\n        #: someone stores a CollisionTraverser pointer here, ShowBase will\n        #: traverse it automatically in the collisionLoop task, so you won't\n        #: need to call :meth:`~panda3d.core.CollisionTraverser.traverse()`\n        #: yourself every frame.\n        self.cTrav: CollisionTraverser | Literal[0] = 0\n        self.shadowTrav: CollisionTraverser | Literal[0] = 0\n        self.cTravStack = Stack()\n        # Ditto for an AppTraverser.\n        self.appTrav: Any | Literal[0] = 0\n\n        # This is the DataGraph traverser, which we might as well\n        # create now.\n        self.dgTrav = DataGraphTraverser()\n\n        # Maybe create a RecorderController to record and/or play back\n        # the user session.\n        self.recorder: RecorderController | None = None\n        playbackSession = ConfigVariableFilename('playback-session', '')\n        recordSession = ConfigVariableFilename('record-session', '')\n        if not playbackSession.empty():\n            self.recorder = RecorderController()\n            self.recorder.beginPlayback(playbackSession.value)\n        elif not recordSession.empty():\n            self.recorder = RecorderController()\n            self.recorder.beginRecord(recordSession.value)\n\n        if self.recorder:\n            # If we're either playing back or recording, pass the\n            # random seed into the system so each session will have\n            # the same random seed.\n            import random #, whrandom\n\n            seed = self.recorder.getRandomSeed()\n            random.seed(seed)\n            #whrandom.seed(seed & 0xff, (seed >> 8) & 0xff, (seed >> 16) & 0xff)\n\n        # For some reason, wx needs to be initialized before the graphics window\n        if sys.platform == \"darwin\":\n            if ConfigVariableBool(\"want-wx\", False):\n                wx = importlib.import_module('wx')\n                self.wxApp = wx.App()\n\n            # Same goes for Tk, which uses a conflicting NSApplication\n            if ConfigVariableBool(\"want-tk\", False):\n                Pmw = importlib.import_module('Pmw')\n                self.tkRoot = Pmw.initialise()\n\n        # Open the default rendering window.\n        if self.windowType != 'none':\n            props = WindowProperties.getDefault()\n            if ConfigVariableBool('read-raw-mice', False):\n                props.setRawMice(1)\n            self.openDefaultWindow(startDirect = False, props=props)\n\n        # The default is trackball mode, which is more convenient for\n        # ad-hoc development in Python using ShowBase.  Applications\n        # can explicitly call base.useDrive() if they prefer a drive\n        # interface.\n        self.mouseInterface = self.trackball\n        self.useTrackball()\n\n        #: `.Loader.Loader` object.\n        self.loader = ShowBaseGlobal.loader\n        self.loader._init_base(self)\n        self.graphicsEngine.setDefaultLoader(self.loader.loader)\n\n        #: The global event manager, as imported from `.EventManagerGlobal`.\n        self.eventMgr = eventMgr\n        #: The global messenger, as imported from `.MessengerGlobal`.\n        self.messenger = messenger\n        #: The global bulletin board, as imported from `.BulletinBoardGlobal`.\n        self.bboard = bulletinBoard\n        #: The global task manager, as imported from `.TaskManagerGlobal`.\n        self.taskMgr = taskMgr\n        self.task_mgr = taskMgr\n        #: The global job manager, as imported from `.JobManagerGlobal`.\n        self.jobMgr = jobMgr\n\n        #: If `enableParticles()` has been called, this is the particle manager\n        #: as imported from :mod:`direct.particles.ParticleManagerGlobal`.\n        self.particleMgr = None\n        self.particleMgrEnabled = False\n\n        #: If `enableParticles()` has been called, this is the physics manager\n        #: as imported from :mod:`direct.showbase.PhysicsManagerGlobal`.\n        self.physicsMgr = None\n        self.physicsMgrEnabled = False\n        self.physicsMgrAngular = False\n\n        #: This is the global :class:`~panda3d.core.InputDeviceManager`, which\n        #: keeps track of connected input devices.\n        self.devices = InputDeviceManager.getGlobalPtr()\n        self.__inputDeviceNodes: dict[InputDevice, NodePath] = {}\n\n        self.createStats()\n\n        self.AppHasAudioFocus = True\n\n        # Get a pointer to Panda's global ClockObject, used for\n        # synchronizing events between Python and C.\n        clock = ClockObject.getGlobalClock()\n\n        #: This is the global :class:`~panda3d.core.ClockObject`.\n        self.clock = clock\n\n        # Since we have already started up a TaskManager, and probably\n        # a number of tasks; and since the TaskManager had to use the\n        # TrueClock to tell time until this moment, make sure the\n        # globalClock object is exactly in sync with the TrueClock.\n        trueClock = TrueClock.getGlobalPtr()\n        clock.setRealTime(trueClock.getShortTime())\n        clock.tick()\n\n        # Now we can make the TaskManager start using the new clock.\n        taskMgr.globalClock = clock\n\n        # client CPU affinity is determined by, in order:\n        # - client-cpu-affinity-mask config\n        # - pcalt-# (# is CPU number, 0-based)\n        # - client-cpu-affinity config\n        # - auto-single-cpu-affinity config\n        affinityMask = ConfigVariableInt('client-cpu-affinity-mask', -1).value\n        if affinityMask != -1:\n            TrueClock.getGlobalPtr().setCpuAffinity(affinityMask)\n        else:\n            # this is useful on machines that perform better with each process\n            # assigned to a single CPU\n            autoAffinity = ConfigVariableBool('auto-single-cpu-affinity', False).value\n            affinity = None\n            if autoAffinity and hasattr(builtins, 'clientIndex'):\n                affinity = abs(int(builtins.clientIndex))\n            else:\n                affinity = ConfigVariableInt('client-cpu-affinity', -1).value\n            if (affinity in (None, -1)) and autoAffinity:\n                affinity = 0\n            if affinity is not None and affinity != -1:\n                # Windows XP supports a 32-bit affinity mask\n                TrueClock.getGlobalPtr().setCpuAffinity(1 << (affinity % 32))\n\n        # Make sure we're not making more than one ShowBase.\n        if hasattr(builtins, 'base'):\n            raise Exception(\"Attempt to spawn multiple ShowBase instances!\")\n\n        # DO NOT ADD TO THIS LIST.  We're trying to phase out the use of\n        # built-in variables by ShowBase.  Use a Global module if necessary.\n        builtins.base = self\n        builtins.render2d = self.render2d\n        builtins.aspect2d = self.aspect2d\n        builtins.pixel2d = self.pixel2d\n        builtins.render = self.render\n        builtins.hidden = self.hidden\n        builtins.camera = self.camera\n        builtins.loader = self.loader\n        builtins.taskMgr = self.taskMgr\n        builtins.jobMgr = self.jobMgr\n        builtins.eventMgr = self.eventMgr\n        builtins.messenger = self.messenger\n        builtins.bboard = self.bboard\n        # Config needs to be defined before ShowBase is constructed\n        #builtins.config = self.config\n        builtins.ostream = Notify.out()\n        builtins.directNotify = directNotify\n        builtins.giveNotify = giveNotify\n        builtins.globalClock = clock\n        builtins.vfs = vfs\n        builtins.cpMgr = ConfigPageManager.getGlobalPtr()\n        builtins.cvMgr = ConfigVariableManager.getGlobalPtr()\n        builtins.pandaSystem = PandaSystem.getGlobalPtr()\n        if __debug__:\n            builtins.deltaProfiler = DeltaProfiler.DeltaProfiler(\"ShowBase\")\n            self.onScreenDebug = OnScreenDebug.OnScreenDebug()\n            builtins.onScreenDebug = self.onScreenDebug\n\n        if self.wantRender2dp:\n            builtins.render2dp = self.render2dp\n            builtins.aspect2dp = self.aspect2dp\n            builtins.pixel2dp = self.pixel2dp\n\n        # Now add this instance to the ShowBaseGlobal module scope.\n        builtins.run = ShowBaseGlobal.run\n        ShowBaseGlobal.base = self\n        ShowBaseGlobal.__dev__ = self.__dev__\n\n        if self.__dev__:\n            ShowBase.notify.debug('__dev__ == %s' % self.__dev__)\n        else:\n            ShowBase.notify.info('__dev__ == %s' % self.__dev__)\n\n        self.createBaseAudioManagers()\n\n        if self.__dev__ and ConfigVariableBool('track-gui-items', False):\n            # dict of guiId to gui item, for tracking down leaks\n            if not hasattr(ShowBase, 'guiItems'):\n                ShowBase.guiItems = {}\n\n        # optionally restore the default gui sounds from 1.7.2 and earlier\n        if ConfigVariableBool('orig-gui-sounds', False).value:\n            from direct.gui import DirectGuiGlobals as DGG\n            DGG.setDefaultClickSound(self.loader.loadSfx(\"audio/sfx/GUI_click.wav\"))\n            DGG.setDefaultRolloverSound(self.loader.loadSfx(\"audio/sfx/GUI_rollover.wav\"))\n\n        # Create a private DirectObject - allowing base.accept for window-event\n        # as well as allowing ShowBase's default handling of this.\n        self.__directObject = DirectObject.DirectObject()\n\n        # Now hang a hook on the window-event from Panda.  This allows\n        # us to detect when the user resizes, minimizes, or closes the\n        # main window.\n        self.__prevWindowProperties: WindowProperties | None = None\n        self.__directObject.accept('window-event', self.windowEvent)\n\n        # Transition effects (fade, iris, etc)\n        from . import Transitions\n\n        #: `.Transitions.Transitions` object.\n        self.transitions = Transitions.Transitions(self.loader)\n\n        if self.win:\n            # Setup the window controls - handy for multiwindow applications\n            self.setupWindowControls()\n\n        # Client sleep\n        sleepTime = ConfigVariableDouble('client-sleep', 0.0)\n        self.clientSleep = 0.0\n        self.setSleep(sleepTime.value)\n\n        # Extra sleep for running 4+ clients on a single machine\n        # adds a sleep right after the main render in igloop\n        # tends to even out the frame rate and keeps it from going\n        # to zero in the out of focus windows\n        self.multiClientSleep = ConfigVariableBool('multi-sleep', False)\n\n        #: Utility for viewing offscreen buffers, see :mod:`.BufferViewer`.\n        self.bufferViewer = BufferViewer(self.win, self.render2dp if self.wantRender2dp else self.render2d)\n\n        if self.windowType != 'none':\n            if fStartDirect: # [gjeon] if this is False let them start direct manually\n                self.__doStartDirect()\n\n            if ConfigVariableBool('show-tex-mem', False):\n                if not self.texmem or self.texmem.cleanedUp:\n                    self.toggleTexMem()\n\n        taskMgr.finalInit()\n\n        # Start IGLOOP\n        self.restart()\n\n    # add a collision traverser via pushCTrav and remove it via popCTrav\n    # that way the owner of the new cTrav doesn't need to hold onto the\n    # previous one in order to put it back\n    def pushCTrav(self, cTrav):\n        self.cTravStack.push(self.cTrav)\n        self.cTrav = cTrav\n\n    def popCTrav(self):\n        self.cTrav = self.cTravStack.pop()\n\n    def __setupProfile(self):\n        \"\"\" Sets up the Python profiler, if available, according to\n        some Panda config settings. \"\"\"\n\n        try:\n            profile = importlib.import_module('profile')\n            pstats = importlib.import_module('pstats')\n        except ImportError:\n            return\n\n        profile.Profile.bias = ConfigVariableDouble(\"profile-bias\", 0.0).value\n\n        def f8(x):\n            return (\"%\" + \"8.%df\" % ConfigVariableInt(\"profile-decimals\", 3)) % x\n        pstats.f8 = f8\n\n    # temp; see ToonBase.py\n    def getExitErrorCode(self):\n        return 0\n\n    def printEnvDebugInfo(self):\n        \"\"\"Print some information about the environment that we are running\n        in.  Stuff like the model paths and other paths.  Feel free to\n        add stuff to this.\n        \"\"\"\n        if ConfigVariableBool('want-env-debug-info', False):\n            print(\"\\n\\nEnvironment Debug Info {\")\n            print(\"* model path:\")\n            print(getModelPath())\n            #print \"* dna path:\"\n            #print getDnaPath()\n            print(\"}\")\n\n    def destroy(self) -> None:\n        \"\"\" Call this function to destroy the ShowBase and stop all\n        its tasks, freeing all of the Panda resources.  Normally, you\n        should not need to call it explicitly, as it is bound to the\n        exitfunc and will be called at application exit time\n        automatically.\n\n        This function is designed to be safe to call multiple times.\n\n        When called from a thread other than the main thread, this will create\n        a task to schedule the destroy on the main thread, and wait for this to\n        complete.\n        \"\"\"\n\n        if sys.platform != \"android\" and Thread.getCurrentThread() != Thread.getMainThread():\n            task = taskMgr.add(self.destroy, extraArgs=[])\n            task.wait()\n            return\n\n        for cb in self.finalExitCallbacks[:]:\n            cb()\n\n        # Remove the built-in base reference\n        if getattr(builtins, 'base', None) is self:\n            del builtins.run\n            del builtins.base\n            del builtins.loader\n            del builtins.taskMgr\n            ShowBaseGlobal = sys.modules.get('direct.showbase.ShowBaseGlobal', None)\n            if ShowBaseGlobal:\n                del ShowBaseGlobal.base\n\n        self.aspect2d.node().removeAllChildren()\n        self.render2d.node().removeAllChildren()\n        self.aspect2d.reparent_to(self.render2d)\n\n        # [gjeon] restore sticky key settings\n        if self.__disabledStickyKeys:\n            allowAccessibilityShortcutKeys(True)\n            self.__disabledStickyKeys = False\n\n        self.__directObject.ignoreAll()\n        self.ignoreAll()\n        self.shutdown()\n\n        if getattr(self, 'musicManager', None):\n            assert self.musicManager is not None\n            self.musicManager.shutdown()\n            self.musicManager = None\n            for sfxManager in self.sfxManagerList:\n                sfxManager.shutdown()\n            self.sfxManagerList = []\n        if getattr(self, 'loader', None):\n            self.loader.destroy()\n            del self.loader\n        if getattr(self, 'graphicsEngine', None):\n            self.graphicsEngine.removeAllWindows()\n\n        try:\n            self.direct.panel.destroy()  # type: ignore[attr-defined]\n        except Exception:\n            pass\n\n        self.win = None\n        self.winList.clear()\n        self.pipe = None\n\n    def makeDefaultPipe(self, printPipeTypes = None):\n        \"\"\"\n        Creates the default GraphicsPipe, which will be used to make\n        windows unless otherwise specified.\n        \"\"\"\n        assert self.pipe is None\n\n        if printPipeTypes is None:\n            # When the user didn't specify an explicit setting, take the value\n            # from the config variable. We could just omit the parameter, however\n            # this way we can keep backward compatibility.\n            printPipeTypes = ConfigVariableBool(\"print-pipe-types\", True).value\n\n        selection = GraphicsPipeSelection.getGlobalPtr()\n        if printPipeTypes:\n            selection.printPipeTypes()\n        self.pipe = selection.makeDefaultPipe()\n        if not self.pipe:\n            self.notify.error(\n                \"No graphics pipe is available!\\n\"\n                \"Your Config.prc file must name at least one valid panda display\\n\"\n                \"library via load-display or aux-display.\")\n\n        self.notify.info(\"Default graphics pipe is %s (%s).\" % (\n            self.pipe.getType().getName(), self.pipe.getInterfaceName()))\n        self.pipeList.append(self.pipe)\n\n    def makeModulePipe(self, moduleName):\n        \"\"\"\n        Returns a GraphicsPipe from the indicated module,\n        e.g. 'pandagl' or 'pandadx9'.  Does not affect base.pipe or\n        base.pipeList.\n\n        :rtype: panda3d.core.GraphicsPipe\n        \"\"\"\n\n        selection = GraphicsPipeSelection.getGlobalPtr()\n        return selection.makeModulePipe(moduleName)\n\n    def makeAllPipes(self):\n        \"\"\"\n        Creates all GraphicsPipes that the system knows about and fill up\n        `pipeList` with them.\n        \"\"\"\n        selection = GraphicsPipeSelection.getGlobalPtr()\n        selection.loadAuxModules()\n\n        # First, we should make sure the default pipe exists.\n        if self.pipe is None:\n            self.makeDefaultPipe()\n\n        # Now go through the list of known pipes, and make each one if\n        # we don't have one already.\n        numPipeTypes = selection.getNumPipeTypes()\n        for i in range(numPipeTypes):\n            pipeType = selection.getPipeType(i)\n\n            # Do we already have a pipe of this type on the list?\n            # This operation is n-squared, but presumably there won't\n            # be more than a handful of pipe types, so who cares.\n            already = 0\n            for pipe in self.pipeList:\n                if pipe.getType() == pipeType:\n                    already = 1\n\n            if not already:\n                pipe = selection.makePipe(pipeType)\n                if pipe:\n                    self.notify.info(\"Got aux graphics pipe %s (%s).\" % (\n                        pipe.getType().getName(), pipe.getInterfaceName()))\n                    self.pipeList.append(pipe)\n                else:\n                    self.notify.info(\"Could not make graphics pipe %s.\" % (\n                        pipeType.getName()))\n\n    def openWindow(self, props = None, fbprops = None, pipe = None, gsg = None,\n                   host = None, type = None, name = None, size = None,\n                   aspectRatio = None, makeCamera = True, keepCamera = False,\n                   scene = None, stereo = None, unexposedDraw = None,\n                   callbackWindowDict = None, requireWindow = None):\n        \"\"\"\n        Creates a window and adds it to the list of windows that are\n        to be updated every frame.\n\n        :param props: the :class:`~panda3d.core.WindowProperties` that\n                      describes the window.\n\n        :param fbprops: the :class:`~panda3d.core.FrameBufferProperties`\n                        indicating the requested framebuffer properties.\n\n        :param type: Either 'onscreen', 'offscreen', or 'none'.\n\n        :param keepCamera: If True, the existing base.cam is set up to\n                           render into the new window.\n\n        :param makeCamera: If True (and keepCamera is False), a new camera is\n                           set up to render into the new window.\n\n        :param unexposedDraw: If not None, it specifies the initial value\n                              of :meth:`~panda3d.core.GraphicsWindow.setUnexposedDraw()`.\n\n        :param callbackWindowDict: If not None, a\n                                   :class:`~panda3d.core.CallbackGraphicsWindow`\n                                   is created instead, which allows the caller\n                                   to create the actual window with its own\n                                   OpenGL context, and direct Panda's rendering\n                                   into that window.\n\n        :param requireWindow: If True, the function should raise an exception\n                              if the window fails to open correctly.\n\n        :rtype: panda3d.core.GraphicsWindow\n        \"\"\"\n\n        # Save this lambda here for convenience; we'll use it to call\n        # down to the underlying _doOpenWindow() with all of the above\n        # parameters.\n        func = lambda: self._doOpenWindow(\n            props = props, fbprops = fbprops, pipe = pipe, gsg = gsg,\n            host = host, type = type, name = name, size = size,\n            aspectRatio = aspectRatio, makeCamera = makeCamera,\n            keepCamera = keepCamera, scene = scene, stereo = stereo,\n            unexposedDraw = unexposedDraw,\n            callbackWindowDict = callbackWindowDict)\n\n        if self.win:\n            # If we've already opened a window before, this is just a\n            # pass-through to _doOpenWindow().\n            win = func()\n            self.graphicsEngine.openWindows()\n            return win\n\n        if type is None:\n            type = self.windowType\n        if requireWindow is None:\n            requireWindow = self.requireWindow\n\n        win = func()\n\n        # Give the window a chance to truly open.\n        self.graphicsEngine.openWindows()\n        if win is not None and not win.isValid():\n            self.notify.info(\"Window did not open, removing.\")\n            self.closeWindow(win)\n            win = None\n\n        if win is None and pipe is None:\n            # Try a little harder if the window wouldn't open.\n            self.makeAllPipes()\n            try:\n                self.pipeList.remove(self.pipe)\n            except ValueError:\n                pass\n            while self.win is None and self.pipeList:\n                self.pipe = self.pipeList[0]\n                self.notify.info(\"Trying pipe type %s (%s)\" % (\n                    self.pipe.getType(), self.pipe.getInterfaceName()))\n                win = func()\n\n                self.graphicsEngine.openWindows()\n                if win is not None and not win.isValid():\n                    self.notify.info(\"Window did not open, removing.\")\n                    self.closeWindow(win)\n                    win = None\n                if win is None:\n                    self.pipeList.remove(self.pipe)\n\n        if win is None:\n            self.notify.warning(\"Unable to open '%s' window.\" % (type))\n            if requireWindow:\n                # Unless require-window is set to false, it is an\n                # error not to open a window.\n                raise Exception('Could not open window.')\n        else:\n            self.notify.info(\"Successfully opened window of type %s (%s)\" % (\n                win.getType(), win.getPipe().getInterfaceName()))\n\n        return win\n\n    def _doOpenWindow(self, props = None, fbprops = None, pipe = None,\n                      gsg = None, host = None, type = None, name = None,\n                      size = None, aspectRatio = None,\n                      makeCamera = True, keepCamera = False,\n                      scene = None, stereo = None, unexposedDraw = None,\n                      callbackWindowDict = None):\n        if pipe is None:\n            pipe = self.pipe\n\n            if pipe is None:\n                self.makeDefaultPipe()\n                pipe = self.pipe\n\n            if pipe is None:\n                # We couldn't get a pipe.\n                return None\n\n        if isinstance(gsg, GraphicsOutput):\n            # If the gsg is a window or buffer, it means to use the\n            # GSG from that buffer.\n            host = gsg\n            gsg = gsg.getGsg()\n\n        # If we are using DirectX, force a new GSG to be created,\n        # since at the moment DirectX seems to misbehave if we do\n        # not do this.  This will cause a delay while all textures\n        # etc. are reloaded, so we should revisit this later if we\n        # can fix the underlying bug in our DirectX support.\n        if pipe.getType().getName().startswith('wdx'):\n            gsg = None\n\n        if type is None:\n            type = self.windowType\n\n        if props is None:\n            props = WindowProperties.getDefault()\n\n        if fbprops is None:\n            fbprops = FrameBufferProperties.getDefault()\n\n        if size is not None:\n            # If we were given an explicit size, use it; otherwise,\n            # the size from the properties is used.\n            props = WindowProperties(props)\n            props.setSize(size[0], size[1])\n\n        if name is None:\n            name = 'window%s' % (self.nextWindowIndex)\n            self.nextWindowIndex += 1\n\n        win = None\n\n        flags = GraphicsPipe.BFFbPropsOptional\n        if type == 'onscreen':\n            flags = flags | GraphicsPipe.BFRequireWindow\n        elif type == 'offscreen':\n            flags = flags | GraphicsPipe.BFRefuseWindow\n\n        if callbackWindowDict:\n            flags = flags | GraphicsPipe.BFRequireCallbackWindow\n\n        if host:\n            assert host.isValid()\n            win = self.graphicsEngine.makeOutput(pipe, name, 0, fbprops,\n                                                 props, flags, host.getGsg(), host)\n        elif gsg:\n            win = self.graphicsEngine.makeOutput(pipe, name, 0, fbprops,\n                                                 props, flags, gsg)\n        else:\n            win = self.graphicsEngine.makeOutput(pipe, name, 0, fbprops,\n                                                 props, flags)\n\n        if win is None:\n            # Couldn't create a window!\n            return None\n\n        if unexposedDraw is not None and hasattr(win, 'setUnexposedDraw'):\n            win.setUnexposedDraw(unexposedDraw)\n\n        if callbackWindowDict:\n            # If we asked for (and received) a CallbackGraphicsWindow,\n            # we now have to assign the callbacks, before we start\n            # trying to do anything with the window.\n            for callbackName in ['Events', 'Properties', 'Render']:\n                func = callbackWindowDict.get(callbackName, None)\n                if not func:\n                    continue\n\n                setCallbackName = 'set%sCallback' % (callbackName)\n                setCallback = getattr(win, setCallbackName)\n                setCallback(PythonCallbackObject(func))\n\n            # We also need to set up the mouse/keyboard objects.\n            for inputName in callbackWindowDict.get('inputDevices', ['mouse']):\n                win.createInputDevice(inputName)\n\n        if hasattr(win, \"requestProperties\"):\n            win.requestProperties(props)\n\n        mainWindow = False\n        if self.win is None:\n            mainWindow = True\n            self.win = win\n            if hasattr(self, 'bufferViewer'):\n                self.bufferViewer.win = win\n\n        self.winList.append(win)\n\n        # Set up a 3-d camera for the window by default.\n        if keepCamera:\n            self.makeCamera(win, scene = scene, aspectRatio = aspectRatio,\n                            stereo = stereo, useCamera = self.cam)\n        elif makeCamera:\n            self.makeCamera(win, scene = scene, aspectRatio = aspectRatio,\n                            stereo = stereo)\n\n        messenger.send('open_window', [win, mainWindow])\n        if mainWindow:\n            messenger.send('open_main_window')\n\n        return win\n\n    def closeWindow(self, win, keepCamera = False, removeWindow = True):\n        \"\"\"\n        Closes the indicated window and removes it from the list of\n        windows.  If it is the main window, clears the main window\n        pointer to None.\n        \"\"\"\n        win.setActive(False)\n\n        # First, remove all of the cameras associated with display\n        # regions on the window.\n        numRegions = win.getNumDisplayRegions()\n        for i in range(numRegions):\n            dr = win.getDisplayRegion(i)\n            # [gjeon] remove drc in base.direct.drList\n            if self.direct is not None:\n                for drc in self.direct.drList:\n                    if drc.cam == dr.getCamera():\n                        self.direct.drList.displayRegionList.remove(drc)\n                        break\n\n            cam = NodePath(dr.getCamera())\n\n            dr.setCamera(NodePath())\n\n            if not cam.isEmpty() and \\\n               cam.node().getNumDisplayRegions() == 0 and \\\n               not keepCamera:\n                # If the camera is used by no other DisplayRegions,\n                # remove it.\n                if self.camList.count(cam) != 0:\n                    self.camList.remove(cam)\n\n                # Don't throw away self.camera; we want to\n                # preserve it for reopening the window.\n                if cam == self.cam:\n                    self.cam = None\n                if cam == self.cam2d:\n                    self.cam2d = None\n                if cam == self.cam2dp:\n                    self.cam2dp = None\n                cam.removeNode()\n\n        # [gjeon] remove winControl\n        for winCtrl in self.winControls:\n            if winCtrl.win == win:\n                self.winControls.remove(winCtrl)\n                break\n        # Now we can actually close the window.\n        if removeWindow:\n            self.graphicsEngine.removeWindow(win)\n        self.winList.remove(win)\n\n        mainWindow = False\n        if win == self.win:\n            mainWindow = True\n            self.win = None\n            if self.frameRateMeter:\n                self.frameRateMeter.clearWindow()\n                self.frameRateMeter = None\n            if self.sceneGraphAnalyzerMeter:\n                self.sceneGraphAnalyzerMeter.clearWindow()\n                self.sceneGraphAnalyzerMeter = None\n\n        messenger.send('close_window', [win, mainWindow])\n        if mainWindow:\n            messenger.send('close_main_window')\n\n        if not self.winList:\n            # Give the window(s) a chance to actually close before we\n            # continue.\n            self.graphicsEngine.renderFrame()\n\n    def openDefaultWindow(self, *args, **kw):\n        \"\"\"\n        Creates the main window for the first time, without being too\n        particular about the kind of graphics API that is chosen.\n        The suggested window type from the load-display config variable is\n        tried first; if that fails, the first window type that can be\n        successfully opened at all is accepted.\n\n        This is intended to be called only once, at application startup.\n        It is normally called automatically unless window-type is configured\n        to 'none'.\n\n        :returns: True on success, False on failure.\n        \"\"\"\n\n        startDirect = kw.get('startDirect', True)\n        if 'startDirect' in kw:\n            del kw['startDirect']\n\n        self.openMainWindow(*args, **kw)\n\n        if startDirect:\n            self.__doStartDirect()\n\n        return self.win is not None\n\n    def openMainWindow(self, *args, **kw):\n        \"\"\"\n        Creates the initial, main window for the application, and sets\n        up the mouse and render2d structures appropriately for it.  If\n        this method is called a second time, it will close the\n        previous main window and open a new one, preserving the lens\n        properties in base.camLens.\n\n        :returns: True on success, or False on failure (in which case base.win\n                  may be either None, or the previous, closed window).\n        \"\"\"\n        keepCamera = kw.get('keepCamera', False)\n\n        success = 1\n        oldWin = self.win\n        oldLens = self.camLens\n        oldClearColorActive = None\n        if self.win is not None:\n            # Close the previous window.\n            oldClearColorActive = self.win.getClearColorActive()\n            oldClearColor = VBase4(self.win.getClearColor())\n            oldClearDepthActive = self.win.getClearDepthActive()\n            oldClearDepth = self.win.getClearDepth()\n            oldClearStencilActive = self.win.getClearStencilActive()\n            oldClearStencil = self.win.getClearStencil()\n            self.closeWindow(self.win, keepCamera = keepCamera)\n\n        # Open a new window.\n        self.openWindow(*args, **kw)\n        if self.win is None:\n            self.win = oldWin\n            self.winList.append(oldWin)\n            success = 0\n\n        if self.win is not None:\n            if isinstance(self.win, GraphicsWindow):\n                self.setupMouse(self.win)\n            self.makeCamera2d(self.win)\n\n            if self.wantRender2dp:\n                self.makeCamera2dp(self.win)\n\n            if oldLens is not None:\n                # Restore the previous lens properties.\n                self.camNode.setLens(oldLens)\n                self.camLens = oldLens\n\n            if oldClearColorActive is not None:\n                # Restore the previous clear properties.\n                self.win.setClearColorActive(oldClearColorActive)\n                self.win.setClearColor(oldClearColor)\n                self.win.setClearDepthActive(oldClearDepthActive)\n                self.win.setClearDepth(oldClearDepth)\n                self.win.setClearStencilActive(oldClearStencilActive)\n                self.win.setClearStencil(oldClearStencil)\n\n            flag = ConfigVariableBool('show-frame-rate-meter', False)\n            self.setFrameRateMeter(flag.value)\n            flag = ConfigVariableBool('show-scene-graph-analyzer-meter', False)\n            self.setSceneGraphAnalyzerMeter(flag.value)\n        return success\n\n    def setSleep(self, amount: float) -> None:\n        \"\"\"\n        Sets up a task that calls python 'sleep' every frame.  This is a simple\n        way to reduce the CPU usage (and frame rate) of a panda program.\n        \"\"\"\n        if self.clientSleep == amount:\n            return\n        self.clientSleep = amount\n        if amount == 0.0:\n            self.taskMgr.remove('clientSleep')\n        else:\n            # Spawn it after igloop (at the end of each frame)\n            self.taskMgr.remove('clientSleep')\n            self.taskMgr.add(self.__sleepCycleTask, 'clientSleep', sort = 55)\n\n    def __sleepCycleTask(self, task):\n        Thread.sleep(self.clientSleep)\n        #time.sleep(self.clientSleep)\n        return Task.cont\n\n    def setFrameRateMeter(self, flag: bool) -> None:\n        \"\"\"\n        Turns on or off (according to flag) a standard frame rate\n        meter in the upper-right corner of the main window.\n        \"\"\"\n        if flag:\n            if not self.frameRateMeter:\n                self.frameRateMeter = FrameRateMeter('frameRateMeter')\n                self.frameRateMeter.setupWindow(self.win)\n        else:\n            if self.frameRateMeter:\n                self.frameRateMeter.clearWindow()\n                self.frameRateMeter = None\n\n    def setSceneGraphAnalyzerMeter(self, flag: bool) -> None:\n        \"\"\"\n        Turns on or off (according to flag) a standard frame rate\n        meter in the upper-right corner of the main window.\n        \"\"\"\n        if flag:\n            if not self.sceneGraphAnalyzerMeter:\n                self.sceneGraphAnalyzerMeter = SceneGraphAnalyzerMeter('sceneGraphAnalyzerMeter', self.render.node())\n                self.sceneGraphAnalyzerMeter.setupWindow(self.win)\n        else:\n            if self.sceneGraphAnalyzerMeter:\n                self.sceneGraphAnalyzerMeter.clearWindow()\n                self.sceneGraphAnalyzerMeter = None\n\n    # [gjeon] now you can add more winControls after creating a showbase instance\n    def setupWindowControls(self, winCtrl=None):\n        if winCtrl is None:\n            winCtrl = WindowControls(\n                self.win, mouseWatcher=self.mouseWatcher,\n                cam=self.camera, camNode = self.camNode, cam2d=self.camera2d,\n                mouseKeyboard = self.dataRoot.find(\"**/*\"))\n        self.winControls.append(winCtrl)\n\n    def setupRender(self) -> None:\n        \"\"\"\n        Creates the render scene graph, the primary scene graph for\n        rendering 3-d geometry.\n        \"\"\"\n        #: This is the root of the 3-D scene graph.\n        self.render = NodePath('render')\n        self.render.setAttrib(RescaleNormalAttrib.makeDefault())\n\n        self.render.setTwoSided(0)\n        self.backfaceCullingEnabled = True\n        self.textureEnabled = True\n        self.wireframeEnabled = False\n\n    def setupRender2d(self) -> None:\n        \"\"\"\n        Creates the render2d scene graph, the primary scene graph for\n        2-d objects and gui elements that are superimposed over the\n        3-d geometry in the window.\n        \"\"\"\n        # We've already created render2d and aspect2d in ShowBaseGlobal,\n        # for the benefit of creating DirectGui elements before ShowBase.\n        from . import ShowBaseGlobal\n\n        #: This is the root of the 2-D scene graph.\n        self.render2d = ShowBaseGlobal.render2d\n\n        # Set up some overrides to turn off certain properties which\n        # we probably won't need for 2-d objects.\n\n        # It's probably important to turn off the depth test, since\n        # many 2-d objects will be drawn over each other without\n        # regard to depth position.\n\n        # We used to avoid clearing the depth buffer before drawing\n        # render2d, but nowadays we clear it anyway, since we\n        # occasionally want to put 3-d geometry under render2d, and\n        # it's simplest (and seems to be easier on graphics drivers)\n        # if the 2-d scene has been cleared first.\n\n        self.render2d.setDepthTest(0)\n        self.render2d.setDepthWrite(0)\n        self.render2d.setMaterialOff(1)\n        self.render2d.setTwoSided(1)\n\n        #: The normal 2-d DisplayRegion has an aspect ratio that\n        #: matches the window, but its coordinate system is square.\n        #: This means anything we parent to render2d gets stretched.\n        #: For things where that makes a difference, we set up\n        #: aspect2d, which scales things back to the right aspect\n        #: ratio along the X axis (Z is still from -1 to 1)\n        self.aspect2d = ShowBaseGlobal.aspect2d\n\n        aspectRatio = self.getAspectRatio()\n        self.aspect2d.setScale(1.0 / aspectRatio, 1.0, 1.0)\n\n        self.a2dBackground = self.aspect2d.attachNewNode(\"a2dBackground\")\n\n        #: The Z position of the top border of the aspect2d screen.\n        self.a2dTop = 1.0\n        #: The Z position of the bottom border of the aspect2d screen.\n        self.a2dBottom = -1.0\n        #: The X position of the left border of the aspect2d screen.\n        self.a2dLeft = -aspectRatio\n        #: The X position of the right border of the aspect2d screen.\n        self.a2dRight = aspectRatio\n\n        self.a2dTopCenter = self.aspect2d.attachNewNode(\"a2dTopCenter\")\n        self.a2dTopCenterNs = self.aspect2d.attachNewNode(\"a2dTopCenterNS\")\n        self.a2dBottomCenter = self.aspect2d.attachNewNode(\"a2dBottomCenter\")\n        self.a2dBottomCenterNs = self.aspect2d.attachNewNode(\"a2dBottomCenterNS\")\n        self.a2dLeftCenter = self.aspect2d.attachNewNode(\"a2dLeftCenter\")\n        self.a2dLeftCenterNs = self.aspect2d.attachNewNode(\"a2dLeftCenterNS\")\n        self.a2dRightCenter = self.aspect2d.attachNewNode(\"a2dRightCenter\")\n        self.a2dRightCenterNs = self.aspect2d.attachNewNode(\"a2dRightCenterNS\")\n\n        self.a2dTopLeft = self.aspect2d.attachNewNode(\"a2dTopLeft\")\n        self.a2dTopLeftNs = self.aspect2d.attachNewNode(\"a2dTopLeftNS\")\n        self.a2dTopRight = self.aspect2d.attachNewNode(\"a2dTopRight\")\n        self.a2dTopRightNs = self.aspect2d.attachNewNode(\"a2dTopRightNS\")\n        self.a2dBottomLeft = self.aspect2d.attachNewNode(\"a2dBottomLeft\")\n        self.a2dBottomLeftNs = self.aspect2d.attachNewNode(\"a2dBottomLeftNS\")\n        self.a2dBottomRight = self.aspect2d.attachNewNode(\"a2dBottomRight\")\n        self.a2dBottomRightNs = self.aspect2d.attachNewNode(\"a2dBottomRightNS\")\n\n        # Put the nodes in their places\n        self.a2dTopCenter.setPos(0, 0, self.a2dTop)\n        self.a2dTopCenterNs.setPos(0, 0, self.a2dTop)\n        self.a2dBottomCenter.setPos(0, 0, self.a2dBottom)\n        self.a2dBottomCenterNs.setPos(0, 0, self.a2dBottom)\n        self.a2dLeftCenter.setPos(self.a2dLeft, 0, 0)\n        self.a2dLeftCenterNs.setPos(self.a2dLeft, 0, 0)\n        self.a2dRightCenter.setPos(self.a2dRight, 0, 0)\n        self.a2dRightCenterNs.setPos(self.a2dRight, 0, 0)\n\n        self.a2dTopLeft.setPos(self.a2dLeft, 0, self.a2dTop)\n        self.a2dTopLeftNs.setPos(self.a2dLeft, 0, self.a2dTop)\n        self.a2dTopRight.setPos(self.a2dRight, 0, self.a2dTop)\n        self.a2dTopRightNs.setPos(self.a2dRight, 0, self.a2dTop)\n        self.a2dBottomLeft.setPos(self.a2dLeft, 0, self.a2dBottom)\n        self.a2dBottomLeftNs.setPos(self.a2dLeft, 0, self.a2dBottom)\n        self.a2dBottomRight.setPos(self.a2dRight, 0, self.a2dBottom)\n        self.a2dBottomRightNs.setPos(self.a2dRight, 0, self.a2dBottom)\n\n        #: This special root, pixel2d, uses units in pixels that are relative\n        #: to the window. The upperleft corner of the window is (0, 0),\n        #: the lowerleft corner is (xsize, -ysize), in this coordinate system.\n        self.pixel2d = self.render2d.attachNewNode(PGTop(\"pixel2d\"))\n        self.pixel2d.setPos(-1, 0, 1)\n        xsize, ysize = self.getSize()\n        if xsize > 0 and ysize > 0:\n            self.pixel2d.setScale(2.0 / xsize, 1.0, 2.0 / ysize)\n\n    def setupRender2dp(self) -> None:\n        \"\"\"\n        Creates a render2d scene graph, the secondary scene graph for\n        2-d objects and gui elements that are superimposed over the\n        2-d and 3-d geometry in the window.\n        \"\"\"\n        self.render2dp = NodePath('render2dp')\n\n        # Set up some overrides to turn off certain properties which\n        # we probably won't need for 2-d objects.\n\n        # It's probably important to turn off the depth test, since\n        # many 2-d objects will be drawn over each other without\n        # regard to depth position.\n\n        dt = DepthTestAttrib.make(DepthTestAttrib.MNone)\n        dw = DepthWriteAttrib.make(DepthWriteAttrib.MOff)\n        self.render2dp.setDepthTest(0)\n        self.render2dp.setDepthWrite(0)\n\n        self.render2dp.setMaterialOff(1)\n        self.render2dp.setTwoSided(1)\n\n        #: The normal 2-d DisplayRegion has an aspect ratio that\n        #: matches the window, but its coordinate system is square.\n        #: This means anything we parent to render2dp gets stretched.\n        #: For things where that makes a difference, we set up\n        #: aspect2dp, which scales things back to the right aspect\n        #: ratio along the X axis (Z is still from -1 to 1)\n        self.aspect2dp = self.render2dp.attachNewNode(PGTop(\"aspect2dp\"))\n        self.aspect2dp.node().setStartSort(16384)\n\n        aspectRatio = self.getAspectRatio()\n        self.aspect2dp.setScale(1.0 / aspectRatio, 1.0, 1.0)\n\n        #: The Z position of the top border of the aspect2dp screen.\n        self.a2dpTop = 1.0\n        #: The Z position of the bottom border of the aspect2dp screen.\n        self.a2dpBottom = -1.0\n        #: The X position of the left border of the aspect2dp screen.\n        self.a2dpLeft = -aspectRatio\n        #: The X position of the right border of the aspect2dp screen.\n        self.a2dpRight = aspectRatio\n\n        self.a2dpTopCenter = self.aspect2dp.attachNewNode(\"a2dpTopCenter\")\n        self.a2dpBottomCenter = self.aspect2dp.attachNewNode(\"a2dpBottomCenter\")\n        self.a2dpLeftCenter = self.aspect2dp.attachNewNode(\"a2dpLeftCenter\")\n        self.a2dpRightCenter = self.aspect2dp.attachNewNode(\"a2dpRightCenter\")\n\n        self.a2dpTopLeft = self.aspect2dp.attachNewNode(\"a2dpTopLeft\")\n        self.a2dpTopRight = self.aspect2dp.attachNewNode(\"a2dpTopRight\")\n        self.a2dpBottomLeft = self.aspect2dp.attachNewNode(\"a2dpBottomLeft\")\n        self.a2dpBottomRight = self.aspect2dp.attachNewNode(\"a2dpBottomRight\")\n\n        # Put the nodes in their places\n        self.a2dpTopCenter.setPos(0, 0, self.a2dpTop)\n        self.a2dpBottomCenter.setPos(0, 0, self.a2dpBottom)\n        self.a2dpLeftCenter.setPos(self.a2dpLeft, 0, 0)\n        self.a2dpRightCenter.setPos(self.a2dpRight, 0, 0)\n\n        self.a2dpTopLeft.setPos(self.a2dpLeft, 0, self.a2dpTop)\n        self.a2dpTopRight.setPos(self.a2dpRight, 0, self.a2dpTop)\n        self.a2dpBottomLeft.setPos(self.a2dpLeft, 0, self.a2dpBottom)\n        self.a2dpBottomRight.setPos(self.a2dpRight, 0, self.a2dpBottom)\n\n        #: This special root, pixel2dp, uses units in pixels that are relative\n        #: to the window. The upperleft corner of the window is (0, 0),\n        #: the lowerleft corner is (xsize, -ysize), in this coordinate system.\n        self.pixel2dp = self.render2dp.attachNewNode(PGTop(\"pixel2dp\"))\n        self.pixel2dp.node().setStartSort(16384)\n        self.pixel2dp.setPos(-1, 0, 1)\n        xsize, ysize = self.getSize()\n        if xsize > 0 and ysize > 0:\n            self.pixel2dp.setScale(2.0 / xsize, 1.0, 2.0 / ysize)\n\n    def setAspectRatio(self, aspectRatio):\n        \"\"\" Sets the global aspect ratio of the main window.  Set it\n        to None to restore automatic scaling. \"\"\"\n        self.__configAspectRatio = aspectRatio\n        self.adjustWindowAspectRatio(self.getAspectRatio())\n\n    def getAspectRatio(self, win = None):\n        # Returns the actual aspect ratio of the indicated (or main\n        # window), or the default aspect ratio if there is not yet a\n        # main window.\n\n        # If the config it set, we return that\n        if self.__configAspectRatio:\n            return self.__configAspectRatio\n\n        aspectRatio = 1\n\n        if win is None:\n            win = self.win\n\n        if win is not None and win.hasSize() and win.getSbsLeftYSize() != 0:\n            aspectRatio = float(win.getSbsLeftXSize()) / float(win.getSbsLeftYSize())\n        else:\n            if win is None or not hasattr(win, \"getRequestedProperties\"):\n                props = WindowProperties.getDefault()\n            else:\n                props = win.getRequestedProperties()\n                if not props.hasSize():\n                    props = WindowProperties.getDefault()\n\n            if props.hasSize() and props.getYSize() != 0:\n                aspectRatio = float(props.getXSize()) / float(props.getYSize())\n\n        if aspectRatio == 0:\n            return 1\n\n        return aspectRatio\n\n    def getSize(self, win = None):\n        \"\"\"\n        Returns the actual size of the indicated (or main window), or the\n        default size if there is not yet a main window.\n        \"\"\"\n\n        if win is None:\n            win = self.win\n\n        if win is not None and win.hasSize():\n            return win.getXSize(), win.getYSize()\n        else:\n            if win is None or not hasattr(win, \"getRequestedProperties\"):\n                props = WindowProperties.getDefault()\n            else:\n                props = win.getRequestedProperties()\n                if not props.hasSize():\n                    props = WindowProperties.getDefault()\n\n            return props.getXSize(), props.getYSize()\n\n    def makeCamera(self, win, sort = 0, scene = None,\n                   displayRegion = (0, 1, 0, 1), stereo = None,\n                   aspectRatio = None, clearDepth = 0, clearColor = None,\n                   lens = None, camName = 'cam', mask = None,\n                   useCamera = None):\n        \"\"\"\n        Makes a new 3-d camera associated with the indicated window,\n        and creates a display region in the indicated subrectangle.\n\n        If stereo is True, then a stereo camera is created, with a\n        pair of DisplayRegions.  If stereo is False, then a standard\n        camera is created.  If stereo is None or omitted, a stereo\n        camera is created if the window says it can render in stereo.\n\n        If useCamera is not None, it is a NodePath to be used as the\n        camera to apply to the window, rather than creating a new\n        camera.\n\n        :rtype: panda3d.core.NodePath\n        \"\"\"\n        # self.camera is the parent node of all cameras: a node that\n        # we can move around to move all cameras as a group.\n        if self.camera is None:\n            # We make it a ModelNode with the PTLocal flag, so that\n            # a wayward flatten operations won't attempt to mangle the\n            # camera.\n            self.camera = self.render.attachNewNode(ModelNode('camera'))\n            self.camera.node().setPreserveTransform(ModelNode.PTLocal)\n            builtins.camera = self.camera\n\n            self.mouse2cam.node().setNode(self.camera.node())\n\n        if useCamera:\n            # Use the existing camera node.\n            cam = useCamera\n            camNode = useCamera.node()\n            assert isinstance(camNode, Camera)\n            lens = camNode.getLens()\n            cam.reparentTo(self.camera)\n\n        else:\n            # Make a new Camera node.\n            camNode = Camera(camName)\n            if lens is None:\n                lens = PerspectiveLens()\n\n                if aspectRatio is None:\n                    aspectRatio = self.getAspectRatio(win)\n                lens.setAspectRatio(aspectRatio)\n\n            cam = self.camera.attachNewNode(camNode)\n\n        if lens is not None:\n            camNode.setLens(lens)\n\n        if scene is not None:\n            camNode.setScene(scene)\n\n        if mask is not None:\n            if isinstance(mask, int):\n                mask = BitMask32(mask)\n            camNode.setCameraMask(mask)\n\n        if self.cam is None:\n            self.cam = cam\n            self.camNode = camNode\n            self.camLens = lens\n\n        self.camList.append(cam)\n\n        # Now, make a DisplayRegion for the camera.\n        if stereo is not None:\n            if stereo:\n                dr = win.makeStereoDisplayRegion(*displayRegion)\n            else:\n                dr = win.makeMonoDisplayRegion(*displayRegion)\n        else:\n            dr = win.makeDisplayRegion(*displayRegion)\n\n        dr.setSort(sort)\n\n        # By default, we do not clear 3-d display regions (the entire\n        # window will be cleared, which is normally sufficient).  But\n        # we will if clearDepth is specified.\n        if clearDepth:\n            dr.setClearDepthActive(1)\n\n        if clearColor:\n            dr.setClearColorActive(1)\n            dr.setClearColor(clearColor)\n\n        dr.setCamera(cam)\n\n        return cam\n\n    def makeCamera2d(self, win, sort = 10,\n                     displayRegion = (0, 1, 0, 1), coords = (-1, 1, -1, 1),\n                     lens = None, cameraName = None):\n        \"\"\"\n        Makes a new camera2d associated with the indicated window, and\n        assigns it to render the indicated subrectangle of render2d.\n\n        :rtype: panda3d.core.NodePath\n        \"\"\"\n        dr = win.makeMonoDisplayRegion(*displayRegion)\n        dr.setSort(sort)\n\n        # Enable clearing of the depth buffer on this new display\n        # region (see the comment in setupRender2d, above).\n        dr.setClearDepthActive(1)\n\n        # Make any texture reloads on the gui come up immediately.\n        dr.setIncompleteRender(False)\n\n        left, right, bottom, top = coords\n\n        # Now make a new Camera node.\n        if cameraName:\n            cam2dNode = Camera('cam2d_' + cameraName)\n        else:\n            cam2dNode = Camera('cam2d')\n\n        if lens is None:\n            lens = OrthographicLens()\n            lens.setFilmSize(right - left, top - bottom)\n            lens.setFilmOffset((right + left) * 0.5, (top + bottom) * 0.5)\n            lens.setNearFar(-1000, 1000)\n        cam2dNode.setLens(lens)\n\n        # self.camera2d is the analog of self.camera, although it's\n        # not as clear how useful it is.\n        if self.camera2d is None:\n            self.camera2d = self.render2d.attachNewNode('camera2d')\n\n        camera2d = self.camera2d.attachNewNode(cam2dNode)\n        dr.setCamera(camera2d)\n\n        if self.cam2d is None:\n            self.cam2d = camera2d\n\n        return camera2d\n\n    def makeCamera2dp(self, win, sort = 20,\n                      displayRegion = (0, 1, 0, 1), coords = (-1, 1, -1, 1),\n                      lens = None, cameraName = None):\n        \"\"\"\n        Makes a new camera2dp associated with the indicated window, and\n        assigns it to render the indicated subrectangle of render2dp.\n\n        :rtype: panda3d.core.NodePath\n        \"\"\"\n        dr = win.makeMonoDisplayRegion(*displayRegion)\n        dr.setSort(sort)\n\n        # Unlike render2d, we don't clear the depth buffer for\n        # render2dp.  Caveat emptor.\n\n        if hasattr(dr, 'setIncompleteRender'):\n            dr.setIncompleteRender(False)\n\n        left, right, bottom, top = coords\n\n        # Now make a new Camera node.\n        if cameraName:\n            cam2dNode = Camera('cam2dp_' + cameraName)\n        else:\n            cam2dNode = Camera('cam2dp')\n\n        if lens is None:\n            lens = OrthographicLens()\n            lens.setFilmSize(right - left, top - bottom)\n            lens.setFilmOffset((right + left) * 0.5, (top + bottom) * 0.5)\n            lens.setNearFar(-1000, 1000)\n        cam2dNode.setLens(lens)\n\n        # self.camera2d is the analog of self.camera, although it's\n        # not as clear how useful it is.\n        if self.camera2dp is None:\n            self.camera2dp = self.render2dp.attachNewNode('camera2dp')\n\n        camera2dp = self.camera2dp.attachNewNode(cam2dNode)\n        dr.setCamera(camera2dp)\n\n        if self.cam2dp is None:\n            self.cam2dp = camera2dp\n\n        return camera2dp\n\n    def setupDataGraph(self) -> None:\n        \"\"\"\n        Creates the data graph and populates it with the basic input\n        devices.\n        \"\"\"\n        self.dataRoot = NodePath('dataRoot')\n        # Cache the node so we do not ask for it every frame\n        self.dataRootNode = self.dataRoot.node()\n\n        # Now we have the main trackball & drive interfaces.\n        # useTrackball() and useDrive() switch these in and out; only\n        # one is in use at a given time.\n        self.trackball = NodePath(Trackball('trackball'))\n        self.drive = NodePath(DriveInterface('drive'))\n        self.mouse2cam = NodePath(Transform2SG('mouse2cam'))\n\n    # [gjeon] now you can create multiple mouse watchers to support multiple windows\n    def setupMouse(self, win, fMultiWin=False):\n        \"\"\"\n        Creates the structures necessary to monitor the mouse input,\n        using the indicated window.  If the mouse has already been set\n        up for a different window, those structures are deleted first.\n\n        :param fMultiWin: If True, then the previous mouse structures are not\n                          deleted; instead, multiple windows are allowed to\n                          monitor the mouse input.  However, in this case, the\n                          trackball controls are not set up, and must be set up\n                          by hand if desired.\n\n        :returns: The ButtonThrower NodePath created for this window.\n        \"\"\"\n        if not fMultiWin and self.buttonThrowers is not None:\n            for bt in self.buttonThrowers:\n                mw = bt.getParent()\n                mk = mw.getParent()\n                bt.removeNode()\n                mw.removeNode()\n                mk.removeNode()\n\n        bts, pws = self.setupMouseCB(win)\n\n        if fMultiWin:\n            return bts[0]\n\n        self.buttonThrowers = bts[:]\n        self.pointerWatcherNodes = pws[:]\n\n        self.mouseWatcher = self.buttonThrowers[0].getParent()\n        self.mouseWatcherNode = self.mouseWatcher.node()\n\n        if self.mouseInterface:\n            self.mouseInterface.reparentTo(self.mouseWatcher)\n\n        if self.recorder:\n            # If we have a recorder, the mouseWatcher belongs under a\n            # special MouseRecorder node, which may intercept the\n            # mouse activity.\n            mw = self.buttonThrowers[0].getParent()\n            mouseRecorder = MouseRecorder('mouse')\n            self.recorder.addRecorder('mouse', mouseRecorder)\n            np = mw.getParent().attachNewNode(mouseRecorder)\n            mw.reparentTo(np)\n\n        mw = self.buttonThrowers[0].getParent()\n\n        #: A special ButtonThrower to generate keyboard events and\n        #: include the time from the OS.  This is separate only to\n        #: support legacy code that did not expect a time parameter; it\n        #: will eventually be folded into the normal ButtonThrower,\n        #: above.\n        self.timeButtonThrower = mw.attachNewNode(ButtonThrower('timeButtons'))\n        self.timeButtonThrower.node().setPrefix('time-')\n        self.timeButtonThrower.node().setTimeFlag(1)\n\n        # Tell the gui system about our new mouse watcher.\n        self.aspect2d.node().setMouseWatcher(mw.node())\n        self.pixel2d.node().setMouseWatcher(mw.node())\n        if self.wantRender2dp:\n            self.aspect2dp.node().setMouseWatcher(mw.node())\n            self.pixel2dp.node().setMouseWatcher(mw.node())\n\n        mw.node().addRegion(PGMouseWatcherBackground())\n\n        return self.buttonThrowers[0]\n\n    # [gjeon] this function is seperated from setupMouse to allow multiple mouse watchers\n    def setupMouseCB(self, win):\n        # For each mouse/keyboard device, we create\n        #  - MouseAndKeyboard\n        #  - MouseWatcher\n        #  - ButtonThrower\n        # The ButtonThrowers are stored in a list, self.buttonThrowers.\n        # Given a ButtonThrower, one can access the MouseWatcher and\n        # MouseAndKeyboard using getParent.\n        #\n        # The MouseAndKeyboard generates mouse events and mouse\n        # button/keyboard events; the MouseWatcher passes them through\n        # unchanged when the mouse is not over a 2-d button, and passes\n        # nothing through when the mouse *is* over a 2-d button.  Therefore,\n        # objects that don't want to get events when the mouse is over a\n        # button, like the driveInterface, should be parented to\n        # MouseWatcher, while objects that want events in all cases, like the\n        # chat interface, should be parented to the MouseAndKeyboard.\n\n        buttonThrowers = []\n        pointerWatcherNodes = []\n        for i in range(win.getNumInputDevices()):\n            name = win.getInputDeviceName(i)\n            mk = self.dataRoot.attachNewNode(MouseAndKeyboard(win, i, name))\n            mw = mk.attachNewNode(MouseWatcher(\"watcher%s\" % (i)))\n\n            if win.getSideBySideStereo():\n                # If the window has side-by-side stereo enabled, then\n                # we should constrain the MouseWatcher to the window's\n                # DisplayRegion.  This will enable the MouseWatcher to\n                # track the left and right halves of the screen\n                # individually.\n                mw.node().setDisplayRegion(win.getOverlayDisplayRegion())\n\n            mb = mw.node().getModifierButtons()\n            mb.addButton(KeyboardButton.shift())\n            mb.addButton(KeyboardButton.control())\n            mb.addButton(KeyboardButton.alt())\n            mb.addButton(KeyboardButton.meta())\n            mw.node().setModifierButtons(mb)\n            bt = mw.attachNewNode(ButtonThrower(\"buttons%s\" % (i)))\n            if i != 0:\n                bt.node().setPrefix('mousedev%s-' % (i))\n            mods = ModifierButtons()\n            mods.addButton(KeyboardButton.shift())\n            mods.addButton(KeyboardButton.control())\n            mods.addButton(KeyboardButton.alt())\n            mods.addButton(KeyboardButton.meta())\n            bt.node().setModifierButtons(mods)\n            buttonThrowers.append(bt)\n            if win.hasPointer(i):\n                pointerWatcherNodes.append(mw.node())\n\n        return buttonThrowers, pointerWatcherNodes\n\n    def enableSoftwareMousePointer(self):\n        \"\"\"\n        Creates some geometry and parents it to render2d to show\n        the currently-known mouse position.  Useful if the mouse\n        pointer is invisible for some reason.\n        \"\"\"\n        mouseViz = self.render2d.attachNewNode('mouseViz')\n        lilsmiley = self.loader.loadModel('lilsmiley')\n        lilsmiley.reparentTo(mouseViz)\n\n        aspectRatio = self.getAspectRatio()\n        # Scale the smiley face to 32x32 pixels.\n        height = self.win.getSbsLeftYSize()\n        lilsmiley.setScale(\n            32.0 / height / aspectRatio,\n            1.0, 32.0 / height)\n        self.mouseWatcherNode.setGeometry(mouseViz.node())\n\n    def getAlt(self):\n        \"\"\"\n        Returns True if the alt key is currently held down.\n        \"\"\"\n        return self.mouseWatcherNode.getModifierButtons().isDown(\n            KeyboardButton.alt())\n\n    def getShift(self):\n        \"\"\"\n        Returns True if the shift key is currently held down.\n        \"\"\"\n        return self.mouseWatcherNode.getModifierButtons().isDown(\n            KeyboardButton.shift())\n\n    def getControl(self):\n        \"\"\"\n        Returns True if the control key is currently held down.\n        \"\"\"\n        return self.mouseWatcherNode.getModifierButtons().isDown(\n            KeyboardButton.control())\n\n    def getMeta(self):\n        \"\"\"\n        Returns True if the meta key is currently held down.\n        \"\"\"\n        return self.mouseWatcherNode.getModifierButtons().isDown(\n            KeyboardButton.meta())\n\n    def attachInputDevice(self, device, prefix=None, watch=False):\n        \"\"\"\n        This function attaches an input device to the data graph, which will\n        cause the device to be polled and generate events.  If a prefix is\n        given and not None, it is used to prefix events generated by this\n        device, separated by a hyphen.\n\n        The watch argument can be set to True (as of Panda3D 1.10.3) to set up\n        the default MouseWatcher to receive inputs from this device, allowing\n        it to be polled via mouseWatcherNode and control user interfaces.\n        Setting this to True will also make it generate unprefixed events,\n        regardless of the specified prefix.\n\n        If you call this, you should consider calling detachInputDevice when\n        you are done with the device or when it is disconnected.\n        \"\"\"\n\n        # Protect against the same device being attached multiple times.\n        assert device not in self.__inputDeviceNodes\n\n        idn = self.dataRoot.attachNewNode(InputDeviceNode(device, device.name))\n\n        # Setup the button thrower to generate events for the device.\n        if prefix is not None or not watch:\n            bt = idn.attachNewNode(ButtonThrower(device.name))\n            if prefix is not None:\n                bt.node().setPrefix(prefix + '-')\n            self.deviceButtonThrowers.append(bt)\n\n        assert self.notify.debug(\"Attached input device {0} with prefix {1}\".format(device, prefix))\n        self.__inputDeviceNodes[device] = idn\n\n        if watch:\n            idn.node().addChild(self.mouseWatcherNode)\n\n    def detachInputDevice(self, device):\n        \"\"\"\n        This should be called after attaching an input device using\n        attachInputDevice and the device is disconnected or you no longer wish\n        to keep polling this device for events.\n\n        You do not strictly need to call this if you expect the device to be\n        reconnected (but be careful that you don't reattach it).\n        \"\"\"\n\n        if device not in self.__inputDeviceNodes:\n            assert device in self.__inputDeviceNodes\n            return\n\n        assert self.notify.debug(\"Detached device {0}\".format(device.name))\n\n        # Remove the ButtonThrower from the deviceButtonThrowers list.\n        idn = self.__inputDeviceNodes[device]\n        for bt in self.deviceButtonThrowers:\n            if idn.isAncestorOf(bt):\n                self.deviceButtonThrowers.remove(bt)\n                break\n\n        idn.removeNode()\n        del self.__inputDeviceNodes[device]\n\n    def addAngularIntegrator(self):\n        \"\"\"\n        Adds a :class:`~panda3d.physics.AngularEulerIntegrator` to the default\n        physics manager.  By default, only a\n        :class:`~panda3d.physics.LinearEulerIntegrator` is attached.\n        \"\"\"\n        if not self.physicsMgrAngular:\n            physics = importlib.import_module('panda3d.physics')\n            self.physicsMgrAngular = 1\n            integrator = physics.AngularEulerIntegrator()\n            self.physicsMgr.attachAngularIntegrator(integrator)\n\n    def enableParticles(self):\n        \"\"\"\n        Enables the particle and physics managers, which are stored in\n        `particleMgr` and `physicsMgr` members, respectively.  Also starts a\n        task to periodically update these managers.\n\n        By default, only a :class:`~panda3d.physics.LinearEulerIntegrator` is\n        attached to the physics manager.  To attach an angular integrator,\n        follow this up with a call to `addAngularIntegrator()`.\n        \"\"\"\n        if not self.particleMgrEnabled:\n            # Use importlib to prevent this import from being picked up\n            # by modulefinder when packaging an application.\n\n            if not self.particleMgr:\n                PMG = importlib.import_module('direct.particles.ParticleManagerGlobal')\n                self.particleMgr = PMG.particleMgr\n                self.particleMgr.setFrameStepping(1)\n\n            if not self.physicsMgr:\n                PMG = importlib.import_module('direct.showbase.PhysicsManagerGlobal')\n                physics = importlib.import_module('panda3d.physics')\n                self.physicsMgr = PMG.physicsMgr\n                integrator = physics.LinearEulerIntegrator()\n                self.physicsMgr.attachLinearIntegrator(integrator)\n\n            self.particleMgrEnabled = 1\n            self.physicsMgrEnabled = 1\n            self.taskMgr.remove('manager-update')\n            self.taskMgr.add(self.updateManagers, 'manager-update')\n\n    def disableParticles(self):\n        \"\"\"\n        The opposite of `enableParticles()`.\n        \"\"\"\n        if self.particleMgrEnabled:\n            self.particleMgrEnabled = 0\n            self.physicsMgrEnabled = 0\n            self.taskMgr.remove('manager-update')\n\n    def toggleParticles(self):\n        \"\"\"\n        Calls `enableParticles()` or `disableParticles()` depending on the\n        current state.\n        \"\"\"\n        if self.particleMgrEnabled == 0:\n            self.enableParticles()\n        else:\n            self.disableParticles()\n\n    def isParticleMgrEnabled(self):\n        \"\"\"\n        Returns True if `enableParticles()` has been called.\n        \"\"\"\n        return self.particleMgrEnabled\n\n    def isPhysicsMgrEnabled(self):\n        \"\"\"\n        Returns True if `enableParticles()` has been called.\n        \"\"\"\n        return self.physicsMgrEnabled\n\n    def updateManagers(self, state):\n        dt = self.clock.dt\n        if self.particleMgrEnabled:\n            self.particleMgr.doParticles(dt)\n        if self.physicsMgrEnabled:\n            self.physicsMgr.doPhysics(dt)\n        return Task.cont\n\n    def createStats(self, hostname: str | None = None, port: int | None = None) -> bool:\n        \"\"\"\n        If want-pstats is set in Config.prc, or the `wantStats` member is\n        otherwise set to True, connects to the PStats server.\n        This is normally called automatically from the ShowBase constructor.\n        \"\"\"\n        # You can specify pstats-host in your Config.prc or use ~pstats/~aipstats\n        # The default is localhost\n        if not self.wantStats:\n            return False\n\n        if PStatClient.isConnected():\n            PStatClient.disconnect()\n        # these default values match the C++ default values\n        if hostname is None:\n            hostname = ''\n        if port is None:\n            port = -1\n        PStatClient.connect(hostname, port)\n        if PStatClient.isConnected():\n            PStatClient.mainTick()\n            return True\n        else:\n            return False\n\n    def addSfxManager(self, extraSfxManager):\n        \"\"\"\n        Adds an additional SFX audio manager to `sfxManagerList`, the list of\n        managers managed by ShowBase.\n        \"\"\"\n        # keep a list of sfx manager objects to apply settings to,\n        # since there may be others in addition to the one we create here\n        self.sfxManagerList.append(extraSfxManager)\n        newSfxManagerIsValid = extraSfxManager is not None and extraSfxManager.isValid()\n        self.sfxManagerIsValidList.append(newSfxManagerIsValid)\n        if newSfxManagerIsValid:\n            extraSfxManager.setActive(self.sfxActive)\n\n    def createBaseAudioManagers(self):\n        \"\"\"\n        Creates the default SFX and music manager.  Called automatically from\n        the ShowBase constructor.\n        \"\"\"\n        self.sfxPlayer = SfxPlayer.SfxPlayer()\n        sfxManager = AudioManager.createAudioManager()\n        self.addSfxManager(sfxManager)\n\n        self.musicManager = AudioManager.createAudioManager()\n        self.musicManagerIsValid = self.musicManager is not None \\\n            and self.musicManager.isValid()\n        if self.musicManagerIsValid:\n            # ensure only 1 midi song is playing at a time:\n            self.musicManager.setConcurrentSoundLimit(1)\n            self.musicManager.setActive(self.musicActive)\n\n    # enableMusic/enableSoundEffects are meant to be called in response\n    # to a user request so sfxActive/musicActive represent how things\n    # *should* be, regardless of App/OS/HW state\n    def enableMusic(self, bEnableMusic):\n        \"\"\"\n        Enables or disables the music manager.\n        \"\"\"\n        # don't setActive(1) if no audiofocus\n        if self.AppHasAudioFocus and self.musicManagerIsValid:\n            self.musicManager.setActive(bEnableMusic)\n        self.musicActive = bEnableMusic\n        if bEnableMusic:\n            # This is useful when we want to play different music\n            # from what the manager has queued\n            messenger.send(\"MusicEnabled\")\n            self.notify.debug(\"Enabling music\")\n        else:\n            self.notify.debug(\"Disabling music\")\n\n    def SetAllSfxEnables(self, bEnabled):\n        \"\"\"Calls ``setActive(bEnabled)`` on all valid SFX managers.\"\"\"\n        for i in range(len(self.sfxManagerList)):\n            if self.sfxManagerIsValidList[i]:\n                self.sfxManagerList[i].setActive(bEnabled)\n\n    def enableSoundEffects(self, bEnableSoundEffects):\n        \"\"\"\n        Enables or disables SFX managers.\n        \"\"\"\n        # don't setActive(1) if no audiofocus\n        if self.AppHasAudioFocus or not bEnableSoundEffects:\n            self.SetAllSfxEnables(bEnableSoundEffects)\n        self.sfxActive = bEnableSoundEffects\n        if bEnableSoundEffects:\n            self.notify.debug(\"Enabling sound effects\")\n        else:\n            self.notify.debug(\"Disabling sound effects\")\n\n    # enable/disableAllAudio allow a programmable global override-off\n    # for current audio settings.  they're meant to be called when app\n    # loses audio focus (switched out), so we can turn off sound without\n    # affecting internal sfxActive/musicActive sound settings, so things\n    # come back ok when the app is switched back to\n\n    def disableAllAudio(self):\n        \"\"\"\n        Disables all SFX and music managers, meant to be called when the app\n        loses audio focus.\n        \"\"\"\n        self.AppHasAudioFocus = 0\n        self.SetAllSfxEnables(0)\n        if self.musicManagerIsValid:\n            self.musicManager.setActive(0)\n        self.notify.debug(\"Disabling audio\")\n\n    def enableAllAudio(self):\n        \"\"\"\n        Reenables the SFX and music managers that were active at the time\n        `disableAllAudio()` was called.  Meant to be called when the app regains\n        audio focus.\n        \"\"\"\n        self.AppHasAudioFocus = 1\n        self.SetAllSfxEnables(self.sfxActive)\n        if self.musicManagerIsValid:\n            self.musicManager.setActive(self.musicActive)\n        self.notify.debug(\"Enabling audio\")\n\n    # This function should only be in the loader but is here for\n    # backwards compatibility. Please do not add code here, add\n    # it to the loader.\n    def loadSfx(self, name):\n        \"\"\"\n        :deprecated: Use `.Loader.Loader.loadSfx()` instead.\n        \"\"\"\n        if __debug__:\n            warnings.warn(\"base.loadSfx is deprecated, use base.loader.loadSfx instead.\", DeprecationWarning, stacklevel=2)\n        return self.loader.loadSfx(name)\n\n    # This function should only be in the loader but is here for\n    # backwards compatibility. Please do not add code here, add\n    # it to the loader.\n    def loadMusic(self, name):\n        \"\"\"\n        :deprecated: Use `.Loader.Loader.loadMusic()` instead.\n        \"\"\"\n        if __debug__:\n            warnings.warn(\"base.loadMusic is deprecated, use base.loader.loadMusic instead.\", DeprecationWarning, stacklevel=2)\n        return self.loader.loadMusic(name)\n\n    def playSfx(\n            self, sfx, looping = 0, interrupt = 1, volume = None,\n            time = 0.0, node = None, listener = None, cutoff = None):\n        # This goes through a special player for potential localization\n        return self.sfxPlayer.playSfx(sfx, looping, interrupt, volume, time, node, listener, cutoff)\n\n    def playMusic(self, music, looping = 0, interrupt = 1, volume = None, time = 0.0):\n        if music:\n            if volume is not None:\n                music.setVolume(volume)\n\n            # if interrupt was set to 0, start over even if it's\n            # already playing\n            if interrupt or (music.status() != AudioSound.PLAYING):\n                music.setTime(time)\n                music.setLoop(looping)\n                music.play()\n\n    def __resetPrevTransform(self, state):\n        # Clear out the previous velocity deltas now, after we have\n        # rendered (the previous frame).  We do this after the render,\n        # so that we have a chance to draw a representation of spheres\n        # along with their velocities.  At the beginning of the frame\n        # really means after the command prompt, which allows the user\n        # to interactively query these deltas meaningfully.\n\n        PandaNode.resetAllPrevTransform()\n        return Task.cont\n\n    def __dataLoop(self, state):\n        # Check if there were newly connected devices.\n        self.devices.update()\n\n        # traverse the data graph.  This reads all the control\n        # inputs (from the mouse and keyboard, for instance) and also\n        # directly acts upon them (for instance, to move the avatar).\n        self.dgTrav.traverse(self.dataRootNode)\n        return Task.cont\n\n    def __ivalLoop(self, state):\n        # Execute all intervals in the global ivalMgr.\n        IntervalManager.ivalMgr.step()\n        return Task.cont\n\n    def initShadowTrav(self):\n        if not self.shadowTrav:\n            # set up the shadow collision traverser\n            self.shadowTrav = CollisionTraverser(\"base.shadowTrav\")\n            self.shadowTrav.setRespectPrevTransform(False)\n\n    def __shadowCollisionLoop(self, state):\n        # run the collision traversal if we have a\n        # CollisionTraverser set.\n        if self.shadowTrav:\n            self.shadowTrav.traverse(self.render)\n        return Task.cont\n\n    def __collisionLoop(self, state):\n        # run the collision traversal if we have a\n        # CollisionTraverser set.\n        if self.cTrav:\n            self.cTrav.traverse(self.render)\n        if self.appTrav:\n            self.appTrav.traverse(self.render)\n        if self.shadowTrav:\n            self.shadowTrav.traverse(self.render)\n        messenger.send(\"collisionLoopFinished\")\n        return Task.cont\n\n    def __audioLoop(self, state):\n        if self.musicManager is not None:\n            self.musicManager.update()\n        for x in self.sfxManagerList:\n            x.update()\n        return Task.cont\n\n    def __garbageCollectStates(self, state):\n        \"\"\" This task is started only when we have\n        garbage-collect-states set in the Config.prc file, in which\n        case we're responsible for taking out Panda's garbage from\n        time to time.  This is not to be confused with Python's\n        garbage collection.  \"\"\"\n\n        TransformState.garbageCollect()\n        RenderState.garbageCollect()\n        return Task.cont\n\n    def __igLoop(self, state):\n        if __debug__:\n            # We render the watch variables for the onScreenDebug as soon\n            # as we reasonably can before the renderFrame().\n            self.onScreenDebug.render()\n\n        if self.recorder:\n            self.recorder.recordFrame()\n\n        # Finally, render the frame.\n        self.graphicsEngine.renderFrame()\n        if self.clusterSyncFlag:\n            self.graphicsEngine.syncFrame()\n        if self.multiClientSleep:\n            time.sleep(0)\n\n        if __debug__:\n            # We clear the text buffer for the onScreenDebug as soon\n            # as we reasonably can after the renderFrame().\n            self.onScreenDebug.clear()\n\n        if self.recorder:\n            self.recorder.playFrame()\n\n        if self.mainWinMinimized:\n            # If the main window is minimized, slow down the app a bit\n            # by sleeping here in igLoop so we don't use all available\n            # CPU needlessly.\n\n            # Note: this isn't quite right if multiple windows are\n            # open.  We should base this on whether *all* windows are\n            # minimized, not just the main window.  But it will do for\n            # now until someone complains.\n            time.sleep(0.1)\n\n        # Lerp stuff needs this event, and it must be generated in\n        # C++, not in Python.\n        throw_new_frame()\n        return Task.cont\n\n    def __igLoopSync(self, state):\n        if __debug__:\n            # We render the watch variables for the onScreenDebug as soon\n            # as we reasonably can before the renderFrame().\n            self.onScreenDebug.render()\n\n        if self.recorder:\n            self.recorder.recordFrame()\n\n        self.cluster.collectData()\n\n        # Finally, render the frame.\n        self.graphicsEngine.renderFrame()\n        if self.clusterSyncFlag:\n            self.graphicsEngine.syncFrame()\n        if self.multiClientSleep:\n            time.sleep(0)\n\n        if __debug__:\n            # We clear the text buffer for the onScreenDebug as soon\n            # as we reasonably can after the renderFrame().\n            self.onScreenDebug.clear()\n\n        if self.recorder:\n            self.recorder.playFrame()\n\n        if self.mainWinMinimized:\n            # If the main window is minimized, slow down the app a bit\n            # by sleeping here in igLoop so we don't use all available\n            # CPU needlessly.\n\n            # Note: this isn't quite right if multiple windows are\n            # open.  We should base this on whether *all* windows are\n            # minimized, not just the main window.  But it will do for\n            # now until someone complains.\n            time.sleep(0.1)\n\n        self.graphicsEngine.readyFlip()\n        self.cluster.waitForFlipCommand()\n        self.graphicsEngine.flipFrame()\n\n        # Lerp stuff needs this event, and it must be generated in\n        # C++, not in Python.\n        throw_new_frame()\n        return Task.cont\n\n    def restart(self, clusterSync: bool = False, cluster=None) -> None:\n        self.shutdown()\n        # __resetPrevTransform goes at the very beginning of the frame.\n        self.taskMgr.add(\n            self.__resetPrevTransform, 'resetPrevTransform', sort = -51)\n        # give the dataLoop task a reasonably \"early\" sort,\n        # so that it will get run before most tasks\n        self.taskMgr.add(self.__dataLoop, 'dataLoop', sort = -50)\n        self.__deadInputs = 0\n        # spawn the ivalLoop with a later sort, so that it will\n        # run after most tasks, but before igLoop.\n        self.taskMgr.add(self.__ivalLoop, 'ivalLoop', sort = 20)\n        # make the collisionLoop task run before igLoop,\n        # but leave enough room for the app to insert tasks\n        # between collisionLoop and igLoop\n        self.taskMgr.add(self.__collisionLoop, 'collisionLoop', sort = 30)\n\n        if ConfigVariableBool('garbage-collect-states').value:\n            self.taskMgr.add(self.__garbageCollectStates, 'garbageCollectStates', sort = 46)\n        # give the igLoop task a reasonably \"late\" sort,\n        # so that it will get run after most tasks\n        self.cluster = cluster\n        if not clusterSync or cluster is None:\n            self.taskMgr.add(self.__igLoop, 'igLoop', sort = 50)\n        else:\n            self.taskMgr.add(self.__igLoopSync, 'igLoop', sort = 50)\n        # the audioLoop updates the positions of 3D sounds.\n        # as such, it needs to run after the cull traversal in the igLoop.\n        self.taskMgr.add(self.__audioLoop, 'audioLoop', sort = 60)\n        self.eventMgr.restart()\n\n    def shutdown(self) -> None:\n        self.taskMgr.remove('audioLoop')\n        self.taskMgr.remove('igLoop')\n        self.taskMgr.remove('shadowCollisionLoop')\n        self.taskMgr.remove('collisionLoop')\n        self.taskMgr.remove('dataLoop')\n        self.taskMgr.remove('resetPrevTransform')\n        self.taskMgr.remove('ivalLoop')\n        self.taskMgr.remove('garbageCollectStates')\n        self.eventMgr.shutdown()\n\n    def getBackgroundColor(self, win = None):\n        \"\"\"\n        Returns the current window background color.  This assumes\n        the window is set up to clear the color each frame (this is\n        the normal setting).\n\n        :rtype: panda3d.core.VBase4\n        \"\"\"\n        if win is None:\n            win = self.win\n\n        return VBase4(win.getClearColor())\n\n    def setBackgroundColor(self, r = None, g = None, b = None, a = 0.0, win = None):\n        \"\"\"\n        Sets the window background color to the indicated value.\n        This assumes the window is set up to clear the color each\n        frame (this is the normal setting).\n\n        The color may be either a VBase3 or a VBase4, or a 3-component\n        tuple, or the individual r, g, b parameters.\n        \"\"\"\n        if g is not None:\n            color = VBase4(r, g, b, a)\n        else:\n            arg = r\n            if isinstance(arg, VBase4):\n                color = arg\n            else:\n                color = VBase4(arg[0], arg[1], arg[2], a)\n\n        if win is None:\n            win = self.win\n\n        if win:\n            win.setClearColor(color)\n\n    def toggleBackface(self):\n        \"\"\"\n        Toggles between `backfaceCullingOn()` and `backfaceCullingOff()`.\n        \"\"\"\n        if self.backfaceCullingEnabled:\n            self.backfaceCullingOff()\n        else:\n            self.backfaceCullingOn()\n\n    def backfaceCullingOn(self):\n        \"\"\"\n        Disables two-sided rendering on the entire 3D scene graph.\n        \"\"\"\n        if not self.backfaceCullingEnabled:\n            self.render.setTwoSided(0)\n        self.backfaceCullingEnabled = 1\n\n    def backfaceCullingOff(self):\n        \"\"\"\n        Enables two-sided rendering on the entire 3D scene graph.\n        \"\"\"\n        if self.backfaceCullingEnabled:\n            self.render.setTwoSided(1)\n        self.backfaceCullingEnabled = 0\n\n    def toggleTexture(self):\n        \"\"\"\n        Toggles between `textureOn()` and `textureOff()`.\n        \"\"\"\n        if self.textureEnabled:\n            self.textureOff()\n        else:\n            self.textureOn()\n\n    def textureOn(self):\n        \"\"\"\n        Undoes the effects of a previous call to `textureOff()`.\n        \"\"\"\n        self.render.clearTexture()\n        self.textureEnabled = 1\n\n    def textureOff(self):\n        \"\"\"\n        Disables texturing on the entire 3D scene graph.\n        \"\"\"\n        self.render.setTextureOff(100)\n        self.textureEnabled = 0\n\n    def toggleWireframe(self):\n        \"\"\"\n        Toggles between `wireframeOn()` and `wireframeOff()`.\n        \"\"\"\n        if self.wireframeEnabled:\n            self.wireframeOff()\n        else:\n            self.wireframeOn()\n\n    def wireframeOn(self):\n        \"\"\"\n        Enables wireframe rendering on the entire 3D scene graph.\n        \"\"\"\n        self.render.setRenderModeWireframe(100)\n        self.render.setTwoSided(1)\n        self.wireframeEnabled = 1\n\n    def wireframeOff(self):\n        \"\"\"\n        Undoes the effects of a previous call to `wireframeOn()`.\n        \"\"\"\n        self.render.clearRenderMode()\n        render.setTwoSided(not self.backfaceCullingEnabled)\n        self.wireframeEnabled = 0\n\n    def disableMouse(self):\n        \"\"\"\n        Temporarily disable the mouse control of the camera, either\n        via the drive interface or the trackball, whichever is\n        currently in use.\n        \"\"\"\n        # We don't reparent the drive interface or the trackball;\n        # whichever one was there before will remain in the data graph\n        # and active.  This way they won't lose button events while\n        # the mouse is disabled.  However, we do move the mouse2cam\n        # object out of there, so we won't be updating the camera any\n        # more.\n        if self.mouse2cam:\n            self.mouse2cam.detachNode()\n\n    def enableMouse(self):\n        \"\"\"\n        Reverse the effect of a previous call to `disableMouse()`.\n        `useDrive()` also implicitly enables the mouse.\n        \"\"\"\n        if self.mouse2cam:\n            self.mouse2cam.reparentTo(self.mouseInterface)\n\n    def silenceInput(self):\n        \"\"\"\n        This is a heavy-handed way of temporarily turning off\n        all inputs.  Bring them back with `reviveInput()`.\n        \"\"\"\n        if not self.__deadInputs:\n            self.__deadInputs = taskMgr.remove('dataLoop')\n\n    def reviveInput(self):\n        \"\"\"\n        Restores inputs after a previous call to `silenceInput()`.\n        \"\"\"\n        if self.__deadInputs:\n            self.eventMgr.doEvents()\n            self.dgTrav.traverse(self.dataRootNode)\n            self.eventMgr.eventQueue.clear()\n            self.taskMgr.add(self.__dataLoop, 'dataLoop', sort = -50)\n            self.__deadInputs = 0\n\n    def setMouseOnNode(self, newNode):\n        if self.mouse2cam:\n            self.mouse2cam.node().setNode(newNode)\n\n    def changeMouseInterface(self, changeTo):\n        \"\"\"\n        Change the mouse interface used to control the camera.\n        \"\"\"\n        # Get rid of the prior interface:\n        self.mouseInterface.detachNode()\n        # Update the mouseInterface to point to the drive\n        self.mouseInterface = changeTo\n        self.mouseInterfaceNode = self.mouseInterface.node()\n        # Hookup the drive to the camera.\n        if self.mouseWatcher:\n            self.mouseInterface.reparentTo(self.mouseWatcher)\n        if self.mouse2cam:\n            self.mouse2cam.reparentTo(self.mouseInterface)\n\n    def useDrive(self):\n        \"\"\"\n        Changes the mouse interface used for camera control to drive mode.\n        \"\"\"\n        if self.drive:\n            self.changeMouseInterface(self.drive)\n            # Set the height to a good eyeheight\n            self.mouseInterfaceNode.reset()\n            self.mouseInterfaceNode.setZ(4.0)\n\n    def useTrackball(self):\n        \"\"\"\n        Changes the mouse interface used for camera control to trackball mode.\n        \"\"\"\n        if self.trackball:\n            self.changeMouseInterface(self.trackball)\n\n    def toggleTexMem(self):\n        \"\"\"\n        Toggles a handy texture memory watcher utility.\n        See :mod:`direct.showutil.TexMemWatcher` for more information.\n        \"\"\"\n\n        if self.texmem and not self.texmem.cleanedUp:\n            self.texmem.cleanup()\n            self.texmem = None\n            return\n\n        # Use importlib to prevent this import from being picked up\n        # by modulefinder when packaging an application.\n        TMW = importlib.import_module('direct.showutil.TexMemWatcher')\n        self.texmem = TMW.TexMemWatcher()\n\n    def toggleShowVertices(self):\n        \"\"\" Toggles a mode that visualizes vertex density per screen\n        area. \"\"\"\n\n        if self.showVertices:\n            # Clean up the old mode.\n            self.showVertices.node().setActive(0)\n            dr = self.showVertices.node().getDisplayRegion(0)\n            self.win.removeDisplayRegion(dr)\n            self.showVertices.removeNode()\n            self.showVertices = None\n            return\n\n        dr = self.win.makeDisplayRegion()\n        dr.setSort(1000)\n        cam = Camera('showVertices')\n        cam.setLens(self.camLens)\n\n        # Set up a funny state to render only vertices.\n        override = 100000\n        t = NodePath('t')\n        t.setColor(1, 0, 1, 0.02, override)\n        t.setColorScale(1, 1, 1, 1, override)\n        t.setAttrib(ColorBlendAttrib.make(ColorBlendAttrib.MAdd, ColorBlendAttrib.OIncomingAlpha, ColorBlendAttrib.OOneMinusIncomingAlpha), override)\n        t.setAttrib(RenderModeAttrib.make(RenderModeAttrib.MPoint, 10), override)\n        t.setTwoSided(True, override)\n        t.setBin('fixed', 0, override)\n        t.setDepthTest(False, override)\n        t.setDepthWrite(False, override)\n        t.setLightOff(override)\n        t.setShaderOff(override)\n        t.setFogOff(override)\n        t.setAttrib(AntialiasAttrib.make(AntialiasAttrib.MNone), override)\n        t.setAttrib(RescaleNormalAttrib.make(RescaleNormalAttrib.MNone), override)\n        t.setTextureOff(override)\n\n        # Make the spots round, so there's less static in the display.\n        # This forces software point generation on many drivers, so\n        # it's not on by default.\n        if ConfigVariableBool('round-show-vertices', False):\n            spot = PNMImage(256, 256, 1)\n            spot.renderSpot((1, 1, 1, 1), (0, 0, 0, 0), 0.8, 1)\n            tex = Texture('spot')\n            tex.load(spot)\n            tex.setFormat(tex.FAlpha)\n            t.setTexture(tex, override)\n            t.setAttrib(TexGenAttrib.make(TextureStage.getDefault(), TexGenAttrib.MPointSprite), override)\n\n        cam.setInitialState(t.getState())\n        cam.setCameraMask(~PandaNode.getOverallBit())\n\n        self.showVertices = self.cam.attachNewNode(cam)\n        dr.setCamera(self.showVertices)\n\n    def oobe(self, cam = None):\n        \"\"\"\n        Enable a special \"out-of-body experience\" mouse-interface\n        mode.  This can be used when a \"god\" camera is needed; it\n        moves the camera node out from under its normal node and sets\n        the world up in trackball state.  Button events are still sent\n        to the normal mouse action node (e.g. the DriveInterface), and\n        mouse events, if needed, may be sent to the normal node by\n        holding down the Control key.\n\n        This is different than `useTrackball()`, which simply changes\n        the existing mouse action to a trackball interface.  In fact,\n        OOBE mode doesn't care whether `useDrive()` or `useTrackball()` is\n        in effect; it just temporarily layers a new trackball\n        interface on top of whatever the basic interface is.  You can\n        even switch between `useDrive()` and `useTrackball()` while OOBE\n        mode is in effect.\n\n        This is a toggle; the second time this function is called, it\n        disables the mode.\n        \"\"\"\n        if cam is None:\n            cam = self.cam\n\n        # If oobeMode was never set, set it to false and create the\n        # structures we need to implement OOBE.\n        if not hasattr(self, 'oobeMode'):\n            self.oobeMode = 0\n\n            self.oobeCamera = self.hidden.attachNewNode('oobeCamera')\n            self.oobeCameraTrackball = self.oobeCamera.attachNewNode('oobeCameraTrackball')\n            self.oobeLens = PerspectiveLens()\n            self.oobeLens.setAspectRatio(self.getAspectRatio())\n            self.oobeLens.setNearFar(0.1, 10000.0)\n            self.oobeLens.setMinFov(40)\n\n            self.oobeTrackball = NodePath(Trackball('oobeTrackball'))\n            self.oobe2cam = self.oobeTrackball.attachNewNode(Transform2SG('oobe2cam'))\n            self.oobe2cam.node().setNode(self.oobeCameraTrackball.node())\n\n            self.oobeVis = base.loader.loadModel('models/misc/camera', okMissing = True)\n            if not self.oobeVis:\n                # Sometimes we have default-model-extension set to\n                # egg, but the file might be a bam file.\n                self.oobeVis = base.loader.loadModel('models/misc/camera.bam', okMissing = True)\n            if not self.oobeVis:\n                self.oobeVis = NodePath('oobeVis')\n            self.oobeVis.node().setFinal(1)\n            self.oobeVis.setLightOff(1)\n            self.oobeCullFrustum = None\n\n            self.__directObject.accept('oobe-down', self.__oobeButton, extraArgs = [''])\n            self.__directObject.accept('oobe-repeat', self.__oobeButton, extraArgs = ['-repeat'])\n            self.__directObject.accept('oobe-up', self.__oobeButton, extraArgs = ['-up'])\n\n        if self.oobeMode:\n            # Disable OOBE mode.\n            if self.oobeCullFrustum is not None:\n                # First, disable OOBE cull mode.\n                self.oobeCull(cam = cam)\n\n            if self.oobeVis:\n                self.oobeVis.reparentTo(self.hidden)\n\n            # Restore the mouse interface node, and remove the oobe\n            # trackball from the data path.\n            self.mouseInterfaceNode.clearButton(KeyboardButton.shift())\n            self.oobeTrackball.detachNode()\n\n            bt = self.buttonThrowers[0].node()\n            bt.setSpecificFlag(1)\n            bt.setButtonDownEvent('')\n            bt.setButtonRepeatEvent('')\n            bt.setButtonUpEvent('')\n\n            cam.reparentTo(self.camera)\n            #if cam == self.cam:\n            #    self.camNode.setLens(self.camLens)\n            self.oobeCamera.reparentTo(self.hidden)\n            self.oobeMode = 0\n            self.bboard.post('oobeEnabled', False)\n        else:\n            self.bboard.post('oobeEnabled', True)\n            try:\n                cameraParent = localAvatar\n            except NameError:\n                # Make oobeCamera be a sibling of wherever camera is now.\n                cameraParent = self.camera.getParent()\n            self.oobeCamera.reparentTo(cameraParent)\n            self.oobeCamera.clearMat()\n\n            # Make the regular MouseInterface node respond only when\n            # the shift button is pressed.  And the oobe node will\n            # respond only when shift is *not* pressed.\n\n            self.mouseInterfaceNode.requireButton(KeyboardButton.shift(), True)\n            self.oobeTrackball.node().requireButton(KeyboardButton.shift(), False)\n            self.oobeTrackball.reparentTo(self.mouseWatcher)\n\n            # Set our initial OOB position to be just behind the camera.\n            mat = Mat4.translateMat(0, -10, 3) * self.camera.getMat(cameraParent)\n            mat.invertInPlace()\n            self.oobeTrackball.node().setMat(mat)\n\n            cam.reparentTo(self.oobeCameraTrackball)\n\n            # Temporarily disable button events by routing them\n            # through the oobe filters.\n            bt = self.buttonThrowers[0].node()\n            bt.setSpecificFlag(0)\n            bt.setButtonDownEvent('oobe-down')\n            bt.setButtonRepeatEvent('oobe-repeat')\n            bt.setButtonUpEvent('oobe-up')\n\n            # Don't change the camera lens--keep it with the original lens.\n            #if cam == self.cam:\n            #    self.camNode.setLens(self.oobeLens)\n\n            if self.oobeVis:\n                self.oobeVis.reparentTo(self.camera)\n            self.oobeMode = 1\n\n    def __oobeButton(self, suffix, button):\n        if button.startswith('mouse'):\n            # Eat mouse buttons.\n            return\n\n        # Transmit other buttons.\n        messenger.send(button + suffix)\n\n    def oobeCull(self, cam = None):\n        \"\"\"\n        While in OOBE mode (see above), cull the viewing frustum as if\n        it were still attached to our original camera.  This allows us\n        to visualize the effectiveness of our bounding volumes.\n        \"\"\"\n        if cam is None:\n            cam = self.cam\n\n        # First, make sure OOBE mode is enabled.\n        if not getattr(self, 'oobeMode', False):\n            self.oobe(cam = cam)\n\n        if self.oobeCullFrustum is None:\n            # Enable OOBE culling.\n            pnode = LensNode('oobeCull')\n            pnode.setLens(self.camLens)\n            pnode.showFrustum()\n            self.oobeCullFrustum = self.camera.attachNewNode(pnode)\n\n            # Tell the camera to cull from here instead of its own\n            # origin.\n            for c in self.camList:\n                c.node().setCullCenter(self.oobeCullFrustum)\n            if cam.node().isOfType(Camera):\n                cam.node().setCullCenter(self.oobeCullFrustum)\n            for c in cam.findAllMatches('**/+Camera'):\n                c.node().setCullCenter(self.oobeCullFrustum)\n        else:\n            # Disable OOBE culling.\n\n            for c in self.camList:\n                c.node().setCullCenter(NodePath())\n            if cam.node().isOfType(Camera):\n                cam.node().setCullCenter(self.oobeCullFrustum)\n            for c in cam.findAllMatches('**/+Camera'):\n                c.node().setCullCenter(NodePath())\n            self.oobeCullFrustum.removeNode()\n            self.oobeCullFrustum = None\n\n    def showCameraFrustum(self):\n        # Create a visible representation of the frustum.\n        self.removeCameraFrustum()\n        geom = self.camLens.makeGeometry()\n        if geom is not None:\n            gn = GeomNode('frustum')\n            gn.addGeom(geom)\n            self.camFrustumVis = self.camera.attachNewNode(gn)\n\n    def removeCameraFrustum(self):\n        if self.camFrustumVis:\n            self.camFrustumVis.removeNode()\n\n    def screenshot(self, namePrefix = 'screenshot',\n                   defaultFilename = 1, source = None,\n                   imageComment=\"\", blocking=True):\n        \"\"\" Captures a screenshot from the main window or from the\n        specified window or Texture and writes it to a filename in the\n        current directory (or to a specified directory).\n\n        If defaultFilename is True, the filename is synthesized by\n        appending namePrefix to a default filename suffix (including\n        the filename extension) specified in the Config variable\n        screenshot-filename.  Otherwise, if defaultFilename is False,\n        the entire namePrefix is taken to be the filename to write,\n        and this string should include a suitable filename extension\n        that will be used to determine the type of image file to\n        write.\n\n        Normally, the source is a GraphicsWindow, GraphicsBuffer or\n        DisplayRegion.  If a Texture is supplied instead, it must have\n        a ram image (that is, if it was generated by\n        makeTextureBuffer() or makeCubeMap(), the parameter toRam\n        should have been set true).  If it is a cube map texture as\n        generated by makeCubeMap(), namePrefix should contain the hash\n        mark ('#') character.\n\n        Normally, this call will block until the screenshot is fully\n        written.  To write the screenshot in a background thread\n        instead, pass blocking = False.  In this case, the return value\n        is a future that can be awaited.\n\n        A \"screenshot\" event will be sent once the screenshot is saved.\n\n        :returns: The filename if successful, or None if there is a problem.\n        \"\"\"\n\n        if source is None:\n            source = self.win\n\n        if defaultFilename:\n            filename = GraphicsOutput.makeScreenshotFilename(namePrefix)\n        else:\n            filename = Filename(namePrefix)\n\n        if isinstance(source, Texture):\n            if source.getZSize() > 1:\n                saved = source.write(filename, 0, 0, 1, 0)\n            else:\n                saved = source.write(filename)\n        elif blocking:\n            saved = source.saveScreenshot(filename, imageComment)\n        else:\n            request = source.saveAsyncScreenshot(filename, imageComment)\n            request.addDoneCallback(lambda fut, filename=filename: messenger.send('screenshot', [filename]))\n            return request\n\n        if saved:\n            # Announce to anybody that a screenshot has been taken\n            messenger.send('screenshot', [filename])\n            return filename\n\n        return None\n\n    def saveCubeMap(self, namePrefix = 'cube_map_#.png',\n                    defaultFilename = 0, source = None,\n                    camera = None, size = 128,\n                    cameraMask = PandaNode.getAllCameraMask(),\n                    sourceLens = None):\n        \"\"\"\n        Similar to :meth:`screenshot()`, this sets up a temporary cube\n        map Texture which it uses to take a series of six snapshots of\n        the current scene, one in each of the six cube map directions.\n        This requires rendering a new frame.\n\n        Unlike `screenshot()`, source may only be a GraphicsWindow,\n        GraphicsBuffer, or DisplayRegion; it may not be a Texture.\n\n        camera should be the node to which the cubemap cameras will be\n        parented.  The default is the camera associated with source,\n        if source is a DisplayRegion, or base.camera otherwise.\n\n        :returns: The filename if successful, or None if there is a problem.\n        \"\"\"\n\n        if source is None:\n            source = self.win\n\n        if camera is None:\n            if hasattr(source, \"getCamera\"):\n                camera = source.getCamera()\n            if camera is None:\n                camera = self.camera\n\n        if sourceLens is None:\n            sourceLens = self.camLens\n\n        if hasattr(source, \"getWindow\"):\n            source = source.getWindow()\n\n        rig = NodePath(namePrefix)\n        buffer = source.makeCubeMap(namePrefix, size, rig, cameraMask, 1)\n        if buffer is None:\n            raise Exception(\"Could not make cube map.\")\n\n        # Set the near and far planes from the default lens.\n        lens = rig.find('**/+Camera').node().getLens()\n\n        lens.setNearFar(sourceLens.getNear(), sourceLens.getFar())\n\n        # Now render a frame to fill up the texture.\n        rig.reparentTo(camera)\n        self.graphicsEngine.openWindows()\n        self.graphicsEngine.renderFrame()\n        self.graphicsEngine.renderFrame()\n        self.graphicsEngine.syncFrame()\n\n        tex = buffer.getTexture()\n        saved = self.screenshot(namePrefix = namePrefix,\n                                defaultFilename = defaultFilename,\n                                source = tex)\n\n        self.graphicsEngine.removeWindow(buffer)\n        rig.removeNode()\n\n        return saved\n\n    def saveSphereMap(self, namePrefix = 'spheremap.png',\n                      defaultFilename = 0, source = None,\n                      camera = None, size = 256,\n                      cameraMask = PandaNode.getAllCameraMask(),\n                      numVertices = 1000, sourceLens = None):\n        \"\"\"\n        This works much like :meth:`saveCubeMap()`, and uses the\n        graphics API's hardware cube-mapping ability to get a 360-degree\n        view of the world.  But then it converts the six cube map faces\n        into a single fisheye texture, suitable for applying as a static\n        environment map (sphere map).\n\n        For eye-relative static environment maps, sphere maps are often\n        preferable to cube maps because they require only a single\n        texture and because they are supported on a broader range of\n        hardware.\n\n        :returns: The filename if successful, or None if there is a problem.\n        \"\"\"\n        if source is None:\n            source = self.win\n\n        if camera is None:\n            if hasattr(source, \"getCamera\"):\n                camera = source.getCamera()\n            if camera is None:\n                camera = self.camera\n\n        if sourceLens is None:\n            sourceLens = self.camLens\n\n        if hasattr(source, \"getWindow\"):\n            source = source.getWindow()\n\n        # First, make an offscreen buffer to convert the cube map to a\n        # sphere map.  We make it first so we can guarantee the\n        # rendering order for the cube map.\n        toSphere = source.makeTextureBuffer(namePrefix, size, size,\n                                            Texture(), 1)\n\n        # Now make the cube map buffer.\n        rig = NodePath(namePrefix)\n        buffer = toSphere.makeCubeMap(namePrefix, size, rig, cameraMask, 0)\n        if buffer is None:\n            self.graphicsEngine.removeWindow(toSphere)\n            raise Exception(\"Could not make cube map.\")\n\n        # Set the near and far planes from the default lens.\n        lens = rig.find('**/+Camera').node().getLens()\n        lens.setNearFar(sourceLens.getNear(), sourceLens.getFar())\n\n        # Set up the scene to convert the cube map.  It's just a\n        # simple scene, with only the FisheyeMaker object in it.\n        dr = toSphere.makeMonoDisplayRegion()\n        camNode = Camera('camNode')\n        lens = OrthographicLens()\n        lens.setFilmSize(2, 2)\n        lens.setNearFar(-1000, 1000)\n        camNode.setLens(lens)\n        root = NodePath('buffer')\n        cam = root.attachNewNode(camNode)\n        dr.setCamera(cam)\n\n        fm = FisheyeMaker('card')\n        fm.setNumVertices(numVertices)\n        fm.setSquareInscribed(1, 1.1)\n        fm.setReflection(1)\n        card = root.attachNewNode(fm.generate())\n        card.setTexture(buffer.getTexture())\n\n        # Now render a frame.  This will render out the cube map and\n        # then apply it to the the card in the toSphere buffer.\n        rig.reparentTo(camera)\n        self.graphicsEngine.openWindows()\n        self.graphicsEngine.renderFrame()\n\n        # One more frame for luck.\n        self.graphicsEngine.renderFrame()\n        self.graphicsEngine.syncFrame()\n\n        saved = self.screenshot(namePrefix = namePrefix,\n                                defaultFilename = defaultFilename,\n                                source = toSphere.getTexture())\n\n        self.graphicsEngine.removeWindow(buffer)\n        self.graphicsEngine.removeWindow(toSphere)\n        rig.removeNode()\n\n        return saved\n\n    def movie(self, namePrefix = 'movie', duration = 1.0, fps = 30,\n              format = 'png', sd = 4, source = None):\n        \"\"\"\n        Spawn a task to capture a movie using the screenshot function.\n\n        Args:\n            namePrefix (str): used to form output file names (can\n                include path information (e.g. '/i/beta/frames/myMovie')\n            duration (float): the length of the movie in seconds\n            fps (float): the frame rate of the resulting movie\n            format (str): specifies output file format (e.g. png, bmp)\n            sd (int): specifies number of significant digits for frame\n                count in the output file name (e.g. if sd = 4, the name\n                will be something like movie_0001.png)\n            source: the Window, Buffer, DisplayRegion, or Texture from\n                which to save the resulting images.  The default is the\n                main window.\n\n        Returns:\n            A `~direct.task.Task` that can be awaited.\n        \"\"\"\n        clock = self.clock\n        clock.mode = ClockObject.MNonRealTime\n        clock.dt = 1.0 / fps\n        t = self.taskMgr.add(self._movieTask, namePrefix + '_task')\n        t.frameIndex = 0  # Frame 0 is not captured.\n        t.numFrames = int(duration * fps)\n        t.source = source\n        t.outputString = namePrefix + '_%0' + repr(sd) + 'd.' + format\n        t.setUponDeath(lambda state: clock.setMode(ClockObject.MNormal))\n        return t\n\n    def _movieTask(self, state):\n        if state.frameIndex != 0:\n            frameName = state.outputString % state.frameIndex\n            self.notify.info(\"Capturing frame: \" + frameName)\n            self.screenshot(namePrefix = frameName, defaultFilename = 0,\n                            source = state.source)\n\n        state.frameIndex += 1\n        if state.frameIndex > state.numFrames:\n            return Task.done\n        else:\n            return Task.cont\n\n    def windowEvent(self, win):\n        if win != self.win:\n            # This event isn't about our window.\n            return\n\n        properties = win.getProperties()\n        if properties != self.__prevWindowProperties:\n            self.__prevWindowProperties = properties\n\n            self.notify.debug(\"Got window event: %s\" % (repr(properties)))\n            if not properties.getOpen():\n                # If the user closes the main window, we should exit.\n                self.notify.info(\"User closed main window.\")\n                if __debug__:\n                    if self.__autoGarbageLogging:\n                        GarbageReport.b_checkForGarbageLeaks()\n                self.userExit()\n\n            if properties.getForeground() and not self.mainWinForeground:\n                self.mainWinForeground = 1\n            elif not properties.getForeground() and self.mainWinForeground:\n                self.mainWinForeground = 0\n                if __debug__:\n                    if self.__autoGarbageLogging:\n                        GarbageReport.b_checkForGarbageLeaks()\n\n            if properties.getMinimized() and not self.mainWinMinimized:\n                # If the main window is minimized, throw an event to\n                # stop the music.\n                self.mainWinMinimized = 1\n                messenger.send('PandaPaused')\n            elif not properties.getMinimized() and self.mainWinMinimized:\n                # If the main window is restored, throw an event to\n                # restart the music.\n                self.mainWinMinimized = 0\n                messenger.send('PandaRestarted')\n\n            # If we have not forced the aspect ratio, let's see if it has\n            # changed and update the camera lenses and aspect2d parameters\n            self.adjustWindowAspectRatio(self.getAspectRatio())\n\n            if win.hasSize() and win.getSbsLeftYSize() != 0:\n                self.pixel2d.setScale(2.0 / win.getSbsLeftXSize(), 1.0, 2.0 / win.getSbsLeftYSize())\n                if self.wantRender2dp:\n                    self.pixel2dp.setScale(2.0 / win.getSbsLeftXSize(), 1.0, 2.0 / win.getSbsLeftYSize())\n            else:\n                xsize, ysize = self.getSize()\n                if xsize > 0 and ysize > 0:\n                    self.pixel2d.setScale(2.0 / xsize, 1.0, 2.0 / ysize)\n                    if self.wantRender2dp:\n                        self.pixel2dp.setScale(2.0 / xsize, 1.0, 2.0 / ysize)\n\n    def adjustWindowAspectRatio(self, aspectRatio):\n        \"\"\" This function is normally called internally by\n        `windowEvent()`, but it may also be called to explicitly adjust\n        the aspect ratio of the render/render2d DisplayRegion, by a\n        class that has redefined these. \"\"\"\n\n        if self.__configAspectRatio:\n            aspectRatio = self.__configAspectRatio\n\n        if aspectRatio != self.__oldAspectRatio:\n            self.__oldAspectRatio = aspectRatio\n            # Fix up some anything that depends on the aspectRatio\n            if self.camLens:\n                self.camLens.setAspectRatio(aspectRatio)\n            if aspectRatio < 1:\n                # If the window is TALL, lets expand the top and bottom\n                self.aspect2d.setScale(1.0, aspectRatio, aspectRatio)\n                self.a2dTop = 1.0 / aspectRatio\n                self.a2dBottom = - 1.0 / aspectRatio\n                self.a2dLeft = -1\n                self.a2dRight = 1.0\n                # Don't forget 2dp\n                if self.wantRender2dp:\n                    self.aspect2dp.setScale(1.0, aspectRatio, aspectRatio)\n                    self.a2dpTop = 1.0 / aspectRatio\n                    self.a2dpBottom = - 1.0 / aspectRatio\n                    self.a2dpLeft = -1\n                    self.a2dpRight = 1.0\n\n            else:\n                # If the window is WIDE, lets expand the left and right\n                self.aspect2d.setScale(1.0 / aspectRatio, 1.0, 1.0)\n                self.a2dTop = 1.0\n                self.a2dBottom = -1.0\n                self.a2dLeft = -aspectRatio\n                self.a2dRight = aspectRatio\n                # Don't forget 2dp\n                if self.wantRender2dp:\n                    self.aspect2dp.setScale(1.0 / aspectRatio, 1.0, 1.0)\n                    self.a2dpTop = 1.0\n                    self.a2dpBottom = -1.0\n                    self.a2dpLeft = -aspectRatio\n                    self.a2dpRight = aspectRatio\n\n            # Reposition the aspect2d marker nodes\n            self.a2dTopCenter.setPos(0, 0, self.a2dTop)\n            self.a2dTopCenterNs.setPos(0, 0, self.a2dTop)\n            self.a2dBottomCenter.setPos(0, 0, self.a2dBottom)\n            self.a2dBottomCenterNs.setPos(0, 0, self.a2dBottom)\n            self.a2dLeftCenter.setPos(self.a2dLeft, 0, 0)\n            self.a2dLeftCenterNs.setPos(self.a2dLeft, 0, 0)\n            self.a2dRightCenter.setPos(self.a2dRight, 0, 0)\n            self.a2dRightCenterNs.setPos(self.a2dRight, 0, 0)\n\n            self.a2dTopLeft.setPos(self.a2dLeft, 0, self.a2dTop)\n            self.a2dTopLeftNs.setPos(self.a2dLeft, 0, self.a2dTop)\n            self.a2dTopRight.setPos(self.a2dRight, 0, self.a2dTop)\n            self.a2dTopRightNs.setPos(self.a2dRight, 0, self.a2dTop)\n            self.a2dBottomLeft.setPos(self.a2dLeft, 0, self.a2dBottom)\n            self.a2dBottomLeftNs.setPos(self.a2dLeft, 0, self.a2dBottom)\n            self.a2dBottomRight.setPos(self.a2dRight, 0, self.a2dBottom)\n            self.a2dBottomRightNs.setPos(self.a2dRight, 0, self.a2dBottom)\n\n            # Reposition the aspect2dp marker nodes\n            if self.wantRender2dp:\n                self.a2dpTopCenter.setPos(0, 0, self.a2dpTop)\n                self.a2dpBottomCenter.setPos(0, 0, self.a2dpBottom)\n                self.a2dpLeftCenter.setPos(self.a2dpLeft, 0, 0)\n                self.a2dpRightCenter.setPos(self.a2dpRight, 0, 0)\n\n                self.a2dpTopLeft.setPos(self.a2dpLeft, 0, self.a2dpTop)\n                self.a2dpTopRight.setPos(self.a2dpRight, 0, self.a2dpTop)\n                self.a2dpBottomLeft.setPos(self.a2dpLeft, 0, self.a2dpBottom)\n                self.a2dpBottomRight.setPos(self.a2dpRight, 0, self.a2dpBottom)\n\n            # If anybody needs to update their GUI, put a callback on this event\n            messenger.send(\"aspectRatioChanged\")\n\n    def userExit(self) -> NoReturn:\n        # The user has requested we exit the program.  Deal with this.\n        if self.exitFunc:\n            self.exitFunc()\n        self.notify.info(\"Exiting ShowBase.\")\n        self.finalizeExit()\n\n    def finalizeExit(self) -> NoReturn:\n        \"\"\"\n        Called by `userExit()` to quit the application.  The default\n        implementation just calls `sys.exit()`.\n        \"\"\"\n        sys.exit()\n\n    # [gjeon] start wxPython\n    def startWx(self, fWantWx = True):\n        fWantWx = bool(fWantWx)\n        if self.wantWx != fWantWx:\n            self.wantWx = fWantWx\n            if self.wantWx:\n                self.spawnWxLoop()\n\n    def spawnWxLoop(self):\n        \"\"\" Call this method to hand the main loop over to wxPython.\n        This sets up a wxTimer callback so that Panda still gets\n        updated, but wxPython owns the main loop (which seems to make\n        it happier than the other way around). \"\"\"\n\n        if self.wxAppCreated:\n            # Don't do this twice.\n            return\n\n        init_app_for_gui()\n\n        # Use importlib to prevent this import from being picked up\n        # by modulefinder when packaging an application.\n        wx = importlib.import_module('wx')\n\n        if not self.wxApp:\n            # Create a new base.wxApp.\n            self.wxApp = wx.App(redirect = False)\n\n        if ConfigVariableBool('wx-main-loop', True):\n            # Put wxPython in charge of the main loop.  It really\n            # seems to like this better; some features of wx don't\n            # work properly unless this is true.\n\n            # Set a timer to run the Panda frame 60 times per second.\n            wxFrameRate = ConfigVariableDouble('wx-frame-rate', 60.0)\n            self.wxTimer = wx.Timer(self.wxApp)\n            self.wxTimer.Start(int(round(1000.0 / wxFrameRate.value)))\n            self.wxApp.Bind(wx.EVT_TIMER, self.__wxTimerCallback)\n\n            # wx is now the main loop, not us any more.\n            self.run = self.wxRun\n            self.taskMgr.run = self.wxRun\n            builtins.run = self.wxRun\n            if self.appRunner:\n                self.appRunner.run = self.wxRun\n\n        else:\n            # Leave Panda in charge of the main loop.  This is\n            # friendlier for IDE's and interactive editing in general.\n            def wxLoop(task):\n                # First we need to ensure that the OS message queue is\n                # processed.\n                self.wxApp.Yield()\n\n                # Now do all the wxPython events waiting on this frame.\n                while self.wxApp.Pending():\n                    self.wxApp.Dispatch()\n\n                return task.again\n\n            self.taskMgr.add(wxLoop, 'wxLoop')\n        self.wxAppCreated = True\n\n    def __wxTimerCallback(self, event):\n        if Thread.getCurrentThread().getCurrentTask():\n            # This happens when the wxTimer expires while igLoop is\n            # rendering.  Ignore it.\n            return\n\n        self.taskMgr.step()\n\n    def wxRun(self):\n        \"\"\" This method replaces `run()` after we have called `spawnWxLoop()`.\n        Since at this point wxPython now owns the main loop, this method is a\n        call to wxApp.MainLoop(). \"\"\"\n\n        if Thread.getCurrentThread().getCurrentTask():\n            # This happens in the p3d environment during startup.\n            # Ignore it.\n            return\n\n        self.wxApp.MainLoop()\n\n    def startTk(self, fWantTk = True):\n        fWantTk = bool(fWantTk)\n        if self.wantTk != fWantTk:\n            self.wantTk = fWantTk\n            if self.wantTk:\n                self.spawnTkLoop()\n\n    def spawnTkLoop(self):\n        \"\"\" Call this method to hand the main loop over to Tkinter.\n        This sets up a timer callback so that Panda still gets\n        updated, but Tkinter owns the main loop (which seems to make\n        it happier than the other way around). \"\"\"\n\n        if self.tkRootCreated:\n            # Don't do this twice.\n            return\n\n        # Use importlib to prevent this import from being picked up\n        # by modulefinder when packaging an application.\n        tkinter = importlib.import_module('_tkinter')\n        Pmw = importlib.import_module('Pmw')\n\n        # Create a new Tk root.\n        if not self.tkRoot:\n            self.tkRoot = Pmw.initialise()\n        builtins.tkroot = self.tkRoot\n\n        init_app_for_gui()\n\n        # Disable the Windows message loop, since Tcl wants to handle this all\n        # on its own, except if the Panda window is on a separate thread.\n        if self.graphicsEngine.getThreadingModel().getDrawStage() == 0:\n            ConfigVariableBool('disable-message-loop', False).value = True\n\n        if ConfigVariableBool('tk-main-loop', True):\n            # Put Tkinter in charge of the main loop.  It really\n            # seems to like this better; the GUI otherwise becomes\n            # largely unresponsive on Mac OS X unless this is true.\n\n            # Set a timer to run the Panda frame 60 times per second.\n            tkFrameRate = ConfigVariableDouble('tk-frame-rate', 60.0)\n            self.tkDelay = int(1000.0 / tkFrameRate.value)\n            self.tkRoot.after(self.tkDelay, self.__tkTimerCallback)\n\n            # wx is now the main loop, not us any more.\n            self.run = self.tkRun\n            self.taskMgr.run = self.tkRun\n            builtins.run = self.tkRun\n            if self.appRunner:\n                self.appRunner.run = self.tkRun\n\n        else:\n            # Leave Panda in charge of the main loop.  This is\n            # friendlier for IDE's and interactive editing in general.\n            def tkLoop(task):\n                # Do all the tkinter events waiting on this frame\n                # dooneevent will return 0 if there are no more events\n                # waiting or 1 if there are still more.\n                # DONT_WAIT tells tkinter not to block waiting for events\n                while self.tkRoot.dooneevent(tkinter.ALL_EVENTS | tkinter.DONT_WAIT):\n                    pass\n\n                return task.again\n\n            self.taskMgr.add(tkLoop, 'tkLoop')\n        self.tkRootCreated = True\n\n    def __tkTimerCallback(self):\n        if not Thread.getCurrentThread().getCurrentTask():\n            self.taskMgr.step()\n\n        self.tkRoot.after(self.tkDelay, self.__tkTimerCallback)\n\n    def tkRun(self):\n        \"\"\" This method replaces `run()` after we have called `spawnTkLoop()`.\n        Since at this point Tkinter now owns the main loop, this method is a\n        call to tkRoot.mainloop(). \"\"\"\n\n        if Thread.getCurrentThread().getCurrentTask():\n            # This happens in the p3d environment during startup.\n            # Ignore it.\n            return\n\n        self.tkRoot.mainloop()\n\n    def startDirect(self, fWantDirect = 1, fWantTk = 1, fWantWx = 0):\n        self.startTk(fWantTk)\n        self.startWx(fWantWx)\n\n        if self.wantDirect == fWantDirect:\n            return\n\n        self.wantDirect = fWantDirect\n\n        if self.wantDirect:\n            # Use importlib to prevent this import from being picked up\n            # by modulefinder when packaging an application.\n            DirectSession = importlib.import_module('direct.directtools.DirectSession')\n            self.direct = DirectSession.DirectSession()\n            self.direct.enable()\n            builtins.direct = self.direct\n        else:\n            builtins.direct = self.direct = None\n\n    def getRepository(self):\n        return None\n\n    def getAxes(self):\n        \"\"\"\n        Loads and returns the ``models/misc/xyzAxis.bam`` model.\n\n        :rtype: panda3d.core.NodePath\n        \"\"\"\n        return self.loader.loadModel(\"models/misc/xyzAxis.bam\")\n\n    def __doStartDirect(self):\n        if self.__directStarted:\n            return\n        self.__directStarted = False\n\n        # Start Tk, Wx and DIRECT if specified by Config.prc\n        fTk = ConfigVariableBool('want-tk', False).value\n        fWx = ConfigVariableBool('want-wx', False).value\n        # Start DIRECT if specified in Config.prc or in cluster mode\n        fDirect = (ConfigVariableBool('want-directtools', 0).value or\n                   (not ConfigVariableString(\"cluster-mode\", '').empty()))\n        # Set fWantTk to 0 to avoid starting Tk with this call\n        self.startDirect(fWantDirect = fDirect, fWantTk = fTk, fWantWx = fWx)\n\n    def run(self) -> None: # pylint: disable=method-hidden\n        \"\"\"This method runs the :class:`~direct.task.Task.TaskManager`\n        when ``self.appRunner is None``, which is to say, when we are\n        not running from within a p3d file.  When we *are* within a p3d\n        file, the Panda3D runtime has to be responsible for running the\n        main loop, so we can't allow the application to do it.\n\n        This method must be called from the main thread, otherwise an error is\n        thrown.\n        \"\"\"\n        if Thread.getCurrentThread() != Thread.getMainThread() and sys.platform != \"android\":\n            self.notify.error(\"run() must be called from the main thread.\")\n            return\n\n        if self.appRunner is None or self.appRunner.dummy or \\\n           (self.appRunner.interactiveConsole and not self.appRunner.initialAppImport):\n            self.taskMgr.run()\n\n    # Snake-case aliases, for people who prefer these.  We're in the process\n    # of migrating everyone to use the snake-case alternatives.\n    make_default_pipe = makeDefaultPipe\n    make_module_pipe = makeModulePipe\n    make_all_pipes = makeAllPipes\n    open_window = openWindow\n    close_window = closeWindow\n    open_default_window = openDefaultWindow\n    open_main_window = openMainWindow\n    set_sleep = setSleep\n    set_frame_rate_meter = setFrameRateMeter\n    set_scene_graph_analyzer_meter = setSceneGraphAnalyzerMeter\n    setup_window_controls = setupWindowControls\n    setup_render = setupRender\n    setup_render2d = setupRender2d\n    setup_render2dp = setupRender2dp\n    set_aspect_ratio = setAspectRatio\n    get_aspect_ratio = getAspectRatio\n    get_size = getSize\n    make_camera = makeCamera\n    make_camera2d = makeCamera2d\n    make_camera2dp = makeCamera2dp\n    setup_data_graph = setupDataGraph\n    setup_mouse = setupMouse\n    setup_mouse_cb = setupMouseCB\n    enable_software_mouse_pointer = enableSoftwareMousePointer\n    detach_input_device = detachInputDevice\n    attach_input_device = attachInputDevice\n    add_angular_integrator = addAngularIntegrator\n    enable_particles = enableParticles\n    disable_particles = disableParticles\n    toggle_particles = toggleParticles\n    create_stats = createStats\n    add_sfx_manager = addSfxManager\n    enable_music = enableMusic\n    enable_sound_effects = enableSoundEffects\n    disable_all_audio = disableAllAudio\n    enable_all_audio = enableAllAudio\n    init_shadow_trav = initShadowTrav\n    get_background_color = getBackgroundColor\n    set_background_color = setBackgroundColor\n    toggle_backface = toggleBackface\n    backface_culling_on = backfaceCullingOn\n    backface_culling_off = backfaceCullingOff\n    toggle_texture = toggleTexture\n    texture_on = textureOn\n    texture_off = textureOff\n    toggle_wireframe = toggleWireframe\n    wireframe_on = wireframeOn\n    wireframe_off = wireframeOff\n    disable_mouse = disableMouse\n    enable_mouse = enableMouse\n    silence_input = silenceInput\n    revive_input = reviveInput\n    set_mouse_on_node = setMouseOnNode\n    change_mouse_interface = changeMouseInterface\n    use_drive = useDrive\n    use_trackball = useTrackball\n    toggle_tex_mem = toggleTexMem\n    toggle_show_vertices = toggleShowVertices\n    oobe_cull = oobeCull\n    show_camera_frustum = showCameraFrustum\n    remove_camera_frustum = removeCameraFrustum\n    save_cube_map = saveCubeMap\n    save_sphere_map = saveSphereMap\n    start_wx = startWx\n    start_tk = startTk\n    start_direct = startDirect\n\n\n# A class to encapsulate information necessary for multiwindow support.\nclass WindowControls:\n    def __init__(\n            self, win, cam=None, camNode=None, cam2d=None, mouseWatcher=None,\n            mouseKeyboard=None, closeCmd=lambda: 0, grid=None):\n        self.win = win\n        self.camera = cam\n        if camNode is None and cam is not None:\n            camNode = cam.node()\n        self.camNode = camNode\n        self.camera2d = cam2d\n        self.mouseWatcher = mouseWatcher\n        self.mouseKeyboard = mouseKeyboard\n        self.closeCommand = closeCmd\n        self.grid = grid\n\n    def __str__(self):\n        s = \"window = \" + str(self.win) + \"\\n\"\n        s += \"camera = \" + str(self.camera) + \"\\n\"\n        s += \"camNode = \" + str(self.camNode) + \"\\n\"\n        s += \"camera2d = \" + str(self.camera2d) + \"\\n\"\n        s += \"mouseWatcher = \" + str(self.mouseWatcher) + \"\\n\"\n        s += \"mouseAndKeyboard = \" + str(self.mouseKeyboard) + \"\\n\"\n        return s\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/ShowBase.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/be1afc59_ShowBase.json",
    "doc_id": "doc_283"
  }
}