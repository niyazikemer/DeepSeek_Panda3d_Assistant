{
  "content": "#! /usr/bin/env python\n\n\"\"\"\n\nThis script can be used to produce a standalone executable from\narbitrary Python code.  You supply the name of the starting Python\nfile to import, and this script attempts to generate an executable\nthat will produce the same results as \"python startfile.py\".\n\nThis script is actually a wrapper around Panda's FreezeTool.py, which\nis itself a tool to use Python's built-in \"freeze\" utility to compile\nPython code into a standalone executable.  It also uses Python's\nbuilt-in modulefinder module, which it uses to find all of the modules\nimported directly or indirectly by the original startfile.py.\n\nUsage::\n\n  pfreeze.py [opts] [startfile]\n\nOptions::\n\n  -o output\n     Specifies the name of the resulting executable file to produce.\n     If this ends in \".mf\", a multifile is written instead of a frozen\n     binary.  If it ends in \".dll\", \".pyd\", or \".so\", a shared library\n     is written.\n\n  -x module[,module...]\n     Specifies a comma-separated list of Python modules to exclude from\n     the resulting file, even if they appear to be referenced.  You\n     may also repeat the -x command for each module.\n\n  -i module[,module...]\n     Specifies a comma-separated list of Python modules to include in\n     the resulting file, even if they do not appear to be referenced.\n     You may also repeat the -i command for each module.\n\n  -p module[,module...]\n     Specifies a list of Python modules that do run-time manipulation\n     of the __path__ variable, and thus must be actually imported to\n     determine the true value of __path__.\n\n  -P path\n     Specifies an additional directory in which we should search for\n     Python modules.  This is equivalent to setting the PYTHONPATH\n     environment variable.  May be repeated.\n\n  -s\n     Adds the standard set of modules that are necessary for embedding\n     the Python interpreter.  Implicitly set if an executable is\n     generated.\n\n  -k\n     Keeps temporary files generated by pfreeze.  Useful when debugging\n     FreezeTool itself.\n\n\"\"\"\n\nimport getopt\nimport sys\nimport os\nfrom . import FreezeTool\n\ndef usage(code, msg = ''):\n    if __doc__:\n        sys.stderr.write(__doc__ + '\\n')\n    sys.stderr.write(str(msg) + '\\n')\n    sys.exit(code)\n\n\ndef main(args=None):\n    if args is None:\n        args = sys.argv[1:]\n\n    freezer = FreezeTool.Freezer()\n\n    basename = None\n    addStartupModules = False\n\n    try:\n        opts, args = getopt.getopt(args, 'o:i:x:p:P:slkh')\n    except getopt.error as msg:\n        usage(1, msg)\n\n    for opt, arg in opts:\n        if opt == '-o':\n            basename = arg\n        elif opt == '-i':\n            for module in arg.split(','):\n                freezer.addModule(module)\n        elif opt == '-x':\n            for module in arg.split(','):\n                freezer.excludeModule(module)\n        elif opt == '-p':\n            for module in arg.split(','):\n                freezer.handleCustomPath(module)\n        elif opt == '-P':\n            sys.path.append(arg)\n        elif opt == '-s':\n            addStartupModules = True\n        elif opt == '-l':\n            freezer.linkExtensionModules = True\n        elif opt == '-k':\n            freezer.keepTemporaryFiles = True\n        elif opt == '-h':\n            usage(0)\n        else:\n            print('illegal option: ' + opt)\n            sys.exit(1)\n\n    if not basename:\n        usage(1, 'You did not specify an output file.')\n\n    if len(args) > 1:\n        usage(1, 'Only one main file may be specified.')\n\n    outputType = 'exe'\n    bl = basename.lower()\n    if bl.endswith('.mf'):\n        outputType = 'mf'\n    elif bl.endswith('.c'):\n        outputType = 'c'\n    elif bl.endswith('.dll') or bl.endswith('.pyd') or bl.endswith('.so'):\n        basename = os.path.splitext(basename)[0]\n        outputType = 'dll'\n    elif bl.endswith('.exe'):\n        basename = os.path.splitext(basename)[0]\n\n    compileToExe = False\n    if args:\n        startfile = args[0]\n        startmod = startfile\n        if startfile.endswith('.py') or startfile.endswith('.pyw') or \\\n        startfile.endswith('.pyc') or startfile.endswith('.pyo'):\n            startmod = os.path.splitext(startfile)[0]\n\n        if outputType == 'dll' or outputType == 'c':\n            freezer.addModule(startmod, filename = startfile)\n        else:\n            freezer.addModule('__main__', filename = startfile)\n            compileToExe = True\n            addStartupModules = True\n\n    elif outputType == 'exe':\n        # We must have a main module when making an executable.\n        usage(1, 'A main file needs to be specified when creating an executable.')\n\n    freezer.done(addStartupModules = addStartupModules)\n\n    if outputType == 'mf':\n        freezer.writeMultifile(basename)\n    elif outputType == 'c':\n        freezer.writeCode(basename)\n    else:\n        freezer.generateCode(basename, compileToExe = compileToExe)\n\n    return 0\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/dist/pfreeze.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/619969b9_pfreeze.json",
    "doc_id": "doc_134"
  }
}