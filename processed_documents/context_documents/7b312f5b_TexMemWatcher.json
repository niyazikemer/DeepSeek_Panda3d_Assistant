{
  "content": "from panda3d.core import (\n    BitArray,\n    ButtonThrower,\n    Camera,\n    CardMaker,\n    ConfigVariableInt,\n    FrameBufferProperties,\n    GraphicsOutput,\n    GraphicsPipe,\n    LineSegs,\n    Mat4,\n    MouseAndKeyboard,\n    MouseWatcher,\n    MouseWatcherRegion,\n    NodePath,\n    OrthographicLens,\n    PNMImage,\n    TextNode,\n    Texture,\n    TextureStage,\n    TransparencyAttrib,\n    WindowProperties,\n)\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.showbase import ShowBaseGlobal\nfrom direct.task.TaskManagerGlobal import taskMgr\nimport math\nimport copy\n\n\nclass TexMemWatcher(DirectObject):\n    \"\"\"\n    This class creates a separate graphics window that displays an\n    approximation of the current texture memory, showing the textures\n    that are resident and/or active, and an approximation of the\n    amount of texture memory consumed by each one.  It's intended as a\n    useful tool to help determine where texture memory is being spent.\n\n    Although it represents the textures visually in a 2-d space, it\n    doesn't actually have any idea how textures are physically laid\n    out in memory--but it has to lay them out somehow, so it makes\n    something up.  It occasionally rearranges the texture display when\n    it feels it needs to, without regard to what the graphics card is\n    actually doing.  This tool can't be used to research texture\n    memory fragmentation issues.\n    \"\"\"\n\n    NextIndex = 1\n\n    StatusHeight = 20  # in pixels\n\n    def __init__(self, gsg = None, limit = None):\n        DirectObject.__init__(self)\n\n        # First, we'll need a name to uniquify the object.\n        self.name = 'tex-mem%s' % (TexMemWatcher.NextIndex)\n        TexMemWatcher.NextIndex += 1\n\n        self.cleanedUp = False\n        self.top = 1.0\n\n        # The textures managed by the TexMemWatcher are packed\n        # arbitrarily into the canvas, which is the viewable region\n        # that represents texture memory allocation.  The packing\n        # arrangement has no relation to actual layout within texture\n        # memory (which we have no way to determine).\n\n        # The visual size of each texture is chosen in proportion to\n        # the total number of bytes of texture memory the texture\n        # consumes.  This includes mipmaps, and accounts for texture\n        # compression.  Visually, a texture with mipmaps will be\n        # represented by a rectangle 33% larger than an\n        # equivalent-sized texture without mipmaps.  Of course, this\n        # once again has little bearing to the way the textures are\n        # actually arranged in memory; but it serves to give a visual\n        # indication of how much texture memory each texture consumes.\n\n        # There is an arbitrary limit, self.limit, which may have been\n        # passed to the constructor, or which may be arbitrarily\n        # determined.  This represents the intended limit to texture\n        # memory utilization.  We (generously) assume that the\n        # graphics card will implement a perfect texture packing\n        # algorithm, so that as long as our total utilization <=\n        # self.limit, it must fit within texture memory.  We represent\n        # this visually by aggressively packing textures within the\n        # self.limit block so that they are guaranteed to fit, as long\n        # as we do not exceed the total utilization.  This may\n        # sometimes mean distorting a texture block or even breaking\n        # it into multiple pieces to get it to fit, clearly\n        # fictionalizing whatever the graphics driver is actually\n        # doing.\n\n        # Internally, textures are packed into an integer grid of\n        # Q-units.  Q-units are in proportion to texture bytes.\n        # Specifically, each Q-unit corresponds to a block of\n        # self.quantize * self.quantize texture bytes in the Texture\n        # Memory window.  The Q-units are the smallest packable unit;\n        # increasing self.quantize therefore reduces the visual\n        # packing resolution correspondingly.  Q-units very roughly\n        # correspond to pixels onscreen (they may be larger, sometimes\n        # considerably larger, than 1 pixel, depending on the window\n        # size).\n\n\n        # This number defines the size of a Q-unit square, in texture\n        # bytes.  It is automatically adjusted in repack() based on\n        # the window size and the texture memory size.\n        self.quantize = 1\n\n        # This is the maximum number of bitmask rows (within\n        # self.limit) to allocate for packing.  This controls the\n        # value assigned to self.quantize in repack().\n        self.maxHeight = ConfigVariableInt('tex-mem-max-height', 300).value\n\n        # The total number of texture bytes tracked, including overflow.\n        self.totalSize = 0\n\n        # The total number of texture bytes placed, not including\n        # overflow (that is, within self.limit).\n        self.placedSize = 0\n\n        # The total number of Q-units placed, not including overflow.\n        self.placedQSize = 0\n\n        # If no GSG is specified, use the main GSG.\n        base = ShowBaseGlobal.base\n        if gsg is None:\n            gsg = base.win.getGsg()\n        elif isinstance(gsg, GraphicsOutput):\n            # If we were passed a window, use that window's GSG.\n            gsg = gsg.getGsg()\n\n        self.gsg = gsg\n\n        # Now open a new window just to render the output.\n        size = ConfigVariableInt('tex-mem-win-size', '300 300')\n        origin = ConfigVariableInt('tex-mem-win-origin', '100 100')\n        self.winSize = (size[0], size[1])\n        name = 'Texture Memory'\n        props = WindowProperties()\n        props.setOrigin(origin[0], origin[1])\n        props.setSize(*self.winSize)\n        props.setTitle(name)\n        props.setFullscreen(False)\n        props.setUndecorated(False)\n\n        fbprops = FrameBufferProperties.getDefault()\n        flags = GraphicsPipe.BFFbPropsOptional | GraphicsPipe.BFRequireWindow\n\n        self.pipe = None\n\n        # Set this to tinydisplay if you're running on a machine with\n        # limited texture memory.  That way you won't compete for\n        # texture memory with the main scene.\n        moduleName = ConfigVariableString('tex-mem-pipe', '').value\n        if moduleName:\n            self.pipe = base.makeModulePipe(moduleName)\n\n        # If the requested pipe fails for some reason, we'll use the\n        # regular pipe.\n        if not self.pipe:\n            self.pipe = base.pipe\n\n        self.win = base.graphicsEngine.makeOutput(self.pipe, name, 0, fbprops,\n                                                  props, flags)\n        assert self.win\n\n        # We should render at the end of the frame.\n        self.win.setSort(10000)\n\n        # We don't need to clear the color buffer, since we'll be\n        # filling it with a texture.  We also don't need to clear the\n        # depth buffer, since we won't be using it.\n        self.win.setClearColorActive(False)\n        self.win.setClearDepthActive(False)\n\n        eventName = '%s-window' % (self.name)\n        self.win.setWindowEvent(eventName)\n        self.accept(eventName, self.windowEvent)\n\n        # Listen for this event so we can update appropriately, if\n        # anyone changes the window's graphics memory limit,\n        self.accept('graphics_memory_limit_changed',\n                    self.graphicsMemoryLimitChanged)\n\n        # We'll need a mouse object to get mouse events.\n        self.mouse = base.dataRoot.attachNewNode(MouseAndKeyboard(self.win, 0, '%s-mouse' % (self.name)))\n        bt = ButtonThrower('%s-thrower' % (self.name))\n        self.mouse.attachNewNode(bt)\n        bt.setPrefix('button-%s-' % (self.name))\n        self.accept('button-%s-mouse1' % (self.name), self.mouseClick)\n\n        self.setupGui()\n        self.setupCanvas()\n\n        # Now start handling up the actual stuff in the scene.\n\n        self.background = None\n        self.nextTexRecordKey = 0\n        self.rollover = None\n        self.isolate = None\n        self.isolated = None\n        self.needsRepack = False\n\n        # How frequently should the texture memory window check for\n        # state changes?\n        updateInterval = ConfigVariableDouble(\"tex-mem-update-interval\", 0.5).value\n        self.task = taskMgr.doMethodLater(updateInterval, self.updateTextures, 'TexMemWatcher')\n\n        self.setLimit(limit)\n\n    def setupGui(self):\n        \"\"\" Creates the gui elements and supporting structures. \"\"\"\n\n        self.render2d = NodePath('render2d')\n        self.render2d.setDepthTest(False)\n        self.render2d.setDepthWrite(False)\n        self.render2d.setTwoSided(True)\n        self.render2d.setBin('unsorted', 0)\n\n        # Create a DisplayRegion and an associated camera.\n        dr = self.win.makeDisplayRegion()\n        cam = Camera('cam2d')\n        self.lens = OrthographicLens()\n        self.lens.setNearFar(-1000, 1000)\n        self.lens.setFilmSize(2, 2)\n        cam.setLens(self.lens)\n\n        np = self.render2d.attachNewNode(cam)\n        dr.setCamera(np)\n\n        self.aspect2d = self.render2d.attachNewNode('aspect2d')\n\n        cm = CardMaker('statusBackground')\n        cm.setColor(0.85, 0.85, 0.85, 1)\n        cm.setFrame(0, 2, 0, 2)\n        self.statusBackground = self.render2d.attachNewNode(cm.generate(), -1)\n        self.statusBackground.setPos(-1, 0, -1)\n\n        self.status = self.aspect2d.attachNewNode('status')\n        self.statusText = TextNode('statusText')\n        self.statusText.setTextColor(0, 0, 0, 1)\n        self.statusTextNP = self.status.attachNewNode(self.statusText)\n        self.statusTextNP.setScale(1.5)\n\n        self.sizeText = TextNode('sizeText')\n        self.sizeText.setTextColor(0, 0, 0, 1)\n        self.sizeText.setAlign(TextNode.ARight)\n        self.sizeText.setCardAsMargin(0.25, 0, 0, -0.25)\n        self.sizeText.setCardColor(0.85, 0.85, 0.85, 1)\n        self.sizeTextNP = self.status.attachNewNode(self.sizeText)\n        self.sizeTextNP.setScale(1.5)\n\n    def setupCanvas(self):\n        \"\"\" Creates the \"canvas\", which is the checkerboard area where\n        texture memory is laid out.  The canvas has its own\n        DisplayRegion. \"\"\"\n\n        self.canvasRoot = NodePath('canvasRoot')\n        self.canvasRoot.setDepthTest(False)\n        self.canvasRoot.setDepthWrite(False)\n        self.canvasRoot.setTwoSided(True)\n        self.canvasRoot.setBin('unsorted', 0)\n\n        self.canvas = self.canvasRoot.attachNewNode('canvas')\n\n        # Create a DisplayRegion and an associated camera.\n        self.canvasDR = self.win.makeDisplayRegion()\n        self.canvasDR.setSort(-10)\n        cam = Camera('cam2d')\n        self.canvasLens = OrthographicLens()\n        self.canvasLens.setNearFar(-1000, 1000)\n        cam.setLens(self.canvasLens)\n\n        np = self.canvasRoot.attachNewNode(cam)\n        self.canvasDR.setCamera(np)\n\n        # Create a MouseWatcher so we can interact with the various\n        # textures.\n        self.mw = MouseWatcher('%s-watcher' % (self.name))\n        self.mw.setDisplayRegion(self.canvasDR)\n        mwnp = self.mouse.attachNewNode(self.mw)\n\n        eventName = '%s-enter' % (self.name)\n        self.mw.setEnterPattern(eventName)\n        self.accept(eventName, self.enterRegion)\n\n        eventName = '%s-leave' % (self.name)\n        self.mw.setLeavePattern(eventName)\n        self.accept(eventName, self.leaveRegion)\n\n        # Create a checkerboard background card for the canvas.\n        p = PNMImage(2, 2, 1)\n        p.setGray(0, 0, 0.40)\n        p.setGray(1, 1, 0.40)\n        p.setGray(0, 1, 0.75)\n        p.setGray(1, 0, 0.75)\n\n        self.checkTex = Texture('checkTex')\n        self.checkTex.load(p)\n        self.checkTex.setMagfilter(Texture.FTNearest)\n\n        self.canvasBackground = None\n\n        self.makeCanvasBackground()\n\n    def makeCanvasBackground(self):\n        if self.canvasBackground:\n            self.canvasBackground.removeNode()\n\n        self.canvasBackground = self.canvasRoot.attachNewNode('canvasBackground', -100)\n\n        cm = CardMaker('background')\n        cm.setFrame(0, 1, 0, 1)\n        cm.setUvRange((0, 0), (1, 1))\n        self.canvasBackground.attachNewNode(cm.generate())\n\n        cm.setFrame(0, 1, 1, self.top)\n        cm.setUvRange((0, 1), (1, self.top))\n        bad = self.canvasBackground.attachNewNode(cm.generate())\n        bad.setColor((0.8, 0.2, 0.2, 1))\n\n        self.canvasBackground.setTexture(self.checkTex)\n\n    def setLimit(self, limit = None):\n        \"\"\" Indicates the texture memory limit.  If limit is None or\n        unspecified, the limit is taken from the GSG, if any; or there\n        is no limit. \"\"\"\n\n        self.__doSetLimit(limit)\n        self.reconfigureWindow()\n\n    def __doSetLimit(self, limit):\n        \"\"\" Internal implementation of setLimit(). \"\"\"\n        self.limit = limit\n        self.lruLimit = False\n        self.dynamicLimit = False\n\n        if not limit:\n            # If no limit was specified, use the specified graphics\n            # memory limit, if any.\n            lruSize = self.gsg.getPreparedObjects().getGraphicsMemoryLimit()\n            if lruSize and lruSize < 2**32 - 1:\n                # Got a real lruSize.  Use it.\n                self.limit = lruSize\n                self.lruLimit = True\n\n            else:\n                # No LRU limit either, so there won't be a practical\n                # limit to the TexMemWatcher.  We'll determine our\n                # limit on-the-fly instead.\n                self.dynamicLimit = True\n\n        if self.dynamicLimit:\n            # Choose a suitable limit by rounding to the next power of two.\n            limit = 1\n            while limit < self.totalSize:\n                limit *= 2\n            self.limit = limit\n\n        # Set our GSG to limit itself to no more textures than we\n        # expect to display onscreen, so we don't go crazy with\n        # texture memory.\n        self.win.getGsg().getPreparedObjects().setGraphicsMemoryLimit(self.limit)\n\n        # The actual height of the canvas, including the overflow\n        # area.  The texture memory itself is restricted to (0..1)\n        # vertically; anything higher than 1 is overflow.\n        top = 1.25\n        if self.dynamicLimit:\n            # Actually, we'll never exceed texture memory, so never mind.\n            top = 1\n        if top != self.top:\n            self.top = top\n            self.makeCanvasBackground()\n\n        self.canvasLens.setFilmSize(1, self.top)\n        self.canvasLens.setFilmOffset(0.5, self.top / 2.0)  # lens covers 0..1 in x and y\n\n    def cleanup(self):\n        if not self.cleanedUp:\n            self.cleanedUp = True\n\n            # Remove the window.\n            self.win.engine.removeWindow(self.win)\n            self.win = None\n            self.gsg = None\n            self.pipe = None\n\n            # Remove the mouse.\n            self.mouse.detachNode()\n\n            taskMgr.remove(self.task)\n            self.ignoreAll()\n\n            self.canvas.getChildren().detach()\n            self.texRecordsByTex = {}\n            self.texRecordsByKey = {}\n            self.texPlacements = {}\n\n    def graphicsMemoryLimitChanged(self):\n        if self.dynamicLimit or self.lruLimit:\n            self.__doSetLimit(None)\n            self.reconfigureWindow()\n\n    def windowEvent(self, win):\n        if win == self.win:\n            props = win.getProperties()\n            if not props.getOpen():\n                # User closed window.\n                self.cleanup()\n                return\n\n            size = (props.getXSize(), props.getYSize())\n            if size != self.winSize:\n                self.winSize = size\n                self.reconfigureWindow()\n\n    def enterRegion(self, region, buttonName):\n        \"\"\" the mouse has rolled over a texture. \"\"\"\n        key, pi = map(int, region.getName().split(':'))\n        tr = self.texRecordsByKey.get(key)\n        if not tr:\n            return\n\n        self.setRollover(tr, pi)\n\n    def leaveRegion(self, region, buttonName):\n        \"\"\" the mouse is no longer over a texture. \"\"\"\n        key, pi = map(int, region.getName().split(':'))\n        tr = self.texRecordsByKey.get(key)\n        if tr != self.rollover:\n            return\n\n        self.setRollover(None, None)\n\n    def mouseClick(self):\n        \"\"\" Received a mouse-click within the window.  This isolates\n        the currently-highlighted texture into a full-window\n        presentation. \"\"\"\n\n        if self.isolate:\n            # We're already isolating a texture; the click undoes this.\n            self.isolateTexture(None)\n            return\n\n        if self.rollover:\n            self.isolateTexture(self.rollover)\n\n    def setRollover(self, tr, pi):\n        \"\"\" Sets the highlighted texture (due to mouse rollover) to\n        the indicated texture, or None to clear it. \"\"\"\n\n        self.rollover = tr\n        if self.rollover:\n            self.statusText.setText(tr.tex.getName())\n        else:\n            self.statusText.setText('')\n\n    def isolateTexture(self, tr):\n        \"\"\" Isolates the indicated texture onscreen, or None to\n        restore normal mode. \"\"\"\n\n        if self.isolate:\n            self.isolate.removeNode()\n            self.isolate = None\n\n        self.isolated = tr\n\n        # Undo the previous call to isolate.\n        self.canvas.show()\n        self.canvasBackground.clearColor()\n        self.win.getGsg().setTextureQualityOverride(Texture.QLDefault)\n        if hasattr(self.gsg, 'clearFlashTexture'):\n            self.gsg.clearFlashTexture()\n\n        if not tr:\n            return\n\n        # Now isolate.\n\n        self.canvas.hide()\n        # Disable the red bar at the top.\n        self.canvasBackground.setColor(1, 1, 1, 1, 1)\n\n        # Show the texture in all its filtered glory.\n        self.win.getGsg().setTextureQualityOverride(Texture.QLBest)\n\n        if hasattr(self.gsg, 'setFlashTexture'):\n            # Start the texture flashing in the main window.\n            self.gsg.setFlashTexture(tr.tex)\n\n        self.isolate = self.render2d.attachNewNode('isolate')\n\n        wx, wy = self.winSize\n\n        # Put a label on the bottom of the screen.\n        tn = TextNode('tn')\n        tn.setText('%s\\n%s x %s\\n%s' % (\n            tr.tex.getName(), tr.tex.getXSize(), tr.tex.getYSize(),\n            self.formatSize(tr.size)))\n        tn.setAlign(tn.ACenter)\n        tn.setCardAsMargin(100.0, 100.0, 0.1, 0.1)\n        tn.setCardColor(0.1, 0.2, 0.4, 1)\n        tnp = self.isolate.attachNewNode(tn)\n        scale = 30.0 / wy\n        tnp.setScale(scale * wy / wx, scale, scale)\n        tnp.setPos(base.render2d, 0, 0, -1 - tn.getBottom() * scale)\n\n        labelTop = tn.getHeight() * scale\n\n        # Make a card that shows the texture in actual pixel size, but\n        # don't let it exceed the screen size.\n        tw = tr.tex.getXSize()\n        th = tr.tex.getYSize()\n\n        wx = float(wx)\n        wy = float(wy) * (2.0 - labelTop) * 0.5\n\n        w = min(tw, wx)\n        h = min(th, wy)\n\n        sx = w / tw\n        sy = h / th\n        s = min(sx, sy)\n\n        w = tw * s / float(self.winSize[0])\n        h = th * s / float(self.winSize[1])\n\n        cx = 0.0\n        cy = 1.0 - (2.0 - labelTop) * 0.5\n\n        l = cx - w\n        r = cx + w\n        b = cy - h\n        t = cy + h\n\n        cm = CardMaker('card')\n        cm.setFrame(l, r, b, t)\n        c = self.isolate.attachNewNode(cm.generate())\n        c.setTexture(tr.tex)\n        c.setTransparency(TransparencyAttrib.MAlpha)\n\n        ls = LineSegs('frame')\n        ls.setColor(0, 0, 0, 1)\n        ls.moveTo(l, 0, b)\n        ls.drawTo(r, 0, b)\n        ls.drawTo(r, 0, t)\n        ls.drawTo(l, 0, t)\n        ls.drawTo(l, 0, b)\n        self.isolate.attachNewNode(ls.create())\n\n\n    def reconfigureWindow(self):\n        \"\"\" Resets everything for a new window size. \"\"\"\n\n        wx, wy = self.winSize\n        if wx <= 0 or wy <= 0:\n            return\n\n        self.aspect2d.setScale(float(wy) / float(wx), 1, 1)\n\n        # Reserve self.StatusHeight pixels for the status bar;\n        # everything else is for the canvas.\n\n        statusScale = float(self.StatusHeight) / float(wy)\n        self.statusBackground.setScale(1, 1, statusScale)\n        self.status.setScale(statusScale)\n        self.statusTextNP.setPos(self.statusBackground, 0, 0, 0.5)\n        self.sizeTextNP.setPos(self.statusBackground, 2, 0, 0.5)\n\n        self.canvasDR.setDimensions(0, 1, statusScale, 1)\n\n        w = self.canvasDR.getPixelWidth()\n        h = self.canvasDR.getPixelHeight()\n        self.canvasBackground.setTexScale(TextureStage.getDefault(),\n                                          w / 20.0, h / (20.0 * self.top))\n\n        if self.isolate:\n            # If we're currently showing an isolated texture, refresh\n            # that display so we get its size right.  And when we come\n            # back to the main window (but not now), repack it.\n            self.needsRepack = True\n            self.isolateTexture(self.isolated)\n\n        else:\n            # If we're showing the main window, just repack it\n            # immediately.\n            self.repack()\n\n    def updateTextures(self, task):\n        \"\"\" Gets the current list of resident textures and adds new\n        textures or removes old ones from the onscreen display, as\n        necessary. \"\"\"\n\n        if self.isolate:\n            # never mind for now.\n            return task.again\n\n        if self.needsRepack:\n            self.needsRepack = False\n            self.repack()\n            return task.again\n\n        pgo = self.gsg.getPreparedObjects()\n        totalSize = 0\n\n        texRecords = []\n        neverVisited = copy.copy(self.texRecordsByTex)\n        for tex in self.gsg.getPreparedTextures():\n            # We have visited this texture; remove it from the\n            # neverVisited list.\n            if tex in neverVisited:\n                del neverVisited[tex]\n\n            size = 0\n            if tex.getResident(pgo):\n                size = tex.getDataSizeBytes(pgo)\n\n            tr = self.texRecordsByTex.get(tex, None)\n\n            if size:\n                totalSize += size\n                active = tex.getActive(pgo)\n                if not tr:\n                    # This is a new texture; need to record it.\n                    key = self.nextTexRecordKey\n                    self.nextTexRecordKey += 1\n                    tr = TexRecord(key, tex, size, active)\n                    texRecords.append(tr)\n                else:\n                    tr.setActive(active)\n                    if tr.size != size or not tr.placements:\n                        # The size has changed; reapply it.\n                        tr.setSize(size)\n                        self.unplaceTexture(tr)\n                        texRecords.append(tr)\n            else:\n                if tr:\n                    # This texture is no longer resident; need to remove it.\n                    self.unplaceTexture(tr)\n\n        # Now go through and make sure we unplace (and remove!) any\n        # textures that we didn't visit at all this pass.\n        for tex, tr in neverVisited.items():\n            self.unplaceTexture(tr)\n            del self.texRecordsByTex[tex]\n            del self.texRecordsByKey[tr.key]\n\n        self.totalSize = totalSize\n        self.sizeText.setText(self.formatSize(self.totalSize))\n        if totalSize > self.limit and self.dynamicLimit:\n            # Actually, never mind on the update: we have exceeded the\n            # dynamic limit computed before, and therefore we need to\n            # repack.\n            self.repack()\n\n        else:\n            overflowCount = sum([tp.overflowed for tp in self.texPlacements.keys()])\n            if totalSize <= self.limit and overflowCount:\n                # Shouldn't be overflowing any more.  Better repack.\n                self.repack()\n\n            else:\n                # Pack in just the newly-loaded textures.\n\n                # Sort the regions from largest to smallest to maximize\n                # packing effectiveness.\n                texRecords.sort(key = lambda tr: (tr.tw, tr.th), reverse = True)\n\n                for tr in texRecords:\n                    self.placeTexture(tr)\n                    self.texRecordsByTex[tr.tex] = tr\n                    self.texRecordsByKey[tr.key] = tr\n\n        return task.again\n\n\n    def repack(self):\n        \"\"\" Repacks all of the current textures. \"\"\"\n\n        self.canvas.getChildren().detach()\n        self.texRecordsByTex = {}\n        self.texRecordsByKey = {}\n        self.texPlacements = {}\n        self.bitmasks = []\n        self.mw.clearRegions()\n        self.setRollover(None, None)\n        self.w = 1\n        self.h = 1\n        self.placedSize = 0\n        self.placedQSize = 0\n\n        pgo = self.gsg.getPreparedObjects()\n        totalSize = 0\n\n        for tex in self.gsg.getPreparedTextures():\n            if tex.getResident(pgo):\n                size = tex.getDataSizeBytes(pgo)\n                if size:\n                    active = tex.getActive(pgo)\n                    key = self.nextTexRecordKey\n                    self.nextTexRecordKey += 1\n                    tr = TexRecord(key, tex, size, active)\n                    self.texRecordsByTex[tr.tex] = tr\n                    self.texRecordsByKey[tr.key] = tr\n                    totalSize += size\n\n        self.totalSize = totalSize\n        self.sizeText.setText(self.formatSize(self.totalSize))\n        if not self.totalSize:\n            return\n\n        if self.dynamicLimit or self.lruLimit:\n            # Adjust the limit to ensure we keep tracking the lru size.\n            self.__doSetLimit(None)\n\n        # Now make that into a 2-D rectangle of the appropriate shape,\n        # such that w * h == limit.\n\n        # Window size\n        x, y = self.winSize\n\n        # There should be a little buffer on the top so we can see if\n        # we overflow.\n        y /= self.top\n\n        r = float(y) / float(x)\n\n        # Region size\n        w = math.sqrt(self.limit) / math.sqrt(r)\n        h = w * r\n\n        # Now choose self.quantize so that we don't exceed\n        # self.maxHeight.\n        if h > self.maxHeight:\n            self.quantize = int(math.ceil(h / self.maxHeight))\n        else:\n            self.quantize = 1\n\n        w = max(int(w / self.quantize + 0.5), 1)\n        h = max(int(h / self.quantize + 0.5), 1)\n        self.w = w\n        self.h = h\n        self.area = self.w * self.h\n\n        # We store a bitarray for each row, for fast lookup for\n        # unallocated space on the canvas.  Each Q-unit on the row\n        # corresponds to a bit in the bitarray, where bit 0 is Q-unit\n        # 0, bit 1 is Q-unit 1, and so on.  If the bit is set, the\n        # space is occupied.\n        self.bitmasks = []\n        for i in range(self.h):\n            self.bitmasks.append(BitArray())\n\n        self.canvas.setScale(1.0 / w, 1.0, 1.0 / h)\n        self.mw.setFrame(0, w, 0, h * self.top)\n\n        # Sort the regions from largest to smallest to maximize\n        # packing effectiveness.\n        texRecords = sorted(self.texRecordsByTex.values(),\n                            key=lambda tr: (tr.tw, tr.th), reverse=True)\n\n        for tr in texRecords:\n            self.placeTexture(tr)\n\n    def formatSize(self, size):\n        \"\"\" Returns a size in MB, KB, GB, whatever. \"\"\"\n        if size < 1000:\n            return '%s bytes' % (size)\n        size /= 1024.0\n        if size < 1000:\n            return '%0.1f kb' % (size)\n        size /= 1024.0\n        if size < 1000:\n            return '%0.1f MB' % (size)\n        size /= 1024.0\n        return '%0.1f GB' % (size)\n\n    def unplaceTexture(self, tr):\n        \"\"\" Removes the texture from its place on the canvas. \"\"\"\n        if tr.placements:\n            for tp in tr.placements:\n                tp.clearBitmasks(self.bitmasks)\n                if not tp.overflowed:\n                    self.placedQSize -= tp.area\n                    assert self.placedQSize >= 0\n                del self.texPlacements[tp]\n            tr.placements = []\n            tr.clearCard(self)\n            if not tr.overflowed:\n                self.placedSize -= tr.size\n                assert self.placedSize >= 0\n        tr.overflowed = 0\n\n    def placeTexture(self, tr):\n        \"\"\" Places the texture somewhere on the canvas where it will\n        fit. \"\"\"\n\n        tr.computePlacementSize(self)\n        tr.overflowed = 0\n\n        shouldFit = False\n        availableSize = self.limit - self.placedSize\n        if availableSize >= tr.size:\n            shouldFit = True\n            availableQSize = self.area - self.placedQSize\n            if availableQSize < tr.area:\n                # The texture should fit, but won't, due to roundoff\n                # error.  Make it correspondingly smaller, so we can\n                # place it anyway.\n                tr.area = availableQSize\n\n        if shouldFit:\n            # Look for a single rectangular hole to hold this piece.\n            tp = self.findHole(tr.area, tr.w, tr.h)\n            if tp:\n                texCmp = (tr.w > tr.h) - (tr.w < tr.h)\n                holeCmp = ((tp.p[1] - tp.p[0]) > (tp.p[3] - tp.p[2])) \\\n                        - ((tp.p[1] - tp.p[0]) < (tp.p[3] - tp.p[2]))\n                if texCmp != 0 and holeCmp != 0 and texCmp != holeCmp:\n                    tp.rotated = True\n                tr.placements = [tp]\n                tr.makeCard(self)\n                tp.setBitmasks(self.bitmasks)\n                self.placedQSize += tp.area\n                self.texPlacements[tp] = tr\n                self.placedSize += tr.size\n                return\n\n            # Couldn't find a single rectangular hole.  We'll have to\n            # divide the texture up into several smaller pieces to cram it\n            # in.\n            tpList = self.findHolePieces(tr.area)\n            if tpList:\n                texCmp = (tr.w > tr.h) - (tr.w < tr.h)\n                tr.placements = tpList\n                for tp in tpList:\n                    holeCmp = ((tp.p[1] - tp.p[0]) > (tp.p[3] - tp.p[2])) \\\n                            - ((tp.p[1] - tp.p[0]) < (tp.p[3] - tp.p[2]))\n                    if texCmp != 0 and holeCmp != 0 and texCmp != holeCmp:\n                        tp.rotated = True\n                    tp.setBitmasks(self.bitmasks)\n                    self.placedQSize += tp.area\n                    self.texPlacements[tp] = tr\n                self.placedSize += tr.size\n                tr.makeCard(self)\n                return\n\n        # Just let it overflow.\n        tr.overflowed = 1\n        tp = self.findOverflowHole(tr.area, tr.w, tr.h)\n        tp.overflowed = 1\n        while len(self.bitmasks) <= tp.p[3]:\n            self.bitmasks.append(BitArray())\n\n        tr.placements = [tp]\n        tr.makeCard(self)\n        tp.setBitmasks(self.bitmasks)\n        self.texPlacements[tp] = tr\n\n\n    def findHole(self, area, w, h):\n        \"\"\" Searches for a rectangular hole that is at least area\n        square units big, regardless of its shape, but attempt to find\n        one that comes close to the right shape, at least.  If one is\n        found, returns an appropriate TexPlacement; otherwise, returns\n        None. \"\"\"\n\n        if area == 0:\n            tp = TexPlacement(0, 0, 0, 0)\n            return tp\n\n        # Rotate the hole to horizontal first.\n        w, h = max(w, h), min(w, h)\n\n        aspect = float(w) / float(h)\n        holes = self.findAvailableHoles(area, w, h)\n\n        # Walk through the list and find the one with the best aspect\n        # match.\n        matches = []\n        for tarea, tp in holes:\n            l, r, b, t = tp.p\n            tw = r - l\n            th = t - b\n\n            # To constrain our area within this rectangle, how would\n            # we have to squish it?\n            if tw < w:\n                # We'd have to make it taller.\n                nh = min(area // tw, th)\n                th = nh\n            elif th < h:\n                # We'd have to make it narrower.\n                nw = min(area // th, tw)\n                tw = nw\n            else:\n                # Hey, we don't have to squish it after all!  Just\n                # return this hole.\n                tw = w\n                th = h\n\n            # Make a new tp that has the right area.\n            tp = TexPlacement(l, l + tw, b, b + th)\n\n            ta = float(max(tw, th)) / float(min(tw, th))\n            if ta == aspect:\n                return tp\n\n            match = min(ta, aspect) / max(ta, aspect)\n            matches.append((match, tp))\n\n        if matches:\n            return max(matches, key=lambda match: match[0])[1]\n        return None\n\n    def findHolePieces(self, area):\n        \"\"\" Returns a list of holes whose net area sums to the given\n        area, or None if there are not enough holes. \"\"\"\n\n        # First, save the original value of self.texPlacements, since\n        # we will be modifying that during this search.\n        savedTexPlacements = copy.copy(self.texPlacements)\n        savedBitmasks = []\n        for ba in self.bitmasks:\n            savedBitmasks.append(BitArray(ba))\n\n        result = []\n\n        while area > 0:\n\n            # We have to call findLargestHole() each time through this\n            # loop, instead of just walking through\n            # findAvailableHoles() in order, because\n            # findAvailableHoles() might return a list of overlapping\n            # holes.\n            tp = self.findLargestHole()\n            if not tp:\n                break\n\n            l, r, b, t = tp.p\n            tpArea = (r - l) * (t - b)\n            if tpArea >= area:\n                # we're done.\n                shorten = (tpArea - area) // (r - l)\n                t -= shorten\n                tp.p = (l, r, b, t)\n                tp.area = (r - l) * (t - b)\n                result.append(tp)\n                self.texPlacements = savedTexPlacements\n                self.bitmasks = savedBitmasks\n                return result\n\n            # Keep going.\n            area -= tpArea\n            result.append(tp)\n            tp.setBitmasks(self.bitmasks)\n            self.texPlacements[tp] = None\n\n        # Huh, not enough room, or no more holes.\n        self.texPlacements = savedTexPlacements\n        self.bitmasks = savedBitmasks\n        return None\n\n    def findLargestHole(self):\n        holes = self.findAvailableHoles(0)\n        if holes:\n            return max(holes, key=lambda hole: hole[0])[1]\n        return None\n\n    def findAvailableHoles(self, area, w = None, h = None):\n        \"\"\" Finds a list of available holes, of at least the indicated\n        area.  Returns a list of tuples, where each tuple is of the\n        form (area, tp).\n\n        If w and h are non-None, this will short-circuit on the first\n        hole it finds that fits w x h, and return just that hole in a\n        singleton list.\n        \"\"\"\n\n        holes = []\n        lastTuples = set()\n        lastBitmask = None\n        b = 0\n        while b < self.h:\n            # Separate this row into (l, r) tuples.\n            bm = self.bitmasks[b]\n            if bm == lastBitmask:\n                # This row is exactly the same as the row below; no\n                # need to reexamine.\n                b += 1\n                continue\n\n            lastBitmask = bm\n\n            tuples = self.findEmptyRuns(bm)\n            newTuples = tuples.difference(lastTuples)\n\n            for l, r in newTuples:\n                # Find out how high we can go with this bitmask.\n                mask = BitArray.range(l, r - l)\n                t = b + 1\n                while t < self.h and (self.bitmasks[t] & mask).isZero():\n                    t += 1\n\n                tpw = r - l\n                tph = t - b\n                tarea = tpw * tph\n                assert tarea > 0\n                if tarea >= area:\n                    tp = TexPlacement(l, r, b, t)\n                    if w and h and \\\n                       ((tpw >= w and tph >= h) or \\\n                        (tph >= w and tpw >= h)):\n                        # This hole is big enough; short circuit.\n                        return [(tarea, tp)]\n\n                    holes.append((tarea, tp))\n\n            lastTuples = tuples\n            b += 1\n\n        return holes\n\n    def findOverflowHole(self, area, w, h):\n        \"\"\" Searches for a hole large enough for (w, h), in the\n        overflow space.  Since the overflow space is infinite, this\n        will always succeed. \"\"\"\n\n        if w > self.w:\n            # It won't fit within the margins at all; just stack it on\n            # the top.\n\n            # Scan down past all of the empty bitmasks that may be\n            # stacked on top.\n            b = len(self.bitmasks)\n            while b > self.h and self.bitmasks[b - 1].isZero():\n                b -= 1\n\n            tp = TexPlacement(0, w, b, b + h)\n            return tp\n\n        # It fits within the margins; find the first row with enough\n        # space for it.\n\n        lastTuples = set()\n        lastBitmask = None\n        b = self.h\n        while True:\n            if b >= len(self.bitmasks):\n                # Off the top.  Just leave it here.\n                tp = TexPlacement(0, w, b, b + h)\n                return tp\n\n            # Separate this row into (l, r) tuples.\n            bm = self.bitmasks[b]\n            if bm == lastBitmask:\n                # This row is exactly the same as the row below; no\n                # need to reexamine.\n                b += 1\n                continue\n\n            lastBitmask = bm\n\n            tuples = self.findEmptyRuns(bm)\n            newTuples = tuples.difference(lastTuples)\n\n            for l, r in newTuples:\n                # Is this region wide enough?\n                if r - l < w:\n                    continue\n\n                # Is it tall enough?\n                r = l + w\n                mask = BitArray.range(l, r - l)\n\n                t = b + 1\n                while t < b + h and \\\n                      (t >= len(self.bitmasks) or (self.bitmasks[t] & mask).isZero()):\n                    t += 1\n\n                if t < b + h:\n                    # Not tall enough.\n                    continue\n\n                tp = TexPlacement(l, r, b, t)\n                return tp\n\n            lastTuples = tuples\n            b += 1\n\n    def findEmptyRuns(self, bm):\n        \"\"\" Separates a bitmask into a list of (l, r) tuples,\n        corresponding to the empty regions in the row between 0 and\n        self.w. \"\"\"\n\n        tuples = set()\n        l = bm.getLowestOffBit()\n        assert l != -1\n        if l < self.w:\n            r = bm.getNextHigherDifferentBit(l)\n            if r == l or r >= self.w:\n                r = self.w\n            tuples.add((l, r))\n            l = bm.getNextHigherDifferentBit(r)\n            while l != r and l < self.w:\n                r = bm.getNextHigherDifferentBit(l)\n                if r == l or r >= self.w:\n                    r = self.w\n                tuples.add((l, r))\n                l = bm.getNextHigherDifferentBit(r)\n\n        return tuples\n\n\nclass TexRecord:\n    def __init__(self, key, tex, size, active):\n        self.key = key\n        self.tex = tex\n        self.active = active\n        self.root = None\n        self.regions = []\n        self.placements = []\n        self.overflowed = 0\n\n        self.setSize(size)\n\n    def setSize(self, size):\n        self.size = size\n        x = self.tex.getXSize()\n        y = self.tex.getYSize()\n        r = float(y) / float(x)\n\n        # Card size, in unscaled texel units.\n        self.tw = math.sqrt(self.size) / math.sqrt(r)\n        self.th = self.tw * r\n\n    def computePlacementSize(self, tmw):\n        self.w = max(int(self.tw / tmw.quantize + 0.5), 1)\n        self.h = max(int(self.th / tmw.quantize + 0.5), 1)\n        self.area = self.w * self.h\n\n\n    def setActive(self, flag):\n        self.active = flag\n        if self.active:\n            self.backing.clearColor()\n            self.matte.clearColor()\n            self.card.clearColor()\n        else:\n            self.backing.setColor((0.2, 0.2, 0.2, 1), 2)\n            self.matte.setColor((0.2, 0.2, 0.2, 1), 2)\n            self.card.setColor((0.4, 0.4, 0.4, 1), 2)\n\n    def clearCard(self, tmw):\n        if self.root:\n            self.root.detachNode()\n            self.root = None\n\n        for r in self.regions:\n            tmw.mw.removeRegion(r)\n        self.regions = []\n\n    def makeCard(self, tmw):\n        self.clearCard(tmw)\n        root = NodePath('root')\n\n        # A matte to frame the texture and indicate its status.\n        matte = root.attachNewNode('matte', 0)\n\n        # A backing to put behind the card.\n        backing = root.attachNewNode('backing', 10)\n\n        # A card to display the texture.\n        card = root.attachNewNode('card', 20)\n\n        # A wire frame to ring the matte and separate the card from\n        # its neighbors.\n        frame = root.attachNewNode('frame', 30)\n\n\n        for p in self.placements:\n            l, r, b, t = p.p\n            cx = (l + r) * 0.5\n            cy = (b + t) * 0.5\n            shrinkMat = Mat4.translateMat(-cx, 0, -cy) * Mat4.scaleMat(0.9) * Mat4.translateMat(cx, 0, cy)\n\n            cm = CardMaker('backing')\n            cm.setFrame(l, r, b, t)\n            cm.setColor(0.1, 0.3, 0.5, 1)\n            c = backing.attachNewNode(cm.generate())\n            c.setMat(shrinkMat)\n\n            cm = CardMaker('card')\n            cm.setFrame(l, r, b, t)\n            if p.rotated:\n                cm.setUvRange((0, 1), (0, 0), (1, 0), (1, 1))\n            c = card.attachNewNode(cm.generate())\n            c.setMat(shrinkMat)\n\n            cm = CardMaker('matte')\n            cm.setFrame(l, r, b, t)\n            matte.attachNewNode(cm.generate())\n\n            ls = LineSegs('frame')\n            ls.setColor(0, 0, 0, 1)\n            ls.moveTo(l, 0, b)\n            ls.drawTo(r, 0, b)\n            ls.drawTo(r, 0, t)\n            ls.drawTo(l, 0, t)\n            ls.drawTo(l, 0, b)\n            f1 = frame.attachNewNode(ls.create())\n            f2 = f1.copyTo(frame)\n            f2.setMat(shrinkMat)\n\n        #matte.flattenStrong()\n        self.matte = matte\n\n        #backing.flattenStrong()\n        self.backing = backing\n\n        card.setTransparency(TransparencyAttrib.MAlpha)\n        card.setTexture(self.tex)\n        #card.flattenStrong()\n        self.card = card\n\n        #frame.flattenStrong()\n        self.frame = frame\n\n        root.reparentTo(tmw.canvas)\n\n        self.root = root\n\n        # Also, make one or more clickable MouseWatcherRegions.\n        assert not self.regions\n        for pi, p in enumerate(self.placements):\n            r = MouseWatcherRegion(f'{self.key}:{pi}', *p.p)\n            tmw.mw.addRegion(r)\n            self.regions.append(r)\n\nclass TexPlacement:\n    def __init__(self, l, r, b, t):\n        self.p = (l, r, b, t)\n        self.area = (r - l) * (t - b)\n        self.rotated = False\n        self.overflowed = 0\n\n    def intersects(self, other):\n        \"\"\" Returns True if the placements intersect, False\n        otherwise. \"\"\"\n\n        ml, mr, mb, mt = self.p\n        tl, tr, tb, tt = other.p\n\n        return (tl < mr and tr > ml and\n                tb < mt and tt > mb)\n\n    def setBitmasks(self, bitmasks):\n        \"\"\" Sets all of the appropriate bits to indicate this region\n        is taken. \"\"\"\n\n        l, r, b, t = self.p\n        mask = BitArray.range(l, r - l)\n\n        for yi in range(b, t):\n            assert (bitmasks[yi] & mask).isZero()\n            bitmasks[yi] |= mask\n\n    def clearBitmasks(self, bitmasks):\n        \"\"\" Clears all of the appropriate bits to indicate this region\n        is available. \"\"\"\n\n        l, r, b, t = self.p\n        mask = ~BitArray.range(l, r - l)\n\n        for yi in range(b, t):\n            assert (bitmasks[yi] | mask).isAllOn()\n            bitmasks[yi] &= mask\n\n    def hasOverlap(self, bitmasks):\n        \"\"\" Returns true if there is an overlap with this region and\n        any other region, false otherwise. \"\"\"\n\n        l, r, b, t = self.p\n        mask = BitArray.range(l, r - l)\n\n        for yi in range(b, t):\n            if not (bitmasks[yi] & mask).isZero():\n                return True\n        return False\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showutil/TexMemWatcher.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/7b312f5b_TexMemWatcher.json",
    "doc_id": "doc_172"
  }
}