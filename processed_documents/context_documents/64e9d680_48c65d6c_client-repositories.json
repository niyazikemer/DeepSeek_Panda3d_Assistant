{
  "content": "Client Repositories\n\nSimilar to the server repositories, client repositories are there to handle the lower-level connection code to the server. As seen earlier in the ai-repositories chapter, client repositories doesn\u2019t necessarily have to be on end-user machines but can also be used on servers. A basic client repository implementation may look as follows or should at least implement the following set of functions to work properly.\n\nfrom direct.distributed.ClientRepository import ClientRepository\nfrom panda3d.core import URLSpec, ConfigVariableInt, ConfigVariableString\nfrom DGameObject import DGameObject\n\nclass GameClientRepository(ClientRepository):\n\n    def __init__(self):\n        dcFileNames = ['direct.dc', 'yourOwnDCFile.dc']\n\n        # a distributed object of our game.\n        self.distributedObject = None\n        self.aiDGameObect = None\n\n        ClientRepository.__init__(\n            self,\n            dcFileNames = dcFileNames,\n            threadedNet = True)\n\n        # Set the same port as configured on the server to be able to connect\n        # to it\n        tcpPort = ConfigVariableInt('server-port', 4400).getValue()\n\n        # Set the IP or hostname of the server we want to connect to\n        hostname = ConfigVariableString('server-host', '127.0.0.1').getValue()\n\n        # Build the URL from the server hostname and port. If your server\n        # uses another protocol then http you should change it accordingly.\n        # Make sure to pass the connectMethod to the ClientRepository.__init__\n        # call too.  Available connection methods are:\n        # self.CM_HTTP, self.CM_NET and self.CM_NATIVE\n        self.url = URLSpec('http://{}:{}'.format(hostname, tcpPort))\n\n        # Attempt a connection to the server\n        self.connect([self.url],\n                     successCallback = self.connectSuccess,\n                     failureCallback = self.connectFailure)\n\n    def lostConnection(self):\n        \"\"\" This should be overridden by a derived class to handle an\n        unexpectedly lost connection to the gameserver. \"\"\"\n        # Handle the disconnection from the server.  This can be a reconnect,\n        # simply exiting the application or anything else.\n        exit()\n\n    def connectFailure(self, statusCode, statusString):\n        \"\"\" Something went wrong \"\"\"\n        exit()\n\n    def connectSuccess(self):\n        \"\"\" Successfully connected.  But we still can't really do\n        anything until we've got the doID range. \"\"\"\n\n        # Make sure we have interest in the by the AIRepository defined\n        # TimeManager zone, so we always see it even if we switch to\n        # another zone.\n        self.setInterestZones([1])\n\n        # We must wait for the TimeManager to be fully created and\n        # synced before we can enter another zone and wait for the\n        # game object.  The uniqueName is important that we get the\n        # correct, our sync message from the TimeManager and not\n        # accidentally a message from another client\n        self.acceptOnce(self.uniqueName('gotTimeSync'), self.syncReady)\n\n    def syncReady(self):\n        \"\"\" Now we've got the TimeManager manifested, and we're in\n        sync with the server time.  Now we can enter the world.  Check\n        to see if we've received our doIdBase yet. \"\"\"\n\n        # This method checks whether we actually have a valid doID range\n        # to create distributed objects yet\n        if self.haveCreateAuthority():\n            # we already have one\n            self.gotCreateReady()\n        else:\n            # Not yet, keep waiting a bit longer.\n            self.accept(self.uniqueName('createReady'), self.gotCreateReady)\n\n    def gotCreateReady(self):\n        \"\"\" Ready to enter the world.  Expand our interest to include\n        any other zones \"\"\"\n\n        # This method checks whether we actually have a valid doID range\n        # to create distributed objects yet\n        if not self.haveCreateAuthority():\n            # Not ready yet.\n            return\n\n        # we are ready now, so ignore further createReady events\n        self.ignore(self.uniqueName('createReady'))\n\n        # Now the client is ready to create DOs and send and receive data\n        # to and from the server\n\nFirst of all, we need to initialize the .ClientRepository. This will handle the connection code to the server. We pass it our dc files as well as the threadedNet parameter which will have the same effect as described in the server repositories.\n\nClientRepository.__init__(\n    self,\n    dcFileNames = dcFileNames,\n    threadedNet = True)\n\nHaving the client repository ready, we can try to connect to the desired server with the .ConnectionRepository.connect call available from the CR. Dependent on the outcome, one of the functions given to the call will be used.\n\nself.connect([self.url],\n             successCallback = self.connectSuccess,\n             failureCallback = self.connectFailure)\n\nIn the connectSuccess method we have to make sure that the client is interested in the correct zones in which a time manager has been instantiated. How the time manager is set up and what it is used for will be shown in a later section. For now we just expect it to exist in zone 1 on the AI Server.\n\nAs soon as the client is synced, the .TimeManager will send a gotTimeSync event. It is recommended to show some kind of waiting screen to the user at this point until the client is fully connected to the server.\n\nIn the syncReady and gotCreateReady methods you\u2019ll see the .ClientRepository.haveCreateAuthority function called. This is a check to see if we are already able to create DOs and give them a correct doId. You can create DOs earlier already, but they may have invalid doIds <doId> then.\n\nAt the end of the gotCreateReady method you can fully use the client and create whatever DOs you may need and add other client related logic.\n\nAt this stage, you may also want to set interest in different zones for the client to see objects created by the server and other clients which are placed in those specific zones. You can do this by calling the .ClientRepository.setInterestZones() method which you simply pass a number of zoneIds that this client should see.\n\nShowBase Client Repository\n\nAfter setting up your main client repository, you should add it to your ShowBase instance in a variable called cr, as in the following example:\n\nbase.cr = MyMainClientRepository()",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/48c65d6c_client-repositories.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/64e9d680_48c65d6c_client-repositories.json",
    "doc_id": "doc_613"
  }
}