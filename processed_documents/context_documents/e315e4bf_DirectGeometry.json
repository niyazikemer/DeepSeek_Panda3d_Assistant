{
  "content": "from panda3d.core import (\n    CSDefault,\n    GeomNode,\n    LineSegs,\n    Mat4,\n    NodePath,\n    Point3,\n    Quat,\n    VBase3,\n    VBase4,\n    Vec3,\n    composeMatrix,\n    decomposeMatrix,\n    deg2Rad,\n    rad2Deg,\n)\nfrom .DirectGlobals import Q_EPSILON, UNIT_VEC, ZERO_VEC\nfrom .DirectUtil import CLAMP\nimport math\n\n\nclass LineNodePath(NodePath):\n    def __init__(self, parent = None, name = None,\n                 thickness = 1.0, colorVec = VBase4(1)):\n\n        # Initialize the superclass\n        NodePath.__init__(self)\n\n        if parent is None:\n            parent = hidden\n\n        # Attach a geomNode to the parent and set self to be\n        # the resulting node path\n        self.lineNode = GeomNode(\"lineNode\")\n        self.assign(parent.attachNewNode(self.lineNode))\n        if name:\n            self.setName(name)\n\n        # Create a lineSegs object to hold the line\n        ls = self.lineSegs = LineSegs()\n        # Initialize the lineSegs parameters\n        ls.setThickness(thickness)\n        ls.setColor(colorVec)\n\n    def moveTo(self, *_args):\n        self.lineSegs.moveTo(*_args)\n\n    def drawTo(self, *_args):\n        self.lineSegs.drawTo(*_args)\n\n    def create(self, frameAccurate = 0):\n        self.lineSegs.create(self.lineNode, frameAccurate)\n\n    def reset(self):\n        self.lineSegs.reset()\n        self.lineNode.removeAllGeoms()\n\n    def isEmpty(self):\n        return self.lineSegs.isEmpty()\n\n    def setThickness(self, thickness):\n        self.lineSegs.setThickness(thickness)\n\n    def setColor(self, *_args):\n        self.lineSegs.setColor(*_args)\n\n    def setVertex(self, *_args):\n        self.lineSegs.setVertex(*_args)\n\n    def setVertexColor(self, vertex, *_args):\n        self.lineSegs.setVertexColor(*(vertex,) + _args)\n\n    def getCurrentPosition(self):\n        return self.lineSegs.getCurrentPosition()\n\n    def getNumVertices(self):\n        return self.lineSegs.getNumVertices()\n\n    def getVertex(self, index):\n        return self.lineSegs.getVertex(index)\n\n    def getVertexColor(self):\n        return self.lineSegs.getVertexColor()\n\n    def drawArrow(self, sv, ev, arrowAngle, arrowLength):\n        \"\"\"\n        Do the work of moving the cursor around to draw an arrow from\n        sv to ev. Hack: the arrows take the z value of the end point\n        \"\"\"\n        self.moveTo(sv)\n        self.drawTo(ev)\n        v = sv - ev\n        # Find the angle of the line\n        angle = math.atan2(v[1], v[0])\n        # Get the arrow angles\n        a1 = angle + deg2Rad(arrowAngle)\n        a2 = angle - deg2Rad(arrowAngle)\n        # Get the arrow points\n        a1x = arrowLength * math.cos(a1)\n        a1y = arrowLength * math.sin(a1)\n        a2x = arrowLength * math.cos(a2)\n        a2y = arrowLength * math.sin(a2)\n        z = ev[2]\n        self.moveTo(ev)\n        self.drawTo(Point3(ev + Point3(a1x, a1y, z)))\n        self.moveTo(ev)\n        self.drawTo(Point3(ev + Point3(a2x, a2y, z)))\n\n    def drawArrow2d(self, sv, ev, arrowAngle, arrowLength):\n        \"\"\"\n        Do the work of moving the cursor around to draw an arrow from\n        sv to ev. Hack: the arrows take the z value of the end point\n        \"\"\"\n        self.moveTo(sv)\n        self.drawTo(ev)\n        v = sv - ev\n        # Find the angle of the line\n        angle = math.atan2(v[2], v[0])\n        # Get the arrow angles\n        a1 = angle + deg2Rad(arrowAngle)\n        a2 = angle - deg2Rad(arrowAngle)\n        # Get the arrow points\n        a1x = arrowLength * math.cos(a1)\n        a1y = arrowLength * math.sin(a1)\n        a2x = arrowLength * math.cos(a2)\n        a2y = arrowLength * math.sin(a2)\n        self.moveTo(ev)\n        self.drawTo(Point3(ev + Point3(a1x, 0.0, a1y)))\n        self.moveTo(ev)\n        self.drawTo(Point3(ev + Point3(a2x, 0.0, a2y)))\n\n    def drawLines(self, lineList):\n        \"\"\"\n        Given a list of lists of points, draw a separate line for each list\n        \"\"\"\n        for pointList in lineList:\n            self.moveTo(*pointList[0])\n            for point in pointList[1:]:\n                self.drawTo(*point)\n\n##\n## Given a point in space, and a direction, find the point of intersection\n## of that ray with a plane at the specified origin, with the specified normal\n\n\ndef planeIntersect(lineOrigin, lineDir, planeOrigin, normal):\n    t = 0\n    offset = planeOrigin - lineOrigin\n    t = offset.dot(normal) / lineDir.dot(normal)\n    hitPt = lineDir * t\n    return hitPt + lineOrigin\n\n\ndef getNearProjectionPoint(nodePath):\n    # Find the position of the projection of the specified node path\n    # on the near plane\n    origin = nodePath.getPos(base.direct.camera)\n    # project this onto near plane\n    if origin[1] != 0.0:\n        return origin * (base.direct.dr.near / origin[1])\n    else:\n        # Object is coplaner with camera, just return something reasonable\n        return Point3(0, base.direct.dr.near, 0)\n\n\ndef getScreenXY(nodePath):\n    # Where does the node path's projection fall on the near plane\n    nearVec = getNearProjectionPoint(nodePath)\n    # Clamp these coordinates to visible screen\n    nearX = CLAMP(nearVec[0], base.direct.dr.left, base.direct.dr.right)\n    nearY = CLAMP(nearVec[2], base.direct.dr.bottom, base.direct.dr.top)\n    # What percentage of the distance across the screen is this?\n    percentX = (nearX - base.direct.dr.left)/base.direct.dr.nearWidth\n    percentY = (nearY - base.direct.dr.bottom)/base.direct.dr.nearHeight\n    # Map this percentage to the same -1 to 1 space as the mouse\n    screenXY = Vec3((2 * percentX) - 1.0, nearVec[1], (2 * percentY) - 1.0)\n    # Return the resulting value\n    return screenXY\n\n\ndef getCrankAngle(center):\n    # Used to compute current angle of mouse (relative to the coa's\n    # origin) in screen space\n    x = base.direct.dr.mouseX - center[0]\n    y = base.direct.dr.mouseY - center[2]\n    return 180 + rad2Deg(math.atan2(y, x))\n\n\ndef relHpr(nodePath, base, h, p, r):\n    # Compute nodePath2newNodePath relative to base coordinate system\n    # nodePath2base\n    mNodePath2Base = nodePath.getMat(base)\n    # delta scale, orientation, and position matrix\n    mBase2NewBase = Mat4(Mat4.identMat()) # [gjeon] fixed to give required argument\n    composeMatrix(mBase2NewBase, UNIT_VEC, VBase3(h, p, r), ZERO_VEC,\n                  CSDefault)\n    # base2nodePath\n    mBase2NodePath = base.getMat(nodePath)\n    # nodePath2 Parent\n    mNodePath2Parent = nodePath.getMat()\n    # Compose the result\n    resultMat = mNodePath2Base * mBase2NewBase\n    resultMat = resultMat * mBase2NodePath\n    resultMat = resultMat * mNodePath2Parent\n    # Extract and apply the hpr\n    hpr = Vec3(0)\n    decomposeMatrix(resultMat, VBase3(), hpr, VBase3(),\n                    CSDefault)\n    nodePath.setHpr(hpr)\n\n# Quaternion interpolation\n\n\ndef qSlerp(startQuat, endQuat, t):\n    startQ = Quat(startQuat)\n    destQuat = Quat(Quat.identQuat())\n    # Calc dot product\n    cosOmega = (startQ.getI() * endQuat.getI() +\n                startQ.getJ() * endQuat.getJ() +\n                startQ.getK() * endQuat.getK() +\n                startQ.getR() * endQuat.getR())\n    # If the above dot product is negative, it would be better to\n    # go between the negative of the initial and the final, so that\n    # we take the shorter path.\n    if cosOmega < 0.0:\n        cosOmega *= -1\n        startQ.setI(-1 * startQ.getI())\n        startQ.setJ(-1 * startQ.getJ())\n        startQ.setK(-1 * startQ.getK())\n        startQ.setR(-1 * startQ.getR())\n    if (1.0 + cosOmega) > Q_EPSILON:\n        # usual case\n        if (1.0 - cosOmega) > Q_EPSILON:\n            # usual case\n            omega = math.acos(cosOmega)\n            sinOmega = math.sin(omega)\n            startScale = math.sin((1.0 - t) * omega)/sinOmega\n            endScale = math.sin(t * omega)/sinOmega\n        else:\n            # ends very close\n            startScale = 1.0 - t\n            endScale = t\n        destQuat.setI(startScale * startQ.getI() +\n                      endScale * endQuat.getI())\n        destQuat.setJ(startScale * startQ.getJ() +\n                      endScale * endQuat.getJ())\n        destQuat.setK(startScale * startQ.getK() +\n                      endScale * endQuat.getK())\n        destQuat.setR(startScale * startQ.getR() +\n                      endScale * endQuat.getR())\n    else:\n        # ends nearly opposite\n        destQuat.setI(-startQ.getJ())\n        destQuat.setJ(startQ.getI())\n        destQuat.setK(-startQ.getR())\n        destQuat.setR(startQ.getK())\n        startScale = math.sin((0.5 - t) * math.pi)\n        endScale = math.sin(t * math.pi)\n        destQuat.setI(startScale * startQ.getI() +\n                      endScale * endQuat.getI())\n        destQuat.setJ(startScale * startQ.getJ() +\n                      endScale * endQuat.getJ())\n        destQuat.setK(startScale * startQ.getK() +\n                      endScale * endQuat.getK())\n    return destQuat\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/directtools/DirectGeometry.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/e315e4bf_DirectGeometry.json",
    "doc_id": "doc_187"
  }
}