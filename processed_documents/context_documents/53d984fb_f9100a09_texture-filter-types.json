{
  "content": "Texture Filter Types\n\nIt's rare that the pixels of a texture image match one-to-one with actual screen pixels when a texture is visible onscreen. Usually, it is the case that either a single pixel of the texture is stretched over multiple screen pixels (texture magnification--the texture image is stretched bigger), or the opposite, that multiple pixels of a texture contribute to the color of a single screen pixel (texture minification--the texture image is squished smaller). Often, a single polygon will have some texture pixels that need to be magnified, and some pixels that need to be minified (the graphics card can handle both cases on a single polygon).\n\nYou can control how the texture looks when it is magnified or minified by setting its filter type.\n\npython\n\ntexture.setMagfilter(type)\ntexture.setMinfilter(type)\n\ncpp\n\ntexture->set_magfilter(type);\ntexture->set_minfilter(type);\n\nThe type value is a value from the FilterType enum of .SamplerState. There is a separate filter type setting for magnification and for minification. For both magnification and minification, the filter type may be one of:\n\nFor minification only, in addition to the above two choices, you can also choose from:\n\nThe default filter type for both magnification and minification is FT_linear.\n\nConsider the visual effects of the various filter types on magnification and minification of the following texture:\n\nFT_nearest\n\npython\n\ntexture.setMagfilter(SamplerState.FT_nearest)\ntexture.setMinfilter(SamplerState.FT_nearest)\n\ncpp\n\ntexture->set_magfilter(SamplerState::FT_nearest);\ntexture->set_minfilter(SamplerState::FT_nearest);\n\nUsually, FT_nearest is used only to achieve a special pixelly effect.\n\nFT_linear\n\npython\n\ntexture.setMagfilter(SamplerState.FT_linear)\ntexture.setMinfilter(SamplerState.FT_linear)\n\ncpp\n\ntexture->set_magfilter(SamplerState::FT_linear);\ntexture->set_minfilter(SamplerState::FT_linear);\n\nFT_linear is a good, general-purpose choice, though it isn't perfect.\n\nMipmaps\n\nMany graphics tutorials will go on for pages and pages about exactly what mipmapping means and how it all works inside. We'll spare you those details here; but you should understand the following things about mipmapping:\n\nIt requires 33% more texture memory (per mipmapped texture), but it renders quickly.\n\nIt helps the texture look much smoother than filtering alone when it is minified.\n\nMipmapping doesn't have anything at all to do with magnification.\n\nIt has a tendency to blur minified textures out a little too much, especially when the texture is applied to a polygon that is very nearly edge-on to the camera.\n\nThere are four different filter types that involve mipmapping, but you almost always want to use just the last one, FT_linear_mipmap_linear. The other modes are for advanced uses, and sometimes can be used to tweak the mipmap artifacts a bit (especially to reduce point 4, above). If you don't understand the description in the table above, it's not worth worrying about.\n\npython\n\ntexture.setMinfilter(SamplerState.FT_linear_mipmap_linear)\n\ncpp\n\ntexture->set_minfilter(SamplerState::FT_linear_mipmap_linear);\n\nAnisotropic Filtering\n\nThere is one final addition to the texture filtering equation: you can enable anisotropic filtering on top of any of the above filter modes, which enables a more expensive, slightly slower rendering mode that generally produces superior effects. In particular, anisotropic filtering is usually better at handling texture minification than mipmapping, and doesn't tend to blur out the texture so much.\n\nTo enable anisotropic filtering, you specify the degree:\n\npython\n\ntexture.setAnisotropicDegree(degree)\n\ncpp\n\ntexture->set_anisotropic_degree(degree);\n\nThe degree should be a power-of-two integer number. The default value is 1, which indicates no anisotropic filtering; set it to a higher number to indicate the amount of filtering you require. Larger numbers are more expensive but produce a better result, up to the capability of your graphics card. Many graphics cards support up to 16x anisotropic filtering.\n\npython\n\ntexture.setAnisotropicDegree(2)\n\ncpp\n\ntexture->set_anisotropic_degree(2);",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/f9100a09_texture-filter-types.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/53d984fb_f9100a09_texture-filter-types.json",
    "doc_id": "doc_592"
  }
}