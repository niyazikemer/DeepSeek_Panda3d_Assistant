{
  "content": "Subclassing\n\nIntroduction\n\nBoth Python and C++, being object-oriented programming languages, take advantage of the concept known as \"Inheritance\", to allow for a class to subclass one or more other classes. This allows for the creation of a sub-class (or descendent class) that is said to \"inherit\" all the attributes of the super class (or ancestor class), usually with the purpose of expanding upon them.\n\nSubclassing pure-python classes from python or C++ classes from C++ is fairly straightforward and there's plenty of literature on the subject. The Wikipedia article on inheritance is a good starting point before proceeding to the language-specific documentation.\n\nSpecial care however must be taken when creating a Python class that subclasses from a C++ class, as there are limitations to it.\n\nThe Theory\n\nThe C++ classes do not exactly exist in the Python namespace. They can't; they're C++ objects, not Python objects. Instead, for each C++ class that must be available through Python, a wrapper class that has the same name as the C++ class and all of the same methods has been created. When you call one of the methods on the Python wrapper, it turns around and calls the underlying C++ method of the same name. Thus, it looks like you're actually dealing directly with the C++ object, even though you're really dealing with a Python object.\n\nWhen you inherit from a C++ class, you are actually inheriting from the Python wrapper class. You can't actually inherit from the C++ class itself, since you're writing a Python class, not a C++ class.\n\nThis means that whenever you create an instance of your new inherited class, you're creating an instance of the C++ class, the Python wrapper, and your Python inherited class. But then if you pass a pointer of your instance to some C++ method, all it receives is a pointer to the C++ class.\n\nIn the context of Panda, if you create an instance of a new \"node\" class and store it in the scene graph, you are really only storing the underlying C++ object in the scene graph--the Python part of the object gets left behind. This makes sense, because the C++ structures can only store pointers to C++ objects, not Python objects.\n\nSo, when you pull the node out of the scene graph later, it creates a new Python wrapper around it and returns that new wrapper. Now all you have is the original C++ node--it's not your new node class anymore, it's just the Python wrapper to the C++ class.\n\nThe Practice\n\nWith most C++ classes the only way forward is to create a new C++ subclass and the related Python wrapper around it. However, there is a work-around for classes such as PandaNode and NodePath. Both these C++ classes have in fact been designed with functionality to store and retrieve python objects on them. Specifically, the methods ~.NodePath.set_python_tag(), ~.NodePath.get_python_tag() and ~.NodePath.has_python_tag() are available to respectively store, retrieve and check for the existence of a pointer to an arbitrary Python object on these C++ objects.\n\nThis allows us to subclass from the Python wrapper class around the C++ object and store, on the C++ object, a pointer to the new sub class.\n\nLet's first see an example of what doesn't work:\n\nimport direct.directbase.DirectStart\nfrom panda3d.core import PandaNode\n\n# Here we define the new class, subclassing PandaNode\n# and adding a new variable to it.\nclass MyNewNode(PandaNode):\n    def __init__(self, aName):\n        PandaNode.__init__(self, aName)\n        self.aVariable = \"A value\"\n\n# Here we are creating a new node and we -think-\n# we are placing it in the scene graph:\nmyNewNode = MyNewNode(\"MyNewNode\")\naNodePath = aspect2d.attachNewNode(myNewNode)\n\n# Here we -attempt- to fetch the stored variable,\n# but we'll get an error because aNodePath.node()\n# returns a PandaNode, not myNewNode!\nprint(aNodePath.node().aVariable)\n\nThe workaround is for an instance of the new node class to store itself on the PandaNode, as a Python tag:\n\nimport direct.directbase.DirectStart\nfrom panda3d.core import PandaNode\n\n# Here we define the new class, subclassing PandaNode\n# storing its own instance as a python tag and\n# initializing a new variable.\nclass MyNewNode(PandaNode):\n    def __init__(self, aName):\n        PandaNode.__init__(self, aName)\n        PandaNode.setPythonTag(self, \"subclass\", self)\n        self.aVariable = \"A value\"\n\n# Here we create a new node and we are aware we are\n# placing its -PandaNode- in the scene graph.\nmyNewNode = MyNewNode(\"MyNewNode\")\naNodePath = aspect2d.attachNewNode(myNewNode)\n\n# Now, first we fetch the panda node:\nthePandaNode = aNodePath.node()\n\n# then we fetch the instance of MyNewNode stored on it:\ntheInstanceOfMyNewNode = thePandaNode.getPythonTag(\"subclass\")\n\n# and finally we fetch the variable we were\n# interested in all along:\nprint(theInstanceOfMyNewNode.aVariable)\n\nIn the real world\n\nIn a real-world scenario, while dealing with many nodes of arbitrary types, things get only marginally more difficult. Ultimately you'll want to access attributes that you know are present on nodes of one or more new subclasses. For this purpose, once you have a handle to the subclass instance, you can either test for the type you are expecting (safe but makes the application more static) or you can test for the presence of the attribute itself (less safe but creates potentially more dynamic, expandable application).\n\nFor example:\n\n# here we setup the scene\naNodePath = render.attachNewNode(anInstanceOfMyNewSubclass)\naPandaNode = aNodePath.node()\n\n# here we loop over all nodes under render,\n# to find the one we are interested in:\nfor child in render.getChildren()\n    if child.hasPythonTag(\"subclass\"):\n        theInstanceOfASubclass = child.getPythonTag(\"subclass\")\n\n        # here we test for its type, which is safe\n        # but doesn't catch subclasses of the subclass\n        # or simply other objects that have the same\n        # interface and would work just as well:\n        if type(theInstanceOfASubclass) == type(MyNewSubclass):\n            theInstanceOfASubclass.aVariable = \"a new value\"\n            continue\n\n        # here instead we test for the presence of an\n        # attribute, which mean that all compatible\n        # objects get modified:\n        if hasattr(theInstanceOfASubclass, \"aVariable\"):\n            theInstanceOfASubclass.aVariable = \"a new value\"\n            continue\n\nConclusion\n\nIn conclusion we might not be able to truly subclass a C++ class from Python, but we can certainly get very close to it. There is of course an overhead and these solutions should not be overused, resorting to pure C++ subclasses where performance is an issue. But where performance is not -as much- of an issue, you can probably get a lot of mileage following the examples provided above and expanding upon them.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/8d61bbfe_subclassing.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/0cbeff75_8d61bbfe_subclassing.json",
    "doc_id": "doc_628"
  }
}