{
  "content": "from panda3d.core import ClockObject, ConfigVariableDouble, ConfigVariableInt\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.distributed import DistributedObject\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.distributed.ClockDelta import globalClockDelta\nfrom direct.showbase.MessengerGlobal import messenger\n\n\nclass TimeManager(DistributedObject.DistributedObject):\n    \"\"\"\n    This DistributedObject lives on the AI and on the client side, and\n    serves to synchronize the time between them so they both agree, to\n    within a few hundred milliseconds at least, what time it is.\n\n    It uses a pull model where the client can request a\n    synchronization check from time to time.  It also employs a\n    round-trip measurement to minimize the effect of latency.\n    \"\"\"\n\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"TimeManager\")\n\n    # The number of seconds to wait between automatic\n    # synchronizations.  Set to 0 to disable auto sync after\n    # startup.\n    updateFreq = ConfigVariableDouble('time-manager-freq', 1800).getValue()\n\n    # The minimum number of seconds to wait between two unrelated\n    # synchronization attempts.  Increasing this number cuts down\n    # on frivolous synchronizations.\n    minWait = ConfigVariableDouble('time-manager-min-wait', 10).getValue()\n\n    # The maximum number of seconds of uncertainty to tolerate in\n    # the clock delta without trying again.\n    maxUncertainty = ConfigVariableDouble('time-manager-max-uncertainty', 1).getValue()\n\n    # The maximum number of attempts to try to get a low-latency\n    # time measurement before giving up and accepting whatever we\n    # get.\n    maxAttempts = ConfigVariableInt('time-manager-max-attempts', 5).getValue()\n\n    # A simulated clock skew for debugging, in seconds.\n    extraSkew = ConfigVariableInt('time-manager-extra-skew', 0).getValue()\n\n    if extraSkew != 0:\n        notify.info(\"Simulating clock skew of %0.3f s\" % extraSkew)\n\n    reportFrameRateInterval = ConfigVariableDouble('report-frame-rate-interval', 300.0).getValue()\n\n    def __init__(self, cr):\n        DistributedObject.DistributedObject.__init__(self, cr)\n\n        self.thisContext = -1\n        self.nextContext = 0\n        self.attemptCount = 0\n        self.start = 0\n        self.lastAttempt = -self.minWait*2\n\n    ### DistributedObject methods ###\n\n    def generate(self):\n        \"\"\"\n        This method is called when the DistributedObject is reintroduced\n        to the world, either for the first time or from the cache.\n        \"\"\"\n        DistributedObject.DistributedObject.generate(self)\n\n        self.accept('clock_error', self.handleClockError)\n\n        if self.updateFreq > 0:\n            self.startTask()\n\n    def announceGenerate(self):\n        DistributedObject.DistributedObject.announceGenerate(self)\n        self.cr.timeManager = self\n        self.synchronize(\"TimeManager.announceGenerate\")\n\n    def disable(self):\n        \"\"\"\n        This method is called when the DistributedObject is removed from\n        active duty and stored in a cache.\n        \"\"\"\n        self.ignore('clock_error')\n        self.stopTask()\n        taskMgr.remove('frameRateMonitor')\n        if self.cr.timeManager is self:\n            self.cr.timeManager = None\n        DistributedObject.DistributedObject.disable(self)\n\n    def delete(self):\n        \"\"\"\n        This method is called when the DistributedObject is permanently\n        removed from the world and deleted from the cache.\n        \"\"\"\n        DistributedObject.DistributedObject.delete(self)\n\n    ### Task management methods ###\n\n    def startTask(self):\n        self.stopTask()\n        taskMgr.doMethodLater(self.updateFreq, self.doUpdate, \"timeMgrTask\")\n\n    def stopTask(self):\n        taskMgr.remove(\"timeMgrTask\")\n\n    def doUpdate(self, task):\n        self.synchronize(\"timer\")\n        # Spawn the next one\n        taskMgr.doMethodLater(self.updateFreq, self.doUpdate, \"timeMgrTask\")\n        return Task.done\n\n    ### Automatic clock error handling ###\n\n    def handleClockError(self):\n        self.synchronize(\"clock error\")\n\n    ### Synchronization methods ###\n\n    def synchronize(self, description):\n        \"\"\"synchronize(self, string description)\n\n        Call this function from time to time to synchronize watches\n        with the server.  This initiates a round-trip transaction;\n        when the transaction completes, the time will be synced.\n\n        The description is the string that will be written to the log\n        file regarding the reason for this synchronization attempt.\n\n        The return value is true if the attempt is made, or false if\n        it is too soon since the last attempt.\n        \"\"\"\n        now = ClockObject.getGlobalClock().getRealTime()\n\n        if now - self.lastAttempt < self.minWait:\n            self.notify.debug(\"Not resyncing (too soon): %s\" % (description))\n            return 0\n\n        self.talkResult = 0\n        self.thisContext = self.nextContext\n        self.attemptCount = 0\n        self.nextContext = (self.nextContext + 1) & 255\n        self.notify.info(\"Clock sync: %s\" % (description))\n        self.start = now\n        self.lastAttempt = now\n        self.sendUpdate(\"requestServerTime\", [self.thisContext])\n\n        return 1\n\n    def serverTime(self, context, timestamp):\n        \"\"\"serverTime(self, int8 context, int32 timestamp)\n\n        This message is sent from the AI to the client in response to\n        a previous requestServerTime.  It contains the time as\n        observed by the AI.\n\n        The client should use this, in conjunction with the time\n        measurement taken before calling requestServerTime (above), to\n        determine the clock delta between the AI and the client\n        machines.\n        \"\"\"\n        clock = ClockObject.getGlobalClock()\n        end = clock.getRealTime()\n\n        if context != self.thisContext:\n            self.notify.info(\"Ignoring TimeManager response for old context %d\" % (context))\n            return\n\n        elapsed = end - self.start\n        self.attemptCount += 1\n        self.notify.info(\"Clock sync roundtrip took %0.3f ms\" % (elapsed * 1000.0))\n\n        average = (self.start + end) / 2.0 - self.extraSkew\n        uncertainty = (end - self.start) / 2.0 + abs(self.extraSkew)\n\n        globalClockDelta.resynchronize(average, timestamp, uncertainty)\n\n        self.notify.info(\"Local clock uncertainty +/- %.3f s\" % (globalClockDelta.getUncertainty()))\n\n        if globalClockDelta.getUncertainty() > self.maxUncertainty:\n            if self.attemptCount < self.maxAttempts:\n                self.notify.info(\"Uncertainty is too high, trying again.\")\n                self.start = clock.getRealTime()\n                self.sendUpdate(\"requestServerTime\", [self.thisContext])\n                return\n            self.notify.info(\"Giving up on uncertainty requirement.\")\n\n        messenger.send(\"gotTimeSync\", taskChain = 'default')\n        messenger.send(self.cr.uniqueName(\"gotTimeSync\"), taskChain = 'default')\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/TimeManager.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/66ea5c2b_TimeManager.json",
    "doc_id": "doc_319"
  }
}