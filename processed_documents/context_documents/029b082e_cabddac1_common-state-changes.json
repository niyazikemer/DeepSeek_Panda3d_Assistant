{
  "content": "Common State Changes\n\nThis page lists some of the most common changes you can make to a 3D node. This page is really only a quick cheat-sheet summary: the detailed documentation for these operations comes later in the manual. A full list of manipulations can be found on the API reference page for the .NodePath class.\n\nPositioning Nodes\n\nTwo of the most common changes are position and orientation.\n\npython\n\nmyNodePath.setPos(X, Y, Z)\nmyNodePath.setHpr(Yaw, Pitch, Roll)\n\ncpp\n\nmyNodePath.set_pos(X, Y, Z);\nmyNodePath.set_hpr(Yaw, Pitch, Roll);\n\nBy default in Panda3D, the X axis points to the right, the Y axis is forward, and Z is up. An object's rotation is usually described using Euler angles called Heading, Pitch, and Roll (sometimes called Yaw, Pitch, and Roll in other packages)--these specify angle rotations in degrees. (If you are more comfortable using quaternions, the ~.NodePath.set_quat() method can be used to specify the rotation as a quaternion.)\n\nYou can change an object's size, either uniformly, or with a different value of x, y, and z.\n\npython\n\nmyNodePath.setScale(S)\n\ncpp\n\nmyNodePath.set_scale(S);\n\nSometimes it is convenient to adjust a single component individually:\n\npython\n\nmyNodePath.setX(X)\nmyNodePath.setY(Y)\nmyNodePath.setZ(Z)\nmyNodePath.setH(H)\nmyNodePath.setP(P)\nmyNodePath.setR(R)\nmyNodePath.setSx(SX)\nmyNodePath.setSy(SY)\nmyNodePath.setSz(SZ)\n\ncpp\n\nmyNodePath.set_x(X);\nmyNodePath.set_y(Y);\nmyNodePath.set_z(Z);\nmyNodePath.set_h(H);\nmyNodePath.set_p(P);\nmyNodePath.set_r(R);\nmyNodePath.set_sx(SX);\nmyNodePath.set_sy(SY);\nmyNodePath.set_sz(SZ);\n\nOr all at the same time:\n\npython\n\nmyNodePath.setPosHprScale(X, Y, Z, H, P, R, SX, SY, SZ)\n\ncpp\n\nmyNodePath.set_pos_hpr_scale(X, Y, Z, H, P, R, SX, SY, SZ);\n\nYou can also query the current transform information for any of the above:\n\npython\n\nmyNodePath.getPos()\nmyNodePath.getX()\nmyNodePath.getY()\nmyNodePath.getZ()\n\ncpp\n\nmyNodePath.get_pos();\nmyNodePath.get_x();\nmyNodePath.get_y();\nmyNodePath.get_z();\n\nAs a more advanced feature, you may also set or query the position (or any of the above transform properties) of a particular NodePath with respect to another one. To do this, specify the relative NodePath as the first parameter:\n\npython\n\nmyNodePath.setPos(otherNodePath, X, Y, Z)\nmyNodePath.getPos(otherNodePath)\n\ncpp\n\nmyNodePath.set_pos(otherNodePath, X, Y, Z);\nmyNodePath.get_pos(otherNodePath);\n\nPutting a NodePath as the first parameter to any of the transform setters or getters makes it a relative operation. The above ~.NodePath.set_pos() means to set myNodePath to the position (X, Y, Z), relative to otherNodePath--that is, the position myNodePath would be in if it were a child of otherNodePath and its position were set to (X, Y, Z). The ~.NodePath.get_pos() call returns the position myNodePath would have if it were a child of otherNodePath.\n\nIt is also important to note that you can use the NodePath in its own relative sets and gets. This may be helpful in situations where you are concerned with distances. For example:\n\npython\n\n# Move myNodePath 3 units forward in the x\nmyNodePath.setPos(myNodePath, 3, 0, 0)\n\ncpp\n\n// Move myNodePath 3 units forward in the x\nmyNodePath.set_pos(myNodePath, 3, 0, 0);\n\nThese relative sets and gets are a very powerful feature of Panda's scene graph, but they can also be confusing; don't worry if it doesn't make sense right now.\n\nThe ~.NodePath.look_at() method rotates a model to face another object; that is, it rotates the first object so that its +Y axis points toward the second object. Note that a particular model might or might not have been generated with the +Y axis forward, so this doesn't necessarily make a model \"look at\" the given object.\n\npython\n\nmyNodePath.lookAt(otherObject)\n\ncpp\n\nmyNodePath.look_at(otherObject);\n\npython\n\nTip\n\nIf you have trouble to place, scale or rotate your nodes you can use the place() function to bring up a small GUI which will help you. You need to have Tkinter installed to use it.\n\nmyNodePath.place()\n\nChanging the Parent\n\nOne of the most fundamental scene graph manipulations is changing a node's parent. You need to do this at least once after you load a model, to put it under render for viewing:\n\npython\n\nmyModel.reparentTo(render)\n\ncpp\n\nmyModel.reparent_to(window->get_render());\n\nAs you become more comfortable with scene graph operations, you may find yourself taking more and more advantage of a deeply nested scene graph, and you may start to parent your models to other nodes than just render. Sometimes it is convenient to create an empty node for this purpose, for instance, to group several models together:\n\npython\n\ndummyNode = render.attachNewNode(\"Dummy Node Name\")\nmyModel.reparentTo(dummyNode)\nmyOtherModel.reparentTo(dummyNode)\n\ncpp\n\nNodePath dummy_node = window->get_render().attach_new_node(\"Dummy Node Name\");\nmyModel.reparent_to(dummy_node);\nmyOtherModel.reparent_to(dummy_node);\n\nSince a node inherits its position information from its parent node, when you reparent a node in the scene graph you might inadvertently change its position in the world. If you need to avoid this, you can use a special variant on ~.NodePath.reparent_to():\n\npython\n\nmyModel.wrtReparentTo(newParent)\n\ncpp\n\nmyModel.wrt_reparent_to(new_parent);\n\nThe \"wrt\" prefix stands for \"with respect to\". This special method works like ~.NodePath.reparent_to(), except that it automatically recomputes the local transform on myModel to compensate for the change in transform under the new parent, so that the node ends up in the same position relative to the world.\n\nNote that the computation required to perform ~.NodePath.wrt_reparent_to() is a floating-point matrix computation and is therefore inherently imprecise. This means that if you use ~.NodePath.wrt_reparent_to() repeatedly, thousands of times on the same node, it may eventually accumulate enough numerical inaccuracies to introduce a slight scale on the object (for instance, a scale of 1, 1, 0.99999); if left unchecked, this scale could eventually become noticeable.\n\nBeginners tend to overuse this method; you should not use ~.NodePath.wrt_reparent_to() unless there is a real reason to use it.\n\nChanging the Color\n\nColor changes are another common alteration. Values for color are floating point numbers from 0 to 1, 0 being black, 1 being white.\n\npython\n\nmyNodePath.setColor(R, G, B, A)\n\ncpp\n\nmyNodePath.set_color(R, G, B, A);\n\nIf models have textures, they may not be distinguishable or even visible at certain color settings. Setting the color to white may restore the visibility of the texture, but it is better to simply clear the current color settings.\n\npython\n\nmyNodePath.clearColor()\n\ncpp\n\nmyNodePath.clear_color();\n\nNote the fourth component of color is alpha. This is usually used to indicate transparency, and it is usually 1.0 to indicate the object is not transparent. If you set the alpha to a value between 0 and 1, you can fade the object to invisible. However, in order for the alpha value to be respected, you must first enable transparency:\n\npython\n\nmyNodePath.setTransparency(TransparencyAttrib.MAlpha)\n\ncpp\n\nmyNodePath.set_transparency(TransparencyAttrib::M_alpha);\n\nThe parameter to ~.NodePath.set_transparency() is usually TransparencyAttrib.M_alpha, which is ordinary transparency. You can also explicitly turn transparency off with TransparencyAttrib.M_none. (Other transparency modes are possible, but that is a more advanced topic. Some older code may pass just 0 or 1 for this parameter, but it is better to name the mode.) If you don't explicitly enable transparency first, the alpha component of color may be ignored. Be sure you don't enable transparency unnecessarily, since it does enable a more expensive rendering mode.\n\nSetting an object's color completely replaces any color on the vertices. However, if you have created a model with per-vertex color, you might prefer to modulate the object's color without losing the per-vertex color. For this there is the ~.NodePath.set_color_scale() variant, which multiplies the indicated color values by the object's existing color:\n\npython\n\nmyNodePath.setColorScale(R, G, B, A)\n\ncpp\n\nmyNodePath.set_color_scale(R, G, B, A);\n\nOne use of ~.NodePath.set_color_scale() is to apply it at the top of the scene graph (e.g. render) to darken the entire scene uniformly, for instance to implement a fade-to-black effect.\n\nSince alpha is so important, there is also a method for scaling it without affecting the other color components:\n\npython\n\nmyNodePath.setAlphaScale(SA)\n\ncpp\n\nmyNodePath.set_alpha_scale(SA);\n\nHiding and Showing\n\nTo temporarily prevent an object from being drawn on all cameras, use ~.NodePath.hide() and ~.NodePath.show():\n\npython\n\nmyNodePath.hide()\nmyNodePath.show()\n\ncpp\n\nmyNodePath.hide();\nmyNodePath.show();\n\nIf you want to hide an object for one camera but not another, you can use the ~.NodePath.hide() and ~.NodePath.show() commands in conjunction with the .Camera.set_camera_mask() function:\n\npython\n\ncamera1.node().setCameraMask(BitMask32.bit(0))\ncamera2.node().setCameraMask(BitMask32.bit(1))\nmyNodePath.hide(BitMask32.bit(0))\nmyNodePath.show(BitMask32.bit(1))\n# Now myNodePath will only be shown on camera2...\n\ncpp\n\ncamera1.node()->set_camera_mask(BitMask32::bit(0));\ncamera2.node()->set_camera_mask(BitMask32::bit(1));\nmyNodePath.hide(BitMask32::bit(0));\nmyNodePath.show(BitMask32::bit(1));\n// Now myNodePath will only be shown on camera2...\n\nPlease note that using hide/show without an argument will mess up any hide/shows with the argument (show(bit) will not undo a hide()...) To hide an object from all cameras instead use nodepath.hide(BitMask32.all_on()).\n\npython\n\nTo set the camera mask for the default camera use base.cam, not base.camera, as base.camera is not an actual camera but a dummy node to hold cameras. Please see the camera section for information on how to set up multiple cameras.\n\nAny object that is parented to the object that is hidden will also be hidden. However, you can call ~.NodePath.show_through() on the nested element to force it to show up even if its parent node is hidden.\n\nHiding a model will only cause it to stop rendering, but other operations (such as checking for collisions) will still continue to take place. To deactivate a node and its children entirely, you can call the ~.NodePath.stash() and ~.NodePath.unstash() methods instead.\n\nStoring Custom Information\n\nAlso, by using the functions ~.NodePath.set_tag() and ~.NodePath.get_tag() you can store your own information in key-value pairs. For example:\n\npython\n\nmyNodePath.setTag(\"Key\", \"value\")\n\ncpp\n\nmyNodePath.set_tag(\"Key\", \"value\");\n\npython\n\nYou can also store Python objects as tags by using the ~.NodePath.set_python_tag() function with the same arguments.\n\nRemoving Nodes\n\nTo completely remove a node from the scene graph you can call the following, which has the effect of emptying the node and releasing the memory taken up by the node. Use it only when you have no further use for the node:\n\npython\n\nmyModel.removeNode()\n\ncpp\n\nmyModel.remove_node();\n\nPlease note, however, that this does not really do much more than just calling ~.NodePath.detach_node() followed by dropping the myModel variable. If the model is still referenced from other places, such as the model pool, it will still take up memory. If releasing the model from memory is desired, use the following code:\n\npython\n\nModelPool.releaseModel(\"path/to/model.egg\")\n\ncpp\n\nModelPool::release_model(\"path/to/model.egg\");",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/cabddac1_common-state-changes.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/029b082e_cabddac1_common-state-changes.json",
    "doc_id": "doc_568"
  }
}