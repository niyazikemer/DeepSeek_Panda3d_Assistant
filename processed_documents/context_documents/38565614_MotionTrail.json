{
  "content": "from __future__ import annotations\n\nfrom panda3d.core import (\n    BoundingVolume,\n    ColorBlendAttrib,\n    ColorWriteAttrib,\n    ConfigVariableBool,\n    Geom,\n    GeomNode,\n    GeomTriangles,\n    GeomVertexData,\n    GeomVertexFormat,\n    GeomVertexWriter,\n    Mat4,\n    NodePath,\n    NurbsCurveEvaluator,\n    Vec2,\n    Vec3,\n    Vec4,\n)\nfrom panda3d.direct import CMotionTrail\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nimport warnings\n\n\n_want_python_motion_trails = ConfigVariableBool('want-python-motion-trails', False)\n\n\ndef remove_task():\n    if MotionTrail.task_added:\n        total_motion_trails = len(MotionTrail.motion_trail_list)\n\n        if total_motion_trails > 0:\n            if __debug__:\n                warnings.warn(\"%d motion trails still exist when motion trail task is removed\" % (total_motion_trails), RuntimeWarning, stacklevel=2)\n\n        MotionTrail.motion_trail_list = []\n\n        taskMgr.remove(MotionTrail.motion_trail_task_name)\n\n        print(\"MotionTrail task removed\")\n\n        MotionTrail.task_added = False\n\n\nclass MotionTrailVertex:\n    def __init__(self, vertex_id, vertex_function, context):\n        self.vertex_id = vertex_id\n        self.vertex_function = vertex_function\n        self.context = context\n        self.vertex = Vec4(0.0, 0.0, 0.0, 1.0)\n\n        # default\n        self.start_color = Vec4(1.0, 1.0, 1.0, 1.0)\n        self.end_color = Vec4(0.0, 0.0, 0.0, 1.0)\n        self.v = 0.0\n\n\nclass MotionTrailFrame:\n    def __init__(self, current_time, transform):\n        self.time = current_time\n        self.transform = transform\n\n\nclass MotionTrail(NodePath, DirectObject):\n    \"\"\"Generates smooth geometry-based motion trails behind a moving object.\n\n    To use this class, first define the shape of the cross-section polygon that\n    is to be extruded along the motion trail by calling `add_vertex()` and\n    `set_vertex_color()`.  When this is done, call `update_vertices()`.\n\n    To generate the motion trail, either call `register_motion_trail()`\n    to have Panda update it automatically, or periodically call the method\n    `update_motion_trail()` with the current time and the new transform.\n\n    The duration of the sample history is specified by `time_window`.  A larger\n    time window creates longer motion trails (given constant speed).  Samples\n    that are no longer within the time window are automatically discarded.\n\n    The `use_nurbs` option can be used to create smooth interpolated curves\n    from the samples.  This option is useful for animations that lack sampling\n    to begin with, animations that move very quickly, or low frame rates, or if\n    `sampling_time` is used to artificially slow down the update frequency.\n\n    By default, the optimized C++ implementation (provided by `.CMotionTrail`)\n    is used to generate the motion trails.  If for some reason you want to use\n    the pure-Python implementation instead, set `want-python-motion-trails` to\n    true in Config.prc.\n    \"\"\"\n\n    notify = directNotify.newCategory(\"MotionTrail\")\n\n    task_added = False\n    motion_trail_list: list[MotionTrail] = []\n    motion_trail_task_name = \"motion_trail_task\"\n\n    global_enable = True\n\n    @classmethod\n    def setGlobalEnable(cls, enable):\n        \"\"\"Set this to False to have the task stop updating all motion trails.\n        This does not prevent updating them manually using the\n        `update_motion_trail()` method.\n        \"\"\"\n        cls.global_enable = enable\n\n    def __init__(self, name, parent_node_path):\n        \"\"\"Creates the motion trail with the given name and parents it to the\n        given root node.\n        \"\"\"\n        NodePath.__init__(self, name)\n\n        # required initialization\n        self.active = True\n        self.enable = True\n\n        self.pause = False\n        self.pause_time = 0.0\n\n        self.fade = False\n        self.fade_end = False\n        self.fade_start_time = 0.0\n        self.fade_color_scale = 1.0\n\n        self.total_vertices = 0\n        self.last_update_time = 0.0\n        self.texture = None\n        self.vertex_list = []\n        self.frame_list = []\n\n        self.parent_node_path = parent_node_path\n\n        self.previous_matrix = None\n        self.calculate_relative_matrix = False\n\n        self.playing = False\n\n        # default options\n        self.continuous_motion_trail = True\n        self.color_scale = 1.0\n\n        #: How long the time window is for which the trail is computed.  Can be\n        #: increased to obtain a longer trail, decreased for a shorter trail.\n        self.time_window = 1.0\n\n        #: How often the trail updates, in seconds.  The default is 0.0, which\n        #: has the trail updated every frame for the smoothest result.  Higher\n        #: values will generate a choppier trail.  The `use_nurbs` option can\n        #: compensate partially for this choppiness, however.\n        self.sampling_time = 0.0\n\n        self.square_t = True\n\n#        self.task_transform = False\n        self.root_node_path = None\n\n        # node path states\n        self.reparentTo(parent_node_path)\n\n        #: A `.GeomNode` object containing the generated geometry.  By default\n        #: parented to the MotionTrail itself, but can be reparented elsewhere\n        #: if necessary.\n        self.geom_node = GeomNode(\"motion_trail\")\n        self.geom_node.setBoundsType(BoundingVolume.BT_box)\n        self.geom_node_path = self.attachNewNode(self.geom_node)\n        node_path = self.geom_node_path\n\n        ### set render states\n\n        node_path.setTwoSided(True)\n\n        # set additive blend effects\n        node_path.setTransparency(True)\n        node_path.setDepthWrite(False)\n        node_path.node().setAttrib(ColorBlendAttrib.make(ColorBlendAttrib.MAdd))\n\n        # do not light\n        node_path.setLightOff()\n\n        # disable writes to destination alpha, write out rgb colors only\n        node_path.setAttrib(ColorWriteAttrib.make(ColorWriteAttrib.CRed | ColorWriteAttrib.CGreen | ColorWriteAttrib.CBlue))\n\n        if not MotionTrail.task_added:\n            #taskMgr.add(self.motion_trail_task, \"motion_trail_task\", priority = 50)\n            taskMgr.add(self.motion_trail_task, MotionTrail.motion_trail_task_name)\n\n            self.acceptOnce(\"clientLogout\", remove_task)\n\n            MotionTrail.task_added = True\n\n        self.relative_to_render = False\n\n        #: Set this to True to use a NURBS curve to generate a smooth trail,\n        #: even if the underlying animation or movement is janky.\n        self.use_nurbs = False\n\n        #: This can be changed to fine-tune the resolution of the NURBS curve.\n        self.resolution_distance = 0.5\n\n        self.cmotion_trail = CMotionTrail()\n        self.cmotion_trail.setGeomNode(self.geom_node)\n\n        self.modified_vertices = True\n        if _want_python_motion_trails:\n            self.use_python_version = True\n        else:\n            self.use_python_version = False\n\n    def delete(self):\n        \"\"\"Completely cleans up the motion trail object.\n        \"\"\"\n        self.reset_motion_trail()\n        self.reset_motion_trail_geometry()\n        self.cmotion_trail.resetVertexList()\n        self.removeNode()\n\n    def print_matrix(self, matrix):\n        separator = ' '\n        print(matrix.getCell(0, 0), separator, matrix.getCell(0, 1), separator, matrix.getCell(0, 2), separator, matrix.getCell(0, 3))\n        print(matrix.getCell(1, 0), separator, matrix.getCell(1, 1), separator, matrix.getCell(1, 2), separator, matrix.getCell(1, 3))\n        print(matrix.getCell(2, 0), separator, matrix.getCell(2, 1), separator, matrix.getCell(2, 2), separator, matrix.getCell(2, 3))\n        print(matrix.getCell(3, 0), separator, matrix.getCell(3, 1), separator, matrix.getCell(3, 2), separator, matrix.getCell(3, 3))\n\n    def motion_trail_task(self, task):\n\n        current_time = task.time\n        total_motion_trails = len(MotionTrail.motion_trail_list)\n\n        index = 0\n        while index < total_motion_trails:\n            motion_trail = MotionTrail.motion_trail_list[index]\n\n            if MotionTrail.global_enable:\n                if motion_trail.use_python_version:\n                    # Python version\n                    if motion_trail.active and motion_trail.check_for_update(current_time):\n                        transform = None\n                        if motion_trail.root_node_path is not None and motion_trail.root_node_path != render:\n                            motion_trail.root_node_path.update()\n\n                        if motion_trail.root_node_path and not motion_trail.relative_to_render:\n                            transform = motion_trail.getMat(motion_trail.root_node_path)\n                        else:\n                            transform = Mat4(motion_trail.getNetTransform().getMat())\n\n                        if transform is not None:\n                            motion_trail.update_motion_trail(current_time, transform)\n                else:\n                    # C++ version\n                    if motion_trail.active and motion_trail.cmotion_trail.checkForUpdate(current_time):\n                        transform = None\n                        if motion_trail.root_node_path is not None and motion_trail.root_node_path != render:\n                            motion_trail.root_node_path.update()\n\n                        if motion_trail.root_node_path and not motion_trail.relative_to_render:\n                            transform = motion_trail.getMat(motion_trail.root_node_path)\n                        else:\n                            transform = Mat4(motion_trail.getNetTransform().getMat())\n\n                        if transform is not None:\n                            motion_trail.transferVertices()\n                            motion_trail.cmotion_trail.updateMotionTrail(current_time, transform)\n\n            else:\n                motion_trail.reset_motion_trail()\n                motion_trail.reset_motion_trail_geometry()\n\n            index += 1\n\n        return Task.cont\n\n    def add_vertex(self, vertex_id, vertex_function=None, context=None, *,\n                   start_color=(1.0, 1.0, 1.0, 1.0), end_color=(0.0, 0.0, 0.0, 1.0)):\n        \"\"\"This must be called initially to define the polygon that forms the\n        cross-section of the generated motion trail geometry.  The first\n        argument is a user-defined vertex identifier, the second is a function\n        that will be called with three parameters that should return the\n        position of the vertex as a `.Vec4` object, and the third is an\n        arbitrary context object that is passed as last argument to the\n        provided function.\n\n        After calling this, you must call `update_vertices()` before the\n        changes will fully take effect.\n\n        As of Panda3D 1.10.13, you may alternatively simply pass in a single\n        argument containing the vertex position as a `.Vec4` or `.Point3`.\n        \"\"\"\n        if vertex_function is None:\n            motion_trail_vertex = MotionTrailVertex(None, None, context)\n            motion_trail_vertex.vertex = Vec4(vertex_id)\n        else:\n            motion_trail_vertex = MotionTrailVertex(vertex_id, vertex_function, context)\n        motion_trail_vertex.start_color = Vec4(start_color)\n        motion_trail_vertex.end_color = Vec4(end_color)\n        total_vertices = len(self.vertex_list)\n\n        self.vertex_list[total_vertices : total_vertices] = [motion_trail_vertex]\n\n        self.total_vertices = len(self.vertex_list)\n\n        self.modified_vertices = True\n\n        return motion_trail_vertex\n\n    def set_vertex_color(self, vertex_id, start_color, end_color):\n        \"\"\"Sets the start and end color of the vertex with the given index,\n        which must have been previously added by `add_vertex()`.  The motion\n        trail will contain a smooth gradient between these colors.  By default,\n        the motion trail fades from white to black (which, with the default\n        additive blending mode, makes it show up as a purely white motion trail\n        that fades out towards the end).\n        \"\"\"\n        if vertex_id >= 0 and vertex_id < self.total_vertices:\n            motion_trail_vertex = self.vertex_list[vertex_id]\n            motion_trail_vertex.start_color = start_color\n            motion_trail_vertex.end_color = end_color\n\n        self.modified_vertices = True\n\n    def set_texture(self, texture):\n        \"\"\"Defines the texture that should be applied to the trail geometry.\n        This also enables generation of UV coordinates.\n        \"\"\"\n        self.texture = texture\n        if texture:\n            self.geom_node_path.setTexture(texture)\n#            texture.setWrapU(Texture.WMClamp)\n#            texture.setWrapV(Texture.WMClamp)\n        else:\n            self.geom_node_path.clearTexture()\n\n        self.modified_vertices = True\n\n    def update_vertices(self):\n        \"\"\"This must be called after the list of vertices defining the\n        cross-section shape of the motion trail has been defined by\n        `add_vertex()` and `set_vertex_color()`.\n        \"\"\"\n        total_vertices = len(self.vertex_list)\n\n        self.total_vertices = total_vertices\n        if total_vertices >= 2:\n            vertex_index = 0\n            while vertex_index < total_vertices:\n                motion_trail_vertex = self.vertex_list[vertex_index]\n                if motion_trail_vertex.vertex_function is not None:\n                    motion_trail_vertex.vertex = motion_trail_vertex.vertex_function(motion_trail_vertex, motion_trail_vertex.vertex_id, motion_trail_vertex.context)\n                vertex_index += 1\n\n            # calculate v coordinate\n            # this is based on the number of vertices only and not on the relative positions of the vertices\n            vertex_index = 0\n            float_vertex_index = 0.0\n            float_total_vertices = 0.0\n            float_total_vertices = total_vertices - 1.0\n            while vertex_index < total_vertices:\n                motion_trail_vertex = self.vertex_list[vertex_index]\n                motion_trail_vertex.v = float_vertex_index / float_total_vertices\n                vertex_index += 1\n                float_vertex_index += 1.0\n\n#                print \"motion_trail_vertex.v\", motion_trail_vertex.v\n\n        self.modified_vertices = True\n\n    def transferVertices(self):\n\n        # transfer only on modification\n        if self.modified_vertices:\n            self.cmotion_trail.setParameters(self.sampling_time, self.time_window, self.texture is not None, self.calculate_relative_matrix, self.use_nurbs, self.resolution_distance)\n\n            self.cmotion_trail.resetVertexList()\n\n            vertex_index = 0\n            total_vertices = len(self.vertex_list)\n            while vertex_index < total_vertices:\n                motion_trail_vertex = self.vertex_list[vertex_index]\n                self.cmotion_trail.addVertex(motion_trail_vertex.vertex, motion_trail_vertex.start_color, motion_trail_vertex.end_color, motion_trail_vertex.v)\n                vertex_index += 1\n\n            self.modified_vertices = False\n\n    def register_motion_trail(self):\n        \"\"\"Adds this motion trail to the list of trails that are updated\n        automatically every frame.  Be careful not to call this twice.\n        \"\"\"\n        MotionTrail.motion_trail_list = MotionTrail.motion_trail_list + [self]\n\n    def unregister_motion_trail(self):\n        \"\"\"Removes this motion trail from the list of trails that are updated\n        automatically every frame.  If it is not on that list, does nothing.\n        \"\"\"\n        if self in MotionTrail.motion_trail_list:\n            MotionTrail.motion_trail_list.remove(self)\n\n    def begin_geometry(self):\n        self.vertex_index = 0\n\n        if self.texture is not None:\n            self.format = GeomVertexFormat.getV3c4t2()\n        else:\n            self.format = GeomVertexFormat.getV3c4()\n\n        self.vertex_data = GeomVertexData(\"vertices\", self.format, Geom.UHStatic)\n\n        self.vertex_writer = GeomVertexWriter(self.vertex_data, \"vertex\")\n        self.color_writer = GeomVertexWriter(self.vertex_data, \"color\")\n        if self.texture is not None:\n            self.texture_writer = GeomVertexWriter(self.vertex_data, \"texcoord\")\n\n        self.triangles = GeomTriangles(Geom.UHStatic)\n\n    def add_geometry_quad(self, v0, v1, v2, v3, c0, c1, c2, c3, t0, t1, t2, t3):\n\n        self.vertex_writer.addData3(v0[0], v0[1], v0[2])\n        self.vertex_writer.addData3(v1[0], v1[1], v1[2])\n        self.vertex_writer.addData3(v2[0], v2[1], v2[2])\n        self.vertex_writer.addData3(v3[0], v3[1], v3[2])\n\n        self.color_writer.addData4(c0)\n        self.color_writer.addData4(c1)\n        self.color_writer.addData4(c2)\n        self.color_writer.addData4(c3)\n\n        if self.texture is not None:\n            self.texture_writer.addData2(t0)\n            self.texture_writer.addData2(t1)\n            self.texture_writer.addData2(t2)\n            self.texture_writer.addData2(t3)\n\n        vertex_index = self.vertex_index\n\n        self.triangles.addVertex(vertex_index + 0)\n        self.triangles.addVertex(vertex_index + 1)\n        self.triangles.addVertex(vertex_index + 2)\n        self.triangles.closePrimitive()\n\n        self.triangles.addVertex(vertex_index + 1)\n        self.triangles.addVertex(vertex_index + 3)\n        self.triangles.addVertex(vertex_index + 2)\n        self.triangles.closePrimitive()\n\n        self.vertex_index += 4\n\n    def end_geometry(self):\n        self.geometry = Geom(self.vertex_data)\n        self.geometry.addPrimitive(self.triangles)\n\n        self.geom_node.removeAllGeoms()\n        self.geom_node.addGeom(self.geometry)\n\n    def check_for_update(self, current_time):\n        \"\"\"Returns true if the motion trail is overdue for an update based on\n        the configured `sampling_time` (by default 0.0 to update continuously),\n        and is not currently paused.\n        \"\"\"\n        state = False\n        if (current_time - self.last_update_time) >= self.sampling_time:\n            state = True\n\n        if self.pause:\n            state = False\n\n        update = state and self.enable\n\n        return state\n\n    def update_motion_trail(self, current_time, transform):\n        \"\"\"If the trail is overdue for an update based on the given time in\n        seconds, updates it, extracting the new object position from the given\n        transform matrix.\n        \"\"\"\n        if len(self.frame_list) >= 1:\n            if transform == self.frame_list[0].transform:\n                # ignore duplicate transform updates\n                return\n\n        if self.check_for_update(current_time):\n            color_scale = self.color_scale\n\n            if self.fade:\n                elapsed_time = current_time - self.fade_start_time\n\n                if elapsed_time < 0.0:\n                    print(\"elapsed_time < 0: %f\" % (elapsed_time))\n                    elapsed_time = 0.0\n\n                if elapsed_time < self.fade_time:\n                    color_scale = (1.0 - (elapsed_time / self.fade_time)) * color_scale\n                else:\n                    color_scale = 0.0\n                    self.fade_end = True\n\n            self.last_update_time = current_time\n\n            # remove expired frames\n            minimum_time = current_time - self.time_window\n\n            index = 0\n\n            last_frame_index = len(self.frame_list) - 1\n\n            while index <= last_frame_index:\n                motion_trail_frame = self.frame_list[last_frame_index - index]\n                if motion_trail_frame.time >= minimum_time:\n                    break\n                index += 1\n\n            if index > 0:\n                self.frame_list[last_frame_index - index: last_frame_index + 1] = []\n\n            # add new frame to beginning of list\n            motion_trail_frame = MotionTrailFrame(current_time, transform)\n            self.frame_list = [motion_trail_frame] + self.frame_list\n\n            # convert frames and vertices to geometry\n            total_frames = len(self.frame_list)\n\n            #print(\"total_frames\", total_frames)\n            #\n            #index = 0\n            #while index < total_frames:\n            #    motion_trail_frame = self.frame_list[index]\n            #    print(\"frame time\", index, motion_trail_frame.time)\n            #    index += 1\n\n            if total_frames >= 2 and self.total_vertices >= 2:\n                self.begin_geometry()\n                total_segments = total_frames - 1\n                last_motion_trail_frame = self.frame_list[total_segments]\n                minimum_time = last_motion_trail_frame.time\n                delta_time = current_time - minimum_time\n\n                if self.calculate_relative_matrix:\n                    inverse_matrix = Mat4(transform)\n                    inverse_matrix.invertInPlace()\n\n                if self.use_nurbs and total_frames >= 5:\n\n                    total_distance = 0.0\n                    vector = Vec3()\n\n                    nurbs_curve_evaluator_list = []\n\n                    total_vertex_segments = self.total_vertices - 1\n\n                    # create a NurbsCurveEvaluator for each vertex(the starting point for the trail)\n                    index = 0\n                    while index < self.total_vertices:\n                        nurbs_curve_evaluator = NurbsCurveEvaluator()\n                        nurbs_curve_evaluator.reset(total_segments)\n                        nurbs_curve_evaluator_list = nurbs_curve_evaluator_list + [nurbs_curve_evaluator]\n                        index += 1\n\n                    # add vertices to each NurbsCurveEvaluator\n                    segment_index = 0\n                    while segment_index < total_segments:\n                        motion_trail_frame_start = self.frame_list[segment_index]\n                        motion_trail_frame_end = self.frame_list[segment_index + 1]\n\n                        vertex_segment_index = 0\n\n                        if self.calculate_relative_matrix:\n                            start_transform = Mat4()\n                            end_transform = Mat4()\n\n                            start_transform.multiply(motion_trail_frame_start.transform, inverse_matrix)\n                            end_transform.multiply(motion_trail_frame_end.transform, inverse_matrix)\n\n                        else:\n                            start_transform = motion_trail_frame_start.transform\n                            end_transform = motion_trail_frame_end.transform\n\n                        motion_trail_vertex_start = self.vertex_list[0]\n\n                        v0 = start_transform.xform(motion_trail_vertex_start.vertex)\n                        v2 = end_transform.xform(motion_trail_vertex_start.vertex)\n\n                        nurbs_curve_evaluator = nurbs_curve_evaluator_list[vertex_segment_index]\n\n                        nurbs_curve_evaluator.setVertex(segment_index, v0)\n\n                        while vertex_segment_index < total_vertex_segments:\n\n                            motion_trail_vertex_start = self.vertex_list[vertex_segment_index]\n                            motion_trail_vertex_end = self.vertex_list[vertex_segment_index + 1]\n\n                            v1 = start_transform.xform(motion_trail_vertex_end.vertex)\n                            v3 = end_transform.xform(motion_trail_vertex_end.vertex)\n\n                            nurbs_curve_evaluator = nurbs_curve_evaluator_list[vertex_segment_index + 1]\n\n                            nurbs_curve_evaluator.setVertex(segment_index, v1)\n\n                            if vertex_segment_index == (total_vertex_segments - 1):\n                                v = v1 - v3\n                                vector.set(v[0], v[1], v[2])\n                                distance = vector.length()\n                                total_distance += distance\n\n                            vertex_segment_index += 1\n\n                        segment_index += 1\n\n                    # evaluate NurbsCurveEvaluator for each vertex\n                    index = 0\n                    nurbs_curve_result_list = []\n                    while index < self.total_vertices:\n                        nurbs_curve_evaluator = nurbs_curve_evaluator_list[index]\n                        nurbs_curve_result = nurbs_curve_evaluator.evaluate()\n                        nurbs_curve_result_list = nurbs_curve_result_list + [nurbs_curve_result]\n\n                        nurbs_start_t = nurbs_curve_result.getStartT()\n                        nurbs_end_t = nurbs_curve_result.getEndT()\n\n                        index += 1\n\n                    # create quads from NurbsCurveResult\n                    total_curve_segments = total_distance / self.resolution_distance\n                    if total_curve_segments < total_segments:\n                        total_curve_segments = total_segments\n\n                    v0 = Vec3()\n                    v1 = Vec3()\n                    v2 = Vec3()\n                    v3 = Vec3()\n\n                    def one_minus_x(x):\n                        x = 1.0 - x\n                        if x < 0.0:\n                            x = 0.0\n                        return x\n\n                    curve_segment_index = 0.0\n                    while curve_segment_index < total_curve_segments:\n\n                        vertex_segment_index = 0\n\n                        st = curve_segment_index / total_curve_segments\n                        et = (curve_segment_index + 1.0) / total_curve_segments\n                        #st = curve_segment_index / total_segments\n                        #et = (curve_segment_index + 1.0) / total_segments\n\n                        start_t = st\n                        end_t = et\n\n                        if self.square_t:\n                            start_t *= start_t\n                            end_t *= end_t\n\n                        motion_trail_vertex_start = self.vertex_list[0]\n\n                        vertex_start_color = motion_trail_vertex_start.end_color + (motion_trail_vertex_start.start_color - motion_trail_vertex_start.end_color)\n                        color_start_t = color_scale * start_t\n                        color_end_t = color_scale * end_t\n                        c0 = vertex_start_color * one_minus_x(color_start_t)\n                        c2 = vertex_start_color * one_minus_x(color_end_t)\n\n                        t0 = Vec2(one_minus_x(st), motion_trail_vertex_start.v)\n                        t2 = Vec2(one_minus_x(et), motion_trail_vertex_start.v)\n\n                        while vertex_segment_index < total_vertex_segments:\n\n                            motion_trail_vertex_start = self.vertex_list[vertex_segment_index]\n                            motion_trail_vertex_end = self.vertex_list[vertex_segment_index + 1]\n\n                            start_nurbs_curve_result = nurbs_curve_result_list[vertex_segment_index]\n                            end_nurbs_curve_result = nurbs_curve_result_list[vertex_segment_index + 1]\n\n                            start_nurbs_start_t = start_nurbs_curve_result.getStartT()\n                            start_nurbs_end_t = start_nurbs_curve_result.getEndT()\n                            end_nurbs_start_t = end_nurbs_curve_result.getStartT()\n                            end_nurbs_end_t = end_nurbs_curve_result.getEndT()\n\n                            start_delta_t = start_nurbs_end_t - start_nurbs_start_t\n                            end_delta_t = end_nurbs_end_t - end_nurbs_start_t\n\n                            start_nurbs_curve_result.evalPoint(start_nurbs_start_t + (start_delta_t * st), v0)\n                            end_nurbs_curve_result.evalPoint(end_nurbs_start_t + (end_delta_t * st), v1)\n\n                            start_nurbs_curve_result.evalPoint(start_nurbs_start_t + (start_delta_t * et), v2)\n                            end_nurbs_curve_result.evalPoint(end_nurbs_start_t + (end_delta_t * et), v3)\n\n                            # color\n                            vertex_end_color = motion_trail_vertex_end.end_color + (motion_trail_vertex_end.start_color - motion_trail_vertex_end.end_color)\n\n                            c1 = vertex_end_color * one_minus_x(color_start_t)\n                            c3 = vertex_end_color * one_minus_x(color_end_t)\n\n                            # uv\n                            t1 = Vec2(one_minus_x(st), motion_trail_vertex_end.v)\n                            t3 = Vec2(one_minus_x(et), motion_trail_vertex_end.v)\n\n                            self.add_geometry_quad(v0, v1, v2, v3, c0, c1, c2, c3, t0, t1, t2, t3)\n\n                            # reuse calculations\n                            c0 = c1\n                            c2 = c3\n\n                            t0 = t1\n                            t2 = t3\n\n                            vertex_segment_index += 1\n\n                        curve_segment_index += 1.0\n\n                else:\n                    segment_index = 0\n                    while segment_index < total_segments:\n                        motion_trail_frame_start = self.frame_list[segment_index]\n                        motion_trail_frame_end = self.frame_list[segment_index + 1]\n\n                        start_t = (motion_trail_frame_start.time - minimum_time) / delta_time\n                        end_t = (motion_trail_frame_end.time - minimum_time) / delta_time\n\n                        st = start_t\n                        et = end_t\n\n                        if self.square_t:\n                            start_t *= start_t\n                            end_t *= end_t\n\n                        vertex_segment_index = 0\n                        total_vertex_segments = self.total_vertices - 1\n\n                        if self.calculate_relative_matrix:\n                            start_transform = Mat4()\n                            end_transform = Mat4()\n                            start_transform.multiply(motion_trail_frame_start.transform, inverse_matrix)\n                            end_transform.multiply(motion_trail_frame_end.transform, inverse_matrix)\n                        else:\n                            start_transform = motion_trail_frame_start.transform\n                            end_transform = motion_trail_frame_end.transform\n\n                        motion_trail_vertex_start = self.vertex_list[0]\n\n                        v0 = start_transform.xform(motion_trail_vertex_start.vertex)\n                        v2 = end_transform.xform(motion_trail_vertex_start.vertex)\n\n                        vertex_start_color = motion_trail_vertex_start.end_color + (motion_trail_vertex_start.start_color - motion_trail_vertex_start.end_color)\n                        color_start_t = color_scale * start_t\n                        color_end_t = color_scale * end_t\n                        c0 = vertex_start_color * color_start_t\n                        c2 = vertex_start_color * color_end_t\n\n                        t0 = Vec2(st, motion_trail_vertex_start.v)\n                        t2 = Vec2(et, motion_trail_vertex_start.v)\n\n                        while vertex_segment_index < total_vertex_segments:\n\n                            motion_trail_vertex_start = self.vertex_list[vertex_segment_index]\n                            motion_trail_vertex_end = self.vertex_list[vertex_segment_index + 1]\n\n                            v1 = start_transform.xform(motion_trail_vertex_end.vertex)\n                            v3 = end_transform.xform(motion_trail_vertex_end.vertex)\n\n                            # color\n                            vertex_end_color = motion_trail_vertex_end.end_color + (motion_trail_vertex_end.start_color - motion_trail_vertex_end.end_color)\n\n                            c1 = vertex_end_color * color_start_t\n                            c3 = vertex_end_color * color_end_t\n\n                            # uv\n                            t1 = Vec2(st, motion_trail_vertex_end.v)\n                            t3 = Vec2(et, motion_trail_vertex_end.v)\n\n                            self.add_geometry_quad(v0, v1, v2, v3, c0, c1, c2, c3, t0, t1, t2, t3)\n\n                            # reuse calculations\n                            v0 = v1\n                            v2 = v3\n\n                            c0 = c1\n                            c2 = c3\n\n                            t0 = t1\n                            t2 = t3\n\n                            vertex_segment_index += 1\n\n                        segment_index += 1\n\n                self.end_geometry()\n\n    def enable_motion_trail(self, enable):\n        \"\"\"Sets whether the motion trail is currently enabled.  Every motion\n        trail starts off as being enabled, passing False to this method prevents\n        it from being updated.\n        \"\"\"\n        self.enable = enable\n\n    def reset_motion_trail(self):\n        \"\"\"Call this to have the motion trail restart from nothing on the next\n        update.\n        \"\"\"\n        self.frame_list = []\n        self.cmotion_trail.reset()\n\n    def reset_motion_trail_geometry(self):\n        \"\"\"Destroys the currently generated motion trail geometry immediately.\n        However, it will be fully regenerated on the next call to update, see\n        `reset_motion_trail()` to prevent this.\n        \"\"\"\n        if self.geom_node is not None:\n            self.geom_node.removeAllGeoms()\n\n    def attach_motion_trail(self):\n        \"\"\"Alias of `reset_motion_trail()`.\n        \"\"\"\n        self.reset_motion_trail()\n\n    def begin_motion_trail(self):\n        if not self.continuous_motion_trail:\n            self.reset_motion_trail()\n            self.active = True\n            self.playing = True\n\n    def end_motion_trail(self):\n        if not self.continuous_motion_trail:\n            self.active = False\n            self.reset_motion_trail()\n            self.reset_motion_trail_geometry()\n            self.playing = False\n\n    # the following functions are not currently supported in the C++ version\n\n    def set_fade(self, time, current_time):\n        if not self.pause:\n            self.fade_color_scale = 1.0\n\n            if time == 0.0:\n                self.fade = False\n            else:\n                self.fade_start_time = current_time\n                self.fade_time = time\n                self.fade = True\n\n    def pause_motion_trail(self, current_time):\n        if not self.pause:\n            self.pause_time = current_time\n            self.pause = True\n\n    def resume_motion_trail(self, current_time):\n        if self.pause:\n            delta_time = current_time - self.pause_time\n\n            frame_index = 0\n            total_frames = len(self.frame_list)\n            while frame_index < total_frames:\n                motion_trail_frame = self.frame_list[frame_index]\n                motion_trail_frame.time += delta_time\n                frame_index += 1\n\n            if self.fade:\n                self.fade_start_time += delta_time\n\n            self.pause = False\n\n    def toggle_pause_motion_trail(self, current_time):\n        if self.pause:\n            self.resume_motion_trail(current_time)\n        else:\n            self.pause_motion_trail(current_time)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/motiontrail/MotionTrail.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/38565614_MotionTrail.json",
    "doc_id": "doc_290"
  }
}