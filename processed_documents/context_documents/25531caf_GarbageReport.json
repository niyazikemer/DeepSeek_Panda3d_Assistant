{
  "content": "\"\"\"Contains utility classes for debugging memory leaks.\"\"\"\n\n__all__ = ['FakeObject', '_createGarbage', 'GarbageReport', 'GarbageLogger']\n\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.showbase.PythonUtil import ScratchPad, Stack, AlphabetCounter\nfrom direct.showbase.PythonUtil import itype, deeptype, fastRepr\nfrom direct.showbase.Job import Job\nfrom direct.showbase.JobManagerGlobal import jobMgr\nfrom direct.showbase.MessengerGlobal import messenger\nfrom panda3d.core import ConfigVariableBool\nimport gc\n\nGarbageCycleCountAnnounceEvent = 'announceGarbageCycleDesc2num'\n\n\nclass FakeObject:\n    pass\n\n\nclass FakeDelObject:\n    def __del__(self):\n        pass\n\n\ndef _createGarbage(num=1):\n    for i in range(num):\n        a = FakeObject()\n        b = FakeObject()\n        a.other = b\n        b.other = a\n        a = FakeDelObject()\n        b = FakeDelObject()\n        a.other = b\n        b.other = a\n\n\nclass GarbageReport(Job):\n    \"\"\"Detects leaked Python objects (via gc.collect()) and reports on garbage\n    items, garbage-to-garbage references, and garbage cycles.\n    If you just want to dump the report to the log, use GarbageLogger.\"\"\"\n    notify = directNotify.newCategory(\"GarbageReport\")\n\n    def __init__(self, name, log=True, verbose=False, fullReport=False, findCycles=True,\n                 threaded=False, doneCallback=None, autoDestroy=False, priority=None,\n                 safeMode=False, delOnly=False, collect=True):\n        # if autoDestroy is True, GarbageReport will self-destroy after logging\n        # if false, caller is responsible for calling destroy()\n        # if threaded is True, processing will be performed over multiple frames\n        # if collect is False, we assume that the caller just did a collect and the results\n        # are still in gc.garbage\n        Job.__init__(self, name)\n        # stick the arguments onto a ScratchPad so we can delete them all at once\n        self._args = ScratchPad(name=name, log=log, verbose=verbose, fullReport=fullReport,\n                                findCycles=findCycles, doneCallback=doneCallback,\n                                autoDestroy=autoDestroy, safeMode=safeMode, delOnly=delOnly,\n                                collect=collect)\n        if priority is not None:\n            self.setPriority(priority)\n        jobMgr.add(self)\n        if not threaded:\n            jobMgr.finish(self)\n\n    def run(self):\n        # do the garbage collection\n        oldFlags = gc.get_debug()\n\n        if self._args.delOnly:\n            # do a collect without SAVEALL, to identify the instances that are involved in\n            # cycles with instances that define __del__\n            # cycles that do not involve any instances that define __del__ are cleaned up\n            # automatically by Python, but they also appear in gc.garbage when SAVEALL is set\n            gc.set_debug(0)\n            if self._args.collect:\n                gc.collect()\n            garbageInstances = gc.garbage[:]\n            del gc.garbage[:]\n            # only yield if there's more time-consuming work to do,\n            # if there's no garbage, give instant feedback\n            if len(garbageInstances) > 0:\n                yield None\n            # don't repr the garbage list if we don't have to\n            if self.notify.getDebug():\n                self.notify.debug('garbageInstances == %s' % fastRepr(garbageInstances))\n\n            self.numGarbageInstances = len(garbageInstances)\n            # grab the ids of the garbage instances (objects with __del__)\n            self.garbageInstanceIds = set()\n            for i in range(len(garbageInstances)):\n                self.garbageInstanceIds.add(id(garbageInstances[i]))\n                if i % 20 == 0:\n                    yield None\n            # then release the list of instances so that it doesn't interfere with the gc.collect() below\n            del garbageInstances\n        else:\n            self.garbageInstanceIds = set()\n\n        # do a SAVEALL pass so that we have all of the objects involved in legitimate garbage cycles\n        # without SAVEALL, gc.garbage only contains objects with __del__ methods\n        gc.set_debug(gc.DEBUG_SAVEALL)\n        if self._args.collect:\n            gc.collect()\n        self.garbage = gc.garbage[:]\n        del gc.garbage[:]\n        # only yield if there's more time-consuming work to do,\n        # if there's no garbage, give instant feedback\n        if len(self.garbage) > 0:\n            yield None\n        # don't repr the garbage list if we don't have to\n        if self.notify.getDebug():\n            self.notify.debug('self.garbage == %s' % fastRepr(self.garbage))\n        gc.set_debug(oldFlags)\n\n        self.numGarbage = len(self.garbage)\n        # only yield if there's more time-consuming work to do,\n        # if there's no garbage, give instant feedback\n        if self.numGarbage > 0:\n            yield None\n\n        if self._args.verbose:\n            self.notify.info('found %s garbage items' % self.numGarbage)\n\n        # print the types of the garbage first, in case the repr of an object\n        # causes a crash\n        #if self.numGarbage > 0:\n        #    self.notify.info('TYPES ONLY (this is only needed if a crash occurs before GarbageReport finishes):')\n        #    for result in printNumberedTypesGen(self.garbage):\n        #        yield None\n\n        # Py obj id -> garbage list index\n        self._id2index = {}\n\n        self.referrersByReference = {}\n        self.referrersByNumber = {}\n\n        self.referentsByReference = {}\n        self.referentsByNumber = {}\n\n        self._id2garbageInfo = {}\n\n        self.cycles = []\n        self.cyclesBySyntax = []\n        self.uniqueCycleSets = set()\n        self.cycleIds = set()\n\n        # make the id->index table to speed up the next steps\n        for i in range(self.numGarbage):\n            self._id2index[id(self.garbage[i])] = i\n            if i % 20 == 0:\n                yield None\n\n        # grab the referrers (pointing to garbage)\n        if self._args.fullReport and (self.numGarbage != 0):\n            if self._args.verbose:\n                self.notify.info('getting referrers...')\n            for i in range(self.numGarbage):\n                yield None\n                for result in self._getReferrers(self.garbage[i]):\n                    yield None\n                byNum, byRef = result\n                self.referrersByNumber[i] = byNum\n                self.referrersByReference[i] = byRef\n\n        # grab the referents (pointed to by garbage)\n        if self.numGarbage > 0:\n            if self._args.verbose:\n                self.notify.info('getting referents...')\n            for i in range(self.numGarbage):\n                yield None\n                for result in self._getReferents(self.garbage[i]):\n                    yield None\n                byNum, byRef = result\n                self.referentsByNumber[i] = byNum\n                self.referentsByReference[i] = byRef\n\n        for i in range(self.numGarbage):\n            if hasattr(self.garbage[i], '_garbageInfo') and callable(self.garbage[i]._garbageInfo):\n                try:\n                    info = self.garbage[i]._garbageInfo()\n                except Exception as e:\n                    info = str(e)\n                self._id2garbageInfo[id(self.garbage[i])] = info\n                yield None\n            else:\n                if i % 20 == 0:\n                    yield None\n\n        # find the cycles\n        if self._args.findCycles and self.numGarbage > 0:\n            if self._args.verbose:\n                self.notify.info('calculating cycles...')\n            for i in range(self.numGarbage):\n                yield None\n                for newCycles in self._getCycles(i, self.uniqueCycleSets):\n                    yield None\n                self.cycles.extend(newCycles)\n                # create a representation of the cycle in human-readable form\n                newCyclesBySyntax = []\n                for cycle in newCycles:\n                    cycleBySyntax = ''\n                    objs = []\n                    # leave off the last index, it's a repeat of the first index\n                    for index in cycle[:-1]:\n                        objs.append(self.garbage[index])\n                        yield None\n                    # make the list repeat so we can safely iterate off the end\n                    numObjs = len(objs) - 1\n                    objs.extend(objs)\n\n                    # state variables for our loop below\n                    numToSkip = 0\n                    objAlreadyRepresented = False\n\n                    # if cycle starts off with an instance dict, start with the instance instead\n                    startIndex = 0\n                    # + 1 to include a reference back to the first object\n                    endIndex = numObjs + 1\n                    if type(objs[0]) is dict and hasattr(objs[-1], '__dict__'):\n                        startIndex -= 1\n                        endIndex -= 1\n\n                    for index in range(startIndex, endIndex):\n                        if numToSkip:\n                            numToSkip -= 1\n                            continue\n                        obj = objs[index]\n                        if hasattr(obj, '__dict__'):\n                            if not objAlreadyRepresented:\n                                cycleBySyntax += '%s' % obj.__class__.__name__\n                            cycleBySyntax += '.'\n                            # skip past the instance dict and get the member obj\n                            numToSkip += 1\n                            member = objs[index+2]\n                            for key, value in obj.__dict__.items():\n                                if value is member:\n                                    break\n                                yield None\n                            else:\n                                key = '<unknown member name>'\n                            cycleBySyntax += '%s' % key\n                            objAlreadyRepresented = True\n                        elif type(obj) is dict:\n                            cycleBySyntax += '{'\n                            # get object referred to by dict\n                            val = objs[index+1]\n                            for key, value in obj.items():\n                                if value is val:\n                                    break\n                                yield None\n                            else:\n                                key = '<unknown key>'\n                            cycleBySyntax += '%s}' % fastRepr(key)\n                            objAlreadyRepresented = True\n                        elif type(obj) in (tuple, list):\n                            brackets = {\n                                tuple: '()',\n                                list: '[]',\n                            }[type(obj)]\n                            # get object being referenced by container\n                            nextObj = objs[index+1]\n                            cycleBySyntax += brackets[0]\n                            for index in range(len(obj)):\n                                if obj[index] is nextObj:\n                                    index = str(index)\n                                    break\n                                yield None\n                            else:\n                                index = '<unknown index>'\n                            cycleBySyntax += '%s%s' % (index, brackets[1])\n                            objAlreadyRepresented = True\n                        else:\n                            cycleBySyntax += '%s --> ' % itype(obj)\n                            objAlreadyRepresented = False\n                    newCyclesBySyntax.append(cycleBySyntax)\n                    yield None\n                self.cyclesBySyntax.extend(newCyclesBySyntax)\n                # if we're not doing a full report, add this cycle's IDs to the master set\n                if not self._args.fullReport:\n                    for cycle in newCycles:\n                        yield None\n                        self.cycleIds.update(set(cycle))\n\n        self.numCycles = len(self.cycles)\n\n        if self._args.findCycles:\n            s = ['===== GarbageReport: \\'%s\\' (%s %s) =====' % (\n                self._args.name, self.numCycles,\n                ('cycle' if self.numCycles == 1 else 'cycles'))]\n        else:\n            s = ['===== GarbageReport: \\'%s\\' =====' % (\n                self._args.name)]\n        if self.numGarbage > 0:\n            # make a list of the ids we will actually be printing\n            if self._args.fullReport:\n                garbageIndices = range(self.numGarbage)\n            else:\n                garbageIndices = sorted(self.cycleIds)\n            numGarbage = len(garbageIndices)\n\n            # log each individual item with a number in front of it\n            if not self._args.fullReport:\n                abbrev = '(abbreviated) '\n            else:\n                abbrev = ''\n            s.append('===== Garbage Items %s=====' % abbrev)\n            digits = 0\n            n = numGarbage\n            while n > 0:\n                yield None\n                digits += 1\n                n = n // 10\n            format = '%0' + '%s' % digits + 'i:%s \\t%s'\n\n            for i in range(numGarbage):\n                yield None\n                idx = garbageIndices[i]\n                if self._args.safeMode:\n                    # in safe mode, don't try to repr any of the objects\n                    objStr = repr(itype(self.garbage[idx]))\n                else:\n                    objStr = fastRepr(self.garbage[idx])\n                maxLen = 5000\n                if len(objStr) > maxLen:\n                    snip = '<SNIP>'\n                    objStr = '%s%s' % (objStr[:(maxLen-len(snip))], snip)\n                s.append(format % (idx, itype(self.garbage[idx]), objStr))\n\n            # also log the types of the objects\n            s.append('===== Garbage Item Types %s=====' % abbrev)\n            for i in range(numGarbage):\n                yield None\n                idx = garbageIndices[i]\n                objStr = str(deeptype(self.garbage[idx]))\n                maxLen = 5000\n                if len(objStr) > maxLen:\n                    snip = '<SNIP>'\n                    objStr = '%s%s' % (objStr[:(maxLen-len(snip))], snip)\n                s.append(format % (idx, itype(self.garbage[idx]), objStr))\n\n            if self._args.findCycles:\n                s.append('===== Garbage Cycles (Garbage Item Numbers) =====')\n                ac = AlphabetCounter()\n                for i in range(self.numCycles):\n                    yield None\n                    s.append('%s:%s' % (ac.next(), self.cycles[i]))\n\n            if self._args.findCycles:\n                s.append('===== Garbage Cycles (Python Syntax) =====')\n                ac = AlphabetCounter()\n                for i in range(len(self.cyclesBySyntax)):\n                    yield None\n                    s.append('%s:%s' % (ac.next(), self.cyclesBySyntax[i]))\n\n            if len(self._id2garbageInfo) > 0:\n                s.append('===== Garbage Custom Info =====')\n                ac = AlphabetCounter()\n                for i in range(len(self.cyclesBySyntax)):\n                    yield None\n                    counter = ac.next()\n                    _id = id(self.garbage[i])\n                    if _id in self._id2garbageInfo:\n                        s.append('%s:%s' % (counter, self._id2garbageInfo[_id]))\n\n            if self._args.fullReport:\n                format = '%0' + '%s' % digits + 'i:%s'\n                s.append('===== Referrers By Number (what is referring to garbage item?) =====')\n                for i in range(numGarbage):\n                    yield None\n                    s.append(format % (i, self.referrersByNumber[i]))\n                s.append('===== Referents By Number (what is garbage item referring to?) =====')\n                for i in range(numGarbage):\n                    yield None\n                    s.append(format % (i, self.referentsByNumber[i]))\n                s.append('===== Referrers (what is referring to garbage item?) =====')\n                for i in range(numGarbage):\n                    yield None\n                    s.append(format % (i, self.referrersByReference[i]))\n                s.append('===== Referents (what is garbage item referring to?) =====')\n                for i in range(numGarbage):\n                    yield None\n                    s.append(format % (i, self.referentsByReference[i]))\n\n        self._report = s\n\n        if self._args.log:\n            self.printingBegin()\n            for i in range(len(self._report)):\n                if self.numGarbage > 0:\n                    yield None\n                self.notify.info(self._report[i])\n            self.notify.info('===== Garbage Report Done =====')\n            self.printingEnd()\n\n        yield Job.Done\n\n    def finished(self):\n        if self._args.doneCallback:\n            self._args.doneCallback(self)\n        if self._args.autoDestroy:\n            self.destroy()\n\n    def destroy(self):\n        #print 'GarbageReport.destroy'\n        del self._args\n        del self.garbage\n        # don't get rid of these, we might need them\n        #del self.numGarbage\n        #del self.numCycles\n        del self.referrersByReference\n        del self.referrersByNumber\n        del self.referentsByReference\n        del self.referentsByNumber\n        if hasattr(self, 'cycles'):\n            del self.cycles\n        del self._report\n        if hasattr(self, '_reportStr'):\n            del self._reportStr\n        Job.destroy(self)\n\n    def getNumCycles(self):\n        # if the job hasn't run yet, we don't have a numCycles yet\n        return self.numCycles\n\n    def getDesc2numDict(self):\n        # dict of python-syntax leak -> number of that type of leak\n        desc2num = {}\n        for cycleBySyntax in self.cyclesBySyntax:\n            desc2num.setdefault(cycleBySyntax, 0)\n            desc2num[cycleBySyntax] += 1\n        return desc2num\n\n    def getGarbage(self):\n        return self.garbage\n\n    def getReport(self):\n        if not hasattr(self, '_reportStr'):\n            self._reportStr = ''\n            for str in self._report:\n                self._reportStr += '\\n' + str\n        return self._reportStr\n\n    def _getReferrers(self, obj):\n        # referrers (pointing to garbage)\n        # returns two lists, first by index into gc.garbage, second by\n        # direct reference\n        yield None\n        byRef = gc.get_referrers(obj)\n        yield None\n        # look to see if each referrer is another garbage item\n        byNum = []\n        for i in range(len(byRef)):\n            if i % 20 == 0:\n                yield None\n            referrer = byRef[i]\n            num = self._id2index.get(id(referrer), None)\n            byNum.append(num)\n        yield byNum, byRef\n\n    def _getReferents(self, obj):\n        # referents (pointed to by garbage)\n        # returns two lists, first by index into gc.garbage, second by\n        # direct reference\n        yield None\n        byRef = gc.get_referents(obj)\n        yield None\n        # look to see if each referent is another garbage item\n        byNum = []\n        for i in range(len(byRef)):\n            if i % 20 == 0:\n                yield None\n            referent = byRef[i]\n            num = self._id2index.get(id(referent), None)\n            byNum.append(num)\n        yield byNum, byRef\n\n    def _getNormalizedCycle(self, cycle):\n        # returns a representation of a cycle (list of indices) that will be\n        # reliably derived from a unique cycle regardless of ordering\n        # this lets us detect duplicate cycles that appear different because of\n        # which element appears first\n        if len(cycle) == 0:\n            return cycle\n        min = 1<<30\n        minIndex = None\n        for i in range(len(cycle)):\n            elem = cycle[i]\n            if elem < min:\n                min = elem\n                minIndex = i\n        return cycle[minIndex:] + cycle[:minIndex]\n\n    def _getCycles(self, index, uniqueCycleSets=None):\n        # detect garbage cycles for a particular item of garbage\n        assert self.notify.debugCall()\n        # returns list of lists, sublists are garbage reference cycles\n        cycles = []\n        # this lets us eliminate duplicate cycles\n        if uniqueCycleSets is None:\n            uniqueCycleSets = set()\n        stateStack = Stack()\n        rootId = index\n        # check if the root object is one of the garbage instances (has __del__)\n        objId = id(self.garbage[rootId])\n        numDelInstances = int(objId in self.garbageInstanceIds)\n        stateStack.push(([rootId], rootId, numDelInstances, 0))\n        while True:\n            yield None\n            if len(stateStack) == 0:\n                break\n            candidateCycle, curId, numDelInstances, resumeIndex = stateStack.pop()\n            if self.notify.getDebug():\n                if self._args.delOnly:\n                    print('restart: %s root=%s cur=%s numDelInstances=%s resume=%s' % (\n                        candidateCycle, rootId, curId, numDelInstances, resumeIndex))\n                else:\n                    print('restart: %s root=%s cur=%s resume=%s' % (\n                        candidateCycle, rootId, curId, resumeIndex))\n            for index in range(resumeIndex, len(self.referentsByNumber[curId])):\n                yield None\n                refId = self.referentsByNumber[curId][index]\n                if self.notify.getDebug():\n                    print('       : %s -> %s' % (curId, refId))\n                if refId == rootId:\n                    # we found a cycle! mark it down and move on to the next refId\n                    normCandidateCycle = self._getNormalizedCycle(candidateCycle)\n                    normCandidateCycleTuple = tuple(normCandidateCycle)\n                    if not normCandidateCycleTuple in uniqueCycleSets:\n                        # cycles with no instances that define __del__ will be\n                        # cleaned up by Python\n                        if (not self._args.delOnly) or numDelInstances >= 1:\n                            if self.notify.getDebug():\n                                print('  FOUND: ', normCandidateCycle + [normCandidateCycle[0],])\n                            cycles.append(normCandidateCycle + [normCandidateCycle[0],])\n                            uniqueCycleSets.add(normCandidateCycleTuple)\n                elif refId in candidateCycle:\n                    pass\n                elif refId is not None:\n                    # check if this object is one of the garbage instances (has __del__)\n                    objId = id(self.garbage[refId])\n                    numDelInstances += int(objId in self.garbageInstanceIds)\n                    # this refId does not complete a cycle. Mark down\n                    # where we are in this list of referents, then\n                    # start looking through the referents of the new refId\n                    stateStack.push((list(candidateCycle), curId, numDelInstances, index+1))\n                    stateStack.push((list(candidateCycle) + [refId], refId, numDelInstances, 0))\n                    break\n        yield cycles\n\n\nclass GarbageLogger(GarbageReport):\n    \"\"\"If you just want to log the current garbage to the log file, make\n    one of these. It automatically destroys itself after logging\"\"\"\n\n    def __init__(self, name, *args, **kArgs):\n        kArgs['log'] = True\n        kArgs['autoDestroy'] = True\n        GarbageReport.__init__(self, name, *args, **kArgs)\n\n\nclass _CFGLGlobals:\n    # for checkForGarbageLeaks\n    LastNumGarbage = 0\n    LastNumCycles = 0\n\n\ndef checkForGarbageLeaks():\n    gc.collect()\n    numGarbage = len(gc.garbage)\n    if numGarbage > 0 and ConfigVariableBool('auto-garbage-logging', False):\n        if numGarbage != _CFGLGlobals.LastNumGarbage:\n            print(\"\")\n            gr = GarbageReport('found garbage', threaded=False, collect=False)\n            print(\"\")\n            _CFGLGlobals.LastNumGarbage = numGarbage\n            _CFGLGlobals.LastNumCycles = gr.getNumCycles()\n            messenger.send(GarbageCycleCountAnnounceEvent, [gr.getDesc2numDict()])\n            gr.destroy()\n        notify = directNotify.newCategory(\"GarbageDetect\")\n        if ConfigVariableBool('allow-garbage-cycles', True):\n            func = notify.warning\n        else:\n            func = notify.error\n        func('%s garbage cycles found, see info above' % _CFGLGlobals.LastNumCycles)\n    return numGarbage\n\n\ndef b_checkForGarbageLeaks(wantReply=False):\n    if not __dev__:\n        return 0\n    # does a garbage collect on the client and the AI\n    # returns number of client garbage leaks\n    # logs leak info and terminates (if configured to do so)\n    try:\n        # if this is the client, tell the AI to check for leaks too\n        base.cr.timeManager\n    except Exception:\n        pass\n    else:\n        if base.cr.timeManager:\n            base.cr.timeManager.d_checkForGarbageLeaks(wantReply=wantReply)\n    return checkForGarbageLeaks()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/GarbageReport.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/25531caf_GarbageReport.json",
    "doc_id": "doc_242"
  }
}