{
  "content": "\n# This is built as a subclass instead of an extension so we can define the\n# class variable FuncDict and so we can import DCSubatomicType at the top\n# of the file rather than every time we call the putArg function.\n\nfrom panda3d.core import Datagram\nfrom panda3d.direct import (\n    STInt8,\n    STInt16,\n    STInt32,\n    STInt64,\n    STUint8,\n    STUint16,\n    STUint32,\n    STUint64,\n    STFloat64,\n    STString,\n    STBlob,\n    STBlob32,\n    STInt16array,\n    STInt32array,\n    STUint16array,\n    STUint32array,\n    STInt8array,\n    STUint8array,\n    STUint32uint8array,\n)\n# Import the type numbers\n\nfrom direct.distributed.MsgTypes import CONTROL_CHANNEL\n\n\nclass PyDatagram(Datagram):\n\n    # This is a little helper Dict to replace the huge <if> statement\n    # for trying to match up datagram subatomic types with add funtions\n    # If Python had an O(1) \"case\" statement we would use that instead\n    FuncDict = {\n        STInt8: (Datagram.addInt8, int),\n        STInt16: (Datagram.addInt16, int),\n        STInt32: (Datagram.addInt32, int),\n        STInt64: (Datagram.addInt64, int),\n        STUint8: (Datagram.addUint8, int),\n        STUint16: (Datagram.addUint16, int),\n        STUint32: (Datagram.addUint32, int),\n        STUint64: (Datagram.addUint64, int),\n        STFloat64: (Datagram.addFloat64, None),\n        STString: (Datagram.addString, None),\n        STBlob: (Datagram.addBlob, None),\n        STBlob32: (Datagram.addBlob32, None),\n    }\n\n    addChannel = Datagram.addUint64\n\n    def addServerHeader(self, channel, sender, code):\n        self.addInt8(1)\n        self.addChannel(channel)\n        self.addChannel(sender)\n        self.addUint16(code)\n\n    def addOldServerHeader(self, channel, sender, code):\n        self.addChannel(channel)\n        self.addChannel(sender)\n        self.addChannel('A')\n        self.addUint16(code)\n\n    def addServerControlHeader(self, code):\n        self.addInt8(1)\n        self.addChannel(CONTROL_CHANNEL)\n        self.addUint16(code)\n\n    def putArg(self, arg, subatomicType, divisor=1):\n        if divisor == 1:\n            funcSpecs = self.FuncDict.get(subatomicType)\n            if funcSpecs:\n                addFunc, argFunc = funcSpecs\n                if argFunc:\n                    arg = argFunc(arg)\n                addFunc(self, arg)\n            # Ok, arrays are not handled by the FuncDict yet\n            elif subatomicType == STInt8array:\n                self.addUint16(len(arg))\n                for i in arg:\n                    self.addInt8(int(i))\n            elif subatomicType == STInt16array:\n                self.addUint16(len(arg) << 1)\n                for i in arg:\n                    self.addInt16(int(i))\n            elif subatomicType == STInt32array:\n                self.addUint16(len(arg) << 2)\n                for i in arg:\n                    self.addInt32(int(i))\n            elif subatomicType == STUint8array:\n                self.addUint16(len(arg))\n                for i in arg:\n                    self.addUint8(int(i))\n            elif subatomicType == STUint16array:\n                self.addUint16(len(arg) << 1)\n                for i in arg:\n                    self.addUint16(int(i))\n            elif subatomicType == STUint32array:\n                self.addUint16(len(arg) << 2)\n                for i in arg:\n                    self.addUint32(int(i))\n            elif subatomicType == STUint32uint8array:\n                self.addUint16(len(arg) * 5)\n                for i in arg:\n                    self.addUint32(int(i[0]))\n                    self.addUint8(int(i[1]))\n            else:\n                raise Exception(\"Error: No such type as: \" + str(subatomicType))\n        else:\n            funcSpecs = self.FuncDict.get(subatomicType)\n            if funcSpecs:\n                # argFunc is only used if divisor == 1\n                addFunc, argFunc = funcSpecs\n                addFunc(self, int(round(arg * divisor)))\n            # Ok, arrays are not handled by the FuncDict yet\n            elif subatomicType == STInt8array:\n                self.addUint16(len(arg))\n                for i in arg:\n                    self.addInt8(int(round(i*divisor)))\n            elif subatomicType == STInt16array:\n                self.addUint16(len(arg) << 1)\n                for i in arg:\n                    self.addInt16(int(round(i*divisor)))\n            elif subatomicType == STInt32array:\n                self.addUint16(len(arg) << 2)\n                for i in arg:\n                    self.addInt32(int(round(i*divisor)))\n            elif subatomicType == STUint8array:\n                self.addUint16(len(arg))\n                for i in arg:\n                    self.addUint8(int(round(i*divisor)))\n            elif subatomicType == STUint16array:\n                self.addUint16(len(arg) << 1)\n                for i in arg:\n                    self.addUint16(int(round(i*divisor)))\n            elif subatomicType == STUint32array:\n                self.addUint16(len(arg) << 2)\n                for i in arg:\n                    self.addUint32(int(round(i*divisor)))\n            elif subatomicType == STUint32uint8array:\n                self.addUint16(len(arg) * 5)\n                for i in arg:\n                    self.addUint32(int(round(i[0]*divisor)))\n                    self.addUint8(int(round(i[1]*divisor)))\n            else:\n                raise Exception(\"Error: type does not accept divisor: \" + str(subatomicType))\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/PyDatagram.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/edf46f16_PyDatagram.json",
    "doc_id": "doc_317"
  }
}