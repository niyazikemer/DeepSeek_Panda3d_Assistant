{
  "content": "Tasks\n\nTasks are special functions that are called once each frame while your application executes. They are similar in concept to threads. However, in Panda3D, tasks are not generally separate threads; instead, all tasks are run cooperatively, one at a time, within the main thread. This design simplifies game programming considerably by removing the requirement to protect critical sections of code from mutual access. (See task-chains in the next section if you really want to use threading.)\n\npython\n\nWhen you start Panda3D by initializing ShowBase, a handful of tasks are created by default, but you are free to add as many additional tasks as you like.\n\ncpp\n\nWhen you start Panda3D by initializing WindowFramework, a handful of tasks are created by default, but you are free to add as many additional tasks as you like.\n\nThe Task Function\n\nA task is defined with a function or class method; this function is the main entry point for the task and will be called once per frame while the task is running. By default, the function receives one parameter, which is the task object; the task object carries information about the task itself, such as the amount of time that the task has been running.\n\nYour task function should return when it has finished processing for the frame. Because all tasks are run in the same thread, you must not spend too much time processing any one task function; the entire application will be locked up until the function returns.\n\npython\n\nThe task function may return either Task.cont to indicate that the task should be called again next frame, or Task.done to indicate that it should not be called again. If it returns None (which is to say, it does not return anything), then the default behavior is to stop.\n\nYou can check how long your task has been running by checking task.time in your task function. You can also check how many times the task function has been run by using task.frame.\n\nThe below example imports the Task module and shows a function used as task.\n\nfrom direct.task import Task\n\n# This task runs for two seconds, then prints done\ndef exampleTask(task):\n    if task.time < 2.0:\n        return Task.cont\n\n    print('Done')\n    return Task.done\n\ncpp\n\nThe task function may return either AsyncTask::DS_cont to indicate that the task should be called again next frame, or AsyncTask::DS_done to indicate that it should not be called again.\n\nYou can check how long your task has been running by checking task->get_elapsed_time() in your task function. You can also check how many times the task function has been run by using task->get_elapsed_frames().\n\n#include \"asyncTaskManager.h\"\n\n// This task runs for two seconds, then prints done\nAsyncTask::DoneStatus example_task(GenericAsyncTask *task, void *data) {\n  if (task->get_elapsed_time() < 2.0) {\n    return AsyncTask::DS_cont;\n  }\n  cout << \"Done\" << endl;\n  return AsyncTask::DS_done;\n}\n\nTask Return Values\n\nThe value returned from a task affects how the task manager handles that task going forward.\n\npython\n\nVariable Purpose Task.done Specifies that a task is finished and removes it from the task\nmanager. Task.cont Perform the task again next frame. Task.again Perform the task again, using the same delay as initially\nspecified.\n\ncpp\n\nVariable Purpose AsyncTask::DS_done Specifies that a task is finished and removes it from the task\nmanager. AsyncTask::DS_cont Perform the task again next frame. AsyncTask::DS_again Perform the task again, using the same delay as initially\nspecified.\n\nThe Do-Later Task\n\ncpp\n\nIf you have used Panda3D in Python, you might be familiar with the Python function taskMgr.doMethodLater(), which lets you schedule a task to be started after a certain delay. This isn't needed in C++, because you can set a delay on a task directly with task->set_delay(). An example will be provided below in the task manager section.\n\npython\n\nA useful special kind of task is the do-later: this is similar to a task, but rather than being called every frame it will be called only once, after a certain amount of time (in seconds) has elapsed. You can, of course, implement a do-later task with a regular task that simply does nothing until a certain amount of time has elapsed (as in the above example), but using a do-later is a much more efficient way to achieve the same thing, especially if you will have many such tasks waiting around.\n\ntaskMgr.doMethodLater(delayTime, myFunction, 'Task Name')\n\nIn this example myFunction must accept a task variable. If you wish to use a function that does not accept a task variable:\n\ntaskMgr.doMethodLater(delayTime, myFunction, 'Task Name', extraArgs = [variables])\n\nNote: if you wish to call a function which takes no variables simply pass extraArgs = []\n\nDo-Later tasks can be repeated from the task function by returning Task.again. You can also change the delay of the Do-Later task by changing task.delayTime, but changing this will not have any effect on the task's actual delay time until the next time it gets added to the do-later list, for instance by returning Task.again.\n\n# This task increments itself so that the delay between task executions\n# gradually increases over time. If you do not change task.delayTime\n# the task will simply repeat itself every 2 seconds\ndef myFunction(task):\n    print(\"Delay: %s\" % task.delayTime)\n    print(\"Frame: %s\" % task.frame)\n    task.delayTime += 1\n    return task.again\n\nmyTask = taskMgr.doMethodLater(2, myFunction, 'tickTask')\n\nIf you wish to change the delayTime outside of the task function itself, and have it make an immediate effect, you can remove and re-add the task by hand, for instance:\n\ntaskMgr.remove(task)\ntask.delayTime += 1\ntaskMgr.add(task)\n\nThere is a read-only public member task.wakeTime which stores the time at which the task should wake up, should you desire to query this.\n\nThe Task Object\n\nThe task object is passed into all task functions. There are several members accessible in the func object, among which:\n\npython\n\nMember Returns task.time A float that indicates how long this task function has been running\nsince the first execution of the function. The timer is running even\nwhen the task function is not being executed. task.frame An integer that counts the number of elapsed frames since this\nfunction was added. Count may start from 0 or 1. task.id An integer that gives the unique id assigned to this task by the\nTask Manager. task.name The task name assigned to the task function.\n\ncpp\n\nMember Returns task->get_elapsed_time() A float that indicates how long this task function has been running\nsince the first execution of the function. The timer is running even\nwhen the task function is not being executed. task->get_elapsed_frames() An integer that counts the number of elapsed frames since this\nfunction was added. Count may start from 0 or 1. task->get_task_id() An integer that gives the unique id assigned to this task by the\nTask Manager. task->get_name() The task name assigned to the task function.\n\nTo remove the task and stop it from executing from outside the task function, call task.remove().\n\nThe Task Manager\n\npython\n\nAll tasks are handled through the global Task Manager object, called taskMgr in Panda3D.\n\ncpp\n\nAll tasks are handled through the Task Manager object. Here we assume that you have obtained a reference to it and stored it in a variable called task_mgr, for example:\n\nPT(AsyncTaskManager) task_mgr = AsyncTaskManager::get_global_ptr();\n\nThe Task Manager keeps a list of all currently-running tasks.\n\npython\n\nTo add your task function to the task list, call taskMgr.add() with your function and an arbitrary name for the task. taskMgr.add() returns a Task which can be used to remove the task later on.\n\ntaskMgr.add(exampleTask, 'MyTaskName')\n\nYou can add extra arguments to the call through the extraArgs parameter. When you do this, the task parameter is no longer sent to your function by default. If you still want it, make sure to set appendTask=True, which makes the task the last argument sent to the function.\n\ntaskMgr.add(exampleTask, 'MyTaskName', extraArgs=[a,b,c], appendTask=True)\n\ncpp\n\nTo add a task to the Task Manager, first create a task object by indicating your function and an arbitrary name, and then add it to the task list by calling task_mgr->add() with a pointer to your task.\n\nPT(GenericAsyncTask) task;\ntask = new GenericAsyncTask(\"MyTaskName\", &example_task, nullptr);\n\ntask_mgr->add(task);\n\nYou can add an arbitrary argument to the call through the third parameter.\n\nAlthough normally each task is given a unique name, you may also create multiple different tasks with the same name. This can be convenient for locating or removing many task functions at the same time. Each task remains independent of the others, even if they have the same name; this means that a task function returning a \"done\" status will not affect any other task functions.\n\npython\n\nTo remove the task and stop it from executing, call taskMgr.remove(). You can pass in either the name of the task, or the task object (which was returned by taskMgr.add(), above).\n\ntaskMgr.remove('MyTaskName')\n\ncpp\n\nTo remove the task and stop it from executing, you can call task->remove().\n\ntask->remove();\n\nA useful task method is task->set_delay(); it causes your task to be called after a certain amount of time (in seconds). You can, of course, implement this kind of functionality with an underlayed task that simply does nothing until a certain amount of time has elapsed (as in the above example), but using this method is a much more efficient way to achieve the same thing, especially if you will have many such tasks waiting around. Note that you need to set the delay before you add the task to the Task Manager, otherwise the call won't have an effect.\n\ntask->set_delay (60);\ntask_mgr->add(task);\n\nSimilarly, if you wish to change the delay time of a task, you have to remove the task and re-add it by hand. For instance:\n\ntask->remove();\ntask->set_delay(10);\ntask_mgr->add(task);\n\nYou can also alter the delay of the task inside the task function, but you will have to return AsyncTask::DS_again afterwards so that it takes effect.\n\npython\n\nYou may add a cleanup function to the task function with the uponDeath parameter. Similar to task functions, the uponDeath function has a task object as a parameter. The cleanup function is called whenever the task finishes, for instance by return Task.done, or when it is explicitly removed via taskMgr.remove().\n\ntaskMgr.add(exampleTask, 'TaskName', uponDeath=cleanupFunc)\n\ncpp\n\nYou may add a cleanup function to the task with the task->set_upon_death() function. Similar to task functions, this function receives a function pointer as a parameter. The cleanup function is called whenever the task finishes, for instance by return AsyncTask::DS_done;, or when it is explicitly removed via a task->remove() call.\n\ntask->set_upon_death(&cleanupFunc);\n\nTo control order in which tasks are executed, you can use sort or priority argument. If you use only sort or only priority, tasks given lesser value will execute sooner.\n\npython\n\ntaskMgr.add(task2, \"second\", sort=2)\ntaskMgr.add(task1, \"first\", sort=1)\n\nor\n\ntaskMgr.add(task2, \"second\", priority=2)\ntaskMgr.add(task1, \"first\", priority=1)\n\nIn both cases, task1 given name \"first\" will be executed before task2 (\"second\").\n\nIf you use both sort and priority arguments, tasks with lower sort value will be executed first. However, if there are several tasks which have same sort value, but different priority value then that tasks are going to be executed in a way that ones with HIGHER priority value will be executed first.\n\npython\n\nTo clarify it a bit, here is code sample, tasks are named in order in which they are executed.\n\ntaskMgr.add(task1, \"first\", sort=1, priority=2)\ntaskMgr.add(task2, \"second\", sort=1, priority=1)\ntaskMgr.add(task3, \"third\", sort=2, priority=1)\ntaskMgr.add(task4, \"fourth\", sort=3, priority=13)\ntaskMgr.add(task5, \"fifth\", sort=3, priority=4)\n\nTo print the list of tasks currently running, simply print out taskMgr. Among your own tasks, you may see the following system tasks listed:\n\nThere also is graphical interface for managing tasks. This is very useful for having a look at the tasks while your application is running.\n\ntaskMgr.popupControls()\n\ncpp\n\nTo print the list of tasks currently running, simply call task_mgr->write(cout);.\n\nTask timing\n\npython\n\nTo see the specific timing information for each task when you print taskMgr, add the following line to your Config.prc file:\n\ntask-timer-verbose #t\n\n(see the-configuration-file for config syntax)\n\nExamples\n\npython\n\nuponDeath\n\ntaskAccumulator = 0\n\ndef cleanUp(task):\n    global taskAccumulator\n    print(\"Task func has accumulated %d\" % taskAccumulator)\n    # Reset the accumulator\n    taskAccumulator = 0\n\n# A task that runs forever\ndef taskFunc(task):\n    global taskAccumulator\n    taskAccumulator += 1\n    return task.cont\n\ndef taskStop(task):\n    taskMgr.remove('Accumulator')\n\n# Add the taskFunc function with an uponDeath argument\ntaskMgr.add(taskFunc, 'Accumulator', uponDeath=cleanUp)\n# Stops the task 2 seconds later\ntaskMgr.doMethodLater(2, taskStop, 'Task Stop')\n\ncpp\n\nset_upon_death()\n\nint task_accumulator = 0;\n\nvoid clean_up(GenericAsyncTask *task, bool clean_exit, void *user_data) {\n  cout << \"Task func has accumulated \" << task_accumulator << endl;\n  //  Reset the accumulator\n  task_accumulator = 0;\n}\n\n// A task that runs forever\nAsyncTask::DoneStatus task_func(GenericAsyncTask *task, void *data) {\n  task_accumulator++;\n  return AsyncTask::DS_cont;\n}\n\nAsyncTask::DoneStatus task_stop(GenericAsyncTask *task, void *data) {\n  ((GenericAsyncTask *)data)->remove();\n  return AsyncTask::DS_done;\n}\n\n// Note that we skip the initialization and finalization of\n// the application for the sake of simplifying the example.\nint main(int argc, char *argv[]) {\n  /* Insert here your app initialization code */\n  /* ... */\n\n  AsyncTaskManager *task_mgr = AsyncTaskManager::get_global_ptr();\n\n  PT(GenericAsyncTask) task, stopper_task;\n\n  // Add the task_func function with an upon_death callback\n  task = new GenericAsyncTask(\"Accumulator\", &task_func, nullptr);\n  task->set_upon_death(&clean_up);\n  task_mgr->add(task);\n\n  // Adds another task to stop the main task 2 seconds later\n  stopper_task = new GenericAsyncTask(\"Task stopper\", &task_stop, task);\n  stopper_task->set_delay(2);\n  task_mgr->add(stopper_task);\n\n  /* Insert here your app finalization code */\n  /* ... */\n}",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/5c9f8c24_tasks.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/6c715f42_5c9f8c24_tasks.json",
    "doc_id": "doc_499"
  }
}