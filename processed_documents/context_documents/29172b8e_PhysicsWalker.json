{
  "content": "\"\"\"\nPhysicsWalker.py is for avatars.\n\nA walker control such as this one provides:\n\n- creation of the collision nodes\n- handling the keyboard and mouse input for avatar movement\n- moving the avatar\n\nit does not:\n\n- play sounds\n- play animations\n\nalthough it does send messages that allow a listener to play sounds or\nanimations based on walker events.\n\"\"\"\n\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.showbase import DirectObject\nfrom direct.controls.ControlManager import CollisionHandlerRayStart\nfrom direct.showbase.InputStateGlobal import inputState\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.task.Task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.extensions_native import Mat3_extensions # pylint: disable=unused-import\nfrom direct.extensions_native import VBase3_extensions # pylint: disable=unused-import\nfrom direct.extensions_native import VBase4_extensions # pylint: disable=unused-import\nfrom panda3d.core import (\n    BitMask32,\n    ClockObject,\n    CollisionHandlerFloor,\n    CollisionHandlerQueue,\n    CollisionNode,\n    CollisionRay,\n    CollisionSphere,\n    CollisionTraverser,\n    ConfigVariableBool,\n    LRotationf,\n    Mat3,\n    NodePath,\n    Point3,\n    Vec3,\n)\nfrom panda3d.physics import (\n    ActorNode,\n    ForceNode,\n    LinearEulerIntegrator,\n    LinearFrictionForce,\n    LinearVectorForce,\n    PhysicsCollisionHandler,\n    PhysicsManager,\n)\nimport math\n\n#import LineStream\n\n\nclass PhysicsWalker(DirectObject.DirectObject):\n\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"PhysicsWalker\")\n    wantDebugIndicator = ConfigVariableBool('want-avatar-physics-indicator', False)\n\n    useLifter = 0\n    useHeightRay = 0\n\n    # special methods\n    def __init__(self, gravity = -32.1740, standableGround=0.707,\n            hardLandingForce=16.0):\n        assert self.debugPrint(\n            \"PhysicsWalker(gravity=%s, standableGround=%s)\"%(\n            gravity, standableGround))\n        DirectObject.DirectObject.__init__(self)\n        self.__gravity=gravity\n        self.__standableGround=standableGround\n        self.__hardLandingForce=hardLandingForce\n\n        self.needToDeltaPos = 0\n        self.physVelocityIndicator=None\n        self.avatarControlForwardSpeed=0\n        self.avatarControlJumpForce=0\n        self.avatarControlReverseSpeed=0\n        self.avatarControlRotateSpeed=0\n        self.__oldAirborneHeight=None\n        self.getAirborneHeight=None\n        self.__oldContact=None\n        self.__oldPosDelta=Vec3(0)\n        self.__oldDt=0\n        self.__speed=0.0\n        self.__rotationSpeed=0.0\n        self.__slideSpeed=0.0\n        self.__vel=Vec3(0.0)\n        self.collisionsActive = 0\n\n        self.isAirborne = 0\n        self.highMark = 0\n\n    def setWalkSpeed(self, forward, jump, reverse, rotate):\n        assert self.debugPrint(\"setWalkSpeed()\")\n        self.avatarControlForwardSpeed=forward\n        self.avatarControlJumpForce=jump\n        self.avatarControlReverseSpeed=reverse\n        self.avatarControlRotateSpeed=rotate\n\n    def getSpeeds(self):\n        #assert self.debugPrint(\"getSpeeds()\")\n        return (self.__speed, self.__rotationSpeed)\n\n    def setAvatar(self, avatar):\n        self.avatar = avatar\n        if avatar is not None:\n            self.setupPhysics(avatar)\n\n    def setupRay(self, floorBitmask, floorOffset):\n        # This is a ray cast from your head down to detect floor polygons\n        # A toon is about 4.0 feet high, so start it there\n        self.cRay = CollisionRay(0.0, 0.0, CollisionHandlerRayStart, 0.0, 0.0, -1.0)\n        cRayNode = CollisionNode('PW.cRayNode')\n        cRayNode.addSolid(self.cRay)\n        self.cRayNodePath = self.avatarNodePath.attachNewNode(cRayNode)\n        self.cRayBitMask = floorBitmask\n        cRayNode.setFromCollideMask(self.cRayBitMask)\n        cRayNode.setIntoCollideMask(BitMask32.allOff())\n\n        if self.useLifter:\n            # set up floor collision mechanism\n            self.lifter = CollisionHandlerFloor()\n            self.lifter.setInPattern(\"enter%in\")\n            self.lifter.setOutPattern(\"exit%in\")\n            self.lifter.setOffset(floorOffset)\n\n            # Limit our rate-of-fall with the lifter.\n            # If this is too low, we actually \"fall\" off steep stairs\n            # and float above them as we go down. I increased this\n            # from 8.0 to 16.0 to prevent this\n            #self.lifter.setMaxVelocity(16.0)\n\n            #self.bobNodePath = self.avatarNodePath.attachNewNode(\"bob\")\n            #self.lifter.addCollider(self.cRayNodePath, self.cRayNodePath)\n            self.lifter.addCollider(self.cRayNodePath, self.avatarNodePath)\n        else: # useCollisionHandlerQueue\n            self.cRayQueue = CollisionHandlerQueue()\n            self.cTrav.addCollider(self.cRayNodePath, self.cRayQueue)\n\n    def determineHeight(self):\n        \"\"\"\n        returns the height of the avatar above the ground.\n        If there is no floor below the avatar, 0.0 is returned.\n        aka get airborne height.\n        \"\"\"\n        if self.useLifter:\n            height = self.avatarNodePath.getPos(self.cRayNodePath)\n            # If the shadow where not pointed strait down, we would need to\n            # get magnitude of the vector.  Since it is strait down, we'll\n            # just get the z:\n            #spammy --> assert self.debugPrint(\"getAirborneHeight() returning %s\"%(height.getZ(),))\n            assert onScreenDebug.add(\"height\", height.getZ())\n            return height.getZ() - self.floorOffset\n        else: # useCollisionHandlerQueue\n            height = 0.0\n            #*#self.cRayTrav.traverse(render)\n            if self.cRayQueue.getNumEntries() != 0:\n                # We have a floor.\n                # Choose the highest of the possibly several floors we're over:\n                self.cRayQueue.sortEntries()\n                floorPoint = self.cRayQueue.getEntry(0).getFromIntersectionPoint()\n                height = -floorPoint.getZ()\n            self.cRayQueue.clearEntries()\n            if __debug__:\n                onScreenDebug.add(\"height\", height)\n            return height\n\n    def setupSphere(self, bitmask, avatarRadius):\n        \"\"\"\n        Set up the collision sphere\n        \"\"\"\n        # This is a sphere on the ground to detect barrier collisions\n        self.avatarRadius = avatarRadius\n        centerHeight = avatarRadius\n        if self.useHeightRay:\n            centerHeight *= 2.0\n        self.cSphere = CollisionSphere(0.0, 0.0, centerHeight, avatarRadius)\n        cSphereNode = CollisionNode('PW.cSphereNode')\n        cSphereNode.addSolid(self.cSphere)\n        self.cSphereNodePath = self.avatarNodePath.attachNewNode(cSphereNode)\n        self.cSphereBitMask = bitmask\n\n        cSphereNode.setFromCollideMask(self.cSphereBitMask)\n        cSphereNode.setIntoCollideMask(BitMask32.allOff())\n\n        # set up collision mechanism\n        self.pusher = PhysicsCollisionHandler()\n        self.pusher.setInPattern(\"enter%in\")\n        self.pusher.setOutPattern(\"exit%in\")\n\n        self.pusher.addCollider(self.cSphereNodePath, self.avatarNodePath)\n\n    def setupPhysics(self, avatarNodePath):\n        assert self.debugPrint(\"setupPhysics()\")\n        # Connect to Physics Manager:\n        self.actorNode=ActorNode(\"PW physicsActor\")\n        self.actorNode.getPhysicsObject().setOriented(1)\n        self.actorNode.getPhysical(0).setViscosity(0.1)\n        physicsActor=NodePath(self.actorNode)\n        avatarNodePath.reparentTo(physicsActor)\n        avatarNodePath.assign(physicsActor)\n        self.phys=PhysicsManager()\n\n        fn=ForceNode(\"gravity\")\n        fnp=NodePath(fn)\n        #fnp.reparentTo(physicsActor)\n        fnp.reparentTo(render)\n        gravity=LinearVectorForce(0.0, 0.0, self.__gravity)\n        fn.addForce(gravity)\n        self.phys.addLinearForce(gravity)\n        self.gravity = gravity\n\n        fn=ForceNode(\"priorParent\")\n        fnp=NodePath(fn)\n        fnp.reparentTo(render)\n        priorParent=LinearVectorForce(0.0, 0.0, 0.0)\n        fn.addForce(priorParent)\n        self.phys.addLinearForce(priorParent)\n        self.priorParentNp = fnp\n        self.priorParent = priorParent\n\n        fn=ForceNode(\"viscosity\")\n        fnp=NodePath(fn)\n        #fnp.reparentTo(physicsActor)\n        fnp.reparentTo(render)\n        self.avatarViscosity=LinearFrictionForce(0.0, 1.0, 0)\n        #self.avatarViscosity.setCoef(0.9)\n        fn.addForce(self.avatarViscosity)\n        self.phys.addLinearForce(self.avatarViscosity)\n\n        self.phys.attachLinearIntegrator(LinearEulerIntegrator())\n        self.phys.attachPhysicalNode(physicsActor.node())\n\n        self.acForce=LinearVectorForce(0.0, 0.0, 0.0)\n        fn=ForceNode(\"avatarControls\")\n        fnp=NodePath(fn)\n        fnp.reparentTo(render)\n        fn.addForce(self.acForce)\n        self.phys.addLinearForce(self.acForce)\n        #self.phys.removeLinearForce(self.acForce)\n        #fnp.remove()\n        return avatarNodePath\n\n    def initializeCollisions(self, collisionTraverser, avatarNodePath,\n            wallBitmask, floorBitmask,\n            avatarRadius = 1.4, floorOffset = 1.0, reach = 1.0):\n        \"\"\"\n        Set up the avatar collisions\n        \"\"\"\n        assert self.debugPrint(\"initializeCollisions()\")\n\n        assert not avatarNodePath.isEmpty()\n\n        self.cTrav = collisionTraverser\n        self.floorOffset = floorOffset = 7.0\n\n        self.avatarNodePath = self.setupPhysics(avatarNodePath)\n        if self.useHeightRay:\n            #self.setupRay(floorBitmask, avatarRadius)\n            self.setupRay(floorBitmask, 0.0)\n        self.setupSphere(wallBitmask|floorBitmask, avatarRadius)\n\n        self.setCollisionsActive(1)\n\n    def setAirborneHeightFunc(self, getAirborneHeight):\n        self.getAirborneHeight = getAirborneHeight\n\n    def setAvatarPhysicsIndicator(self, indicator):\n        \"\"\"\n        indicator is a NodePath\n        \"\"\"\n        assert self.debugPrint(\"setAvatarPhysicsIndicator()\")\n        self.cSphereNodePath.show()\n        if indicator:\n            # Indicator Node:\n            change = render.attachNewNode(\"change\")\n            #change.setPos(Vec3(1.0, 1.0, 1.0))\n            #change.setHpr(0.0, 0.0, 0.0)\n            change.setScale(0.1)\n            #change.setColor(Vec4(1.0, 1.0, 1.0, 1.0))\n            indicator.reparentTo(change)\n\n            indicatorNode = render.attachNewNode(\"physVelocityIndicator\")\n            #indicatorNode.setScale(0.1)\n            #indicatorNode.setP(90.0)\n            indicatorNode.setPos(self.avatarNodePath, 0.0, 0.0, 6.0)\n            indicatorNode.setColor(0.0, 0.0, 1.0, 1.0)\n            change.reparentTo(indicatorNode)\n\n            self.physVelocityIndicator=indicatorNode\n            # Contact Node:\n            contactIndicatorNode = render.attachNewNode(\"physContactIndicator\")\n            contactIndicatorNode.setScale(0.25)\n            contactIndicatorNode.setP(90.0)\n            contactIndicatorNode.setPos(self.avatarNodePath, 0.0, 0.0, 5.0)\n            contactIndicatorNode.setColor(1.0, 0.0, 0.0, 1.0)\n            indicator.instanceTo(contactIndicatorNode)\n            self.physContactIndicator=contactIndicatorNode\n        else:\n            print(\"failed load of physics indicator\")\n\n    def avatarPhysicsIndicator(self, task):\n        #assert self.debugPrint(\"avatarPhysicsIndicator()\")\n        # Velocity:\n        self.physVelocityIndicator.setPos(self.avatarNodePath, 0.0, 0.0, 6.0)\n        physObject=self.actorNode.getPhysicsObject()\n        a=physObject.getVelocity()\n        self.physVelocityIndicator.setScale(math.sqrt(a.length()))\n        a+=self.physVelocityIndicator.getPos()\n        self.physVelocityIndicator.lookAt(Point3(a))\n        # Contact:\n        contact=self.actorNode.getContactVector()\n        if contact==Vec3.zero():\n            self.physContactIndicator.hide()\n        else:\n            self.physContactIndicator.show()\n            self.physContactIndicator.setPos(self.avatarNodePath, 0.0, 0.0, 5.0)\n            #contact=self.actorNode.getContactVector()\n            point=Point3(contact+self.physContactIndicator.getPos())\n            self.physContactIndicator.lookAt(point)\n        return Task.cont\n\n    def deleteCollisions(self):\n        assert self.debugPrint(\"deleteCollisions()\")\n        del self.cTrav\n\n        if self.useHeightRay:\n            del self.cRayQueue\n            self.cRayNodePath.removeNode()\n            del self.cRayNodePath\n\n        del self.cSphere\n        self.cSphereNodePath.removeNode()\n        del self.cSphereNodePath\n\n        del self.pusher\n\n        del self.getAirborneHeight\n\n    def setCollisionsActive(self, active = 1):\n        assert self.debugPrint(\"collisionsActive(active=%s)\"%(active,))\n        if self.collisionsActive != active:\n            self.collisionsActive = active\n            if active:\n                self.cTrav.addCollider(self.cSphereNodePath, self.pusher)\n                if self.useHeightRay:\n                    if self.useLifter:\n                        self.cTrav.addCollider(self.cRayNodePath, self.lifter)\n                    else:\n                        self.cTrav.addCollider(self.cRayNodePath, self.cRayQueue)\n            else:\n                self.cTrav.removeCollider(self.cSphereNodePath)\n                if self.useHeightRay:\n                    self.cTrav.removeCollider(self.cRayNodePath)\n                # Now that we have disabled collisions, make one more pass\n                # right now to ensure we aren't standing in a wall.\n                self.oneTimeCollide()\n\n    def getCollisionsActive(self):\n        assert self.debugPrint(\n            \"getCollisionsActive() returning=%s\"%(\n            self.collisionsActive,))\n        return self.collisionsActive\n\n    def placeOnFloor(self):\n        \"\"\"\n        Make a reasonable effort to place the avatar on the ground.\n        For example, this is useful when switching away from the\n        current walker.\n        \"\"\"\n        self.oneTimeCollide()\n        self.avatarNodePath.setZ(self.avatarNodePath.getZ()-self.getAirborneHeight())\n\n    def oneTimeCollide(self):\n        \"\"\"\n        Makes one quick collision pass for the avatar, for instance as\n        a one-time straighten-things-up operation after collisions\n        have been disabled.\n        \"\"\"\n        assert self.debugPrint(\"oneTimeCollide()\")\n        tempCTrav = CollisionTraverser(\"oneTimeCollide\")\n        if self.useHeightRay:\n            if self.useLifter:\n                tempCTrav.addCollider(self.cRayNodePath, self.lifter)\n            else:\n                tempCTrav.addCollider(self.cRayNodePath, self.cRayQueue)\n        tempCTrav.traverse(render)\n\n    def addBlastForce(self, vector):\n        pass\n\n    def displayDebugInfo(self):\n        \"\"\"\n        For debug use.\n        \"\"\"\n        onScreenDebug.add(\"w controls\", \"PhysicsWalker\")\n\n        if self.useLifter:\n            onScreenDebug.add(\"w airborneHeight\", self.lifter.getAirborneHeight())\n            onScreenDebug.add(\"w isOnGround\", self.lifter.isOnGround())\n            #onScreenDebug.add(\"w gravity\", self.lifter.getGravity())\n            onScreenDebug.add(\"w contact normal\", self.lifter.getContactNormal().pPrintValues())\n            onScreenDebug.add(\"w impact\", self.lifter.getImpactVelocity())\n            onScreenDebug.add(\"w velocity\", self.lifter.getVelocity())\n            onScreenDebug.add(\"w hasContact\", self.lifter.hasContact())\n        #onScreenDebug.add(\"w falling\", self.falling)\n        #onScreenDebug.add(\"w jumpForce\", self.avatarControlJumpForce)\n        #onScreenDebug.add(\"w mayJump\", self.mayJump)\n        onScreenDebug.add(\"w isAirborne\", self.isAirborne)\n\n    def handleAvatarControls(self, task):\n        \"\"\"\n        Check on the arrow keys and update the avatar.\n        \"\"\"\n        if __debug__:\n            if self.wantDebugIndicator:\n                onScreenDebug.append(\"localAvatar pos = %s\\n\"%(base.localAvatar.getPos().pPrintValues(),))\n                onScreenDebug.append(\"localAvatar h = % 10.4f\\n\"%(base.localAvatar.getH(),))\n                onScreenDebug.append(\"localAvatar anim = %s\\n\"%(base.localAvatar.animFSM.getCurrentState().getName(),))\n        #assert self.debugPrint(\"handleAvatarControls(task=%s)\"%(task,))\n        physObject=self.actorNode.getPhysicsObject()\n        #rotAvatarToPhys=Mat3.rotateMatNormaxis(-self.avatarNodePath.getH(), Vec3.up())\n        #rotPhysToAvatar=Mat3.rotateMatNormaxis(self.avatarNodePath.getH(), Vec3.up())\n        contact=self.actorNode.getContactVector()\n\n        # hack fix for falling through the floor:\n        if contact==Vec3.zero() and self.avatarNodePath.getZ()<-50.0:\n            # DCR: don't reset X and Y; allow player to move\n            self.reset()\n            self.avatarNodePath.setZ(50.0)\n            messenger.send(\"walkerIsOutOfWorld\", [self.avatarNodePath])\n\n        if self.wantDebugIndicator:\n            self.displayDebugInfo()\n\n        # get the button states:\n        forward = inputState.isSet(\"forward\")\n        reverse = inputState.isSet(\"reverse\")\n        turnLeft = inputState.isSet(\"turnLeft\")\n        turnRight = inputState.isSet(\"turnRight\")\n        slide = 0#inputState.isSet(\"slide\")\n        slideLeft = 0#inputState.isSet(\"slideLeft\")\n        slideRight = 0#inputState.isSet(\"slideRight\")\n        jump = inputState.isSet(\"jump\")\n\n        # Check for Auto-Run\n        if base.localAvatar.getAutoRun():\n            forward = 1\n            reverse = 0\n\n        # Determine what the speeds are based on the buttons:\n        self.__speed=(forward and self.avatarControlForwardSpeed or\n                reverse and -self.avatarControlReverseSpeed)\n        avatarSlideSpeed=self.avatarControlForwardSpeed*0.5\n        #self.__slideSpeed=slide and (\n        #        (turnLeft and -avatarSlideSpeed) or\n        #        (turnRight and avatarSlideSpeed))\n        self.__slideSpeed=(\n                (slideLeft and -avatarSlideSpeed) or\n                (slideRight and avatarSlideSpeed))\n        self.__rotationSpeed=not slide and (\n                (turnLeft and self.avatarControlRotateSpeed) or\n                (turnRight and -self.avatarControlRotateSpeed))\n\n        # How far did we move based on the amount of time elapsed?\n        dt=ClockObject.getGlobalClock().getDt()\n\n        if self.needToDeltaPos:\n            self.setPriorParentVector()\n            self.needToDeltaPos = 0\n        #self.__oldPosDelta = render.getRelativeVector(\n        #    self.avatarNodePath,\n        #    self.avatarNodePath.getPosDelta(render))\n        #self.__oldPosDelta = self.avatarNodePath.getRelativeVector(\n        #    render,\n        #    self.avatarNodePath.getPosDelta(render))\n        self.__oldPosDelta = self.avatarNodePath.getPosDelta(render)\n        self.__oldDt = dt\n        #posDelta = self.avatarNodePath.getPosDelta(render)\n        #if posDelta==Vec3.zero():\n        #    self.priorParent.setVector(self.__oldPosDelta)\n        #else:\n        #    self.priorParent.setVector(Vec3.zero())\n        #    # We must copy the vector to preserve it:\n        #    self.__oldPosDelta=Vec3(posDelta)\n        if __debug__:\n            if self.wantDebugIndicator:\n                onScreenDebug.add(\"posDelta1\",\n                    self.avatarNodePath.getPosDelta(render).pPrintValues())\n\n                #onScreenDebug.add(\"posDelta3\",\n                #    render.getRelativeVector(\n                #        self.avatarNodePath,\n                #        self.avatarNodePath.getPosDelta(render)).pPrintValues())\n\n                #onScreenDebug.add(\"gravity\",\n                #    self.gravity.getLocalVector().pPrintValues())\n                #onScreenDebug.add(\"priorParent\",\n                #    self.priorParent.getLocalVector().pPrintValues())\n                #onScreenDebug.add(\"avatarViscosity\",\n                #    \"% 10.4f\"%(self.avatarViscosity.getCoef(),))\n                #\n                #onScreenDebug.add(\"physObject pos\",\n                #    physObject.getPosition().pPrintValues())\n                #onScreenDebug.add(\"physObject hpr\",\n                #    physObject.getOrientation().getHpr().pPrintValues())\n                #onScreenDebug.add(\"physObject orien\",\n                #    physObject.getOrientation().pPrintValues())\n\n                onScreenDebug.add(\"physObject vel\",\n                    physObject.getVelocity().pPrintValues())\n                onScreenDebug.add(\"physObject len\",\n                    \"% 10.4f\"%physObject.getVelocity().length())\n\n                #onScreenDebug.add(\"posDelta4\",\n                #    self.priorParentNp.getRelativeVector(\n                #        render,\n                #        self.avatarNodePath.getPosDelta(render)).pPrintValues())\n\n                onScreenDebug.add(\"priorParent\",\n                    self.priorParent.getLocalVector().pPrintValues())\n\n                #onScreenDebug.add(\"priorParent po\",\n                #    self.priorParent.getVector(physObject).pPrintValues())\n\n                #onScreenDebug.add(\"__posDelta\",\n                #    self.__oldPosDelta.pPrintValues())\n\n                onScreenDebug.add(\"contact\",\n                    contact.pPrintValues())\n                #onScreenDebug.add(\"airborneHeight\", \"% 10.4f\"%(\n                #    self.getAirborneHeight(),))\n\n                #onScreenDebug.add(\"__oldContact\",\n                #    contact.pPrintValues())\n                #onScreenDebug.add(\"__oldAirborneHeight\", \"% 10.4f\"%(\n                #    self.getAirborneHeight(),))\n        airborneHeight = self.getAirborneHeight()\n        if airborneHeight > self.highMark:\n            self.highMark = airborneHeight\n            if __debug__:\n                onScreenDebug.add(\"highMark\", \"% 10.4f\"%(self.highMark,))\n        #if airborneHeight < 0.1: #contact!=Vec3.zero():\n        if (airborneHeight > self.avatarRadius*0.5\n                    or physObject.getVelocity().getZ() > 0.0\n                ): # Check stair angles before changing this.\n            # ...the avatar is airborne (maybe a lot or a tiny amount).\n            self.isAirborne = 1\n        else:\n            # ...the avatar is very close to the ground (close enough to be\n            # considered on the ground).\n            if self.isAirborne and physObject.getVelocity().getZ() <= 0.0:\n                # ...the avatar has landed.\n                contactLength = contact.length()\n                if contactLength>self.__hardLandingForce:\n                    #print \"jumpHardLand\"\n                    messenger.send(\"jumpHardLand\")\n                else:\n                    #print \"jumpLand\"\n                    messenger.send(\"jumpLand\")\n                self.priorParent.setVector(Vec3.zero())\n                self.isAirborne = 0\n            elif jump:\n                #print \"jump\"\n                #self.__jumpButton = 0\n                messenger.send(\"jumpStart\")\n\n                ## ...jump away from walls and with with the slope normal.\n                #jumpVec=Vec3(contact+Vec3.up())\n                ##jumpVec=Vec3(rotAvatarToPhys.xform(jumpVec))\n                #jumpVec.normalize()\n\n                # ...jump straight up, even if next to a wall.\n                jumpVec=Vec3.up()\n\n                jumpVec *= self.avatarControlJumpForce\n                physObject.addImpulse(Vec3(jumpVec))\n                self.isAirborne = 1 # Avoid double impulse before fully airborne.\n            else:\n                self.isAirborne = 0\n        if __debug__:\n            onScreenDebug.add(\"isAirborne\", \"%d\"%(self.isAirborne,))\n\n        if contact != self.__oldContact:\n            # We must copy the vector to preserve it:\n            self.__oldContact = Vec3(contact)\n        self.__oldAirborneHeight = airborneHeight\n\n        moveToGround = Vec3.zero()\n        if not self.useHeightRay or self.isAirborne:\n            # ...the airborne check is a hack to stop sliding.\n            self.phys.doPhysics(dt)\n            if __debug__:\n                onScreenDebug.add(\"phys\", \"on\")\n        else:\n            physObject.setVelocity(Vec3.zero())\n            #if airborneHeight>0.001 and contact==Vec3.zero():\n            #    moveToGround = Vec3(0.0, 0.0, -airborneHeight)\n            #moveToGround = Vec3(0.0, 0.0, -airborneHeight)\n            moveToGround = Vec3(0.0, 0.0, -self.determineHeight())\n            if __debug__:\n                onScreenDebug.add(\"phys\", \"off\")\n        # Check to see if we're moving at all:\n        if self.__speed or self.__slideSpeed or self.__rotationSpeed or moveToGround!=Vec3.zero():\n            distance = dt * self.__speed\n            slideDistance = dt * self.__slideSpeed\n            rotation = dt * self.__rotationSpeed\n\n            #debugTempH=self.avatarNodePath.getH()\n            assert self.avatarNodePath.getQuat().isSameDirection(physObject.getOrientation())\n            assert self.avatarNodePath.getPos().almostEqual(physObject.getPosition(), 0.0001)\n\n            # update pos:\n            # Take a step in the direction of our previous heading.\n            self.__vel=Vec3(\n                Vec3.forward() * distance +\n                Vec3.right() * slideDistance)\n\n            # rotMat is the rotation matrix corresponding to\n            # our previous heading.\n            rotMat=Mat3.rotateMatNormaxis(self.avatarNodePath.getH(), Vec3.up())\n            step=rotMat.xform(self.__vel)\n            physObject.setPosition(Point3(\n                physObject.getPosition()+step+moveToGround))\n\n            # update hpr:\n            o=physObject.getOrientation()\n            r=LRotationf()\n            r.setHpr(Vec3(rotation, 0.0, 0.0))\n            physObject.setOrientation(o*r)\n\n            # sync the change:\n            self.actorNode.updateTransform()\n\n            assert self.avatarNodePath.getQuat().isSameDirection(physObject.getOrientation())\n            assert self.avatarNodePath.getPos().almostEqual(physObject.getPosition(), 0.0001)\n            #assert self.avatarNodePath.getH()==debugTempH-rotation\n            messenger.send(\"avatarMoving\")\n        else:\n            self.__vel.set(0.0, 0.0, 0.0)\n        # Clear the contact vector so we can tell if we contact something next frame:\n        self.actorNode.setContactVector(Vec3.zero())\n        return Task.cont\n\n    def doDeltaPos(self):\n        assert self.debugPrint(\"doDeltaPos()\")\n        self.needToDeltaPos = 1\n\n    def setPriorParentVector(self):\n        assert self.debugPrint(\"doDeltaPos()\")\n\n        print(\"self.__oldDt %s self.__oldPosDelta %s\" % (self.__oldDt, self.__oldPosDelta))\n        if __debug__:\n            onScreenDebug.add(\"__oldDt\", \"% 10.4f\"%self.__oldDt)\n            onScreenDebug.add(\"self.__oldPosDelta\",\n                              self.__oldPosDelta.pPrintValues())\n\n        velocity = self.__oldPosDelta*(1/self.__oldDt)*4.0 # *4.0 is a hack\n        assert self.debugPrint(\"  __oldPosDelta=%s\"%(self.__oldPosDelta,))\n        assert self.debugPrint(\"  velocity=%s\"%(velocity,))\n        self.priorParent.setVector(Vec3(velocity))\n        if __debug__:\n            if self.wantDebugIndicator:\n                onScreenDebug.add(\"velocity\", velocity.pPrintValues())\n\n    def reset(self):\n        assert self.debugPrint(\"reset()\")\n        self.actorNode.getPhysicsObject().resetPosition(self.avatarNodePath.getPos())\n        self.priorParent.setVector(Vec3.zero())\n        self.highMark = 0\n        self.actorNode.setContactVector(Vec3.zero())\n        if __debug__:\n            contact=self.actorNode.getContactVector()\n            onScreenDebug.add(\"priorParent po\",\n                self.priorParent.getVector(self.actorNode.getPhysicsObject()).pPrintValues())\n            onScreenDebug.add(\"highMark\", \"% 10.4f\"%(self.highMark,))\n            onScreenDebug.add(\"contact\", contact.pPrintValues())\n\n    def getVelocity(self):\n        physObject=self.actorNode.getPhysicsObject()\n        return physObject.getVelocity()\n\n    def enableAvatarControls(self):\n        \"\"\"\n        Activate the arrow keys, etc.\n        \"\"\"\n        assert self.debugPrint(\"enableAvatarControls()\")\n        assert self.collisionsActive\n\n        if __debug__:\n            #self.accept(\"control-f3\", self.spawnTest) #*#\n            self.accept(\"f3\", self.reset) # for debugging only.\n\n        taskName = \"AvatarControls-%s\"%(id(self),)\n        # remove any old\n        taskMgr.remove(taskName)\n        # spawn the new task\n        taskMgr.add(self.handleAvatarControls, taskName, 25)\n        if self.physVelocityIndicator:\n            taskMgr.add(self.avatarPhysicsIndicator, \"AvatarControlsIndicator%s\"%(id(self),), 35)\n\n    def disableAvatarControls(self):\n        \"\"\"\n        Ignore the arrow keys, etc.\n        \"\"\"\n        assert self.debugPrint(\"disableAvatarControls()\")\n        taskName = \"AvatarControls-%s\"%(id(self),)\n        taskMgr.remove(taskName)\n\n        taskName = \"AvatarControlsIndicator%s\"%(id(self),)\n        taskMgr.remove(taskName)\n\n        if __debug__:\n            self.ignore(\"control-f3\") #*#\n            self.ignore(\"f3\")\n\n    def flushEventHandlers(self):\n        if hasattr(self, 'cTrav'):\n            if self.useLifter:\n                self.lifter.flush() # not currently defined or needed\n            self.pusher.flush()\n\n    if __debug__:\n        def setupAvatarPhysicsIndicator(self):\n            if self.wantDebugIndicator:\n                indicator = base.loader.loadModel('phase_5/models/props/dagger')\n                #self.walkControls.setAvatarPhysicsIndicator(indicator)\n\n        def debugPrint(self, message):\n            \"\"\"for debugging\"\"\"\n            return self.notify.debug(\n                    str(id(self))+' '+message)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/controls/PhysicsWalker.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/29172b8e_PhysicsWalker.json",
    "doc_id": "doc_225"
  }
}