{
  "content": "from panda3d.core import (\n    BitMask32,\n    BoundingSphere,\n    CollisionHandlerQueue,\n    CollisionNode,\n    CollisionRay,\n    CollisionSegment,\n    CollisionSphere,\n    CollisionTraverser,\n    GeomNode,\n    Mat4,\n    NodePath,\n    Point3,\n    TransformState,\n    VBase4,\n    Vec3,\n    Vec4,\n)\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.showbase.MessengerGlobal import messenger\nfrom . import DirectGlobals as DG\nfrom .DirectUtil import useDirectRenderStyle\nfrom .DirectGeometry import LineNodePath\n\nCOA_ORIGIN = 0\nCOA_CENTER = 1\n\n# MRM: To do: handle broken node paths in selected and deselected dicts\n\n\nclass DirectNodePath(NodePath):\n    # A node path augmented with info, bounding box, and utility methods\n    def __init__(self, nodePath, bboxColor=None):\n        # Initialize the superclass\n        NodePath.__init__(self)\n        self.assign(nodePath)\n        # Create a bounding box\n        self.bbox = DirectBoundingBox(self, bboxColor)\n        center = self.bbox.getCenter()\n        # Create matrix to hold the offset between the nodepath\n        # and its center of action (COA)\n        self.mCoa2Dnp = Mat4(Mat4.identMat())\n        if base.direct.coaMode == COA_CENTER:\n            self.mCoa2Dnp.setRow(3, Vec4(center[0], center[1], center[2], 1))\n\n        # Transform from nodePath to widget\n        self.tDnp2Widget = TransformState.makeIdentity()\n\n    def highlight(self, fRecompute = 1):\n        if fRecompute:\n            pass\n            #self.bbox.recompute()\n        self.bbox.show()\n\n    def dehighlight(self):\n        self.bbox.hide()\n\n    def getCenter(self):\n        return self.bbox.getCenter()\n\n    def getRadius(self):\n        return self.bbox.getRadius()\n\n    def getMin(self):\n        return self.bbox.getMin()\n\n    def getMax(self):\n        return self.bbox.getMax()\n\n\nclass SelectedNodePaths(DirectObject):\n    def __init__(self):\n        self.reset()\n        self.tagList = []\n\n    def addTag(self, tag):\n        if tag not in self.tagList:\n            self.tagList.append(tag)\n\n    def removeTag(self, tag):\n        self.tagList.remove(tag)\n\n    def reset(self):\n        self.selectedDict = {}\n        self.selectedList = [] # [gjeon] to maintain selected order\n        self.deselectedDict = {}\n        __builtins__[\"last\"] = self.last = None\n\n    def select(self, nodePath, fMultiSelect = 0, fSelectTag = 1):\n        \"\"\" Select the specified node path.  Multiselect as required \"\"\"\n        # Do nothing if nothing selected\n        if not nodePath:\n            print('Nothing selected!!')\n            return None\n\n        # Reset selected objects and highlight if multiSelect is false\n        if not fMultiSelect:\n            self.deselectAll()\n\n        # Select tagged object if present\n        if fSelectTag:\n            for tag in self.tagList:\n                if nodePath.hasNetTag(tag):\n                    nodePath = nodePath.findNetTag(tag)\n                    break\n\n        # Get this pointer\n        id = nodePath.get_key()\n        # First see if its already in the selected dictionary\n        dnp = self.getSelectedDict(id)\n        # If so, deselect it\n        if dnp:\n            self.deselect(nodePath)\n            return None\n        else:\n            # See if it is in the deselected dictionary\n            dnp = self.getDeselectedDict(id)\n            if dnp:\n                # Remove it from the deselected dictionary\n                del self.deselectedDict[id]\n                # Show its bounding box\n                dnp.highlight()\n            else:\n                # Didn't find it, create a new selectedNodePath instance\n                dnp = DirectNodePath(nodePath)\n                # Show its bounding box\n                dnp.highlight(fRecompute = 0)\n            # Add it to the selected dictionary\n            self.selectedDict[dnp.get_key()] = dnp\n            self.selectedList.append(dnp) # [gjeon]\n\n        # And update last\n        __builtins__[\"last\"] = self.last = dnp\n        # Update cluster servers if this is a cluster client\n        if base.direct.clusterMode == 'client':\n            cluster.selectNodePath(dnp)\n        return dnp\n\n    def deselect(self, nodePath):\n        \"\"\" Deselect the specified node path \"\"\"\n        # Get this pointer\n        id = nodePath.get_key()\n        # See if it is in the selected dictionary\n        dnp = self.getSelectedDict(id)\n        if dnp:\n            # It was selected:\n            # Hide its bounding box\n            dnp.dehighlight()\n            # Remove it from the selected dictionary\n            del self.selectedDict[id]\n            if dnp in self.selectedList: # [gjeon]\n                self.selectedList.remove(dnp)\n            # And keep track of it in the deselected dictionary\n            self.deselectedDict[id] = dnp\n            # Send a message\n            messenger.send('DIRECT_deselectedNodePath', [dnp])\n            # Update cluster servers if this is a cluster client\n            if base.direct.clusterMode == 'client':\n                cluster.deselectNodePath(dnp)\n        return dnp\n\n    def getSelectedAsList(self):\n        \"\"\"\n        Return a list of all selected node paths.  No verification of\n        connectivity is performed on the members of the list\n        \"\"\"\n        #return self.selectedDict.values()[:]\n        return self.selectedList[:] # [gjeon] now return the list with selected order\n\n    def __getitem__(self, index):\n        return self.getSelectedAsList()[index]\n\n    def getSelectedDict(self, id):\n        \"\"\"\n        Search selectedDict for node path, try to repair broken node paths.\n        \"\"\"\n        dnp = self.selectedDict.get(id, None)\n        if dnp:\n            return dnp\n        else:\n            # Not in selected dictionary\n            return None\n\n    def getDeselectedAsList(self):\n        return list(self.deselectedDict.values())\n\n    def getDeselectedDict(self, id):\n        \"\"\"\n        Search deselectedDict for node path, try to repair broken node paths.\n        \"\"\"\n        dnp = self.deselectedDict.get(id, None)\n        if dnp:\n            # Yes\n            return dnp\n        else:\n            # Not in deselected dictionary\n            return None\n\n    def forEachSelectedNodePathDo(self, func):\n        \"\"\"\n        Perform given func on selected node paths.  No node path\n        connectivity verification performed\n        \"\"\"\n        selectedNodePaths = self.getSelectedAsList()\n        for nodePath in selectedNodePaths:\n            func(nodePath)\n\n    def forEachDeselectedNodePathDo(self, func):\n        \"\"\"\n        Perform given func on deselected node paths.  No node path\n        connectivity verification performed\n        \"\"\"\n        deselectedNodePaths = self.getDeselectedAsList()\n        for nodePath in deselectedNodePaths:\n            func(nodePath)\n\n    def getWrtAll(self):\n        self.forEachSelectedNodePathDo(self.getWrt)\n\n    def getWrt(self, nodePath):\n        nodePath.tDnp2Widget = nodePath.getTransform(base.direct.widget)\n\n    def moveWrtWidgetAll(self):\n        self.forEachSelectedNodePathDo(self.moveWrtWidget)\n\n    def moveWrtWidget(self, nodePath):\n        nodePath.setTransform(base.direct.widget, nodePath.tDnp2Widget)\n\n    def deselectAll(self):\n        self.forEachSelectedNodePathDo(self.deselect)\n\n    def highlightAll(self):\n        self.forEachSelectedNodePathDo(DirectNodePath.highlight)\n\n    def dehighlightAll(self):\n        self.forEachSelectedNodePathDo(DirectNodePath.dehighlight)\n\n    def removeSelected(self):\n        selected = self.last\n        if selected:\n            selected.remove()\n        __builtins__[\"last\"] = self.last = None\n\n    def removeAll(self):\n        # Remove all selected nodePaths from the Scene Graph\n        self.forEachSelectedNodePathDo(NodePath.remove)\n\n    def toggleVisSelected(self):\n        selected = self.last\n        # Toggle visibility of selected node paths\n        if selected:\n            if selected.isHidden():\n                selected.show()\n            else:\n                selected.hide()\n\n    def toggleVisAll(self):\n        # Toggle viz for all selected node paths\n        selectedNodePaths = self.getSelectedAsList()\n        for nodePath in selectedNodePaths:\n            if nodePath.isHidden():\n                nodePath.show()\n            else:\n                nodePath.hide()\n\n    def isolateSelected(self):\n        selected = self.last\n        if selected:\n            selected.showAllDescendents()\n            for sib in selected.getParent().getChildren():\n                if sib.node() != selected.node():\n                    sib.hide()\n\n    def getDirectNodePath(self, nodePath):\n        # Get this pointer\n        id = nodePath.get_key()\n        # First check selected dict\n        dnp = self.getSelectedDict(id)\n        if dnp:\n            return dnp\n        # Otherwise return result of deselected search\n        return self.getDeselectedDict(id)\n\n    def getNumSelected(self):\n        return len(self.selectedDict)\n\n\nclass DirectBoundingBox:\n    def __init__(self, nodePath, bboxColor=None):\n        # Record the node path\n        self.nodePath = nodePath\n        # Compute bounds, min, max, etc.\n        self.computeTightBounds()\n        # Generate the bounding box\n        self.lines = self.createBBoxLines(bboxColor)\n\n    def recompute(self):\n        # Compute bounds, min, max, etc.\n        self.computeTightBounds()\n        self.updateBBoxLines()\n\n    def computeTightBounds(self):\n        # Compute bounding box using tighter calcTightBounds function\n        # Need to clear out existing transform on node path\n        tMat = Mat4(self.nodePath.getMat())\n        self.nodePath.clearMat()\n        # Get bounds\n        self.min = Point3(0)\n        self.max = Point3(0)\n        self.nodePath.calcTightBounds(self.min, self.max)\n        # Calc center and radius\n        self.center = Point3((self.min + self.max)/2.0)\n        self.radius = Vec3(self.max - self.min).length()\n        # Restore transform\n        self.nodePath.setMat(tMat)\n        del tMat\n\n    def computeBounds(self):\n        self.bounds = self.getBounds()\n        if self.bounds.isEmpty() or self.bounds.isInfinite():\n            self.center = Point3(0)\n            self.radius = 1.0\n        else:\n            self.center = self.bounds.getCenter()\n            self.radius = self.bounds.getRadius()\n        self.min = Point3(self.center - Point3(self.radius))\n        self.max = Point3(self.center + Point3(self.radius))\n\n    def createBBoxLines(self, bboxColor=None):\n        # Create a line segments object for the bbox\n        lines = LineNodePath(hidden)\n        lines.node().setName('bboxLines')\n        if bboxColor:\n            lines.setColor(VBase4(*bboxColor))\n        else:\n            lines.setColor(VBase4(1., 0., 0., 1.))\n        lines.setThickness(0.5)\n\n        minX = self.min[0]\n        minY = self.min[1]\n        minZ = self.min[2]\n        maxX = self.max[0]\n        maxY = self.max[1]\n        maxZ = self.max[2]\n\n        # Bottom face\n        lines.moveTo(minX, minY, minZ)\n        lines.drawTo(maxX, minY, minZ)\n        lines.drawTo(maxX, maxY, minZ)\n        lines.drawTo(minX, maxY, minZ)\n        lines.drawTo(minX, minY, minZ)\n\n        # Front Edge/Top face\n        lines.drawTo(minX, minY, maxZ)\n        lines.drawTo(maxX, minY, maxZ)\n        lines.drawTo(maxX, maxY, maxZ)\n        lines.drawTo(minX, maxY, maxZ)\n        lines.drawTo(minX, minY, maxZ)\n\n        # Three remaining edges\n        lines.moveTo(maxX, minY, minZ)\n        lines.drawTo(maxX, minY, maxZ)\n        lines.moveTo(maxX, maxY, minZ)\n        lines.drawTo(maxX, maxY, maxZ)\n        lines.moveTo(minX, maxY, minZ)\n        lines.drawTo(minX, maxY, maxZ)\n\n        # Create and return bbox lines\n        lines.create()\n\n        # Make sure bbox is never lit or drawn in wireframe\n        useDirectRenderStyle(lines)\n\n        return lines\n\n    def setBoxColorScale(self, r, g, b, a):\n        if self.lines:\n            self.lines.reset()\n            self.lines = None\n        self.lines = self.createBBoxLines((r, g, b, a))\n        self.show()\n\n    def updateBBoxLines(self):\n        ls = self.lines.lineSegs\n\n        minX = self.min[0]\n        minY = self.min[1]\n        minZ = self.min[2]\n        maxX = self.max[0]\n        maxY = self.max[1]\n        maxZ = self.max[2]\n\n        # Bottom face\n        ls.setVertex(0, minX, minY, minZ)\n        ls.setVertex(1, maxX, minY, minZ)\n        ls.setVertex(2, maxX, maxY, minZ)\n        ls.setVertex(3, minX, maxY, minZ)\n        ls.setVertex(4, minX, minY, minZ)\n\n        # Front Edge/Top face\n        ls.setVertex(5, minX, minY, maxZ)\n        ls.setVertex(6, maxX, minY, maxZ)\n        ls.setVertex(7, maxX, maxY, maxZ)\n        ls.setVertex(8, minX, maxY, maxZ)\n        ls.setVertex(9, minX, minY, maxZ)\n\n        # Three remaining edges\n        ls.setVertex(10, maxX, minY, minZ)\n        ls.setVertex(11, maxX, minY, maxZ)\n        ls.setVertex(12, maxX, maxY, minZ)\n        ls.setVertex(13, maxX, maxY, maxZ)\n        ls.setVertex(14, minX, maxY, minZ)\n        ls.setVertex(15, minX, maxY, maxZ)\n\n    def getBounds(self):\n        # Get a node path's bounds\n        nodeBounds = BoundingSphere()\n        nodeBounds.extendBy(self.nodePath.node().getInternalBound())\n        for child in self.nodePath.getChildren():\n            nodeBounds.extendBy(child.getBounds())\n        return nodeBounds.makeCopy()\n\n    def show(self):\n        self.lines.reparentTo(self.nodePath)\n\n    def hide(self):\n        self.lines.reparentTo(hidden)\n\n    def getCenter(self):\n        return self.center\n\n    def getRadius(self):\n        return self.radius\n\n    def getMin(self):\n        return self.min\n\n    def getMax(self):\n        return self.max\n\n    def vecAsString(self, vec):\n        return '%.2f %.2f %.2f' % (vec[0], vec[1], vec[2])\n\n    def __repr__(self):\n        return (repr(self.__class__) +\n                '\\nNodePath:\\t%s\\n' % self.nodePath.getName() +\n                'Min:\\t\\t%s\\n' % self.vecAsString(self.min) +\n                'Max:\\t\\t%s\\n' % self.vecAsString(self.max) +\n                'Center:\\t\\t%s\\n' % self.vecAsString(self.center) +\n                'Radius:\\t\\t%.2f' % self.radius\n                )\n\n\nclass SelectionQueue(CollisionHandlerQueue):\n    def __init__(self, parentNP = None):\n        if parentNP is None:\n            parentNP = render\n        # Initialize the superclass\n        CollisionHandlerQueue.__init__(self)\n        # Current index and entry in collision queue\n        self.index = -1\n        self.entry = None\n        self.skipFlags = DG.SKIP_NONE\n        # Create a collision node path attached to the given NP\n        self.collisionNodePath = NodePath(CollisionNode(\"collisionNP\"))\n        self.setParentNP(parentNP)\n        # Don't pay the penalty of drawing this collision ray\n        self.collisionNodePath.hide()\n        self.collisionNode = self.collisionNodePath.node()\n        # Intersect with geometry to begin with\n        self.collideWithGeom()\n        # And a traverser to do the actual collision tests\n        self.ct = CollisionTraverser(\"DirectSelection\")\n        self.ct.setRespectPrevTransform(False)\n        # Let the traverser know about the collision node and the queue\n        self.ct.addCollider(self.collisionNodePath, self)\n        # List of objects that can't be selected\n        self.unpickable = DG.UNPICKABLE\n        # Derived class must add Collider to complete initialization\n\n    def setParentNP(self, parentNP):\n        # Update collisionNodePath's parent\n        self.collisionNodePath.reparentTo(parentNP)\n\n    def addCollider(self, collider):\n        # Inherited class must call this function to specify collider object\n        # Record collision object\n        self.collider = collider\n        # Add the collider to the collision Node\n        self.collisionNode.addSolid(self.collider)\n\n    def collideWithBitMask(self, bitMask):\n        # The into collide mask is the bit pattern colliders look at\n        # when deciding whether or not to test for a collision \"into\"\n        # this collision solid.  Set to all Off so this collision solid\n        # will not be considered in any collision tests\n        self.collisionNode.setIntoCollideMask(BitMask32().allOff())\n        # The from collide mask is the bit pattern *this* collision solid\n        # compares against the into collide mask of candidate collision solids\n        # Turn this mask all off since we're not testing for collisions against\n        # collision solids\n        self.collisionNode.setFromCollideMask(bitMask)\n\n    def collideWithGeom(self):\n        # The into collide mask is the bit pattern colliders look at\n        # when deciding whether or not to test for a collision \"into\"\n        # this collision solid.  Set to all Off so this collision solid\n        # will not be considered in any collision tests\n        self.collisionNode.setIntoCollideMask(BitMask32().allOff())\n        # The from collide mask is the bit pattern *this* collision solid\n        # compares against the into collide mask of candidate collision solids\n        # Turn this mask all off since we're not testing for collisions against\n        # collision solids\n        self.collisionNode.setFromCollideMask(GeomNode.getDefaultCollideMask())\n\n    def collideWithWidget(self):\n        # This collision node should not be tested against by any other\n        # collision solids\n        self.collisionNode.setIntoCollideMask(BitMask32().allOff())\n        # This collision node will test for collisions with any collision\n        # solids with a bit mask set to 0x80000000\n        mask = BitMask32()\n        mask.setWord(0x80000000)\n        self.collisionNode.setFromCollideMask(mask)\n\n    def addUnpickable(self, item):\n        if item not in self.unpickable:\n            self.unpickable.append(item)\n\n    def removeUnpickable(self, item):\n        if item in self.unpickable:\n            self.unpickable.remove(item)\n\n    def setCurrentIndex(self, index):\n        if (index < 0) or (index >= self.getNumEntries()):\n            self.index = -1\n        else:\n            self.index = index\n\n    def setCurrentEntry(self, entry):\n        self.entry = entry\n\n    def getCurrentEntry(self):\n        return self.entry\n\n    def isEntryBackfacing(self, entry):\n        # If dot product of collision point surface normal and\n        # ray from camera to collision point is positive, we are\n        # looking at the backface of the polygon\n        if not entry.hasSurfaceNormal():\n            # Well, no way to tell.  Assume we're not backfacing.\n            return 0\n\n        if base.direct:\n            cam = base.direct.cam\n        else:\n            cam = base.cam\n\n        fromNodePath = entry.getFromNodePath()\n        v = Vec3(entry.getSurfacePoint(fromNodePath))\n        n = entry.getSurfaceNormal(fromNodePath)\n        # Convert to camera space for backfacing test\n        if self.collisionNodePath.getParent() != cam:\n            # Problem: assumes base.cam is the camera in question\n            p2cam = self.collisionNodePath.getParent().getMat(cam)\n            v = Vec3(p2cam.xformPoint(v))\n            n = p2cam.xformVec(n)\n        # Normalize and check angle between to vectors\n        v.normalize()\n        return v.dot(n) >= 0\n\n    def findNextCollisionEntry(self, skipFlags = DG.SKIP_NONE):\n        return self.findCollisionEntry(skipFlags, self.index + 1)\n\n    def findCollisionEntry(self, skipFlags = DG.SKIP_NONE, startIndex = 0):\n        # Init self.index and self.entry\n        self.setCurrentIndex(-1)\n        self.setCurrentEntry(None)\n        # Pick out the closest object that isn't a widget\n        for i in range(startIndex, self.getNumEntries()):\n            entry = self.getEntry(i)\n            nodePath = entry.getIntoNodePath()\n            if (skipFlags & DG.SKIP_HIDDEN) and nodePath.isHidden():\n                # Skip if hidden node\n                pass\n            elif (skipFlags & DG.SKIP_BACKFACE) and self.isEntryBackfacing(entry):\n                # Skip, if backfacing poly\n                pass\n            elif (skipFlags & DG.SKIP_CAMERA) and \\\n                 (base.camera in nodePath.getAncestors()):\n                # Skip if parented to a camera.\n                pass\n            # Can pick unpickable, use the first visible node\n            elif (skipFlags & DG.SKIP_UNPICKABLE) and \\\n                 (nodePath.getName() in self.unpickable):\n                # Skip if in unpickable list\n                pass\n            elif base.direct and \\\n                 ((skipFlags & DG.SKIP_WIDGET) and\n                 (nodePath.getTag('WidgetName') != base.direct.widget.getName())):\n                # Skip if this widget part is not belong to current widget\n                pass\n            elif base.direct and \\\n                 ((skipFlags & DG.SKIP_WIDGET) and base.direct.fControl and\n                 (nodePath.getName()[2:] == 'ring')):\n                # Skip when ununiformly scale in ortho view\n                pass\n            else:\n                self.setCurrentIndex(i)\n                self.setCurrentEntry(entry)\n                break\n        return self.getCurrentEntry()\n\n\nclass SelectionRay(SelectionQueue):\n    def __init__(self, parentNP = None):\n        if parentNP is None:\n            parentNP = render\n        # Initialize the superclass\n        SelectionQueue.__init__(self, parentNP)\n        self.addCollider(CollisionRay())\n\n    def pick(self, targetNodePath, xy = None):\n        # Determine ray direction based upon the mouse coordinates\n        if xy:\n            mx = xy[0]\n            my = xy[1]\n        elif base.direct:\n            mx = base.direct.dr.mouseX\n            my = base.direct.dr.mouseY\n        else:\n            if not base.mouseWatcherNode.hasMouse():\n                # No mouse in window.\n                self.clearEntries()\n                return\n            mx = base.mouseWatcherNode.getMouseX()\n            my = base.mouseWatcherNode.getMouseY()\n\n        if base.direct:\n            self.collider.setFromLens(base.direct.camNode, mx, my)\n        else:\n            self.collider.setFromLens(base.camNode, mx, my)\n        self.ct.traverse(targetNodePath)\n        self.sortEntries()\n\n    def pickBitMask(self, bitMask = BitMask32.allOff(),\n                    targetNodePath = None,\n                    skipFlags = DG.SKIP_ALL):\n        if targetNodePath is None:\n            targetNodePath = render\n        self.collideWithBitMask(bitMask)\n        self.pick(targetNodePath)\n        # Determine collision entry\n        return self.findCollisionEntry(skipFlags)\n\n    def pickGeom(self, targetNodePath = None, skipFlags = DG.SKIP_ALL,\n                 xy = None):\n        if targetNodePath is None:\n            targetNodePath = render\n        self.collideWithGeom()\n        self.pick(targetNodePath, xy = xy)\n        # Determine collision entry\n        return self.findCollisionEntry(skipFlags)\n\n    def pickWidget(self, targetNodePath = None, skipFlags = DG.SKIP_NONE):\n        if targetNodePath is None:\n            targetNodePath = render\n        self.collideWithWidget()\n        self.pick(targetNodePath)\n        # Determine collision entry\n        return self.findCollisionEntry(skipFlags)\n\n    def pick3D(self, targetNodePath, origin, dir):\n        # Determine ray direction based upon the mouse coordinates\n        self.collider.setOrigin(origin)\n        self.collider.setDirection(dir)\n        self.ct.traverse(targetNodePath)\n        self.sortEntries()\n\n    def pickGeom3D(self, targetNodePath = None,\n                   origin = Point3(0), dir = Vec3(0, 0, -1),\n                   skipFlags = DG.SKIP_HIDDEN | DG.SKIP_CAMERA):\n        if targetNodePath is None:\n            targetNodePath = render\n        self.collideWithGeom()\n        self.pick3D(targetNodePath, origin, dir)\n        # Determine collision entry\n        return self.findCollisionEntry(skipFlags)\n\n    def pickBitMask3D(self, bitMask = BitMask32.allOff(),\n                      targetNodePath = None,\n                      origin = Point3(0), dir = Vec3(0, 0, -1),\n                      skipFlags = DG.SKIP_ALL):\n        if targetNodePath is None:\n            targetNodePath = render\n        self.collideWithBitMask(bitMask)\n        self.pick3D(targetNodePath, origin, dir)\n        # Determine collision entry\n        return self.findCollisionEntry(skipFlags)\n\n\nclass SelectionSegment(SelectionQueue):\n    # Like a selection ray but with two endpoints instead of an endpoint\n    # and a direction\n    def __init__(self, parentNP = None, numSegments = 1):\n        if parentNP is None:\n            parentNP = render\n        # Initialize the superclass\n        SelectionQueue.__init__(self, parentNP)\n        self.colliders = []\n        self.numColliders = 0\n        for i in range(numSegments):\n            self.addCollider(CollisionSegment())\n\n    def addCollider(self, collider):\n        # Record new collision object\n        self.colliders.append(collider)\n        # Add the collider to the collision Node\n        self.collisionNode.addSolid(collider)\n        self.numColliders += 1\n\n    def pickGeom(self, targetNodePath = None, endPointList = [],\n                 skipFlags = DG.SKIP_HIDDEN | DG.SKIP_CAMERA):\n        if targetNodePath is None:\n            targetNodePath = render\n        self.collideWithGeom()\n        for i in range(min(len(endPointList), self.numColliders)):\n            pointA, pointB = endPointList[i]\n            collider = self.colliders[i]\n            collider.setPointA(pointA)\n            collider.setPointB(pointB)\n        self.ct.traverse(targetNodePath)\n        # Determine collision entry\n        return self.findCollisionEntry(skipFlags)\n\n    def pickBitMask(self, bitMask = BitMask32.allOff(),\n                    targetNodePath = None, endPointList = [],\n                 skipFlags = DG.SKIP_HIDDEN | DG.SKIP_CAMERA):\n        if targetNodePath is None:\n            targetNodePath = render\n        self.collideWithBitMask(bitMask)\n        for i in range(min(len(endPointList), self.numColliders)):\n            pointA, pointB = endPointList[i]\n            collider = self.colliders[i]\n            collider.setPointA(pointA)\n            collider.setPointB(pointB)\n        self.ct.traverse(targetNodePath)\n        # Determine collision entry\n        return self.findCollisionEntry(skipFlags)\n\n\nclass SelectionSphere(SelectionQueue):\n    # Wrapper around collision sphere\n    def __init__(self, parentNP = None, numSpheres = 1):\n        if parentNP is None:\n            parentNP = render\n        # Initialize the superclass\n        SelectionQueue.__init__(self, parentNP)\n        self.colliders = []\n        self.numColliders = 0\n        for i in range(numSpheres):\n            self.addCollider(CollisionSphere(Point3(0), 1))\n\n    def addCollider(self, collider):\n        # Record new collision object\n        self.colliders.append(collider)\n        # Add the collider to the collision Node\n        self.collisionNode.addSolid(collider)\n        self.numColliders += 1\n\n    def setCenter(self, i, center):\n        c = self.colliders[i]\n        c.setCenter(center)\n\n    def setRadius(self, i, radius):\n        c = self.colliders[i]\n        c.setRadius(radius)\n\n    def setCenterRadius(self, i, center, radius):\n        c = self.colliders[i]\n        c.setCenter(center)\n        c.setRadius(radius)\n\n    def isEntryBackfacing(self, entry):\n        # If dot product of collision point surface normal and\n        # ray from sphere origin to collision point is positive,\n        # center is on the backside of the polygon\n        fromNodePath = entry.getFromNodePath()\n        v = Vec3(entry.getSurfacePoint(fromNodePath) -\n                 entry.getFrom().getCenter())\n        n = entry.getSurfaceNormal(fromNodePath)\n        # If points almost on top of each other, reject face\n        # (treat as backfacing)\n        if v.length() < 0.05:\n            return 1\n        # Normalize and check angle between to vectors\n        v.normalize()\n        return v.dot(n) >= 0\n\n    def pick(self, targetNodePath, skipFlags):\n        self.ct.traverse(targetNodePath)\n        self.sortEntries()\n        return self.findCollisionEntry(skipFlags)\n\n    def pickGeom(self, targetNodePath = None,\n                 skipFlags = DG.SKIP_HIDDEN | DG.SKIP_CAMERA):\n        if targetNodePath is None:\n            targetNodePath = render\n        self.collideWithGeom()\n        return self.pick(targetNodePath, skipFlags)\n\n    def pickBitMask(self, bitMask = BitMask32.allOff(),\n                    targetNodePath = None,\n                    skipFlags = DG.SKIP_HIDDEN | DG.SKIP_CAMERA):\n        if targetNodePath is None:\n            targetNodePath = render\n        self.collideWithBitMask(bitMask)\n        return self.pick(targetNodePath, skipFlags)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/directtools/DirectSelection.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/eebfe557_DirectSelection.json",
    "doc_id": "doc_186"
  }
}