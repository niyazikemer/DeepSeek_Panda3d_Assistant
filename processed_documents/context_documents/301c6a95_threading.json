{
  "content": "\"\"\" This module reimplements Python's native threading module using Panda\nthreading constructs.  It's designed as a drop-in replacement for the\nthreading module for code that works with Panda; it is necessary because\nin some compilation models, Panda's threading constructs are\nincompatible with the OS-provided threads used by Python's thread\nmodule.\n\nThis module implements the threading module with a thin layer over\nPanda's threading constructs.  As such, the semantics are close to,\nbut not precisely, the semantics documented for Python's standard\nthreading module.  If you really do require strict adherence to\nPython's semantics, see the threading2 module instead.\n\nHowever, if you don't need such strict adherence to Python's original\nsemantics, this module is probably a better choice.  It is likely to\nbe slighly faster than the threading2 module (and even slightly faster\nthan Python's own threading module).  It is also better integrated\nwith Panda's threads, so that Panda's thread debug mechanisms will be\neasier to use and understand.\n\nIt is permissible to mix-and-match both threading and threading2\nwithin the same application. \"\"\"\n\nfrom panda3d import core\nfrom direct.stdpy import thread as _thread\nimport sys as _sys\n\nimport weakref\n\n__all__ = [\n    'Thread',\n    'Lock', 'RLock',\n    'Condition',\n    'Semaphore', 'BoundedSemaphore',\n    'Event',\n    'Timer',\n    'ThreadError',\n    'local',\n    'current_thread',\n    'main_thread',\n    'enumerate', 'active_count',\n    'settrace', 'setprofile', 'stack_size',\n    'TIMEOUT_MAX',\n]\n\nTIMEOUT_MAX = _thread.TIMEOUT_MAX\n\nlocal = _thread._local\n_newname = _thread._newname\nThreadError = _thread.error\n\n\nclass ThreadBase:\n    \"\"\" A base class for both Thread and ExternalThread in this\n    module. \"\"\"\n\n    def __init__(self):\n        pass\n\n    def getName(self):\n        return self.name\n\n    def isDaemon(self):\n        return self.daemon\n\n    def setDaemon(self, daemon):\n        if self.is_alive():\n            raise RuntimeError\n\n        self.__dict__['daemon'] = daemon\n\n    def __setattr__(self, key, value):\n        if key == 'name':\n            self.setName(value)\n        elif key == 'ident':\n            raise AttributeError\n        elif key == 'daemon':\n            self.setDaemon(value)\n        else:\n            self.__dict__[key] = value\n\n\n# Copy these static methods from Panda's Thread object.  These are\n# useful if you may be running in Panda's SIMPLE_THREADS compilation\n# mode.\nThreadBase.forceYield = core.Thread.forceYield  # type: ignore[attr-defined]\nThreadBase.considerYield = core.Thread.considerYield  # type: ignore[attr-defined]\n\n\nclass Thread(ThreadBase):\n    \"\"\" This class provides a wrapper around Panda's PythonThread\n    object.  The wrapper is designed to emulate Python's own\n    threading.Thread object. \"\"\"\n\n    def __init__(self, group=None, target=None, name=None, args=(), kwargs={}, daemon=None):\n        ThreadBase.__init__(self)\n\n        assert group is None\n        self.__target = target\n        self.__args = args\n        self.__kwargs = kwargs\n\n        if not name:\n            name = _newname()\n\n        current = current_thread()\n        if daemon is not None:\n            self.__dict__['daemon'] = daemon\n        else:\n            self.__dict__['daemon'] = current.daemon\n        self.__dict__['name'] = name\n\n        def call_run():\n            # As soon as the thread is done, break the circular reference.\n            try:\n                self.run()\n            finally:\n                self.__thread = None\n                _thread._remove_thread_id(self.ident)\n\n        self.__thread = core.PythonThread(call_run, None, name, name)\n        threadId = _thread._add_thread(self.__thread, weakref.proxy(self))\n        self.__dict__['ident'] = threadId\n\n    def __del__(self):\n        _thread._remove_thread_id(self.ident)\n\n    def is_alive(self):\n        thread = self.__thread\n        return thread is not None and thread.is_started()\n\n    isAlive = is_alive\n\n    def start(self):\n        thread = self.__thread\n        if thread is None or thread.is_started():\n            raise RuntimeError\n\n        if not thread.start(core.TPNormal, True):\n            raise RuntimeError\n\n    def run(self):\n        if _settrace_func:\n            _sys.settrace(_settrace_func)\n        if _setprofile_func:\n            _sys.setprofile(_setprofile_func)\n\n        self.__target(*self.__args, **self.__kwargs)\n\n    def join(self, timeout = None):\n        # We don't support a timed join here, sorry.\n        assert timeout is None\n        thread = self.__thread\n        if thread is not None:\n            thread.join()\n            # Clear the circular reference.\n            self.__thread = None\n            _thread._remove_thread_id(self.ident)\n\n    def setName(self, name):\n        self.__dict__['name'] = name\n        self.__thread.setName(name)\n\n\nclass ExternalThread(ThreadBase):\n    \"\"\" Returned for a Thread object that wasn't created by this\n    interface. \"\"\"\n\n    def __init__(self, extThread, threadId):\n        ThreadBase.__init__(self)\n\n        self.__thread = extThread\n        self.__dict__['daemon'] = True\n        self.__dict__['name'] = self.__thread.getName()\n        self.__dict__['ident'] = threadId\n\n    def is_alive(self):\n        return self.__thread.isStarted()\n\n    def isAlive(self):\n        return self.__thread.isStarted()\n\n    def start(self):\n        raise RuntimeError\n\n    def run(self):\n        raise RuntimeError\n\n    def join(self, timeout = None):\n        raise RuntimeError\n\n    def setDaemon(self, daemon):\n        raise RuntimeError\n\n\nclass MainThread(ExternalThread):\n    \"\"\" Returned for the MainThread object. \"\"\"\n\n    def __init__(self, extThread, threadId):\n        ExternalThread.__init__(self, extThread, threadId)\n        self.__dict__['daemon'] = False\n\n\nclass Lock(core.Mutex):\n    \"\"\" This class provides a wrapper around Panda's Mutex object.\n    The wrapper is designed to emulate Python's own threading.Lock\n    object. \"\"\"\n\n    def __init__(self, name = \"PythonLock\"):\n        core.Mutex.__init__(self, name)\n\n\nclass RLock(core.ReMutex):\n    \"\"\" This class provides a wrapper around Panda's ReMutex object.\n    The wrapper is designed to emulate Python's own threading.RLock\n    object. \"\"\"\n\n    def __init__(self, name = \"PythonRLock\"):\n        core.ReMutex.__init__(self, name)\n\n\nclass Condition(core.ConditionVar):\n    \"\"\" This class provides a wrapper around Panda's ConditionVar\n    object.  The wrapper is designed to emulate Python's own\n    threading.Condition object. \"\"\"\n\n    def __init__(self, lock = None):\n        if not lock:\n            lock = Lock()\n\n        # Panda doesn't support RLock objects used with condition\n        # variables.\n        assert isinstance(lock, Lock)\n\n        self.__lock = lock\n        core.ConditionVar.__init__(self, self.__lock)\n\n    def acquire(self, *args, **kw):\n        return self.__lock.acquire(*args, **kw)\n\n    def release(self):\n        self.__lock.release()\n\n    def wait(self, timeout = None):\n        if timeout is None:\n            core.ConditionVar.wait(self)\n        else:\n            core.ConditionVar.wait(self, timeout)\n\n    def notifyAll(self):\n        core.ConditionVar.notifyAll(self)\n\n    notify_all = notifyAll\n\n    __enter__ = acquire\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n\nclass Semaphore(core.Semaphore):\n    \"\"\" This class provides a wrapper around Panda's Semaphore\n    object.  The wrapper is designed to emulate Python's own\n    threading.Semaphore object. \"\"\"\n\n    def __init__(self, value = 1):\n        core.Semaphore.__init__(self, value)\n\n    def acquire(self, blocking = True):\n        if blocking:\n            core.Semaphore.acquire(self)\n            return True\n        else:\n            return core.Semaphore.tryAcquire(self)\n\n    __enter__ = acquire\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n\nclass BoundedSemaphore(Semaphore):\n    \"\"\" This class provides a wrapper around Panda's Semaphore\n    object.  The wrapper is designed to emulate Python's own\n    threading.BoundedSemaphore object. \"\"\"\n\n    def __init__(self, value = 1):\n        self.__max = value\n        Semaphore.__init__(value)\n\n    def release(self):\n        if self.getCount() > self.__max:\n            raise ValueError\n\n        Semaphore.release(self)\n\n\nclass Event:\n    \"\"\" This class is designed to emulate Python's own threading.Event\n    object. \"\"\"\n\n    def __init__(self):\n        self.__lock = core.Mutex(\"Python Event\")\n        self.__cvar = core.ConditionVar(self.__lock)\n        self.__flag = False\n\n    def is_set(self):\n        return self.__flag\n\n    isSet = is_set\n\n    def set(self):\n        self.__lock.acquire()\n        try:\n            self.__flag = True\n            self.__cvar.notifyAll()\n\n        finally:\n            self.__lock.release()\n\n    def clear(self):\n        self.__lock.acquire()\n        try:\n            self.__flag = False\n\n        finally:\n            self.__lock.release()\n\n    def wait(self, timeout = None):\n        self.__lock.acquire()\n        try:\n            if timeout is None:\n                while not self.__flag:\n                    self.__cvar.wait()\n            else:\n                clock = core.TrueClock.getGlobalPtr()\n                expires = clock.getShortTime() + timeout\n                while not self.__flag:\n                    wait = expires - clock.getShortTime()\n                    if wait < 0:\n                        return\n\n                    self.__cvar.wait(wait)\n\n        finally:\n            self.__lock.release()\n\n\nclass Timer(Thread):\n    \"\"\"Call a function after a specified number of seconds:\n\n    t = Timer(30.0, f, args=[], kwargs={})\n    t.start()\n    t.cancel() # stop the timer's action if it's still waiting\n    \"\"\"\n\n    def __init__(self, interval, function, args=[], kwargs={}):\n        Thread.__init__(self)\n        self.interval = interval\n        self.function = function\n        self.args = args\n        self.kwargs = kwargs\n        self.finished = Event()\n\n    def cancel(self):\n        \"\"\"Stop the timer if it hasn't finished yet\"\"\"\n        self.finished.set()\n\n    def run(self):\n        self.finished.wait(self.interval)\n        if not self.finished.isSet():\n            self.function(*self.args, **self.kwargs)\n        self.finished.set()\n\n\ndef _create_thread_wrapper(t, threadId):\n    \"\"\" Creates a thread wrapper for the indicated external thread. \"\"\"\n    if isinstance(t, core.MainThread):\n        pyt = MainThread(t, threadId)\n    else:\n        pyt = ExternalThread(t, threadId)\n\n    return pyt\n\n\ndef current_thread():\n    t = core.Thread.getCurrentThread()\n    return _thread._get_thread_wrapper(t, _create_thread_wrapper)\n\n\ndef main_thread():\n    t = core.Thread.getMainThread()\n    return _thread._get_thread_wrapper(t, _create_thread_wrapper)\n\n\ncurrentThread = current_thread\n\n\ndef enumerate():\n    tlist = []\n    _thread._threadsLock.acquire()\n    try:\n        for thread, locals, wrapper in list(_thread._threads.values()):\n            if wrapper and wrapper.is_alive():\n                tlist.append(wrapper)\n        return tlist\n    finally:\n        _thread._threadsLock.release()\n\n\ndef active_count():\n    return len(enumerate())\n\n\nactiveCount = active_count\n\n_settrace_func = None\n\n\ndef settrace(func):\n    global _settrace_func\n    _settrace_func = func\n\n\n_setprofile_func = None\n\n\ndef setprofile(func):\n    global _setprofile_func\n    _setprofile_func = func\n\n\ndef stack_size(size = None):\n    raise ThreadError\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/stdpy/threading.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/301c6a95_threading.json",
    "doc_id": "doc_202"
  }
}