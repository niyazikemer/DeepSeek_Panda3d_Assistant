{
  "content": "\"\"\"Contains various utility functions.\"\"\"\n\n__all__ = ['findClass', 'rebindClass', 'copyFuncs', 'replaceMessengerFunc', 'replaceTaskMgrFunc', 'replaceStateFunc', 'replaceCRFunc', 'replaceAIRFunc', 'replaceIvalFunc']\n\nimport types\nimport os\nimport sys\n\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.task.TaskManagerGlobal import taskMgr\n\n\ndef findClass(className):\n    \"\"\"\n    Look in sys.modules dictionary for a module that defines a class\n    with this className.\n    \"\"\"\n    for moduleName, module in sys.modules.items():\n        # Some modules are None for some reason\n        if module:\n            # print \"Searching in \", moduleName\n            classObj = module.__dict__.get(className)\n            # If this modules defines some object called classname and the\n            # object is a class or type definition and that class's module\n            # is the same as the module we are looking in, then we found\n            # the matching class and a good module namespace to redefine\n            # our class in.\n            if classObj and isinstance(classObj, type) and \\\n               classObj.__module__ == moduleName:\n                return [classObj, module.__dict__]\n    return None\n\n\ndef rebindClass(filename):\n    file = open(filename, 'r')\n    lines = file.readlines()\n    for line in lines:\n        if line[0:6] == 'class ':\n            # Chop off the \"class \" syntax and strip extra whitespace\n            classHeader = line[6:].strip()\n            # Look for a open paren if it does inherit\n            parenLoc = classHeader.find('(')\n            if parenLoc > 0:\n                className = classHeader[:parenLoc]\n            else:\n                # Look for a colon if it does not inherit\n                colonLoc = classHeader.find(':')\n                if colonLoc > 0:\n                    className = classHeader[:colonLoc]\n                else:\n                    print('error: className not found')\n                    # Remove that temp file\n                    file.close()\n                    os.remove(filename)\n                    return\n            print('Rebinding class name: ' + className)\n            break\n\n    # Try to find the original class with this class name\n    res = findClass(className)\n\n    if not res:\n        print('Warning: Finder could not find class')\n        # Remove the temp file we made\n        file.close()\n        os.remove(filename)\n        return\n\n    # Store the original real class\n    realClass, realNameSpace = res\n\n    # Now execute that class def in this namespace\n    exec(compile(open(filename).read(), filename, 'exec'), realNameSpace)\n\n    # That execfile should have created a new class obj in that namespace\n    tmpClass = realNameSpace[className]\n\n    # Copy the functions that we just redefined into the real class\n    copyFuncs(tmpClass, realClass)\n\n    # Now make sure the original class is in that namespace,\n    # not our temp one from the execfile. This will help us preserve\n    # class variables and other state on the original class.\n    realNameSpace[className] = realClass\n\n    # Remove the temp file we made\n    file.close()\n    os.remove(filename)\n\n    print('    Finished rebind')\n\n\ndef copyFuncs(fromClass, toClass):\n    replaceFuncList = []\n    newFuncList = []\n\n    # Copy the functions from fromClass into toClass dictionary\n    for funcName, newFunc in fromClass.__dict__.items():\n        # Filter out for functions\n        if isinstance(newFunc, types.FunctionType):\n            # See if we already have a function with this name\n            oldFunc = toClass.__dict__.get(funcName)\n            if oldFunc:\n                # This code is nifty, but with nested functions, give an error:\n                #   SystemError: cellobject.c:22: bad argument to internal function\n                # Give the new function code the same filename as the old function\n                # Perhaps there is a cleaner way to do this? This was my best idea.\n                #newCode = types.CodeType(newFunc.func_code.co_argcount,\n                #                         newFunc.func_code.co_nlocals,\n                #                         newFunc.func_code.co_stacksize,\n                #                         newFunc.func_code.co_flags,\n                #                         newFunc.func_code.co_code,\n                #                         newFunc.func_code.co_consts,\n                #                         newFunc.func_code.co_names,\n                #                         newFunc.func_code.co_varnames,\n                #                         # Use the oldFunc's filename here. Tricky!\n                #                         oldFunc.func_code.co_filename,\n                #                         newFunc.func_code.co_name,\n                #                         newFunc.func_code.co_firstlineno,\n                #                         newFunc.func_code.co_lnotab)\n                #newFunc = types.FunctionType(newCode,\n                #                             newFunc.func_globals,\n                #                             newFunc.func_name,\n                #                             newFunc.func_defaults,\n                #                             newFunc.func_closure)\n                replaceFuncList.append((oldFunc, funcName, newFunc))\n            else:\n                # TODO: give these new functions a proper code filename\n                newFuncList.append((funcName, newFunc))\n\n    # Look in the messenger, taskMgr, and other globals that store func\n    # pointers to see if this old function pointer is stored there, and\n    # update it to the new function pointer.\n    replaceMessengerFunc(replaceFuncList)\n    replaceTaskMgrFunc(replaceFuncList)\n    replaceStateFunc(replaceFuncList)\n    replaceCRFunc(replaceFuncList)\n    replaceAIRFunc(replaceFuncList)\n    replaceIvalFunc(replaceFuncList)\n\n    # Now that we've the globals funcs, actually swap the pointers in\n    # the new class to the new functions\n    for oldFunc, funcName, newFunc in replaceFuncList:\n        # print \"replacing old func: \", oldFunc, funcName, newFunc\n        setattr(toClass, funcName, newFunc)\n    # Add the brand new functions too\n    for funcName, newFunc in newFuncList:\n        # print \"adding new func: \", oldFunc, funcName, newFunc\n        setattr(toClass, funcName, newFunc)\n\n\ndef replaceMessengerFunc(replaceFuncList):\n    try:\n        messenger\n    except Exception:\n        return\n    for oldFunc, funcName, newFunc in replaceFuncList:\n        res = messenger.replaceMethod(oldFunc, newFunc)\n        if res:\n            print('replaced %s messenger function(s): %s' % (res, funcName))\n\n\ndef replaceTaskMgrFunc(replaceFuncList):\n    try:\n        taskMgr\n    except Exception:\n        return\n    for oldFunc, funcName, newFunc in replaceFuncList:\n        if taskMgr.replaceMethod(oldFunc, newFunc):\n            print('replaced taskMgr function: %s' % funcName)\n\n\ndef replaceStateFunc(replaceFuncList):\n    if not sys.modules.get('base.direct.fsm.State'):\n        return\n    from direct.fsm.State import State\n    for oldFunc, funcName, newFunc in replaceFuncList:\n        res = State.replaceMethod(oldFunc, newFunc)\n        if res:\n            print('replaced %s FSM transition function(s): %s' % (res, funcName))\n\n\ndef replaceCRFunc(replaceFuncList):\n    try:\n        base.cr\n    except Exception:\n        return\n    # masad: Gyedo's fake cr causes a crash in followingreplaceMethod on rebinding, so\n    # I throw in the isFake check. I still think the fake cr should be eliminated.\n    if hasattr(base.cr, 'isFake'):\n        return\n    for oldFunc, funcName, newFunc in replaceFuncList:\n        if base.cr.replaceMethod(oldFunc, newFunc):\n            print('replaced DistributedObject function: %s' % funcName)\n\n\ndef replaceAIRFunc(replaceFuncList):\n    try:\n        simbase.air\n    except Exception:\n        return\n    for oldFunc, funcName, newFunc in replaceFuncList:\n        if simbase.air.replaceMethod(oldFunc, newFunc):\n            print('replaced DistributedObject function: %s' % funcName)\n\n\ndef replaceIvalFunc(replaceFuncList):\n    # Make sure we have imported IntervalManager and thus created\n    # a global ivalMgr.\n    if not sys.modules.get('base.direct.interval.IntervalManager'):\n        return\n    from direct.interval.FunctionInterval import FunctionInterval\n    for oldFunc, funcName, newFunc in replaceFuncList:\n        res = FunctionInterval.replaceMethod(oldFunc, newFunc)\n        if res:\n            print('replaced %s interval function(s): %s' % (res, funcName))\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/Finder.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/faa5e57a_Finder.json",
    "doc_id": "doc_259"
  }
}