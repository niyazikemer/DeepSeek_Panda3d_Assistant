{
  "content": "Event Handlers\n\ncpp\n\nNote\n\nThis page has not yet been updated to cover the C++ event API.\n\nEvents occur either when the user does something (such as clicking a mouse <mouse-support> or pressing a key <keyboard-support>) or when sent by the script using messenger.send() <direct.showbase.Messenger.Messenger.send>. When an event occurs, Panda's \"messenger\" will check to see if you have written an \"event handler\" routine. If so, your event handler will be called. The messenger system is object-oriented, to create an event handler, you have to first create a class that inherits from DirectObject. Your event handler will be a method of your class.\n\nDefining a class that can Handle Events\n\nThe first step is to import the ~direct.showbase.DirectObject module:\n\nfrom direct.showbase import DirectObject\n\nWith DirectObject loaded, it is possible to create a subclass of DirectObject. This allows the class to inherit the messaging API and thus listen for events.\n\nclass myClassName(DirectObject.DirectObject):\n\nThe sample below creates a class that can listen for events. The \"accept\" function notifies panda that the printHello method is an event handler for the mouse1 event. The \"accept\" function and the various event names will be explained in detail later.\n\nclass Hello(DirectObject.DirectObject):\n    def __init__(self):\n        self.accept('mouse1', self.printHello)\n\n    def printHello(self):\n        print('Hello!')\n\nh = Hello()\n\nEvent Handling Functions\n\nEvents first go to a mechanism built into panda called the \"Messenger.\" The messenger may accept or ignore events that it receives. If it accepts an event, then an event handler will be called. If ignored, then no handler will be called.\n\nAn object may accept an event an infinite number of times or accept it only once. If checking for an accept within the object listening to it, it should be prefixed with self. If the accept command occurs outside the class, then the variable the class is associated with should be used.\n\nmyDirectObject.accept('Event Name', myDirectObjectMethod)\nmyDirectObject.acceptOnce('Event Name', myDirectObjectMethod)\n\nSpecific events may be ignored, so that no message is sent. Also, all events coming from an object may be ignored.\n\nmyDirectObject.ignore('Event Name')\nmyDirectObject.ignoreAll()\n\nFinally, there are some useful utility functions for debugging. The messenger typically does not print out when every event occurs. Toggling verbose mode will make the messenger print every event it receives. Toggling it again will revert it to the default. A number of methods exist for checking to see what object is checking for what event, but the print method will show who is accepting each event. Also, if accepts keep changing to the point where it is too confusing, the clear method will start the messenger over with a clear dictionary.\n\nmessenger.toggleVerbose()\nprint(messenger)\nmessenger.clear()\n\nSending Custom Events\n\nCustom events can be sent by the script using the code\n\nmessenger.send('Event Name')\n\nA list of parameters can optionally be sent to the event handler. Parameters defined in accept() are passed first, and then the parameters defined in send(). for example this would print out \"eggs sausage foo bar\":\n\nclass Test(DirectObject):\n    def __init__(self):\n        self.accept('spam', self.on_spam, ['eggs', 'sausage'])\n\n    def on_spam(self, a, b, c, d):\n        print(a, b, c, d)\n\ntest = Test()\nmessenger.send('spam', ['foo', 'bar'])\nbase.run()\n\nA Note on Object Management\n\nWhen a DirectObject accepts an event, the messenger retains a reference to that DirectObject. To ensure that objects that are no longer needed are properly disposed of, they must ignore any messages they are accepting.\n\nFor example, the following code may not do what you expect:\n\nimport direct.directbase.DirectStart\nfrom direct.showbase import DirectObject\nfrom panda3d.core import *\n\nclass Test(DirectObject.DirectObject):\n    def __init__(self):\n        self.accept(\"FireZeMissiles\", self._fireMissiles)\n\n    def _fireMissiles(self):\n        print(\"Missiles fired! Oh noes!\")\n\nfoo = Test() # create our test object\ndel foo      # get rid of our test object\n\nmessenger.send(\"FireZeMissiles\") # oops! Why did those missiles fire?\nbase.run()\n\nTry the example above, and you'll find that the missiles fire even though the object that would handle the event had been deleted.\n\nOne solution (patterned after other parts of the Panda3D architecture) is to define a \"destroy\" method for any custom classes you create, which calls \"ignoreAll\" to unregister from the event-handler system.\n\nimport direct.directbase.DirectStart\nfrom direct.showbase import DirectObject\nfrom panda3d.core import *\n\nclass Test(DirectObject.DirectObject):\n    def __init__(self):\n        self.accept(\"FireZeMissiles\", self._fireMissiles)\n\n    def _fireMissiles(self):\n        print(\"Missiles fired! Oh noes!\")\n\n    # function to get rid of me\n    def destroy(self):\n        self.ignoreAll()\n\nfoo = Test()  # create our test object\nfoo.destroy() # get rid of our test object\n\ndel foo\n\nmessenger.send(\"FireZeMissiles\") # No missiles fire\nbase.run()\n\nCoroutine Event Handlers\n\nIt is permissible for any event handler to be a coroutine (i.e. marked as an async def), which permits use of the await keyword inside the handler. Usage is otherwise identical to a regular event handler.\n\nclass Test(DirectObject):\n    def __init__(self):\n        self.accept('space', self.on_space)\n\n    async def on_space(self):\n        await Task.pause(1.0)\n        print(\"The space key was pressed one second ago!\")",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/149a857c_event-handlers.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/26c3d669_149a857c_event-handlers.json",
    "doc_id": "doc_410"
  }
}