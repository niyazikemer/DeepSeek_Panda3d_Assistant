{
  "content": "\"\"\"DistributedSmoothNode module: contains the DistributedSmoothNode class\"\"\"\n\nimport math\nfrom panda3d.core import ClockObject, ConfigVariableBool, ConfigVariableDouble, NodePath\nfrom panda3d.direct import SmoothMover\nfrom .ClockDelta import globalClockDelta\nfrom . import DistributedNode\nfrom . import DistributedSmoothNodeBase\nfrom direct.task.Task import cont\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.showbase.PythonUtil import report\n\n# This number defines our tolerance for out-of-sync telemetry packets.\n# If a packet appears to have originated from more than MaxFuture\n# seconds in the future, assume we're out of sync with the other\n# avatar and suggest a resync for both.\nMaxFuture = ConfigVariableDouble(\"smooth-max-future\", 0.2)\n\n# How frequently can we suggest a resynchronize with another client?\nMinSuggestResync = ConfigVariableDouble(\"smooth-min-suggest-resync\", 15)\n\n# These flags indicate whether global smoothing and/or prediction is\n# allowed or disallowed.\nEnableSmoothing = ConfigVariableBool(\"smooth-enable-smoothing\", True)\nEnablePrediction = ConfigVariableBool(\"smooth-enable-prediction\", True)\n\n# These values represent the amount of time, in seconds, to delay the\n# apparent position of other avatars, when non-predictive and\n# predictive smoothing is in effect, respectively.  This is in\n# addition to the automatic delay of the observed average latency from\n# each avatar, which is intended to compensate for relative clock\n# skew.\nLag = ConfigVariableDouble(\"smooth-lag\", 0.2)\nPredictionLag = ConfigVariableDouble(\"smooth-prediction-lag\", 0.0)\n\n\nGlobalSmoothing = 0\nGlobalPrediction = 0\n\n\ndef globalActivateSmoothing(smoothing, prediction):\n    \"\"\" Globally activates or deactivates smoothing and prediction on\n    all DistributedSmoothNodes currently in existence, or yet to be\n    generated. \"\"\"\n\n    global GlobalSmoothing, GlobalPrediction\n    GlobalSmoothing = smoothing\n    GlobalPrediction = prediction\n\n    for obj in base.cr.getAllOfType(DistributedSmoothNode):\n        obj.activateSmoothing(smoothing, prediction)\n\n\n# For historical reasons, we temporarily define\n# DistributedSmoothNode.activateSmoothing() to be the global function.\n# We'll remove this soon, so it won't get confused with the instance\n# method, below.\nactivateSmoothing = globalActivateSmoothing\n\n\nclass DistributedSmoothNode(DistributedNode.DistributedNode,\n                            DistributedSmoothNodeBase.DistributedSmoothNodeBase):\n    \"\"\"\n    This specializes DistributedNode to add functionality to smooth\n    motion over time, via the SmoothMover C++ object defined in\n    DIRECT.\n    \"\"\"\n\n    def __init__(self, cr):\n        if not hasattr(self, 'DistributedSmoothNode_initialized'):\n            self.DistributedSmoothNode_initialized = 1\n            DistributedNode.DistributedNode.__init__(self, cr)\n            DistributedSmoothNodeBase.DistributedSmoothNodeBase.__init__(self)\n            self.smoothStarted = 0\n\n            # Set this True to assert that the local process has\n            # complete authority over the position of this object when\n            # smoothing is not in effect.  When this is True, position\n            # reports received over the wire will not be applied to\n            # this node's position, unless those position reports are\n            # received between startSmooth() and endSmooth().\n            self.localControl = False\n\n            # flag set when we receive a stop message\n            self.stopped = False\n\n    def generate(self):\n        self.smoother = SmoothMover()\n        self.smoothStarted = 0\n        self.lastSuggestResync = 0\n        self._smoothWrtReparents = False\n\n        DistributedNode.DistributedNode.generate(self)\n        DistributedSmoothNodeBase.DistributedSmoothNodeBase.generate(self)\n        self.cnode.setRepository(self.cr, 0, 0)\n\n        self.activateSmoothing(GlobalSmoothing, GlobalPrediction)\n\n        # clear stopped flag for re-generate\n        self.stopped = False\n\n    def disable(self):\n        DistributedSmoothNodeBase.DistributedSmoothNodeBase.disable(self)\n        DistributedNode.DistributedNode.disable(self)\n        del self.smoother\n\n    def delete(self):\n        DistributedSmoothNodeBase.DistributedSmoothNodeBase.delete(self)\n        DistributedNode.DistributedNode.delete(self)\n\n    ### Methods to handle computing and updating of the smoothed\n    ### position.\n\n    def smoothPosition(self):\n        \"\"\"\n        This function updates the position of the node to its computed\n        smoothed position.  This may be overridden by a derived class\n        to specialize the behavior.\n        \"\"\"\n        self.smoother.computeAndApplySmoothPosHpr(self, self)\n\n    def doSmoothTask(self, task):\n        self.smoothPosition()\n        return cont\n\n    def wantsSmoothing(self):\n        # Override this function to return 0 if this particular kind\n        # of smooth node doesn't really want to be smoothed.\n        return 1\n\n    def startSmooth(self):\n        \"\"\"\n        This function starts the task that ensures the node is\n        positioned correctly every frame.  However, while the task is\n        running, you won't be able to lerp the node or directly\n        position it.\n        \"\"\"\n        if not self.wantsSmoothing() or self.isDisabled() or self.isLocal():\n            return\n        if not self.smoothStarted:\n            taskName = self.taskName(\"smooth\")\n            taskMgr.remove(taskName)\n            self.reloadPosition()\n            taskMgr.add(self.doSmoothTask, taskName)\n            self.smoothStarted = 1\n\n    def stopSmooth(self):\n        \"\"\"\n        This function stops the task spawned by startSmooth(), and\n        allows show code to move the node around directly.\n        \"\"\"\n        if self.smoothStarted:\n            taskName = self.taskName(\"smooth\")\n            taskMgr.remove(taskName)\n            self.forceToTruePosition()\n            self.smoothStarted = 0\n\n    def setSmoothWrtReparents(self, flag):\n        self._smoothWrtReparents = flag\n\n    def getSmoothWrtReparents(self):\n        return self._smoothWrtReparents\n\n    def forceToTruePosition(self):\n        \"\"\"\n        This forces the node to reposition itself to its latest known\n        position.  This may result in a pop as the node skips the last\n        of its lerp points.\n        \"\"\"\n        #printStack()\n        if (not self.isLocal()) and \\\n           self.smoother.getLatestPosition():\n            self.smoother.applySmoothPosHpr(self, self)\n        self.smoother.clearPositions(1)\n\n    def reloadPosition(self):\n        \"\"\"\n        This function re-reads the position from the node itself and\n        clears any old position reports for the node.  This should be\n        used whenever show code bangs on the node position and expects\n        it to stick.\n        \"\"\"\n        self.smoother.clearPositions(0)\n        self.smoother.setPosHpr(self.getPos(), self.getHpr())\n        self.smoother.setPhonyTimestamp()\n        self.smoother.markPosition()\n\n    def _checkResume(self, timestamp):\n        \"\"\"\n        Determine if we were previously stopped and now need to\n        resume movement by making sure any old stored positions\n        reflect the node's current position\n        \"\"\"\n        if self.stopped:\n            currTime = ClockObject.getGlobalClock().getFrameTime()\n            now = currTime - self.smoother.getExpectedBroadcastPeriod()\n            last = self.smoother.getMostRecentTimestamp()\n            if now > last:\n                # only set a new timestamp postion if we still have\n                # a position being smoothed to (so we don't interrupt\n                # any current smoothing and only do this if the object\n                # is actually locally stopped)\n                if timestamp is None:\n                    # no timestamp, use current time\n                    local = 0.0\n                else:\n                    local = globalClockDelta.networkToLocalTime(\n                        timestamp, currTime)\n\n                self.smoother.setPhonyTimestamp(local,True)\n                self.smoother.markPosition()\n\n        self.stopped = False\n\n    # distributed set pos and hpr functions\n    # 'send' versions are inherited from DistributedSmoothNodeBase\n    def setSmStop(self, timestamp=None):\n        self.setComponentTLive(timestamp)\n        self.stopped = True\n\n    def setSmH(self, h, timestamp=None):\n        self._checkResume(timestamp)\n        self.setComponentH(h)\n        self.setComponentTLive(timestamp)\n\n    def setSmZ(self, z, timestamp=None):\n        self._checkResume(timestamp)\n        self.setComponentZ(z)\n        self.setComponentTLive(timestamp)\n\n    def setSmXY(self, x, y, timestamp=None):\n        self._checkResume(timestamp)\n        self.setComponentX(x)\n        self.setComponentY(y)\n        self.setComponentTLive(timestamp)\n\n    def setSmXZ(self, x, z, timestamp=None):\n        self._checkResume(timestamp)\n        self.setComponentX(x)\n        self.setComponentZ(z)\n        self.setComponentTLive(timestamp)\n\n    def setSmPos(self, x, y, z, timestamp=None):\n        self._checkResume(timestamp)\n        self.setComponentX(x)\n        self.setComponentY(y)\n        self.setComponentZ(z)\n        self.setComponentTLive(timestamp)\n\n    def setSmHpr(self, h, p, r, timestamp=None):\n        self._checkResume(timestamp)\n        self.setComponentH(h)\n        self.setComponentP(p)\n        self.setComponentR(r)\n        self.setComponentTLive(timestamp)\n\n    def setSmXYH(self, x, y, h, timestamp):\n        self._checkResume(timestamp)\n        self.setComponentX(x)\n        self.setComponentY(y)\n        self.setComponentH(h)\n        self.setComponentTLive(timestamp)\n\n    def setSmXYZH(self, x, y, z, h, timestamp=None):\n        self._checkResume(timestamp)\n        self.setComponentX(x)\n        self.setComponentY(y)\n        self.setComponentZ(z)\n        self.setComponentH(h)\n        self.setComponentTLive(timestamp)\n\n    def setSmPosHpr(self, x, y, z, h, p, r, timestamp=None):\n        self._checkResume(timestamp)\n        self.setComponentX(x)\n        self.setComponentY(y)\n        self.setComponentZ(z)\n        self.setComponentH(h)\n        self.setComponentP(p)\n        self.setComponentR(r)\n        self.setComponentTLive(timestamp)\n\n    def setSmPosHprL(self, l, x, y, z, h, p, r, timestamp=None):\n        self._checkResume(timestamp)\n        self.setComponentL(l)\n        self.setComponentX(x)\n        self.setComponentY(y)\n        self.setComponentZ(z)\n        self.setComponentH(h)\n        self.setComponentP(p)\n        self.setComponentR(r)\n        self.setComponentTLive(timestamp)\n\n    ### component set pos and hpr functions ###\n\n    ### These are the component functions that are invoked\n    ### remotely by the above composite functions.\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def setComponentX(self, x):\n        self.smoother.setX(x)\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def setComponentY(self, y):\n        self.smoother.setY(y)\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def setComponentZ(self, z):\n        self.smoother.setZ(z)\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def setComponentH(self, h):\n        self.smoother.setH(h)\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def setComponentP(self, p):\n        self.smoother.setP(p)\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def setComponentR(self, r):\n        self.smoother.setR(r)\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def setComponentL(self, l):\n        if l != self.zoneId:\n            # only perform set location if location is different\n            self.setLocation(self.parentId,l)\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def setComponentT(self, timestamp):\n        # This is a little bit hacky.  If *this* function is called,\n        # it must have been called directly by the server, for\n        # instance to update the values previously set for some avatar\n        # that was already into the zone as we entered.  (A live\n        # update would have gone through the function called\n        # setComponentTLive, below.)\n\n        # Since we know this update came through the server, it may\n        # reflect very old data.  Thus, we can't accurately decode the\n        # network timestamp (since the network time encoding can only\n        # represent a time up to about 5 minutes in the past), but we\n        # don't really need to know the timestamp anyway.  We'll just\n        # arbitrarily place it at right now.\n        self.smoother.setPhonyTimestamp()\n        self.smoother.clearPositions(1)\n        self.smoother.markPosition()\n\n        # mark position only takes most recent position sent over the wire\n        # and applies it to the smoother's sample points, but we still\n        # need to make sure and apply that position to the actual node\n        # path\n        self.forceToTruePosition()\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def setComponentTLive(self, timestamp):\n        # This is the variant of setComponentT() that will be called\n        # whenever we receive a live update directly from the other\n        # client.  This is because the component functions, above,\n        # call this function explicitly instead of setComponentT().\n\n        #print 'setComponentTLive: %s' % timestamp\n\n        if timestamp is None:\n            # if no timestamp, re-use the most recent timestamp to keep things\n            # from getting out of order\n            if self.smoother.hasMostRecentTimestamp():\n                self.smoother.setTimestamp(self.smoother.getMostRecentTimestamp())\n            else:\n                # no most-recent timestamp, use current time\n                self.smoother.setPhonyTimestamp()\n            self.smoother.markPosition()\n        else:\n            globalClock = ClockObject.getGlobalClock()\n            now = globalClock.getFrameTime()\n            local = globalClockDelta.networkToLocalTime(timestamp, now)\n            realTime = globalClock.getRealTime()\n            chug = realTime - now\n\n            # Sanity check the timestamp from the other avatar.  It should\n            # be just slightly in the past, but it might be off by as much\n            # as this frame's amount of time forward or back.\n            howFarFuture = local - now\n            if howFarFuture - chug >= MaxFuture.value:\n                # Too far off; advise the other client of our clock information.\n                if globalClockDelta.getUncertainty() is not None and \\\n                   realTime - self.lastSuggestResync >= MinSuggestResync.value and \\\n                   hasattr(self.cr, 'localAvatarDoId'):\n                    self.lastSuggestResync = realTime\n                    timestampB = globalClockDelta.localToNetworkTime(realTime)\n                    serverTime = realTime - globalClockDelta.getDelta()\n                    assert self.notify.info(\n                        \"Suggesting resync for %s, with discrepency %s; local time is %s and server time is %s.\" % (\n                        self.doId, howFarFuture - chug,\n                        realTime, serverTime))\n                    self.d_suggestResync(\n                        self.cr.localAvatarDoId, timestamp,\n                        timestampB, serverTime,\n                        globalClockDelta.getUncertainty())\n\n            self.smoother.setTimestamp(local)\n            self.smoother.markPosition()\n\n        if not self.localControl and not self.smoothStarted and \\\n           self.smoother.getLatestPosition():\n            self.smoother.applySmoothPosHpr(self, self)\n\n    # These are all required by the CMU server, which requires get* to\n    # match set* in more cases than the Disney server does.\n    def getComponentL(self):\n        return self.zoneId\n\n    def getComponentX(self):\n        return self.getX()\n\n    def getComponentY(self):\n        return self.getY()\n\n    def getComponentZ(self):\n        return self.getZ()\n\n    def getComponentH(self):\n        return self.getH()\n\n    def getComponentP(self):\n        return self.getP()\n\n    def getComponentR(self):\n        return self.getR()\n\n    def getComponentT(self):\n        return 0\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def clearSmoothing(self, bogus = None):\n        # Call this to invalidate all the old position reports\n        # (e.g. just before popping to a new position).\n        #printStack()\n        self.smoother.clearPositions(1)\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def wrtReparentTo(self, parent):\n        # We override this NodePath method to force it to\n        # automatically reset the smoothing position when we call it.\n        if self.smoothStarted:\n            if self._smoothWrtReparents:\n                #print self.getParent(), parent, self.getParent().getPos(parent)\n                self.smoother.handleWrtReparent(self.getParent(), parent)\n                NodePath.wrtReparentTo(self, parent)\n            else:\n                self.forceToTruePosition()\n                NodePath.wrtReparentTo(self, parent)\n                self.reloadPosition()\n        else:\n            NodePath.wrtReparentTo(self, parent)\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def d_setParent(self, parentToken):\n        # We override this DistributedNode method to force a full position\n        # update immediately after the distributed setParent is sent.\n        # See ParentMgr.py for an explanation.\n        DistributedNode.DistributedNode.d_setParent(self, parentToken)\n\n        self.forceToTruePosition()\n        self.sendCurrentPosition()\n\n    ### Monitor clock sync ###\n\n    def d_suggestResync(self, avId, timestampA, timestampB,\n                        serverTime, uncertainty):\n        serverTimeSec = math.floor(serverTime)\n        serverTimeUSec = (serverTime - serverTimeSec) * 10000.0\n        self.sendUpdate(\"suggestResync\", [avId, timestampA, timestampB,\n                                          serverTimeSec, serverTimeUSec,\n                                          uncertainty])\n\n    def suggestResync(self, avId, timestampA, timestampB,\n                      serverTimeSec, serverTimeUSec, uncertainty):\n        \"\"\"\n        This message is sent from one client to another when the other\n        client receives a timestamp from this client that is so far\n        out of date as to suggest that one or both clients needs to\n        resynchronize their clock information.\n        \"\"\"\n        serverTime = float(serverTimeSec) + float(serverTimeUSec) / 10000.0\n        result = self.peerToPeerResync(\n            avId, timestampA, serverTime, uncertainty)\n        if result >= 0 and \\\n           globalClockDelta.getUncertainty() is not None:\n            other = self.cr.doId2do.get(avId)\n            if not other:\n                assert self.notify.info(\n                    \"Warning: couldn't find the avatar %d\" % (avId))\n            elif hasattr(other, \"d_returnResync\") and \\\n                 hasattr(self.cr, 'localAvatarDoId'):\n                globalClock = ClockObject.getGlobalClock()\n                realTime = globalClock.getRealTime()\n                serverTime = realTime - globalClockDelta.getDelta()\n                assert self.notify.info(\n                    \"Returning resync for %s; local time is %s and server time is %s.\" % (\n                    self.doId, realTime, serverTime))\n                other.d_returnResync(\n                    self.cr.localAvatarDoId, timestampB,\n                    serverTime,\n                    globalClockDelta.getUncertainty())\n\n    def d_returnResync(self, avId, timestampB, serverTime, uncertainty):\n        serverTimeSec = math.floor(serverTime)\n        serverTimeUSec = (serverTime - serverTimeSec) * 10000.0\n        self.sendUpdate(\"returnResync\", [\n            avId, timestampB, serverTimeSec, serverTimeUSec, uncertainty])\n\n    def returnResync(self, avId, timestampB, serverTimeSec, serverTimeUSec,\n                     uncertainty):\n        \"\"\"\n        A reply sent by a client whom we recently sent suggestResync\n        to, this reports the client's new delta information so we can\n        adjust our clock as well.\n        \"\"\"\n        serverTime = float(serverTimeSec) + float(serverTimeUSec) / 10000.0\n        self.peerToPeerResync(avId, timestampB, serverTime, uncertainty)\n\n    def peerToPeerResync(self, avId, timestamp, serverTime, uncertainty):\n        gotSync = globalClockDelta.peerToPeerResync(\n            avId, timestamp, serverTime, uncertainty)\n\n        # If we didn't get anything useful from the other client,\n        # maybe our clock is just completely hosed.  Go ask the AI.\n        if not gotSync:\n            if self.cr.timeManager is not None:\n                self.cr.timeManager.synchronize(\"suggested by %d\" % (avId))\n\n        return gotSync\n\n    def activateSmoothing(self, smoothing, prediction):\n        \"\"\"\n        Enables or disables the smoothing of other avatars' motion.\n        This used to be a global flag, but now it is specific to each\n        avatar instance.  However, see globalActivateSmoothing() in\n        this module.\n\n        If smoothing is off, no kind of smoothing will be performed,\n        regardless of the setting of prediction.\n\n        This is not necessarily predictive smoothing; if predictive\n        smoothing is off, avatars will be lagged by a certain factor\n        to achieve smooth motion.  Otherwise, if predictive smoothing\n        is on, avatars will be drawn as nearly as possible in their\n        current position, by extrapolating from old position reports.\n\n        This assumes you have a client repository that knows its\n        localAvatarDoId -- stored in self.cr.localAvatarDoId\n        \"\"\"\n        if smoothing and EnableSmoothing:\n            if prediction and EnablePrediction:\n                # Prediction and smoothing.\n                self.smoother.setSmoothMode(SmoothMover.SMOn)\n                self.smoother.setPredictionMode(SmoothMover.PMOn)\n                self.smoother.setDelay(PredictionLag.value)\n            else:\n                # Smoothing, but no prediction.\n                self.smoother.setSmoothMode(SmoothMover.SMOn)\n                self.smoother.setPredictionMode(SmoothMover.PMOff)\n                self.smoother.setDelay(Lag.value)\n        else:\n            # No smoothing, no prediction.\n            self.smoother.setSmoothMode(SmoothMover.SMOff)\n            self.smoother.setPredictionMode(SmoothMover.PMOff)\n            self.smoother.setDelay(0.0)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/DistributedSmoothNode.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/3cb775cb_DistributedSmoothNode.json",
    "doc_id": "doc_305"
  }
}