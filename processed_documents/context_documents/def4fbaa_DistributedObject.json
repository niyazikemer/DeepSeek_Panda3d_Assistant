{
  "content": "\"\"\"DistributedObject module: contains the DistributedObject class\"\"\"\n\nfrom panda3d.direct import DCPacker\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.distributed.DistributedObjectBase import DistributedObjectBase\n#from PyDatagram import PyDatagram\n#from PyDatagramIterator import PyDatagramIterator\n\n# Values for DistributedObject.activeState\n\nESNew          = 1\nESDeleted      = 2\nESDisabling    = 3\nESDisabled     = 4  # values here and lower are considered \"disabled\"\nESGenerating   = 5  # values here and greater are considered \"generated\"\nESGenerated    = 6\n\n# update this table if the values above change\nESNum2Str = {\n    ESNew: 'ESNew',\n    ESDeleted: 'ESDeleted',\n    ESDisabling: 'ESDisabling',\n    ESDisabled: 'ESDisabled',\n    ESGenerating: 'ESGenerating',\n    ESGenerated: 'ESGenerated',\n}\n\n\nclass DistributedObject(DistributedObjectBase):\n    \"\"\"\n    The Distributed Object class is the base class for all network based\n    (i.e. distributed) objects.  These will usually (always?) have a\n    dclass entry in a \\\\*.dc file.\n    \"\"\"\n    notify = directNotify.newCategory(\"DistributedObject\")\n\n    # A few objects will set neverDisable to 1... Examples are\n    # localToon, and anything that lives in the UberZone. This\n    # keeps them from being disabled when you change zones,\n    # even to the quiet zone.\n    neverDisable = 0\n\n    def __init__(self, cr):\n        assert self.notify.debugStateCall(self)\n        if not hasattr(self, 'DistributedObject_initialized'):\n            self.DistributedObject_initialized = 1\n            DistributedObjectBase.__init__(self, cr)\n\n            # Most DistributedObjects are simple and require no real\n            # effort to load.  Some, particularly actors, may take\n            # some significant time to load; these we can optimize by\n            # caching them when they go away instead of necessarily\n            # deleting them.  The object should set cacheable to 1 if\n            # it needs to be optimized in this way.\n            self.setCacheable(0)\n\n            # this is for Toontown only, see toontown.distributed.DelayDeletable\n            self._token2delayDeleteName = {}\n            self._delayDeleteForceAllow = False\n            self._delayDeleted = 0\n\n            # Keep track of our state as a distributed object.  This\n            # is only trustworthy if the inheriting class properly\n            # calls up the chain for disable() and generate().\n            self.activeState = ESNew\n\n            # These are used by getCallbackContext() and doCallbackContext().\n            self.__nextContext = 0\n            self.__callbacks = {}\n\n            # This is used by doneBarrier().\n            self.__barrierContext = None\n\n    if __debug__:\n        def status(self, indent=0):\n            \"\"\"\n            print out \"doId(parentId, zoneId) className\n                and conditionally show generated, disabled, neverDisable,\n                or cachable\"\n            \"\"\"\n            spaces = ' ' * (indent + 2)\n            try:\n                print(\"%s%s:\" % (' ' * indent, self.__class__.__name__))\n\n                flags = []\n                if self.activeState == ESGenerated:\n                    flags.append(\"generated\")\n                if self.activeState < ESGenerating:\n                    flags.append(\"disabled\")\n                if self.neverDisable:\n                    flags.append(\"neverDisable\")\n                if self.cacheable:\n                    flags.append(\"cacheable\")\n\n                flagStr = \"\"\n                if len(flags) > 0:\n                    flagStr = \" (%s)\" % (\" \".join(flags))\n\n                print(\"%sfrom DistributedObject doId:%s, parent:%s, zone:%s%s\" % (\n                    spaces, self.doId, self.parentId, self.zoneId, flagStr))\n            except Exception as e:\n                print(\"%serror printing status %s\" % (spaces, e))\n\n    def getAutoInterests(self):\n        # returns the sub-zones under this object that are automatically\n        # opened for us by the server.\n        # have we already cached it?\n        def _getAutoInterests(cls):\n            # returns set of auto-interests for this class and all derived\n            # have we already computed this class's autoInterests?\n            if 'autoInterests' in cls.__dict__:\n                autoInterests = cls.autoInterests\n            else:\n                autoInterests = set()\n                # grab autoInterests from base classes\n                for base in cls.__bases__:\n                    autoInterests.update(_getAutoInterests(base))\n                # grab autoInterests from this class\n                if cls.__name__ in self.cr.dclassesByName:\n                    dclass = self.cr.dclassesByName[cls.__name__]\n                    field = dclass.getFieldByName('AutoInterest')\n                    if field is not None:\n                        p = DCPacker()\n                        p.setUnpackData(field.getDefaultValue())\n                        length = p.rawUnpackUint16() // 4\n                        for i in range(length):\n                            zone = int(p.rawUnpackUint32())\n                            autoInterests.add(zone)\n                    autoInterests.update(autoInterests)\n                    cls.autoInterests = autoInterests\n            return set(autoInterests)\n        autoInterests = _getAutoInterests(self.__class__)\n        # if the server starts supporting multiple auto-interest per class, this check\n        # should be removed\n        if len(autoInterests) > 1:\n            self.notify.error(\n                'only one auto-interest allowed per DC class, %s has %s autoInterests (%s)' %\n                (self.dclass.getName(), len(autoInterests), list(autoInterests)))\n        _getAutoInterests = None\n        return list(autoInterests)\n\n    def setNeverDisable(self, boolean):\n        assert boolean == 1 or boolean == 0\n        self.neverDisable = boolean\n\n    def getNeverDisable(self):\n        return self.neverDisable\n\n    def _retrieveCachedData(self):\n        # once we know our doId, grab any data that might be stored in the data cache\n        # from the last time we were on the client\n        if self.cr.doDataCache.hasCachedData(self.doId):\n            self._cachedData = self.cr.doDataCache.popCachedData(self.doId)\n\n    def setCachedData(self, name, data):\n        assert isinstance(name, str)\n        # ownership of the data passes to the repository data cache\n        self.cr.doDataCache.setCachedData(self.doId, name, data)\n\n    def hasCachedData(self, name):\n        assert isinstance(name, str)\n        if not hasattr(self, '_cachedData'):\n            return False\n        return name in self._cachedData\n\n    def getCachedData(self, name):\n        assert isinstance(name, str)\n        # ownership of the data passes to the caller of this method\n        data = self._cachedData[name]\n        del self._cachedData[name]\n        return data\n\n    def flushCachedData(self, name):\n        assert isinstance(name, str)\n        # call this to throw out cached data from a previous instantiation\n        self._cachedData[name].flush()\n\n    def setCacheable(self, boolean):\n        assert boolean == 1 or boolean == 0\n        self.cacheable = boolean\n\n    def getCacheable(self):\n        return self.cacheable\n\n    def deleteOrDelay(self):\n        if len(self._token2delayDeleteName) > 0:\n            if not self._delayDeleted:\n                self._delayDeleted = 1\n                # Object is delayDeleted. Clean up DistributedObject state,\n                # remove from repository tables, so that we won't crash if\n                # another instance of the same object gets generated while\n                # this instance is still delayDeleted.\n                messenger.send(self.getDelayDeleteEvent())\n                if len(self._token2delayDeleteName) > 0:\n                    self.delayDelete()\n                    if len(self._token2delayDeleteName) > 0:\n                        self._deactivateDO()\n        else:\n            self.disableAnnounceAndDelete()\n\n    def disableAnnounceAndDelete(self):\n        self.disableAndAnnounce()\n        self.delete()\n        self._destroyDO()\n\n    def getDelayDeleteCount(self):\n        return len(self._token2delayDeleteName)\n\n    def getDelayDeleteEvent(self):\n        return self.uniqueName(\"delayDelete\")\n\n    def getDisableEvent(self):\n        return self.uniqueName(\"disable\")\n\n    def disableAndAnnounce(self):\n        \"\"\"\n        Inheritors should *not* redefine this function.\n        \"\"\"\n        # We must send the disable announce message *before* we\n        # actually disable the object.  That way, the various cleanup\n        # tasks can run first and take care of restoring the object to\n        # a normal, nondisabled state; and *then* the disable function\n        # can properly disable it (for instance, by parenting it to\n        # hidden).\n        if self.activeState != ESDisabled:\n            self.activeState = ESDisabling\n            messenger.send(self.getDisableEvent())\n            self.disable()\n            self.activeState = ESDisabled\n            if not self._delayDeleted:\n                # if the object is DelayDeleted, _deactivateDO has\n                # already been called\n                self._deactivateDO()\n\n    def announceGenerate(self):\n        \"\"\"\n        Sends a message to the world after the object has been\n        generated and all of its required fields filled in.\n        \"\"\"\n        assert self.notify.debug('announceGenerate(): %s' % (self.doId))\n\n    def _deactivateDO(self):\n        # after this is called, the object is no longer an active DistributedObject\n        # and it may be placed in the cache\n        if not self.cr:\n            # we are going to crash, output the destroyDo stacktrace\n            self.notify.warning('self.cr is none in _deactivateDO %d' % self.doId)\n            if hasattr(self, 'destroyDoStackTrace'):\n                print(self.destroyDoStackTrace)\n        self.__callbacks = {}\n        self.cr.closeAutoInterests(self)\n        self.setLocation(0,0)\n        self.cr.deleteObjectLocation(self, self.parentId, self.zoneId)\n\n    def _destroyDO(self):\n        # after this is called, the object is no longer a DistributedObject\n        # but may still be used as a DelayDeleted object\n        if __debug__:\n            # StackTrace is omitted in packed versions\n            from direct.showbase.PythonUtil import StackTrace\n            self.destroyDoStackTrace = StackTrace()\n        # check for leftover cached data that was not retrieved or flushed by this object\n        # this will catch typos in the data name in calls to get/setCachedData\n        if hasattr(self, '_cachedData'):\n            for name, cachedData in self._cachedData.items():\n                self.notify.warning('flushing unretrieved cached data: %s' % name)\n                cachedData.flush()\n            del self._cachedData\n        self.cr = None\n        self.dclass = None\n\n    def disable(self):\n        \"\"\"\n        Inheritors should redefine this to take appropriate action on disable\n        \"\"\"\n        assert self.notify.debug('disable(): %s' % (self.doId))\n\n    def isDisabled(self):\n        \"\"\"\n        Returns true if the object has been disabled and/or deleted,\n        or if it is brand new and hasn't yet been generated.\n        \"\"\"\n        return self.activeState < ESGenerating\n\n    def isGenerated(self):\n        \"\"\"\n        Returns true if the object has been fully generated by now,\n        and not yet disabled.\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        return self.activeState == ESGenerated\n\n    def delete(self):\n        \"\"\"\n        Inheritors should redefine this to take appropriate action on delete\n        \"\"\"\n        assert self.notify.debug('delete(): %s' % (self.doId))\n        self.DistributedObject_deleted = 1\n\n    def generate(self):\n        \"\"\"\n        Inheritors should redefine this to take appropriate action on generate\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        self.activeState = ESGenerating\n        # this has already been set at this point\n        #self.cr.storeObjectLocation(self, self.parentId, self.zoneId)\n        # semi-hack: we seem to be calling generate() more than once for objects that multiply-inherit\n        if not hasattr(self, '_autoInterestHandle'):\n            self.cr.openAutoInterests(self)\n\n    def generateInit(self):\n        \"\"\"\n        This method is called when the DistributedObject is first introduced\n        to the world... Not when it is pulled from the cache.\n        \"\"\"\n        self.activeState = ESGenerating\n\n    def getDoId(self):\n        \"\"\"\n        Return the distributed object id\n        \"\"\"\n        return self.doId\n\n    #This message was moved out of announce generate\n    #to avoid ordering issues.\n\n    def postGenerateMessage(self):\n        if self.activeState != ESGenerated:\n            self.activeState = ESGenerated\n            messenger.send(self.uniqueName(\"generate\"), [self])\n\n    def updateRequiredFields(self, dclass, di):\n        dclass.receiveUpdateBroadcastRequired(self, di)\n        self.announceGenerate()\n        self.postGenerateMessage()\n\n    def updateAllRequiredFields(self, dclass, di):\n        dclass.receiveUpdateAllRequired(self, di)\n        self.announceGenerate()\n        self.postGenerateMessage()\n\n    def updateRequiredOtherFields(self, dclass, di):\n        # First, update the required fields\n        dclass.receiveUpdateBroadcastRequired(self, di)\n\n        # Announce generate after updating all the required fields,\n        # but before we update the non-required fields.\n        self.announceGenerate()\n        self.postGenerateMessage()\n\n        dclass.receiveUpdateOther(self, di)\n\n    def sendUpdate(self, fieldName, args = [], sendToId = None):\n        if self.cr:\n            dg = self.dclass.clientFormatUpdate(\n                fieldName, sendToId or self.doId, args)\n            self.cr.send(dg)\n        else:\n            assert self.notify.error(\"sendUpdate failed, because self.cr is not set\")\n\n    def sendDisableMsg(self):\n        self.cr.sendDisableMsg(self.doId)\n\n    def sendDeleteMsg(self):\n        self.cr.sendDeleteMsg(self.doId)\n\n    def taskName(self, taskString):\n        return \"%s-%s\" % (taskString, self.doId)\n\n    def uniqueName(self, idString):\n        return \"%s-%s\" % (idString, self.doId)\n\n    def getCallbackContext(self, callback, extraArgs = []):\n        # Some objects implement a back-and-forth handshake operation\n        # with the AI via an arbitrary context number.  This method\n        # (coupled with doCallbackContext(), below) maps a Python\n        # callback onto that context number so that client code may\n        # easily call the method and wait for a callback, rather than\n        # having to negotiate context numbers.\n\n        # This method generates a new context number and stores the\n        # callback so that it may later be called when the response is\n        # returned.\n\n        # This is intended to be called within derivations of\n        # DistributedObject, not directly by other objects.\n\n        context = self.__nextContext\n        self.__callbacks[context] = (callback, extraArgs)\n        # We assume the context number is passed as a uint16.\n        self.__nextContext = (self.__nextContext + 1) & 0xffff\n\n        return context\n\n    def getCurrentContexts(self):\n        # Returns a list of the currently outstanding contexts created\n        # by getCallbackContext().\n        return list(self.__callbacks.keys())\n\n    def getCallback(self, context):\n        # Returns the callback that was passed in to the previous\n        # call to getCallbackContext.\n        return self.__callbacks[context][0]\n\n    def getCallbackArgs(self, context):\n        # Returns the extraArgs that were passed in to the previous\n        # call to getCallbackContext.\n        return self.__callbacks[context][1]\n\n    def doCallbackContext(self, context, args):\n        # This is called after the AI has responded to the message\n        # sent via getCallbackContext(), above.  The context number is\n        # looked up in the table and the associated callback is\n        # issued.\n\n        # This is intended to be called within derivations of\n        # DistributedObject, not directly by other objects.\n\n        tuple = self.__callbacks.get(context)\n        if tuple:\n            callback, extraArgs = tuple\n            completeArgs = args + extraArgs\n            if callback is not None:\n                callback(*completeArgs)\n            del self.__callbacks[context]\n        else:\n            self.notify.warning(\"Got unexpected context from AI: %s\" % (context))\n\n    def setBarrierData(self, data):\n        # This message is sent by the AI to tell us the barriers and\n        # avIds for which the AI is currently waiting.  The client\n        # needs to look up its pending context in the table (and\n        # ignore the other contexts).  When the client is done\n        # handling whatever it should handle in its current state, it\n        # should call doneBarrier(), which will send the context\n        # number back to the AI.\n        for context, name, avIds in data:\n            for avId in avIds:\n                if self.cr.isLocalId(avId):\n                    # We found the local avatar's id; stop here.\n                    self.__barrierContext = (context, name)\n                    assert self.notify.debug('setBarrierData(%s, %s)' % (context, name))\n                    return\n\n        # This barrier didn't involve this client; ignore it.\n        assert self.notify.debug('setBarrierData(%s)' % (None))\n        self.__barrierContext = None\n\n    def getBarrierData(self):\n        # Return a trivially-empty (context, name, avIds) value.\n        return ((0, '', []),)\n\n    def doneBarrier(self, name = None):\n        # Tells the AI we have finished handling our task.  If the\n        # optional name parameter is specified, it must match the\n        # barrier name specified on the AI, or the barrier is ignored.\n        # This is used to ensure we are not clearing the wrong\n        # barrier.\n\n        # If this is None, it either means we have called\n        # doneBarrier() twice, or we have not received a barrier\n        # context from the AI.  I think in either case it's ok to\n        # silently ignore the error.\n        if self.__barrierContext is not None:\n            context, aiName = self.__barrierContext\n            if name is None or name == aiName:\n                assert self.notify.debug('doneBarrier(%s, %s)' % (context, aiName))\n                self.sendUpdate(\"setBarrierReady\", [context])\n                self.__barrierContext = None\n            else:\n                assert self.notify.debug('doneBarrier(%s) ignored; current barrier is %s' % (name, aiName))\n        else:\n            assert self.notify.debug('doneBarrier(%s) ignored; no active barrier.' % (name))\n\n    def addInterest(self, zoneId, note=\"\", event=None):\n        return self.cr.addInterest(self.getDoId(), zoneId, note, event)\n\n    def removeInterest(self, handle, event=None):\n        return self.cr.removeInterest(handle, event)\n\n    def b_setLocation(self, parentId, zoneId):\n        self.d_setLocation(parentId, zoneId)\n        self.setLocation(parentId, zoneId)\n\n    def d_setLocation(self, parentId, zoneId):\n        self.cr.sendSetLocation(self.doId, parentId, zoneId)\n\n    def setLocation(self, parentId, zoneId):\n        self.cr.storeObjectLocation(self, parentId, zoneId)\n\n    def getLocation(self):\n        try:\n            if self.parentId == 0 and self.zoneId == 0:\n                return None\n            # This is a -1 stuffed into a uint32\n            if self.parentId == 0xffffffff and self.zoneId == 0xffffffff:\n                return None\n            return (self.parentId, self.zoneId)\n        except AttributeError:\n            return None\n\n    def getParentObj(self):\n        if self.parentId is None:\n            return None\n        return self.cr.doId2do.get(self.parentId)\n\n    def isLocal(self):\n        # This returns true if the distributed object is \"local,\"\n        # which means the client created it instead of the AI, and it\n        # gets some other special handling.  Normally, only the local\n        # avatar class overrides this to return true.\n        return self.cr and self.cr.isLocalId(self.doId)\n\n    def isGridParent(self):\n        # If this distributed object is a DistributedGrid return 1.  0 by default\n        return 0\n\n    def execCommand(self, string, mwMgrId, avId, zoneId):\n        pass\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/DistributedObject.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/def4fbaa_DistributedObject.json",
    "doc_id": "doc_324"
  }
}