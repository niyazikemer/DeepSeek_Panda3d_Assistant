{
  "content": "from direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom .DistributedNodeAI import DistributedNodeAI\nfrom .CartesianGridBase import CartesianGridBase\n\nclass DistributedCartesianGridAI(DistributedNodeAI, CartesianGridBase):\n    notify = directNotify.newCategory(\"DistributedCartesianGridAI\")\n\n    RuleSeparator = \":\"\n\n    def __init__(self, air, startingZone, gridSize, gridRadius, cellWidth,\n            style=\"Cartesian\"):\n        DistributedNodeAI.__init__(self, air)\n        self.style = style\n        self.startingZone = startingZone\n        self.gridSize = gridSize\n        self.gridRadius = gridRadius\n        self.cellWidth = cellWidth\n\n        # Keep track of all AI objects added to the grid\n        self.gridObjects = {}\n        self.updateTaskStarted = 0\n\n    def delete(self):\n        DistributedNodeAI.delete(self)\n        self.stopUpdateGridTask()\n\n    def isGridParent(self):\n        # If this distributed object is a DistributedGrid return 1.\n        # 0 by default\n        return 1\n\n    def getCellWidth(self):\n        return self.cellWidth\n\n    def getParentingRules(self):\n        self.notify.debug(\"calling getter\")\n        rule = (\"%i%s%i%s%i\" % (self.startingZone, self.RuleSeparator,\n                                self.gridSize, self.RuleSeparator,\n                                self.gridRadius))\n        return [self.style, rule]\n\n    # Reparent and setLocation on av to DistributedOceanGrid\n    def addObjectToGrid(self, av, useZoneId=-1, startAutoUpdate=True):\n        self.notify.debug(\"setting parent to grid %s\" % self)\n        avId = av.doId\n\n        # Create a grid parent\n        #gridParent = self.attachNewNode(\"gridParent-%s\" % avId)\n        #self.gridParents[avId] = gridParent\n        self.gridObjects[avId] = av\n\n        # Put the avatar on the grid\n        self.handleAvatarZoneChange(av, useZoneId)\n\n        if startAutoUpdate and not self.updateTaskStarted:\n            self.startUpdateGridTask()\n\n    def removeObjectFromGrid(self, av):\n        # TODO: WHAT LOCATION SHOULD WE SET THIS TO?\n        #av.wrtReparentTo(self.parentNP)\n        #av.setLocation(self.air.districtId, 1000)\n\n        # Remove grid parent for this av\n        avId = av.doId\n        if avId in self.gridObjects:\n            del self.gridObjects[avId]\n\n        # Stop task if there are no more av's being managed\n        if len(self.gridObjects) == 0:\n            self.stopUpdateGridTask()\n\n    #####################################################################\n    # updateGridTask\n    # This task is similar to the processVisibility task for the local client.\n    # A couple differences:\n    #  - we are not doing setInterest on the AI (that is a local client\n    #    specific call).\n    #  - we assume that the moving objects on the grid are parented to a\n    #    gridParent, and are broadcasting their position relative to that\n    #    gridParent.  This makes the task's math easy.  Just check to see\n    #    when our position goes out of the current grid cell.  When it does,\n    #    call handleAvatarZoneChange\n\n    def startUpdateGridTask(self):\n        self.stopUpdateGridTask()\n        self.updateTaskStarted = 1\n        taskMgr.add(self.updateGridTask, self.taskName(\"updateGridTask\"))\n\n    def stopUpdateGridTask(self):\n        taskMgr.remove(self.taskName(\"updateGridTask\"))\n        self.updateTaskStarted = 0\n\n    def updateGridTask(self, task=None):\n        # Run through all grid objects and update their parents if needed\n        missingObjs = []\n        for avId in list(self.gridObjects.keys()):\n            av = self.gridObjects[avId]\n            # handle a missing object after it is already gone?\n            if av.isEmpty():\n                task.setDelay(1.0)\n                del self.gridObjects[avId]\n                continue\n            pos = av.getPos()\n            if (pos[0] < 0 or pos[1] < 0) or \\\n               (pos[0] > self.cellWidth or pos[1] > self.cellWidth):\n                # we are out of the bounds of this current cell\n                self.handleAvatarZoneChange(av)\n        # Do this every second, not every frame\n        if task:\n            task.setDelay(1.0)\n        return Task.again\n\n    def handleAvatarZoneChange(self, av, useZoneId=-1):\n        # Calculate zone id\n        # Get position of av relative to this grid\n        if useZoneId == -1:\n            pos = av.getPos(self)\n            zoneId = self.getZoneFromXYZ(pos)\n        else:\n            # zone already calculated, position of object might not\n            # give the correct zone\n            pos = None\n            zoneId = useZoneId\n\n        if not self.isValidZone(zoneId):\n            self.notify.warning(\n                \"%s handleAvatarZoneChange %s: not a valid zone (%s) for pos %s\" %(self.doId, av.doId, zoneId, pos))\n            return\n\n        # Set the location on the server.\n        # setLocation will update the gridParent\n        av.b_setLocation(self.doId, zoneId)\n\n    def handleSetLocation(self, av, parentId, zoneId):\n        pass\n        #if av.parentId != parentId:\n            # parent changed, need to look up instance tree\n            # to see if avatar's named area location information\n            # changed\n            #av.requestRegionUpdateTask(regionegionUid)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/DistributedCartesianGridAI.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/7ef9e01d_DistributedCartesianGridAI.json",
    "doc_id": "doc_325"
  }
}