{
  "content": "\"\"\"The VFS importer allows importing Python modules from Panda3D's virtual\nfile system, through Python's standard import mechanism.\n\nCalling the :func:`register()` function to register the import hooks should be\nsufficient to enable this functionality.\n\"\"\"\n\n__all__ = ['register', 'sharedPackages',\n           'reloadSharedPackage', 'reloadSharedPackages']\n\nfrom panda3d.core import Filename, VirtualFileSystem, VirtualFileMountSystem, OFileStream, copyStream\nfrom direct.stdpy.file import open\nimport sys\nimport marshal\nimport imp\nimport types\n\n#: The sharedPackages dictionary lists all of the \"shared packages\",\n#: special Python packages that automatically span multiple directories\n#: via magic in the VFSImporter.  You can make a package \"shared\"\n#: simply by adding its name into this dictionary (and then calling\n#: reloadSharedPackages() if it's already been imported).\n#:\n#: When a package name is in this dictionary at import time, *all*\n#: instances of the package are located along sys.path, and merged into\n#: a single Python module with a __path__ setting that represents the\n#: union.  Thus, you can have a direct.showbase.foo in your own\n#: application, and loading it won't shadow the system\n#: direct.showbase.ShowBase which is in a different directory on disk.\nsharedPackages = {}\n\nvfs = VirtualFileSystem.getGlobalPtr()\n\ncompiledExtensions = ['pyc', 'pyo']\nif not __debug__:\n    # In optimized mode, we prefer loading .pyo files over .pyc files.\n    # We implement that by reversing the extension names.\n    compiledExtensions = ['pyo', 'pyc']\n\n\nclass VFSImporter:\n    \"\"\" This class serves as a Python importer to support loading\n    Python .py and .pyc/.pyo files from Panda's Virtual File System,\n    which allows loading Python source files from mounted .mf files\n    (among other places). \"\"\"\n\n    def __init__(self, path):\n        if isinstance(path, Filename):\n            self.dir_path = Filename(path)\n        else:\n            self.dir_path = Filename.fromOsSpecific(path)\n\n    def find_module(self, fullname, path = None):\n        if path is None:\n            dir_path = self.dir_path\n        else:\n            dir_path = path\n        #print >>sys.stderr, \"find_module(%s), dir_path = %s\" % (fullname, dir_path)\n        basename = fullname.split('.')[-1]\n        path = Filename(dir_path, basename)\n\n        # First, look for Python files.\n        filename = Filename(path)\n        filename.setExtension('py')\n        vfile = vfs.getFile(filename, True)\n        if vfile:\n            return VFSLoader(dir_path, vfile, filename,\n                             desc=('.py', 'r', imp.PY_SOURCE))\n\n        # If there's no .py file, but there's a .pyc file, load that\n        # anyway.\n        for ext in compiledExtensions:\n            filename = Filename(path)\n            filename.setExtension(ext)\n            vfile = vfs.getFile(filename, True)\n            if vfile:\n                return VFSLoader(dir_path, vfile, filename,\n                                 desc=('.'+ext, 'rb', imp.PY_COMPILED))\n\n        # Look for a C/C++ extension module.\n        for desc in imp.get_suffixes():\n            if desc[2] != imp.C_EXTENSION:\n                continue\n\n            filename = Filename(path + desc[0])\n            vfile = vfs.getFile(filename, True)\n            if vfile:\n                return VFSLoader(dir_path, vfile, filename, desc=desc)\n\n        # Finally, consider a package, i.e. a directory containing\n        # __init__.py.\n        filename = Filename(path, '__init__.py')\n        vfile = vfs.getFile(filename, True)\n        if vfile:\n            return VFSLoader(dir_path, vfile, filename, packagePath=path,\n                             desc=('.py', 'r', imp.PY_SOURCE))\n        for ext in compiledExtensions:\n            filename = Filename(path, '__init__.' + ext)\n            vfile = vfs.getFile(filename, True)\n            if vfile:\n                return VFSLoader(dir_path, vfile, filename, packagePath=path,\n                                 desc=('.'+ext, 'rb', imp.PY_COMPILED))\n\n        #print >>sys.stderr, \"not found.\"\n        return None\n\n\nclass VFSLoader:\n    \"\"\" The second part of VFSImporter, this is created for a\n    particular .py file or directory. \"\"\"\n\n    def __init__(self, dir_path, vfile, filename, desc, packagePath=None):\n        self.dir_path = dir_path\n        self.timestamp = None\n        if vfile:\n            self.timestamp = vfile.getTimestamp()\n        self.filename = filename\n        self.desc = desc\n        self.packagePath = packagePath\n\n    def load_module(self, fullname, loadingShared = False):\n        #print >>sys.stderr, \"load_module(%s), dir_path = %s, filename = %s\" % (fullname, self.dir_path, self.filename)\n        if self.desc[2] == imp.PY_FROZEN:\n            return self._import_frozen_module(fullname)\n        if self.desc[2] == imp.C_EXTENSION:\n            return self._import_extension_module(fullname)\n\n        # Check if this is a child of a shared package.\n        if not loadingShared and self.packagePath and '.' in fullname:\n            parentname = fullname.rsplit('.', 1)[0]\n            if parentname in sharedPackages:\n                # It is.  That means it's a shared package too.\n                parent = sys.modules[parentname]\n                path = getattr(parent, '__path__', None)\n                importer = VFSSharedImporter()\n                sharedPackages[fullname] = True\n                loader = importer.find_module(fullname, path = path)\n                assert loader\n                return loader.load_module(fullname)\n\n        code = self._read_code()\n        if not code:\n            raise ImportError('No Python code in %s' % (fullname))\n\n        mod = sys.modules.setdefault(fullname, imp.new_module(fullname))\n        mod.__file__ = self.filename.toOsSpecific()\n        mod.__loader__ = self\n        if self.packagePath:\n            mod.__path__ = [self.packagePath.toOsSpecific()]\n            #print >> sys.stderr, \"loaded %s, path = %s\" % (fullname, mod.__path__)\n\n        exec(code, mod.__dict__)\n        return sys.modules[fullname]\n\n    def getdata(self, path):\n        path = Filename(self.dir_path, Filename.fromOsSpecific(path))\n        vfile = vfs.getFile(path)\n        if not vfile:\n            raise IOError(\"Could not find '%s'\" % (path))\n        return vfile.readFile(True)\n\n    def is_package(self, fullname):\n        return bool(self.packagePath)\n\n    def get_code(self, fullname):\n        return self._read_code()\n\n    def get_source(self, fullname):\n        return self._read_source()\n\n    def get_filename(self, fullname):\n        return self.filename.toOsSpecific()\n\n    def _read_source(self):\n        \"\"\" Returns the Python source for this file, if it is\n        available, or None if it is not.  May raise IOError. \"\"\"\n\n        if self.desc[2] == imp.PY_COMPILED or \\\n           self.desc[2] == imp.C_EXTENSION:\n            return None\n\n        filename = Filename(self.filename)\n        filename.setExtension('py')\n        filename.setText()\n\n        # Use the tokenize module to detect the encoding.\n        import tokenize\n        fh = open(self.filename, 'rb')\n        encoding, lines = tokenize.detect_encoding(fh.readline)\n        return (b''.join(lines) + fh.read()).decode(encoding)\n\n    def _import_extension_module(self, fullname):\n        \"\"\" Loads the binary shared object as a Python module, and\n        returns it. \"\"\"\n\n        vfile = vfs.getFile(self.filename, False)\n\n        # We can only import an extension module if it already exists on\n        # disk.  This means if it's a truly virtual file that has no\n        # on-disk equivalent, we have to write it to a temporary file\n        # first.\n        if hasattr(vfile, 'getMount') and \\\n           isinstance(vfile.getMount(), VirtualFileMountSystem):\n            # It's a real file.\n            filename = self.filename\n        elif self.filename.exists():\n            # It's a virtual file, but it's shadowing a real file in\n            # the same directory.  Assume they're the same, and load\n            # the real one.\n            filename = self.filename\n        else:\n            # It's a virtual file with no real-world existence.  Dump\n            # it to disk.  TODO: clean up this filename.\n            filename = Filename.temporary('', self.filename.getBasenameWoExtension(),\n                                          '.' + self.filename.getExtension(),\n                                          type = Filename.TDso)\n            filename.setExtension(self.filename.getExtension())\n            filename.setBinary()\n            sin = vfile.openReadFile(True)\n            sout = OFileStream()\n            if not filename.openWrite(sout):\n                raise IOError\n            if not copyStream(sin, sout):\n                raise IOError\n            vfile.closeReadFile(sin)\n            del sout\n\n        module = imp.load_module(fullname, None, filename.toOsSpecific(),\n                                 self.desc)\n        module.__file__ = self.filename.toOsSpecific()\n        return module\n\n    def _import_frozen_module(self, fullname):\n        \"\"\" Imports the frozen module without messing around with\n        searching any more. \"\"\"\n        #print >>sys.stderr, \"importing frozen %s\" % (fullname)\n        module = imp.load_module(fullname, None, fullname,\n                                 ('', '', imp.PY_FROZEN))\n        module.__path__ = []\n        return module\n\n    def _read_code(self):\n        \"\"\" Returns the Python compiled code object for this file, if\n        it is available, or None if it is not.  May raise IOError,\n        ValueError, SyntaxError, or a number of other errors generated\n        by the low-level system. \"\"\"\n\n        if self.desc[2] == imp.PY_COMPILED:\n            # It's a pyc file; just read it directly.\n            pycVfile = vfs.getFile(self.filename, False)\n            if pycVfile:\n                return self._loadPyc(pycVfile, None)\n            raise IOError('Could not read %s' % (self.filename))\n\n        elif self.desc[2] == imp.C_EXTENSION:\n            return None\n\n        # It's a .py file (or an __init__.py file; same thing).  Read\n        # the .pyc file if it is available and current; otherwise read\n        # the .py file and compile it.\n        t_pyc = None\n        for ext in compiledExtensions:\n            pycFilename = Filename(self.filename)\n            pycFilename.setExtension(ext)\n            pycVfile = vfs.getFile(pycFilename, False)\n            if pycVfile:\n                t_pyc = pycVfile.getTimestamp()\n                break\n\n        code = None\n        if t_pyc and t_pyc >= self.timestamp:\n            try:\n                code = self._loadPyc(pycVfile, self.timestamp)\n            except ValueError:\n                code = None\n\n        if not code:\n            source = self._read_source()\n            filename = Filename(self.filename)\n            filename.setExtension('py')\n            code = self._compile(filename, source)\n\n        return code\n\n    def _loadPyc(self, vfile, timestamp):\n        \"\"\" Reads and returns the marshal data from a .pyc file.\n        Raises ValueError if there is a problem. \"\"\"\n\n        code = None\n        data = vfile.readFile(True)\n        if data[:4] != imp.get_magic():\n            raise ValueError(\"Bad magic number in %s\" % (vfile))\n\n        t = int.from_bytes(data[4:8], 'little')\n        data = data[12:]\n\n        if not timestamp or t == timestamp:\n            return marshal.loads(data)\n        else:\n            raise ValueError(\"Timestamp wrong on %s\" % (vfile))\n\n    def _compile(self, filename, source):\n        \"\"\" Compiles the Python source code to a code object and\n        attempts to write it to an appropriate .pyc file.  May raise\n        SyntaxError or other errors generated by the compiler. \"\"\"\n\n        if source and source[-1] != '\\n':\n            source = source + '\\n'\n        code = compile(source, filename.toOsSpecific(), 'exec')\n\n        # try to cache the compiled code\n        pycFilename = Filename(filename)\n        pycFilename.setExtension(compiledExtensions[0])\n        try:\n            f = open(pycFilename.toOsSpecific(), 'wb')\n        except IOError:\n            pass\n        else:\n            f.write(imp.get_magic())\n            f.write((self.timestamp & 0xffffffff).to_bytes(4, 'little'))\n            f.write(b'\\0\\0\\0\\0')\n            f.write(marshal.dumps(code))\n            f.close()\n\n        return code\n\n\nclass VFSSharedImporter:\n    \"\"\" This is a special importer that is added onto the meta_path\n    list, so that it is called before sys.path is traversed.  It uses\n    special logic to load one of the \"shared\" packages, by searching\n    the entire sys.path for all instances of this shared package, and\n    merging them. \"\"\"\n\n    def __init__(self):\n        pass\n\n    def find_module(self, fullname, path = None, reload = False):\n        #print >>sys.stderr, \"shared find_module(%s), path = %s\" % (fullname, path)\n\n        if fullname not in sharedPackages:\n            # Not a shared package; fall back to normal import.\n            return None\n\n        if path is None:\n            path = sys.path\n\n        excludePaths = []\n        if reload:\n            # If reload is true, we are simply reloading the module,\n            # looking for new paths to add.\n            mod = sys.modules[fullname]\n            excludePaths = getattr(mod, '_vfs_shared_path', None)\n            if excludePaths is None:\n                # If there isn't a _vfs_shared_path symbol already,\n                # the module must have been loaded through\n                # conventional means.  Try to guess which path it was\n                # found on.\n                d = self.getLoadedDirname(mod)\n                excludePaths = [d]\n\n        loaders = []\n        for dir in path:\n            if dir in excludePaths:\n                continue\n\n            importer = sys.path_importer_cache.get(dir, None)\n            if importer is None:\n                try:\n                    importer = VFSImporter(dir)\n                except ImportError:\n                    continue\n\n                sys.path_importer_cache[dir] = importer\n\n            try:\n                loader = importer.find_module(fullname)\n                if not loader:\n                    continue\n            except ImportError:\n                continue\n\n            loaders.append(loader)\n\n        if not loaders:\n            return None\n        return VFSSharedLoader(loaders, reload = reload)\n\n    def getLoadedDirname(self, mod):\n        \"\"\" Returns the directory name that the indicated\n        conventionally-loaded module must have been loaded from. \"\"\"\n\n        if not getattr(mod, '__file__', None):\n            return None\n\n        fullname = mod.__name__\n        dirname = Filename.fromOsSpecific(mod.__file__).getDirname()\n\n        parentname = None\n        basename = fullname\n        if '.' in fullname:\n            parentname, basename = fullname.rsplit('.', 1)\n\n        path = None\n        if parentname:\n            parent = sys.modules[parentname]\n            path = parent.__path__\n        if path is None:\n            path = sys.path\n\n        for dir in path:\n            pdir = str(Filename.fromOsSpecific(dir))\n            if pdir + '/' + basename == dirname:\n                # We found it!\n                return dir\n\n        # Couldn't figure it out.\n        return None\n\n\nclass VFSSharedLoader:\n    \"\"\" The second part of VFSSharedImporter, this imports a list of\n    packages and combines them. \"\"\"\n\n    def __init__(self, loaders, reload):\n        self.loaders = loaders\n        self.reload = reload\n\n    def load_module(self, fullname):\n        #print >>sys.stderr, \"shared load_module(%s), loaders = %s\" % (fullname, map(lambda l: l.dir_path, self.loaders))\n\n        mod = None\n        message = None\n        path = []\n        vfs_shared_path = []\n        if self.reload:\n            mod = sys.modules[fullname]\n            path = mod.__path__ or []\n            if path == fullname:\n                # Work around Python bug setting __path__ of frozen modules.\n                path = []\n            vfs_shared_path = getattr(mod, '_vfs_shared_path', [])\n\n        for loader in self.loaders:\n            try:\n                mod = loader.load_module(fullname, loadingShared = True)\n            except ImportError:\n                etype, evalue, etraceback = sys.exc_info()\n                print(\"%s on %s: %s\" % (etype.__name__, fullname, evalue))\n                if not message:\n                    message = '%s: %s' % (fullname, evalue)\n                continue\n            for dir in getattr(mod, '__path__', []):\n                if dir not in path:\n                    path.append(dir)\n\n        if mod is None:\n            # If all of them failed to load, raise ImportError.\n            raise ImportError(message)\n\n        # If at least one of them loaded successfully, return the\n        # union of loaded modules.\n        mod.__path__ = path\n        mod.__package__ = fullname\n\n        # Also set this special symbol, which records that this is a\n        # shared package, and also lists the paths we have already\n        # loaded.\n        mod._vfs_shared_path = vfs_shared_path + [l.dir_path for l in self.loaders]\n\n        return mod\n\n\n_registered = False\n\n\ndef register():\n    \"\"\" Register the VFSImporter on the path_hooks, if it has not\n    already been registered, so that future Python import statements\n    will vector through here (and therefore will take advantage of\n    Panda's virtual file system). \"\"\"\n\n    global _registered\n    if not _registered:\n        _registered = True\n        sys.path_hooks.insert(0, VFSImporter)\n        sys.meta_path.insert(0, VFSSharedImporter())\n\n        # Blow away the importer cache, so we'll come back through the\n        # VFSImporter for every folder in the future, even those\n        # folders that previously were loaded directly.\n        sys.path_importer_cache = {}\n\n\ndef reloadSharedPackage(mod):\n    \"\"\" Reloads the specific module as a shared package, adding any\n    new directories that might have appeared on the search path. \"\"\"\n\n    fullname = mod.__name__\n    path = None\n    if '.' in fullname:\n        parentname = fullname.rsplit('.', 1)[0]\n        parent = sys.modules[parentname]\n        path = parent.__path__\n\n    importer = VFSSharedImporter()\n    loader = importer.find_module(fullname, path = path, reload = True)\n    if loader:\n        loader.load_module(fullname)\n\n    # Also force any child packages to become shared packages, if\n    # they aren't already.\n    for basename, child in list(mod.__dict__.items()):\n        if isinstance(child, types.ModuleType):\n            childname = child.__name__\n            if childname == fullname + '.' + basename and \\\n               hasattr(child, '__path__') and \\\n               childname not in sharedPackages:\n                sharedPackages[childname] = True\n                reloadSharedPackage(child)\n\n\ndef reloadSharedPackages():\n    \"\"\" Walks through the sharedPackages list, and forces a reload of\n    any modules on that list that have already been loaded.  This\n    allows new directories to be added to the search path. \"\"\"\n\n    #print >> sys.stderr, \"reloadSharedPackages, path = %s, sharedPackages = %s\" % (sys.path, sharedPackages.keys())\n\n    # Sort the list, just to make sure parent packages are reloaded\n    # before child packages are.\n    for fullname in sorted(sharedPackages.keys()):\n        mod = sys.modules.get(fullname, None)\n        if not mod:\n            continue\n\n        reloadSharedPackage(mod)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/VFSImporter.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/0b1673e6_VFSImporter.json",
    "doc_id": "doc_246"
  }
}