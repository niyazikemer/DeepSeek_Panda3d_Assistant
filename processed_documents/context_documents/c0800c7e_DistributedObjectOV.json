{
  "content": "\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.distributed.DistributedObjectBase import DistributedObjectBase\nfrom direct.showbase.MessengerGlobal import messenger\n\n#from PyDatagram import PyDatagram\n#from PyDatagramIterator import PyDatagramIterator\n\n# Values for DistributedObjectOV.activeState\n# these should match DistributedObject.ES*\n\nESNew          = 1\nESDeleted      = 2\nESDisabling    = 3\nESDisabled     = 4  # values here and lower are considered \"disabled\"\nESGenerating   = 5  # values here and greater are considered \"generated\"\nESGenerated    = 6\n\nclass DistributedObjectOV(DistributedObjectBase):\n    \"\"\"\n    Implementation of the 'owner view' (OV) of a distributed object;\n    \"\"\"\n    notify = directNotify.newCategory(\"DistributedObjectOV\")\n\n    def __init__(self, cr):\n        assert self.notify.debugStateCall(self)\n        if not hasattr(self, 'DistributedObjectOV_initialized'):\n            self.DistributedObjectOV_initialized = 1\n            DistributedObjectBase.__init__(self, cr)\n\n            # Keep track of our state as a distributed object.  This\n            # is only trustworthy if the inheriting class properly\n            # calls up the chain for disable() and generate().\n            self.activeState = ESNew\n\n    if __debug__:\n        def status(self, indent=0):\n            \"\"\"\n            print out \"doId(parentId, zoneId) className\"\n                and conditionally show generated, disabled\n            \"\"\"\n            spaces = ' ' * (indent + 2)\n            try:\n                print(\"%s%s:\" % (' ' * indent, self.__class__.__name__))\n\n                flags = []\n                if self.activeState == ESGenerated:\n                    flags.append(\"generated\")\n                if self.activeState < ESGenerating:\n                    flags.append(\"disabled\")\n\n                flagStr = \"\"\n                if len(flags) > 0:\n                    flagStr = \" (%s)\" % (\" \".join(flags))\n\n                print(\"%sfrom DistributedObjectOV doId:%s, parent:%s, zone:%s%s\" % (\n                    spaces, self.doId, self.parentId, self.zoneId, flagStr))\n            except Exception as e:\n                print(\"%serror printing status %s\" % (spaces, e))\n\n\n    def getDelayDeleteCount(self):\n        # OV objects cannot be delayDeleted\n        return 0\n\n    def deleteOrDelay(self):\n        self.disableAnnounceAndDelete()\n\n    def disableAnnounceAndDelete(self):\n        self.disableAndAnnounce()\n        self.delete()\n\n    def disableAndAnnounce(self):\n        # We must send the disable announce message *before* we\n        # actually disable the object.  That way, the various cleanup\n        # tasks can run first and take care of restoring the object to\n        # a normal, nondisabled state; and *then* the disable function\n        # can properly disable it (for instance, by parenting it to\n        # hidden).\n        if self.activeState != ESDisabled:\n            self.activeState = ESDisabling\n            messenger.send(self.uniqueName(\"disable\"))\n            self.disable()\n\n    def announceGenerate(self):\n        \"\"\"\n        Sends a message to the world after the object has been\n        generated and all of its required fields filled in.\n        \"\"\"\n        assert self.notify.debug('announceGenerate(): %s' % (self.doId))\n\n    def disable(self):\n        \"\"\"\n        Inheritors should redefine this to take appropriate action on disable\n        \"\"\"\n        assert self.notify.debug('disable(): %s' % (self.doId))\n        if self.activeState != ESDisabled:\n            self.activeState = ESDisabled\n\n    def isDisabled(self):\n        \"\"\"\n        Returns true if the object has been disabled and/or deleted,\n        or if it is brand new and hasn't yet been generated.\n        \"\"\"\n        return self.activeState < ESGenerating\n\n    def isGenerated(self):\n        \"\"\"\n        Returns true if the object has been fully generated by now,\n        and not yet disabled.\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        return self.activeState == ESGenerated\n\n    def delete(self):\n        \"\"\"\n        Inheritors should redefine this to take appropriate action on delete\n        \"\"\"\n        assert self.notify.debug('delete(): %s' % (self.doId))\n        if not hasattr(self, 'DistributedObjectOV_deleted'):\n            self.DistributedObjectOV_deleted = 1\n            self.cr = None\n            self.dclass = None\n\n    def generate(self):\n        \"\"\"\n        Inheritors should redefine this to take appropriate action on generate\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        self.activeState = ESGenerating\n        # this has already been set at this point\n        #self.cr.storeObjectLocation(self, self.parentId, self.zoneId)\n\n    def generateInit(self):\n        \"\"\"\n        This method is called when the DistributedObjectOV is first introduced\n        to the world... Not when it is pulled from the cache.\n        \"\"\"\n        self.activeState = ESGenerating\n\n    def getDoId(self):\n        \"\"\"\n        Return the distributed object id\n        \"\"\"\n        return self.doId\n\n    def postGenerateMessage(self):\n        if self.activeState != ESGenerated:\n            self.activeState = ESGenerated\n            messenger.send(self.uniqueName(\"generate\"), [self])\n\n\n    def updateRequiredFields(self, dclass, di):\n        dclass.receiveUpdateBroadcastRequired(self, di)\n        self.announceGenerate()\n        self.postGenerateMessage()\n\n    def updateAllRequiredFields(self, dclass, di):\n        dclass.receiveUpdateAllRequired(self, di)\n        self.announceGenerate()\n        self.postGenerateMessage()\n\n    def updateRequiredOtherFields(self, dclass, di):\n        # First, update the required fields\n        dclass.receiveUpdateBroadcastRequiredOwner(self, di)\n\n        # Announce generate after updating all the required fields,\n        # but before we update the non-required fields.\n        self.announceGenerate()\n        self.postGenerateMessage()\n\n        dclass.receiveUpdateOther(self, di)\n\n    def getCacheable(self):\n        return False\n\n    def sendUpdate(self, fieldName, args = [], sendToId = None):\n        if self.cr:\n            dg = self.dclass.clientFormatUpdate(\n                fieldName, sendToId or self.doId, args)\n            self.cr.send(dg)\n        else:\n            self.notify.warning(\"sendUpdate failed, because self.cr is not set\")\n\n    def taskName(self, taskString):\n        return '%s-%s-OV' % (taskString, self.getDoId())\n\n    def uniqueName(self, idString):\n        return '%s-%s-OV' % (idString, self.getDoId())\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/DistributedObjectOV.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/c0800c7e_DistributedObjectOV.json",
    "doc_id": "doc_336"
  }
}