{
  "content": "\"\"\"State module: contains State class\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = ['State']\n\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.showbase.DirectObject import DirectObject\n\n\nclass State(DirectObject):\n    notify = directNotify.newCategory(\"State\")\n\n    # this 'constant' can be used to specify that the state\n    # can transition to any other state\n    Any = 'ANY'\n\n    # Keep a list of State objects currently in memory for\n    # Control-C-Control-V redefining. These are just weakrefs so they\n    # should not cause any leaks.\n    if __debug__:\n        import weakref\n        States: weakref.WeakKeyDictionary[State, int] = weakref.WeakKeyDictionary()\n\n        @classmethod\n        def replaceMethod(cls, oldFunction, newFunction):\n            import types\n            count = 0\n            for state in cls.States:\n                # Note: you can only replace methods currently\n                enterFunc = state.getEnterFunc()\n                exitFunc = state.getExitFunc()\n                # print 'testing: ', state, enterFunc, exitFunc, oldFunction\n                if isinstance(enterFunc, types.MethodType):\n                    if enterFunc.__func__ == oldFunction:\n                        # print 'found: ', enterFunc, oldFunction\n                        state.setEnterFunc(types.MethodType(newFunction,\n                                                            enterFunc.__self__))\n                        count += 1\n                if isinstance(exitFunc, types.MethodType):\n                    if exitFunc.__func__ == oldFunction:\n                        # print 'found: ', exitFunc, oldFunction\n                        state.setExitFunc(types.MethodType(newFunction,\n                                                           exitFunc.__self__))\n                        count += 1\n            return count\n\n\n    def __init__(self, name, enterFunc=None, exitFunc=None,\n                 transitions=Any, inspectorPos = []):\n        \"\"\"__init__(self, string, func, func, string[], inspectorPos = [])\n        State constructor: takes name, enter func, exit func, and\n        a list of states it can transition to (or State.Any).\"\"\"\n        self.__name = name\n        self.__enterFunc = enterFunc\n        self.__exitFunc = exitFunc\n        self.__transitions = transitions\n        self.__FSMList = []\n        if __debug__:\n            self.setInspectorPos(inspectorPos)\n            # For redefining\n            self.States[self] = 1\n\n    # setters and getters\n\n    def getName(self):\n        return self.__name\n\n    def setName(self, stateName):\n        self.__name = stateName\n\n    def getEnterFunc(self):\n        return self.__enterFunc\n\n    def setEnterFunc(self, stateEnterFunc):\n        self.__enterFunc = stateEnterFunc\n\n    def getExitFunc(self):\n        return self.__exitFunc\n\n    def setExitFunc(self, stateExitFunc):\n        self.__exitFunc = stateExitFunc\n\n    def transitionsToAny(self):\n        \"\"\" returns true if State defines transitions to any other state \"\"\"\n        return self.__transitions is State.Any\n\n    def getTransitions(self):\n        \"\"\"\n        warning -- if the state transitions to any other state,\n        returns an empty list (falsely implying that the state\n        has no transitions)\n        see State.transitionsToAny()\n        \"\"\"\n        if self.transitionsToAny():\n            return []\n        return self.__transitions\n\n    def isTransitionDefined(self, otherState):\n        if self.transitionsToAny():\n            return 1\n\n        # if we're given a state object, get its name instead\n        if not isinstance(otherState, str):\n            otherState = otherState.getName()\n        return otherState in self.__transitions\n\n    def setTransitions(self, stateTransitions):\n        \"\"\"setTransitions(self, string[])\"\"\"\n        self.__transitions = stateTransitions\n\n    def addTransition(self, transition):\n        \"\"\"addTransitions(self, string)\"\"\"\n        if not self.transitionsToAny():\n            self.__transitions.append(transition)\n        else:\n            State.notify.warning(\n                'attempted to add transition %s to state that '\n                'transitions to any state')\n\n    if __debug__:\n        def getInspectorPos(self):\n            \"\"\"getInspectorPos(self)\"\"\"\n            return self.__inspectorPos\n\n        def setInspectorPos(self, inspectorPos):\n            \"\"\"setInspectorPos(self, [x, y])\"\"\"\n            self.__inspectorPos = inspectorPos\n\n    # support for HFSMs\n\n    def getChildren(self):\n        \"\"\"\n        Return the list of child FSMs\n        \"\"\"\n        return self.__FSMList\n\n    def setChildren(self, FSMList):\n        \"\"\"setChildren(self, ClassicFSM[])\n        Set the children to given list of FSMs\n        \"\"\"\n        self.__FSMList = FSMList\n\n    def addChild(self, ClassicFSM):\n        \"\"\"\n        Add the given ClassicFSM to list of child FSMs\n        \"\"\"\n        self.__FSMList.append(ClassicFSM)\n\n    def removeChild(self, ClassicFSM):\n        \"\"\"\n        Remove the given ClassicFSM from list of child FSMs\n        \"\"\"\n        if ClassicFSM in self.__FSMList:\n            self.__FSMList.remove(ClassicFSM)\n\n    def hasChildren(self):\n        \"\"\"\n        Return true if state has child FSMs\n        \"\"\"\n        return len(self.__FSMList) > 0\n\n    def __enterChildren(self, argList):\n        \"\"\"\n        Enter all child FSMs\n        \"\"\"\n        for fsm in self.__FSMList:\n            # Check to see if the child fsm is already in a state\n            # if it is, politely request the initial state\n\n            if fsm.getCurrentState():\n                # made this 'conditional_request()' instead of 'request()' to avoid warning when\n                # loading minigames where rules->frameworkInit transition doesnt exist and you\n                # don't want to add it since it results in hanging the game\n                fsm.conditional_request((fsm.getInitialState()).getName())\n\n            # If it has no current state, I assume this means it\n            # has never entered the initial state, so enter it\n            # explicitly\n            else:\n                fsm.enterInitialState()\n\n    def __exitChildren(self, argList):\n        \"\"\"\n        Exit all child FSMs\n        \"\"\"\n        for fsm in self.__FSMList:\n            fsm.request((fsm.getFinalState()).getName())\n\n\n    # basic State functionality\n\n    def enter(self, argList=[]):\n        \"\"\"\n        Call the enter function for this state\n        \"\"\"\n        # enter child FSMs first. It is assumed these have a start\n        # state that is safe to enter\n        self.__enterChildren(argList)\n\n        if self.__enterFunc is not None:\n            self.__enterFunc(*argList)\n\n    def exit(self, argList=[]):\n        \"\"\"\n        Call the exit function for this state\n        \"\"\"\n        # first exit child FSMs\n        self.__exitChildren(argList)\n\n        # call exit function if it exists\n        if self.__exitFunc is not None:\n            self.__exitFunc(*argList)\n\n    def __str__(self):\n        return \"State: name = %s, enter = %s, exit = %s, trans = %s, children = %s\" %\\\n               (self.__name, self.__enterFunc, self.__exitFunc, self.__transitions, self.__FSMList)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/fsm/State.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/417dc244_State.json",
    "doc_id": "doc_147"
  }
}