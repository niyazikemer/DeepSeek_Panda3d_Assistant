{
  "content": "\"\"\"OnscreenText module: contains the OnscreenText class.\n\nSee the :ref:`onscreentext` page in the programming manual for explanation of\nthis class.\n\"\"\"\n\n__all__ = ['OnscreenText', 'Plain', 'ScreenTitle', 'ScreenPrompt', 'NameConfirm', 'BlackOnWhite']\n\nfrom panda3d.core import LColor, Mat4, NodePath, Point3, TextNode, TextProperties, Vec3\nfrom . import DirectGuiGlobals as DGG\nimport warnings\n\n## These are the styles of text we might commonly see.  They set the\n## overall appearance of the text according to one of a number of\n## pre-canned styles.  You can further customize the appearance of the\n## text by specifying individual parameters as well.\nPlain = 1\nScreenTitle = 2\nScreenPrompt = 3\nNameConfirm = 4\nBlackOnWhite = 5\n\n\nclass OnscreenText(NodePath):\n\n    def __init__(self, text = '',\n                 style = Plain,\n                 pos = (0, 0),\n                 roll = 0,\n                 scale = None,\n                 fg = None,\n                 bg = None,\n                 shadow = None,\n                 shadowOffset = (0.04, 0.04),\n                 frame = None,\n                 align = None,\n                 wordwrap = None,\n                 drawOrder = None,\n                 decal = 0,\n                 font = None,\n                 parent = None,\n                 sort = 0,\n                 mayChange = True,\n                 direction = None):\n        \"\"\"\n        Make a text node from string, put it into the 2d sg and set it\n        up with all the indicated parameters.\n\n        Parameters:\n\n          text: the actual text to display.  This may be omitted and\n              specified later via setText() if you don't have it\n              available, but it is better to specify it up front.\n\n          style: one of the pre-canned style parameters defined at the\n              head of this file.  This sets up the default values for\n              many of the remaining parameters if they are\n              unspecified; however, a parameter may still be specified\n              to explicitly set it, overriding the pre-canned style.\n\n          pos: the x, y position of the text on the screen.\n\n          scale: the size of the text.  This may either be a single\n              float (and it will usually be a small number like 0.07)\n              or it may be a 2-tuple of floats, specifying a different\n              x, y scale.\n\n          fg: the (r, g, b, a) foreground color of the text.  This is\n              normally a 4-tuple of floats or ints.\n\n          bg: the (r, g, b, a) background color of the text.  If the\n              fourth value, a, is nonzero, a card is created to place\n              behind the text and set to the given color.\n\n          shadow: the (r, g, b, a) color of the shadow behind the text.\n              If the fourth value, a, is nonzero, a little drop shadow\n              is created and placed behind the text.\n\n          frame: the (r, g, b, a) color of the frame drawn around the\n              text.  If the fourth value, a, is nonzero, a frame is\n              created around the text.\n\n          align: one of TextNode.ALeft, TextNode.ARight, or TextNode.ACenter.\n\n          wordwrap: either the width to wordwrap the text at, or None\n              to specify no automatic word wrapping.\n\n          drawOrder: the drawing order of this text with respect to\n              all other things in the 'fixed' bin within render2d.\n              The text will actually use drawOrder through drawOrder +\n              2.\n\n          decal: if this is True, the text is decalled onto its\n              background card.  Useful when the text will be parented\n              into the 3-D scene graph.\n\n          font: the font to use for the text.\n\n          parent: the NodePath to parent the text to initially.\n\n          mayChange: pass true if the text or its properties may need\n              to be changed at runtime, false if it is static once\n              created (which leads to better memory optimization).\n\n          direction: this can be set to 'ltr' or 'rtl' to override the\n              direction of the text.\n        \"\"\"\n        if parent is None:\n            from direct.showbase import ShowBaseGlobal\n            parent = ShowBaseGlobal.aspect2d\n\n        # make a text node\n        textNode = TextNode('')\n        self.textNode = textNode\n\n        # We ARE a node path.  Initially, we're an empty node path.\n        NodePath.__init__(self)\n\n        # Choose the default parameters according to the selected\n        # style.\n        if style == Plain:\n            scale = scale or 0.07\n            fg = fg or (0, 0, 0, 1)\n            bg = bg or (0, 0, 0, 0)\n            shadow = shadow or (0, 0, 0, 0)\n            frame = frame or (0, 0, 0, 0)\n            if align is None:\n                align = TextNode.ACenter\n        elif style == ScreenTitle:\n            scale = scale or 0.15\n            fg = fg or (1, 0.2, 0.2, 1)\n            bg = bg or (0, 0, 0, 0)\n            shadow = shadow or (0, 0, 0, 1)\n            frame = frame or (0, 0, 0, 0)\n            if align is None:\n                align = TextNode.ACenter\n        elif style == ScreenPrompt:\n            scale = scale or 0.1\n            fg = fg or (1, 1, 0, 1)\n            bg = bg or (0, 0, 0, 0)\n            shadow = shadow or (0, 0, 0, 1)\n            frame = frame or (0, 0, 0, 0)\n            if align is None:\n                align = TextNode.ACenter\n        elif style == NameConfirm:\n            scale = scale or 0.1\n            fg = fg or (0, 1, 0, 1)\n            bg = bg or (0, 0, 0, 0)\n            shadow = shadow or (0, 0, 0, 0)\n            frame = frame or (0, 0, 0, 0)\n            if align is None:\n                align = TextNode.ACenter\n        elif style == BlackOnWhite:\n            scale = scale or 0.1\n            fg = fg or (0, 0, 0, 1)\n            bg = bg or (1, 1, 1, 1)\n            shadow = shadow or (0, 0, 0, 0)\n            frame = frame or (0, 0, 0, 0)\n            if align is None:\n                align = TextNode.ACenter\n        else:\n            raise ValueError\n\n        if not isinstance(scale, tuple):\n            # If the scale is already a tuple, it's a 2-d (x, y) scale.\n            # Otherwise, it's a uniform scale--make it a tuple.\n            scale = (scale, scale)\n\n        # Save some of the parameters for posterity.\n        self.__scale = scale\n        self.__pos = pos\n        self.__roll = roll\n        self.__wordwrap = wordwrap\n\n        if decal:\n            textNode.setCardDecal(True)\n\n        if font is None:\n            font = DGG.getDefaultFont()\n\n        textNode.setFont(font)\n        textNode.setTextColor(fg[0], fg[1], fg[2], fg[3])\n        textNode.setAlign(align)\n\n        if wordwrap:\n            textNode.setWordwrap(wordwrap)\n\n        if bg[3] != 0:\n            # If we have a background color, create a card.\n            textNode.setCardColor(bg[0], bg[1], bg[2], bg[3])\n            textNode.setCardAsMargin(0.1, 0.1, 0.1, 0.1)\n\n        if shadow[3] != 0:\n            # If we have a shadow color, create a shadow.\n            # Can't use the *shadow interface because it might be a VBase4.\n            #textNode.setShadowColor(*shadow)\n            textNode.setShadowColor(shadow[0], shadow[1], shadow[2], shadow[3])\n            textNode.setShadow(*shadowOffset)\n\n        if frame[3] != 0:\n            # If we have a frame color, create a frame.\n            textNode.setFrameColor(frame[0], frame[1], frame[2], frame[3])\n            textNode.setFrameAsMargin(0.1, 0.1, 0.1, 0.1)\n\n        if direction is not None:\n            if isinstance(direction, str):\n                direction = direction.lower()\n                if direction == 'rtl':\n                    direction = TextProperties.D_rtl\n                elif direction == 'ltr':\n                    direction = TextProperties.D_ltr\n                else:\n                    raise ValueError('invalid direction')\n            textNode.setDirection(direction)\n\n        # Create a transform for the text for our scale and position.\n        # We'd rather do it here, on the text itself, rather than on\n        # our NodePath, so we have one fewer transforms in the scene\n        # graph.\n        self.updateTransformMat()\n\n        if drawOrder is not None:\n            textNode.setBin('fixed')\n            textNode.setDrawOrder(drawOrder)\n\n        self.setText(text)\n        if not text:\n            # If we don't have any text, assume we'll be changing it later.\n            self.mayChange = 1\n        else:\n            self.mayChange = mayChange\n\n        # Ok, now update the node.\n        if not self.mayChange:\n            # If we aren't going to change the text later, we can\n            # throw away the TextNode.\n            self.textNode = textNode.generate()\n\n        self.isClean = 0\n\n        # Set ourselves up as the NodePath that points to this node.\n        self.assign(parent.attachNewNode(self.textNode, sort))\n\n    def cleanup(self):\n        self.textNode = None\n        if self.isClean == 0:\n            self.isClean = 1\n            self.removeNode()\n\n    def destroy(self):\n        self.cleanup()\n\n    def freeze(self):\n        pass\n\n    def thaw(self):\n        pass\n\n    # Allow changing of several of the parameters after the text has\n    # been created.  These should be used with caution; it is better\n    # to set all the parameters up front.  These functions are\n    # primarily intended for interactive placement of the initial\n    # text, and for those rare occasions when you actually want to\n    # change a text's property after it has been created.\n\n    def setDecal(self, decal):\n        self.textNode.setCardDecal(decal)\n\n    def getDecal(self):\n        return self.textNode.getCardDecal()\n\n    decal = property(getDecal, setDecal)\n\n    def setFont(self, font):\n        self.textNode.setFont(font)\n\n    def getFont(self):\n        return self.textNode.getFont()\n\n    font = property(getFont, setFont)\n\n    def clearText(self):\n        self.textNode.clearText()\n\n    def setText(self, text):\n        assert not isinstance(text, bytes)\n        self.textNode.setWtext(text)\n\n    def appendText(self, text):\n        assert not isinstance(text, bytes)\n        self.textNode.appendWtext(text)\n\n    def getText(self):\n        return self.textNode.getWtext()\n\n    text = property(getText, setText)\n\n    def setTextX(self, x):\n        \"\"\"\n        .. versionadded:: 1.10.8\n        \"\"\"\n        self.setTextPos(x, self.__pos[1])\n\n    def setX(self, x):\n        \"\"\"\n        .. deprecated:: 1.11.0\n           Use `.setTextX()` method instead.\n        \"\"\"\n        if __debug__:\n            warnings.warn(\"Use `.setTextX()` method instead.\", DeprecationWarning, stacklevel=2)\n        self.setTextPos(x, self.__pos[1])\n\n    def setTextY(self, y):\n        \"\"\"\n        .. versionadded:: 1.10.8\n        \"\"\"\n        self.setTextPos(self.__pos[0], y)\n\n    def setY(self, y):\n        \"\"\"\n        .. deprecated:: 1.11.0\n           Use `.setTextY()` method instead.\n        \"\"\"\n        if __debug__:\n            warnings.warn(\"Use `.setTextY()` method instead.\", DeprecationWarning, stacklevel=2)\n        self.setTextPos(self.__pos[0], y)\n\n    def setTextPos(self, x, y=None):\n        \"\"\"\n        Position the onscreen text in 2d screen space\n\n        .. versionadded:: 1.10.8\n        \"\"\"\n        if y is None:\n            self.__pos = tuple(x)\n        else:\n            self.__pos = (x, y)\n        self.updateTransformMat()\n\n    def getTextPos(self):\n        \"\"\"\n        .. versionadded:: 1.10.8\n        \"\"\"\n        return self.__pos\n\n    text_pos = property(getTextPos, setTextPos)\n\n    def setPos(self, x, y):\n        \"\"\"setPos(self, float, float)\n        Position the onscreen text in 2d screen space\n\n        .. deprecated:: 1.11.0\n           Use `.setTextPos()` method or `.text_pos` property instead.\n        \"\"\"\n        if __debug__:\n            warnings.warn(\"Use `.setTextPos()` method or `.text_pos` property instead.\", DeprecationWarning, stacklevel=2)\n        self.__pos = (x, y)\n        self.updateTransformMat()\n\n    def getPos(self):\n        \"\"\"\n        .. deprecated:: 1.11.0\n           Use `.getTextPos()` method or `.text_pos` property instead.\n        \"\"\"\n        if __debug__:\n            warnings.warn(\"Use `.getTextPos()` method or `.text_pos` property instead.\", DeprecationWarning, stacklevel=2)\n        return self.__pos\n\n    pos = property(getPos)\n\n    def setTextR(self, r):\n        \"\"\"setTextR(self, float)\n        Rotates the text around the screen's normal.\n\n        .. versionadded:: 1.10.8\n        \"\"\"\n        self.__roll = -r\n        self.updateTransformMat()\n\n    def getTextR(self):\n        return -self.__roll\n\n    text_r = property(getTextR, setTextR)\n\n    def setRoll(self, roll):\n        \"\"\"setRoll(self, float)\n        Rotate the onscreen text around the screen's normal.\n\n        .. deprecated:: 1.11.0\n           Use ``setTextR(-roll)`` instead (note the negated sign).\n        \"\"\"\n        if __debug__:\n            warnings.warn(\"Use ``setTextR(-roll)`` instead (note the negated sign).\", DeprecationWarning, stacklevel=2)\n        self.__roll = roll\n        self.updateTransformMat()\n\n    def getRoll(self):\n        \"\"\"\n        .. deprecated:: 1.11.0\n           Use ``-getTextR()`` instead (note the negated sign).\n        \"\"\"\n        if __debug__:\n            warnings.warn(\"Use ``-getTextR()`` instead (note the negated sign).\", DeprecationWarning, stacklevel=2)\n        return self.__roll\n\n    roll = property(getRoll, setRoll)\n\n    def setTextScale(self, sx, sy = None):\n        \"\"\"setTextScale(self, float, float)\n        Scale the text in 2d space.  You may specify either a single\n        uniform scale, or two scales, or a tuple of two scales.\n\n        .. versionadded:: 1.10.8\n        \"\"\"\n\n        if sy is None:\n            if isinstance(sx, tuple):\n                self.__scale = sx\n            else:\n                self.__scale = (sx, sx)\n        else:\n            self.__scale = (sx, sy)\n        self.updateTransformMat()\n\n    def getTextScale(self):\n        \"\"\"\n        .. versionadded:: 1.10.8\n        \"\"\"\n        return self.__scale\n\n    text_scale = property(getTextScale, setTextScale)\n\n    def setScale(self, sx, sy = None):\n        \"\"\"setScale(self, float, float)\n        Scale the text in 2d space.  You may specify either a single\n        uniform scale, or two scales, or a tuple of two scales.\n\n        .. deprecated:: 1.11.0\n           Use `.setTextScale()` method or `.text_scale` property instead.\n        \"\"\"\n        if __debug__:\n            warnings.warn(\"Use `.setTextScale()` method or `.text_scale` property instead.\", DeprecationWarning, stacklevel=2)\n        if sy is None:\n            if isinstance(sx, tuple):\n                self.__scale = sx\n            else:\n                self.__scale = (sx, sx)\n        else:\n            self.__scale = (sx, sy)\n        self.updateTransformMat()\n\n    def getScale(self):\n        \"\"\"\n        .. deprecated:: 1.11.0\n           Use `.getTextScale()` method or `.text_scale` property instead.\n        \"\"\"\n        if __debug__:\n            warnings.warn(\"Use `.getTextScale()` method or `.text_scale` property instead.\", DeprecationWarning, stacklevel=2)\n        return self.__scale\n\n    scale = property(getScale, setScale)\n\n    def updateTransformMat(self):\n        assert isinstance(self.textNode, TextNode)\n        mat = (\n            Mat4.scaleMat(Vec3.rfu(self.__scale[0], 1, self.__scale[1])) *\n            Mat4.rotateMat(self.__roll, Vec3.back()) *\n            Mat4.translateMat(Point3.rfu(self.__pos[0], 0, self.__pos[1]))\n        )\n        self.textNode.setTransform(mat)\n\n    def setWordwrap(self, wordwrap):\n        self.__wordwrap = wordwrap\n\n        if wordwrap:\n            self.textNode.setWordwrap(wordwrap)\n        else:\n            self.textNode.clearWordwrap()\n\n    def getWordwrap(self):\n        return self.__wordwrap\n\n    wordwrap = property(getWordwrap, setWordwrap)\n\n    def __getFg(self):\n        return self.textNode.getTextColor()\n\n    def setFg(self, fg):\n        self.textNode.setTextColor(fg[0], fg[1], fg[2], fg[3])\n\n    fg = property(__getFg, setFg)\n\n    def __getBg(self):\n        if self.textNode.hasCard():\n            return self.textNode.getCardColor()\n        else:\n            return LColor(0)\n\n    def setBg(self, bg):\n        if bg[3] != 0:\n            # If we have a background color, create a card.\n            self.textNode.setCardColor(bg[0], bg[1], bg[2], bg[3])\n            self.textNode.setCardAsMargin(0.1, 0.1, 0.1, 0.1)\n        else:\n            # Otherwise, remove the card.\n            self.textNode.clearCard()\n\n    bg = property(__getBg, setBg)\n\n    def __getShadow(self):\n        return self.textNode.getShadowColor()\n\n    def setShadow(self, shadow):\n        if shadow[3] != 0:\n            # If we have a shadow color, create a shadow.\n            self.textNode.setShadowColor(shadow[0], shadow[1], shadow[2], shadow[3])\n            self.textNode.setShadow(0.04, 0.04)\n        else:\n            # Otherwise, remove the shadow.\n            self.textNode.clearShadow()\n\n    shadow = property(__getShadow, setShadow)\n\n    def __getFrame(self):\n        return self.textNode.getFrameColor()\n\n    def setFrame(self, frame):\n        if frame[3] != 0:\n            # If we have a frame color, create a frame.\n            self.textNode.setFrameColor(frame[0], frame[1], frame[2], frame[3])\n            self.textNode.setFrameAsMargin(0.1, 0.1, 0.1, 0.1)\n        else:\n            # Otherwise, remove the frame.\n            self.textNode.clearFrame()\n\n    frame = property(__getFrame, setFrame)\n\n    def configure(self, option=None, **kw):\n        # These is for compatibility with DirectGui functions\n        if not self.mayChange:\n            print('OnscreenText.configure: mayChange == 0')\n            return\n        for option, value in kw.items():\n            # Use option string to access setter function\n            try:\n                if option == 'pos':\n                    self.setTextPos(value[0], value[1])\n                elif option == 'roll':\n                    self.setTextR(-value)\n                elif option == 'scale':\n                    self.setTextScale(value)\n                elif option == 'x':\n                    self.setTextX(value)\n                elif option == 'y':\n                    self.setTextY(value)\n                else:\n                    setter = getattr(self, 'set' + option[0].upper() + option[1:])\n                    setter(value)\n            except AttributeError:\n                print('OnscreenText.configure: invalid option: %s' % option)\n\n    # Allow index style references\n    def __setitem__(self, key, value):\n        self.configure(*(), **{key: value})\n\n    def cget(self, option):\n        # Get current configuration setting.\n        # This is for compatibility with DirectGui functions\n        if option == 'pos':\n            return self.__pos\n        elif option == 'roll':\n            return self.__roll\n        elif option == 'scale':\n            return self.__scale\n        elif option == 'x':\n            return self.__pos[0]\n        elif option == 'y':\n            return self.__pos[1]\n\n        getter = getattr(self, 'get' + option[0].upper() + option[1:])\n        return getter()\n\n    def __getAlign(self):\n        return self.textNode.getAlign()\n\n    def setAlign(self, align):\n        self.textNode.setAlign(align)\n\n    align = property(__getAlign, setAlign)\n\n    # Allow index style refererences\n    __getitem__ = cget\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/gui/OnscreenText.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/de45d2f7_OnscreenText.json",
    "doc_id": "doc_82"
  }
}