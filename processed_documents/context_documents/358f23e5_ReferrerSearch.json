{
  "content": "import inspect\nimport sys\nimport gc\nfrom direct.showbase.PythonUtil import _getSafeReprNotify, fastRepr\nfrom direct.showbase.Job import Job\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.task.TaskManagerGlobal import taskMgr\n\n\nclass ReferrerSearch(Job):\n    def __init__(self, obj, maxRefs = 100):\n        Job.__init__(self, 'ReferrerSearch')\n        self.obj = obj\n        self.maxRefs = maxRefs\n        self.visited = set()\n        self.depth = 0\n        self.found = 0\n        self.shouldPrintStats = False\n\n    def __call__(self):\n        safeReprNotify = _getSafeReprNotify()\n        info = safeReprNotify.getInfo()\n        safeReprNotify.setInfo(0)\n\n        self.visited = set()\n        try:\n            self.step(0, [self.obj])\n        finally:\n            self.obj = None\n\n        safeReprNotify.setInfo(info)\n\n    def run(self):\n        safeReprNotify = _getSafeReprNotify()\n        self.info = safeReprNotify.getInfo()\n        safeReprNotify.setInfo(0)\n\n        print('RefPath(%s): Beginning ReferrerSearch for %s' %(self._id, fastRepr(self.obj)))\n\n        self.visited = set()\n        for x in self.stepGenerator(0, [self.obj]):\n            yield None\n\n        yield Job.Done\n\n    def finished(self):\n        print('RefPath(%s): Finished ReferrerSearch for %s' %(self._id, fastRepr(self.obj)))\n        self.obj = None\n\n        safeReprNotify = _getSafeReprNotify()\n        safeReprNotify.setInfo(self.info)\n\n    def __del__(self):\n        print('ReferrerSearch garbage collected')\n\n    def truncateAtNewLine(self, s):\n        if s.find('\\n') == -1:\n            return s\n        else:\n            return s[:s.find('\\n')]\n\n    def printStatsWhenAble(self):\n        self.shouldPrintStats = True\n\n    def myrepr(self, referrer, refersTo):\n        pre = ''\n        if isinstance(referrer, dict):\n            for k,v in referrer.items():\n                if v is refersTo:\n                    pre = self.truncateAtNewLine(fastRepr(k)) + ']-> '\n                    break\n        elif isinstance(referrer, (list, tuple)):\n            for x, ref in enumerate(referrer):\n                if ref is refersTo:\n                    pre = '%s]-> ' % (x)\n                    break\n\n        if isinstance(refersTo, dict):\n            post = 'dict['\n        elif isinstance(refersTo, list):\n            post = 'list['\n        elif isinstance(refersTo, tuple):\n            post = 'tuple['\n        elif isinstance(refersTo, set):\n            post = 'set->'\n        else:\n            post = self.truncateAtNewLine(fastRepr(refersTo)) + \"-> \"\n\n        return '%s%s' % (pre, post)\n\n    def step(self, depth, path):\n        if self.shouldPrintStats:\n            self.printStats(path)\n            self.shouldPrintStats = False\n\n        at = path[-1]\n\n        if id(at) in self.visited:\n            # don't continue down this path\n            return\n\n        # check for success\n        if self.isAtRoot(at, path):\n            self.found += 1\n            return\n\n        # mark our progress after checking goal\n        self.visited.add(id(at))\n\n        referrers = [ref for ref in gc.get_referrers(at) \\\n                     if not (ref is path or \\\n                       inspect.isframe(ref) or \\\n                       (isinstance(ref, dict) and \\\n                        list(ref.keys()) == list(locals().keys())) or \\\n                       ref is self.__dict__ or \\\n                       id(ref) in self.visited)]\n\n        # Check to see if this object has an unusually large\n        # ref-count.  This usually indicates that it is some\n        # sort of global, singleton, or manager object\n        # and as such no further knowledge would be gained from\n        # traversing further up the ref tree.\n        if self.isManyRef(at, path, referrers):\n            return\n\n        while referrers:\n            ref = referrers.pop()\n            self.depth += 1\n            for x in self.stepGenerator(depth + 1, path + [ref]):\n                pass\n            self.depth -= 1\n\n    def stepGenerator(self, depth, path):\n        if self.shouldPrintStats:\n            self.printStats(path)\n\n            self.shouldPrintStats = False\n\n        at = path[-1]\n\n        # check for success\n        if self.isAtRoot(at, path):\n            self.found += 1\n            raise StopIteration\n\n        if id(at) in self.visited:\n            # don't continue down this path\n            raise StopIteration\n\n        # mark our progress after checking goal\n        self.visited.add(id(at))\n\n        # Look for all referrers, culling out the ones that\n        # we know to be red herrings.\n        referrers = [ref for ref in gc.get_referrers(at) \\\n                     if not (# we disregard the steps of our traversal\n                             ref is path or \\\n                             # The referrer is this call frame\n                             inspect.isframe(ref) or \\\n                             # The referrer is the locals() dictionary (closure)\n                             (isinstance(ref, dict) and list(ref.keys()) == list(locals().keys())) or \\\n                             # We found the reference on self\n                             ref is self.__dict__ or \\\n                             # We've already seen this referrer\n                             id(ref) in self.visited)]\n\n        # Check to see if this object has an unusually large\n        # ref-count.  This usually indicates that it is some\n        # sort of global, singleton, or manager object\n        # and as such no further knowledge would be gained from\n        # traversing further up the ref tree.\n        if self.isManyRef(at, path, referrers):\n            raise StopIteration\n\n        while referrers:\n            ref = referrers.pop()\n            self.depth += 1\n            for x in self.stepGenerator(depth + 1, path + [ref]):\n                yield None\n            self.depth -= 1\n\n        yield None\n\n    def printStats(self, path):\n        path = list(reversed(path))\n        path.insert(0,0)\n        print('RefPath(%s) - Stats - visited(%s) | found(%s) | depth(%s) | CurrentPath(%s)' % \\\n              (self._id, len(self.visited), self.found, self.depth, ''.join(self.myrepr(path[x], path[x+1]) for x in range(len(path) - 1))))\n\n    def isAtRoot(self, at, path):\n        # Now we define our 'roots', or places where we will\n        # end this particular thread of search\n\n        # We found a circular reference\n        if at in path:\n            sys.stdout.write(\"RefPath(%s): Circular: \" % self._id)\n            path = list(reversed(path))\n            path.insert(0,0)\n            for x in range(len(path) - 1):\n                sys.stdout.write(self.myrepr(path[x], path[x+1]))\n            print(\"\")\n            return True\n\n        # __builtins__\n        if at is __builtins__:\n            sys.stdout.write(\"RefPath(%s): __builtins__-> \" % self._id)\n            path = list(reversed(path))\n            path.insert(0,0)\n            for x in range(len(path) - 1):\n                sys.stdout.write(self.myrepr(path[x], path[x+1]))\n            print(\"\")\n            return True\n\n        # any module scope\n        if inspect.ismodule(at):\n            sys.stdout.write(\"RefPath(%s): Module(%s)-> \" % (self._id, at.__name__))\n            path = list(reversed(path))\n            for x in range(len(path) - 1):\n                sys.stdout.write(self.myrepr(path[x], path[x+1]))\n            print(\"\")\n            return True\n\n        # any class scope\n        if inspect.isclass(at):\n            sys.stdout.write(\"RefPath(%s): Class(%s)-> \" % (self._id, at.__name__))\n            path = list(reversed(path))\n            for x in range(len(path) - 1):\n                sys.stdout.write(self.myrepr(path[x], path[x+1]))\n            print(\"\")\n            return True\n\n        # simbase\n        if at is simbase:\n            sys.stdout.write(\"RefPath(%s): simbase-> \" % self._id)\n            path = list(reversed(path))\n            for x in range(len(path) - 1):\n                sys.stdout.write(self.myrepr(path[x], path[x+1]))\n            print(\"\")\n            return True\n\n        # simbase.air\n        if at is simbase.air:\n            sys.stdout.write(\"RefPath(%s): simbase.air-> \" % self._id)\n            path = list(reversed(path))\n            for x in range(len(path) - 1):\n                sys.stdout.write(self.myrepr(path[x], path[x+1]))\n            print(\"\")\n            return True\n\n        # messenger\n        if at is messenger:\n            sys.stdout.write(\"RefPath(%s): messenger-> \" % self._id)\n            path = list(reversed(path))\n            for x in range(len(path) - 1):\n                sys.stdout.write(self.myrepr(path[x], path[x+1]))\n            print(\"\")\n            return True\n\n        # taskMgr\n        if at is taskMgr:\n            sys.stdout.write(\"RefPath(%s): taskMgr-> \" % self._id)\n            path = list(reversed(path))\n            for x in range(len(path) - 1):\n                sys.stdout.write(self.myrepr(path[x], path[x+1]))\n            print(\"\")\n            return True\n\n        # world\n        if hasattr(simbase.air, 'mainWorld') and at is simbase.air.mainWorld:\n            sys.stdout.write(\"RefPath(%s): mainWorld-> \" % self._id)\n            path = list(reversed(path))\n            for x in range(len(path) - 1):\n                sys.stdout.write(self.myrepr(path[x], path[x+1]))\n            print(\"\")\n            return True\n\n        return False\n\n    def isManyRef(self, at, path, referrers):\n        if (len(referrers) > self.maxRefs and \\\n            at is not self.obj):\n            if not isinstance(at, (list, tuple, dict, set)):\n                sys.stdout.write(\"RefPath(%s): ManyRefs(%s)[%s]-> \" % (self._id, len(referrers), fastRepr(at)))\n                path = list(reversed(path))\n                path.insert(0,0)\n                for x in range(len(path) - 1):\n                    sys.stdout.write(self.myrepr(path[x], path[x+1]))\n                print(\"\")\n                return True\n            else:\n                sys.stdout.write(\"RefPath(%s): ManyRefsAllowed(%s)[%s]-> \" % (self._id, len(referrers), fastRepr(at, maxLen = 1, strFactor = 30)))\n                print(\"\")\n        return False\n\n\n#from direct.showbase.ReferrerSearch import ReferrerSearch\n#door = simbase.air.doFind(\"DistributedBuildingDoorAI\")\n#class A: pass\n#door = A()\n#ReferrerSearch()(door)\n#reload(ReferrerSearch); from direct.showbase.PythonUtil import ReferrerSearch\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/ReferrerSearch.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/358f23e5_ReferrerSearch.json",
    "doc_id": "doc_279"
  }
}