{
  "content": "\nfrom direct.showbase.InputStateGlobal import inputState\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.task.Task import Task\nfrom panda3d.core import ClockObject, Mat3, Point3, Vec3\nfrom . import GravityWalker\n\nBattleStrafe = 0\n\ndef ToggleStrafe():\n    global BattleStrafe\n    BattleStrafe = not BattleStrafe\n\ndef SetStrafe(status):\n    global BattleStrafe\n    BattleStrafe = status\n\nclass BattleWalker(GravityWalker.GravityWalker):\n    def __init__(self):\n        GravityWalker.GravityWalker.__init__(self)\n        self.slideSpeed = 0\n        self.advanceSpeed = 0\n\n    def getSpeeds(self):\n        return (self.speed, self.rotationSpeed, self.slideSpeed, self.advanceSpeed)\n\n    def handleAvatarControls(self, task):\n        \"\"\"\n        Check on the arrow keys and update the avatar.\n        \"\"\"\n        # get the button states:\n        run = inputState.isSet(\"run\")\n        forward = inputState.isSet(\"forward\")\n        reverse = inputState.isSet(\"reverse\")\n        turnLeft = inputState.isSet(\"turnLeft\")\n        turnRight = inputState.isSet(\"turnRight\")\n        slideLeft = inputState.isSet(\"slideLeft\")\n        slideRight = inputState.isSet(\"slideRight\")\n        jump = inputState.isSet(\"jump\")\n\n        # Check for Auto-Run\n        if base.localAvatar.getAutoRun():\n            forward = 1\n            reverse = 0\n\n        # Determine what the speeds are based on the buttons:\n        self.speed=(forward and self.avatarControlForwardSpeed or\n                    reverse and -self.avatarControlReverseSpeed)\n        # Slide speed is a scaled down version of forward speed\n        self.slideSpeed=(slideLeft and -self.avatarControlForwardSpeed or\n                         slideRight and self.avatarControlForwardSpeed) * 0.5\n        self.rotationSpeed=not (slideLeft or slideRight) and (\n                (turnLeft and self.avatarControlRotateSpeed) or\n                (turnRight and -self.avatarControlRotateSpeed))\n\n        debugRunning = inputState.isSet(\"debugRunning\")\n\n        if debugRunning:\n            self.speed*=base.debugRunningMultiplier\n            self.slideSpeed*=base.debugRunningMultiplier\n            self.rotationSpeed*=1.25\n\n        if self.needToDeltaPos:\n            self.setPriorParentVector()\n            self.needToDeltaPos = 0\n        if self.wantDebugIndicator:\n            self.displayDebugInfo()\n        if self.lifter.isOnGround():\n            if self.isAirborne:\n                self.isAirborne = 0\n                assert self.debugPrint(\"isAirborne 0 due to isOnGround() true\")\n                impact = self.lifter.getImpactVelocity()\n                if impact < -30.0:\n                    messenger.send(\"jumpHardLand\")\n                    self.startJumpDelay(0.3)\n                else:\n                    messenger.send(\"jumpLand\")\n                    if impact < -5.0:\n                        self.startJumpDelay(0.2)\n                    # else, ignore the little potholes.\n            assert self.isAirborne == 0\n            self.priorParent = Vec3.zero()\n            if jump and self.mayJump:\n                # The jump button is down and we're close\n                # enough to the ground to jump.\n                self.lifter.addVelocity(self.avatarControlJumpForce)\n                messenger.send(\"jumpStart\")\n                self.isAirborne = 1\n                assert self.debugPrint(\"isAirborne 1 due to jump\")\n        else:\n            if self.isAirborne == 0:\n                assert self.debugPrint(\"isAirborne 1 due to isOnGround() false\")\n            self.isAirborne = 1\n\n        self.__oldPosDelta = self.avatarNodePath.getPosDelta(render)\n        # How far did we move based on the amount of time elapsed?\n        self.__oldDt = ClockObject.getGlobalClock().getDt()\n        dt=self.__oldDt\n\n        # Check to see if we're moving at all:\n        self.moving = self.speed or self.slideSpeed or self.rotationSpeed or (self.priorParent!=Vec3.zero())\n        if self.moving:\n            distance = dt * self.speed\n            slideDistance = dt * self.slideSpeed\n            rotation = dt * self.rotationSpeed\n\n            # Take a step in the direction of our previous heading.\n            if distance or slideDistance or self.priorParent != Vec3.zero():\n                # rotMat is the rotation matrix corresponding to\n                # our previous heading.\n                rotMat=Mat3.rotateMatNormaxis(self.avatarNodePath.getH(), Vec3.up())\n                if self.isAirborne:\n                    forward = Vec3.forward()\n                else:\n                    contact = self.lifter.getContactNormal()\n                    forward = contact.cross(Vec3.right())\n                    # Consider commenting out this normalize.  If you do so\n                    # then going up and down slops is a touch slower and\n                    # steeper terrain can cut the movement in half.  Without\n                    # the normalize the movement is slowed by the cosine of\n                    # the slope (i.e. it is multiplied by the sign as a\n                    # side effect of the cross product above).\n                    forward.normalize()\n                self.vel=Vec3(forward * distance)\n                if slideDistance:\n                    if self.isAirborne:\n                        right = Vec3.right()\n                    else:\n                        right = forward.cross(contact)\n                        # See note above for forward.normalize()\n                        right.normalize()\n                    self.vel=Vec3(self.vel + (right * slideDistance))\n                self.vel=Vec3(rotMat.xform(self.vel))\n                step=self.vel + (self.priorParent * dt)\n                self.avatarNodePath.setFluidPos(Point3(\n                        self.avatarNodePath.getPos()+step))\n            self.avatarNodePath.setH(self.avatarNodePath.getH()+rotation)\n        else:\n            self.vel.set(0.0, 0.0, 0.0)\n        if self.moving or jump:\n            messenger.send(\"avatarMoving\")\n        return Task.cont\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/controls/BattleWalker.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/df5d144c_BattleWalker.json",
    "doc_id": "doc_230"
  }
}