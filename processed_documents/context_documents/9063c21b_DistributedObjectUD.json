{
  "content": "\"\"\"DistributedObjectUD module: contains the DistributedObjectUD class\"\"\"\n\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.distributed.DistributedObjectBase import DistributedObjectBase\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.showbase import PythonUtil\n#from PyDatagram import PyDatagram\n#from PyDatagramIterator import PyDatagramIterator\n\nclass DistributedObjectUD(DistributedObjectBase):\n    notify = directNotify.newCategory(\"DistributedObjectUD\")\n    QuietZone = 1\n\n    def __init__(self, air):\n        if not hasattr(self, 'DistributedObjectUD_initialized'):\n            self.DistributedObjectUD_initialized = 1\n            DistributedObjectBase.__init__(self, air)\n\n            self.accountName = ''\n            # Record the repository\n            self.air = air\n\n            # Record our distributed class\n            className = self.__class__.__name__\n            self.dclass = self.air.dclassesByName[className]\n            # init doId pre-allocated flag\n            self.__preallocDoId = 0\n\n            # used to track zone changes across the quiet zone\n            # NOTE: the quiet zone is defined in OTP, but we need it\n            # here.\n            self.lastNonQuietZone = None\n\n            self._DOUD_requestedDelete = False\n\n            # These are used to implement beginBarrier().\n            self.__nextBarrierContext = 0\n            self.__barriers = {}\n\n            self.__generated = False\n            # reference count for multiple inheritance\n            self.__generates = 0\n\n    # Uncomment if you want to debug DO leaks\n    #def __del__(self):\n    #    \"\"\"\n    #    For debugging purposes, this just prints out what got deleted\n    #    \"\"\"\n    #    print (\"Destructing: \" + self.__class__.__name__)\n\n    if __debug__:\n        def status(self, indent=0):\n            \"\"\"\n            print out doId(parentId, zoneId) className\n                and conditionally show generated or deleted\n            \"\"\"\n            spaces = ' ' * (indent + 2)\n            try:\n                print(\"%s%s:\" % (' ' * indent, self.__class__.__name__))\n\n                flags = []\n                if self.__generated:\n                    flags.append(\"generated\")\n                if self.air is None:\n                    flags.append(\"deleted\")\n\n                flagStr = \"\"\n                if len(flags) > 0:\n                    flagStr = \" (%s)\" % (\" \".join(flags))\n\n                print(\"%sfrom DistributedObject doId:%s, parent:%s, zone:%s%s\" % (\n                    spaces, self.doId, self.parentId, self.zoneId, flagStr))\n            except Exception as e:\n                print(\"%serror printing status %s\" % (spaces, e))\n\n    def getDeleteEvent(self):\n        # this is sent just before we get deleted\n        if hasattr(self, 'doId'):\n            return 'distObjDelete-%s' % self.doId\n        return None\n\n    def sendDeleteEvent(self):\n        # this is called just before we get deleted\n        delEvent = self.getDeleteEvent()\n        if delEvent:\n            messenger.send(delEvent)\n\n    def delete(self):\n        \"\"\"\n        Inheritors should redefine this to take appropriate action on delete\n        Note that this may be called multiple times if a class inherits\n        from DistributedObjectUD more than once.\n        \"\"\"\n        self.__generates -= 1\n        if self.__generates < 0:\n            self.notify.debug('DistributedObjectUD: delete() called more times than generate()')\n        if self.__generates == 0:\n            # prevent this code from executing multiple times\n            if self.air is not None:\n                # self.doId may not exist.  The __dict__ syntax works around that.\n                assert self.notify.debug('delete(): %s' % (self.__dict__.get(\"doId\")))\n\n                #if not self._DOUD_requestedDelete:\n                #    # this logs every delete that was not requested by us.\n                #    # TODO: this currently prints warnings for deletes of objects\n                #    # that we did not create. We need to add a 'locally created'\n                #    # flag to every object to filter these out.\n                #\n                #    DistributedObjectUD.notify.warning(\n                #        'delete() called but requestDelete never called for %s: %s'\n                #        % (self.__dict__.get('doId'), self.__class__.__name__))\n                #\n                #    # print a stack trace so we can detect whether this is the\n                #    # result of a network msg.\n                #    # this is slow.\n                #    from direct.showbase.PythonUtil import StackTrace\n                #    DistributedObjectUD.notify.warning(\n                #        'stack trace: %s' % StackTrace())\n\n                self._DOUD_requestedDelete = False\n\n                # Clean up all the pending barriers.\n                for barrier in self.__barriers.values():\n                    barrier.cleanup()\n                self.__barriers = {}\n\n                # Asad: As per Roger's suggestion, turn off the following block until a solution is\n                # Thought out of how to prevent this delete message or to handle this message better\n##              if not hasattr(self, \"doNotDeallocateChannel\"):\n##                  if self.air:\n##                      self.air.deallocateChannel(self.doId)\n##              self.air = None\n                self.parentId = None\n                self.zoneId = None\n                self.__generated = False\n\n    def isDeleted(self):\n        \"\"\"\n        Returns true if the object has been deleted,\n        or if it is brand new and hasnt yet been generated.\n        \"\"\"\n        return self.air is None\n\n    def isGenerated(self):\n        \"\"\"\n        Returns true if the object has been generated\n        \"\"\"\n        return self.__generated\n\n    def getDoId(self):\n        \"\"\"\n        Return the distributed object id\n        \"\"\"\n        return self.doId\n\n    def preAllocateDoId(self):\n        \"\"\"\n        objects that need to have a doId before they are generated\n        can call this to pre-allocate a doId for the object\n        \"\"\"\n        assert not self.__preallocDoId\n        self.doId = self.air.allocateChannel()\n        self.__preallocDoId = 1\n\n    def announceGenerate(self):\n        \"\"\"\n        Called after the object has been generated and all\n        of its required fields filled in. Overwrite when needed.\n        \"\"\"\n        self.__generated = True\n\n    def postGenerateMessage(self):\n        messenger.send(self.uniqueName(\"generate\"), [self])\n\n    def addInterest(self, zoneId, note=\"\", event=None):\n        self.air.addInterest(self.getDoId(), zoneId, note, event)\n\n    def b_setLocation(self, parentId, zoneId):\n        self.d_setLocation(parentId, zoneId)\n        self.setLocation(parentId, zoneId)\n\n    def d_setLocation(self, parentId, zoneId):\n        self.air.sendSetLocation(self, parentId, zoneId)\n\n    def setLocation(self, parentId, zoneId):\n        self.air.storeObjectLocation(self, parentId, zoneId)\n\n    def getLocation(self):\n        try:\n            if self.parentId <= 0 and self.zoneId <= 0:\n                return None\n            # This is a -1 stuffed into a uint32\n            if self.parentId == 0xffffffff and self.zoneId == 0xffffffff:\n                return None\n            return (self.parentId, self.zoneId)\n        except AttributeError:\n            return None\n\n    def updateRequiredFields(self, dclass, di):\n        dclass.receiveUpdateBroadcastRequired(self, di)\n        self.announceGenerate()\n        self.postGenerateMessage()\n\n    def updateAllRequiredFields(self, dclass, di):\n        dclass.receiveUpdateAllRequired(self, di)\n        self.announceGenerate()\n        self.postGenerateMessage()\n\n    def updateRequiredOtherFields(self, dclass, di):\n        dclass.receiveUpdateBroadcastRequired(self, di)\n        # Announce generate after updating all the required fields,\n        # but before we update the non-required fields.\n        self.announceGenerate()\n        self.postGenerateMessage()\n\n        dclass.receiveUpdateOther(self, di)\n\n    def updateAllRequiredOtherFields(self, dclass, di):\n        dclass.receiveUpdateAllRequired(self, di)\n        # Announce generate after updating all the required fields,\n        # but before we update the non-required fields.\n        self.announceGenerate()\n        self.postGenerateMessage()\n\n        dclass.receiveUpdateOther(self, di)\n\n    def sendSetZone(self, zoneId):\n        self.air.sendSetZone(self, zoneId)\n\n    def getZoneChangeEvent(self):\n        # this event is generated whenever this object changes zones.\n        # arguments are newZoneId, oldZoneId\n        # includes the quiet zone.\n        return 'DOChangeZone-%s' % self.doId\n\n    def getLogicalZoneChangeEvent(self):\n        # this event is generated whenever this object changes to a\n        # non-quiet-zone zone.\n        # arguments are newZoneId, oldZoneId\n        # does not include the quiet zone.\n        return 'DOLogicalChangeZone-%s' % self.doId\n\n    def handleLogicalZoneChange(self, newZoneId, oldZoneId):\n        \"\"\"this function gets called as if we never go through the\n        quiet zone. Note that it is called once you reach the newZone,\n        and not at the time that you leave the oldZone.\"\"\"\n        messenger.send(self.getLogicalZoneChangeEvent(),\n                       [newZoneId, oldZoneId])\n\n    def getRender(self):\n        # note that this will return a different node if we change zones\n        return self.air.getRender(self.zoneId)\n\n    def getNonCollidableParent(self):\n        return self.air.getNonCollidableParent(self.zoneId)\n\n    def getParentMgr(self):\n        return self.air.getParentMgr(self.zoneId)\n\n    def getCollTrav(self, *args, **kArgs):\n        return self.air.getCollTrav(self.zoneId, *args, **kArgs)\n\n    def sendUpdate(self, fieldName, args = []):\n        assert self.notify.debugStateCall(self)\n        if self.air:\n            self.air.sendUpdate(self, fieldName, args)\n\n    def GetPuppetConnectionChannel(self, doId):\n        return doId + (1001 << 32)\n\n    def GetAccountConnectionChannel(self, doId):\n        return doId + (1003 << 32)\n\n    def GetAccountIDFromChannelCode(self, channel):\n        return channel >> 32\n\n    def GetAvatarIDFromChannelCode(self, channel):\n        return channel & 0xffffffff\n\n    def sendUpdateToAvatarId(self, avId, fieldName, args):\n        assert self.notify.debugStateCall(self)\n        channelId = self.GetPuppetConnectionChannel(avId)\n        self.sendUpdateToChannel(channelId, fieldName, args)\n\n    def sendUpdateToAccountId(self, accountId, fieldName, args):\n        assert self.notify.debugStateCall(self)\n        channelId = self.GetAccountConnectionChannel(accountId)\n        self.sendUpdateToChannel(channelId, fieldName, args)\n\n    def sendUpdateToChannel(self, channelId, fieldName, args):\n        assert self.notify.debugStateCall(self)\n        if self.air:\n            self.air.sendUpdateToChannel(self, channelId, fieldName, args)\n\n    def generateWithRequired(self, zoneId, optionalFields=[]):\n        assert self.notify.debugStateCall(self)\n        # have we already allocated a doId?\n        if self.__preallocDoId:\n            self.__preallocDoId = 0\n            return self.generateWithRequiredAndId(self.doId, zoneId,\n                                                  optionalFields)\n\n        # The repository is the one that really does the work\n        parentId = self.air.districtId\n        self.parentId = parentId\n        self.zoneId = zoneId\n        self.air.generateWithRequired(self, parentId, zoneId, optionalFields)\n        self.generate()\n\n    # this is a special generate used for estates, or anything else that\n    # needs to have a hard coded doId as assigned by the server\n    def generateWithRequiredAndId(self, doId, parentId, zoneId, optionalFields=[]):\n        assert self.notify.debugStateCall(self)\n        # have we already allocated a doId?\n        if self.__preallocDoId:\n            assert doId == self.__preallocDoId\n            self.__preallocDoId = 0\n\n        # The repository is the one that really does the work\n        self.air.generateWithRequiredAndId(self, doId, parentId, zoneId, optionalFields)\n        ## self.parentId = parentId\n        ## self.zoneId = zoneId\n        self.generate()\n        self.announceGenerate()\n        self.postGenerateMessage()\n\n    def generateOtpObject(self, parentId, zoneId, optionalFields=[], doId=None):\n        assert self.notify.debugStateCall(self)\n        # have we already allocated a doId?\n        if self.__preallocDoId:\n            assert doId is None or doId == self.__preallocDoId\n            doId = self.__preallocDoId\n            self.__preallocDoId = 0\n\n        # Assign it an id\n        if doId is None:\n            self.doId = self.air.allocateChannel()\n        else:\n            self.doId = doId\n        # Put the new DO in the dictionaries\n        self.air.addDOToTables(self, location = (parentId, zoneId))\n        # Send a generate message\n        self.sendGenerateWithRequired(self.air, parentId, zoneId, optionalFields)\n\n        ## assert not hasattr(self, 'parentId') or self.parentId is None\n        ## self.parentId = parentId\n        ## self.zoneId = zoneId\n        self.generate()\n\n    def generate(self):\n        \"\"\"\n        Inheritors should put functions that require self.zoneId or\n        other networked info in this function.\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n        self.__generates += 1\n        self.air.storeObjectLocation(self, self.parentId, self.zoneId)\n\n    def generateInit(self, repository=None):\n        \"\"\"\n        First generate (not from cache).\n        \"\"\"\n        assert self.notify.debugStateCall(self)\n\n    def generateTargetChannel(self, repository):\n        \"\"\"\n        Who to send this to for generate messages\n        \"\"\"\n        if hasattr(self, \"dbObject\"):\n            return self.doId\n        return repository.serverId\n\n    def sendGenerateWithRequired(self, repository, parentId, zoneId, optionalFields=[]):\n        assert self.notify.debugStateCall(self)\n        dg = self.dclass.aiFormatGenerate(\n            self, self.doId, parentId, zoneId,\n            #repository.serverId,\n            self.generateTargetChannel(repository),\n            repository.ourChannel,\n            optionalFields)\n        repository.send(dg)\n\n    def initFromServerResponse(self, valDict):\n        assert self.notify.debugStateCall(self)\n        # This is a special method used for estates, etc., which get\n        # their fields set from the database indirectly by way of the\n        # UD.  The input parameter is a dictionary of field names to\n        # datagrams that describes the initial field values from the\n        # database.\n\n        dclass = self.dclass\n        for key, value in valDict.items():\n            # Update the field\n            dclass.directUpdate(self, key, value)\n\n    def requestDelete(self):\n        assert self.notify.debugStateCall(self)\n        if not self.air:\n            doId = \"none\"\n            if hasattr(self, \"doId\"):\n                doId = self.doId\n            self.notify.warning(\"Tried to delete a %s (doId %s) that is already deleted\" % (self.__class__, doId))\n            return\n        self.air.requestDelete(self)\n        self._DOUD_requestedDelete = True\n\n    def taskName(self, taskString):\n        return \"%s-%s\" % (taskString, self.doId)\n\n    def uniqueName(self, idString):\n        return \"%s-%s\" % (idString, self.doId)\n\n    def validate(self, avId, bool, msg):\n        if not bool:\n            self.air.writeServerEvent('suspicious', avId, msg)\n            self.notify.warning('validate error: avId: %s -- %s' % (avId, msg))\n        return bool\n\n    def beginBarrier(self, name, avIds, timeout, callback):\n        # Begins waiting for a set of avatars.  When all avatars in\n        # the list have reported back in or the callback has expired,\n        # calls the indicated callback with the list of toons that\n        # made it through.  There may be multiple barriers waiting\n        # simultaneously on different lists of avatars, although they\n        # should have different names.\n\n        from otp.ai import Barrier  # type: ignore[import-not-found]\n        context = self.__nextBarrierContext\n        # We assume the context number is passed as a uint16.\n        self.__nextBarrierContext = (self.__nextBarrierContext + 1) & 0xffff\n\n        assert self.notify.debug('beginBarrier(%s, %s, %s, %s)' % (context, name, avIds, timeout))\n\n        if avIds:\n            barrier = Barrier.Barrier(\n                name, self.uniqueName(name), avIds, timeout,\n                doneFunc = PythonUtil.Functor(\n                    self.__barrierCallback, context, callback))\n            self.__barriers[context] = barrier\n\n            # Send the context number to each involved client.\n            self.sendUpdate(\"setBarrierData\", [self.__getBarrierData()])\n        else:\n            # No avatars; just call the callback immediately.\n            callback(avIds)\n\n        return context\n\n    def __getBarrierData(self):\n        # Returns the barrier data formatted for sending to the\n        # clients.  This lists all of the current outstanding barriers\n        # and the avIds waiting for them.\n        data = []\n        for context, barrier in self.__barriers.items():\n            toons = barrier.pendingToons\n            if toons:\n                data.append((context, barrier.name, toons))\n        return data\n\n    def ignoreBarrier(self, context):\n        # Aborts a previously-set barrier.  The context is the return\n        # value from the previous call to beginBarrier().\n        barrier = self.__barriers.get(context)\n        if barrier:\n            barrier.cleanup()\n            del self.__barriers[context]\n\n    def setBarrierReady(self, context):\n        # Generated by the clients to check in after a beginBarrier()\n        # call.\n        avId = self.air.getAvatarIdFromSender()\n        assert self.notify.debug('setBarrierReady(%s, %s)' % (context, avId))\n        barrier = self.__barriers.get(context)\n        if barrier is None:\n            # This may be None if a client was slow and missed an\n            # earlier timeout.  Too bad.\n            return\n\n        barrier.clear(avId)\n\n    def __barrierCallback(self, context, callback, avIds):\n        assert self.notify.debug('barrierCallback(%s, %s)' % (context, avIds))\n        # The callback that is generated when a barrier is completed.\n        barrier = self.__barriers.get(context)\n        if barrier:\n            barrier.cleanup()\n            del self.__barriers[context]\n            callback(avIds)\n        else:\n            self.notify.warning(\"Unexpected completion from barrier %s\" % (context))\n\n    def isGridParent(self):\n        # If this distributed object is a DistributedGrid return 1.  0 by default\n        return 0\n\n    def execCommand(self, string, mwMgrId, avId, zoneId):\n        pass\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/DistributedObjectUD.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/9063c21b_DistributedObjectUD.json",
    "doc_id": "doc_318"
  }
}