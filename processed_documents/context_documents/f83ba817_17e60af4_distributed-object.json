{
  "content": "Distributed Objects\n\nDistributedObjects are the base for all things that should be managed over the distributed network. This may include players, level objects, the level itself, a message object for chat messages and really anything else in the application world.\n\nAs seen in earlier sections, they can be created on the client repositories and, when created, they will automatically be distributed to other clients.\n\nTo define who will see DOs <DO>, they can be set in specific zones. Zones are just numbers that have to be set on a DO and a client needs to show interest in them to be able to see objects in them. In addition, objects that a client doesn't own can't be updated by that client. Only the object's owner can change fields in it, except if they are specially marked with the clsend keyword in the DC definition file.\n\nMost DOs will have a basic class definition (eg. \"Foo\") and an AI definition which would be called \"FooAI\". The Foo class will be used on clients and the FooAI class will be generated on the AI servers.\n\nAn example of a distributed object class implementation may look like the following:\n\nClient-side DGameObject.py:\n\nfrom direct.distributed.DistributedObject import DistributedObject\n\nclass DGameObject(DistributedObject):\n    def __init__(self, cr):\n        DistributedObject.__init__(self, cr)\n\n    def d_sendGameData(self):\n        \"\"\" A method to send an update message to the server.  The d_ stands\n        for distributed \"\"\"\n\n        # send the message to the server\n        self.sendUpdate('sendGameData', [('ValueA', 123, 1.25)])\n\nAI Server side DGameObjectAI.py\n\nfrom direct.distributed.DistributedObjectAI import DistributedObjectAI\n\nclass DGameObjectAI(DistributedObjectAI):\n    def __init__(self, aiRepository):\n        DistributedObjectAI.__init__(self, aiRepository)\n\n    def sendGameData(self, data):\n        \"\"\" Method that can be called from the clients with an sendUpdate call \"\"\"\n        print(data)\n\nHere we see that a new object derives from .DistributedObject and .DistributedObjectAI respectively. Usually those classes will be filled with methods that follow the form of foo, d_foo and b_foo.\n\nThe foo method is the one that will have an effect locally.\n\nThe d_foo (d_ stands for distributed) method will send a message to the server and hence to other clients as needed and will update them. As you see, you can simply send data to the server with a self.sendUpdate call. There is also another method called .DistributedObjectAI.sendUpdateToAvatarId which accepts a doId of a client and will send the message directly to it. This method is only available on the AI and UD side.\n\nthe b_foo (b_ stands for both) method will update both, the local object as well as send the data to the server. This can usually easily be achieved by simply calling both, the foo and d_foo method within the b_foo method.\n\nSpecial Methods\n\nAside of your own methods for sending and receiving messages between the client and server-side objects, there are some methods worth knowing which are implemented by the .DistributedObject class. Those methods will usually be overwritten when creating a distributed object class and fitted to your own needs.\n\n~.DistributedObject.announceGenerate: This method will be called as soon as the object has been manifested. On the client side, you may want to use this for AI-created objects. For example:\n\ndef announceGenerate(self):\n\n    base.messenger.send(self.cr.uniqueName('myObject-generated'), [self.doId])\n\n    # call the base class method\n    DistributedObject.announceGenerate(self)\n\n~.DistributedObject.disable: This method will be called when the object gets disabled. This usually comes prior to a delete call.\n\n~.DistributedObject.delete: This method is called whenever a DO gets deleted. For example if the client who created it has left the zone or server. DOs should implement cleanup code here.\n\n~.DistributedObject.generate: This method is called at generation time of the DO.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/17e60af4_distributed-object.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/f83ba817_17e60af4_distributed-object.json",
    "doc_id": "doc_699"
  }
}