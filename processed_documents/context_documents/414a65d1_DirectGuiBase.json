{
  "content": "\"\"\"\nBase class for all DirectGui items.  Handles composite widgets and\ncommand line argument parsing.\n\nCode overview:\n\n1)  Each widget defines a set of options (optiondefs) as a list of tuples\n    of the form ``('name', defaultValue, handler)``.\n    'name' is the name of the option (used during construction of configure)\n    handler can be: None, method, or INITOPT.  If a method is specified, it\n    will be called during widget construction (via initialiseoptions), if the\n    Handler is specified as an INITOPT, this is an option that can only be set\n    during widget construction.\n\n2)  :func:`~DirectGuiBase.defineoptions` is called.  defineoption creates:\n\n    self._constructorKeywords = { keyword: [value, useFlag] }\n        A dictionary of the keyword options specified as part of the\n        constructor keywords can be of the form 'component_option', where\n        component is the name of a widget's component, a component group or a\n        component alias.\n\n    self._dynamicGroups\n        A list of group names for which it is permissible to specify options\n        before components of that group are created.\n        If a widget is a derived class the order of execution would be::\n\n          foo.optiondefs = {}\n          foo.defineoptions()\n            fooParent()\n               fooParent.optiondefs = {}\n               fooParent.defineoptions()\n\n3)  :func:`~DirectGuiBase.addoptions` is called.  This combines options\n    specified as keywords to the widget constructor (stored in\n    self._constructorKeywords) with the default options (stored in optiondefs).\n    Results are stored in\n    ``self._optionInfo = { keyword: [default, current, handler] }``.\n    If a keyword is of the form 'component_option' it is left in the\n    self._constructorKeywords dictionary (for use by component constructors),\n    otherwise it is 'used', and deleted from self._constructorKeywords.\n\n    Notes:\n\n    - constructor keywords override the defaults.\n    - derived class default values override parent class defaults\n    - derived class handler functions override parent class functions\n\n4)  Superclass initialization methods are called (resulting in nested calls\n    to define options (see 2 above)\n\n5)  Widget components are created via calls to\n    :func:`~DirectGuiBase.createcomponent`.  User can specify aliases and groups\n    for each component created.\n\n    Aliases are alternate names for components, e.g. a widget may have a\n    component with a name 'entryField', which itself may have a component\n    named 'entry', you could add an alias 'entry' for the 'entryField_entry'\n    These are stored in self.__componentAliases.  If an alias is found,\n    all keyword entries which use that alias are expanded to their full\n    form (to avoid conversion later)\n\n    Groups allow option specifications that apply to all members of the group.\n    If a widget has components: 'text1', 'text2', and 'text3' which all belong\n    to the 'text' group, they can be all configured with keywords of the form:\n    'text_keyword' (e.g. ``text_font='comic.rgb'``).  A component's group\n    is stored as the fourth element of its entry in self.__componentInfo.\n\n    Note: the widget constructors have access to all remaining keywords in\n    _constructorKeywords (those not transferred to _optionInfo by\n    define/addoptions).  If a component defines an alias that applies to\n    one of the keywords, that keyword is replaced with a new keyword with\n    the alias expanded.\n\n    If a keyword (or substituted alias keyword) is used during creation of the\n    component, it is deleted from self._constructorKeywords.  If a group\n    keyword applies to the component, that keyword is marked as used, but is\n    not deleted from self._constructorKeywords, in case it applies to another\n    component.  If any constructor keywords remain at the end of component\n    construction (and initialisation), an error is raised.\n\n5)  :func:`~DirectGuiBase.initialiseoptions` is called.  This method calls any\n    option handlers to respond to any keyword/default values, then checks to\n    see if any keywords are left unused.  If so, an error is raised.\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = ['DirectGuiBase', 'DirectGuiWidget']\n\n\nfrom panda3d.core import (\n    ConfigVariableBool,\n    KeyboardButton,\n    MouseWatcherRegion,\n    NodePath,\n    PGFrameStyle,\n    PGItem,\n    Point3,\n    Texture,\n    Vec3,\n)\nfrom direct.showbase import ShowBaseGlobal\nfrom direct.showbase.ShowBase import ShowBase\nfrom direct.showbase.MessengerGlobal import messenger\nfrom . import DirectGuiGlobals as DGG\nfrom direct.directtools.DirectUtil import ROUND_TO\nfrom direct.showbase import DirectObject\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\n\n_track_gui_items = ConfigVariableBool('track-gui-items', False)\n\n\nclass DirectGuiBase(DirectObject.DirectObject):\n    \"\"\"Base class of all DirectGUI widgets.\"\"\"\n\n    def __init__(self):\n        # Default id of all gui object, subclasses should override this\n        self.guiId = 'guiObject'\n        # List of all post initialization functions\n        self.postInitialiseFuncList = []\n        # To avoid doing things redundantly during initialisation\n        self.fInit = 1\n        # Mapping from each megawidget option to a list of information\n        # about the option\n        #   - default value\n        #   - current value\n        #   - function to call when the option is initialised in the\n        #     call to initialiseoptions() in the constructor or\n        #     modified via configure().  If this is INITOPT, the\n        #     option is an initialisation option (an option that can\n        #     be set by the call to the constructor but can not be\n        #     used with configure).\n        # This mapping is not initialised here, but in the call to\n        # defineoptions() which precedes construction of this base class.\n        #\n        # self._optionInfo = {}\n\n        # Mapping from each component name to a tuple of information\n        # about the component.\n        #   - component widget instance\n        #   - configure function of widget instance\n        #   - the class of the widget (Frame, EntryField, etc)\n        #   - cget function of widget instance\n        #   - the name of the component group of this component, if any\n        self.__componentInfo = {}\n\n        # Mapping from alias names to the names of components or\n        # sub-components.\n        self.__componentAliases = {}\n\n        # Contains information about the keywords provided to the\n        # constructor.  It is a mapping from the keyword to a tuple\n        # containing:\n        #    - value of keyword\n        #    - a boolean indicating if the keyword has been used.\n        # A keyword is used if, during the construction of a megawidget,\n        #    - it is defined in a call to defineoptions() or addoptions(), or\n        #    - it references, by name, a component of the megawidget, or\n        #    - it references, by group, at least one component\n        # At the end of megawidget construction, a call is made to\n        # initialiseoptions() which reports an error if there are\n        # unused options given to the constructor.\n        #\n        # self._constructorKeywords = {}\n\n        # List of dynamic component groups.  If a group is included in\n        # this list, then it not an error if a keyword argument for\n        # the group is given to the constructor or to configure(), but\n        # no components with this group have been created.\n        # self._dynamicGroups = ()\n\n    def defineoptions(self, keywords, optionDefs, dynamicGroups = ()):\n        \"\"\" defineoptions(keywords, optionDefs, dynamicGroups = {}) \"\"\"\n        # Create options, providing the default value and the method\n        # to call when the value is changed.  If any option created by\n        # base classes has the same name as one in <optionDefs>, the\n        # base class's value and function will be overriden.\n\n        # keywords is a dictionary of keyword/value pairs from the constructor\n        # optionDefs is a dictionary of default options for the widget\n        # dynamicGroups is a tuple of component groups for which you can\n        # specify options even though no components of this group have\n        # been created\n\n        # This should be called before the constructor of the base\n        # class, so that default values defined in the derived class\n        # override those in the base class.\n        if not hasattr(self, '_constructorKeywords'):\n            tmp = {}\n            for option, value in keywords.items():\n                tmp[option] = [value, 0]\n            self._constructorKeywords = tmp\n            self._optionInfo = {}\n        # Initialize dictionary of dynamic groups\n        if not hasattr(self, '_dynamicGroups'):\n            self._dynamicGroups = ()\n        self._dynamicGroups = self._dynamicGroups + tuple(dynamicGroups)\n        # Reconcile command line and default options\n        self.addoptions(optionDefs, keywords)\n\n    def addoptions(self, optionDefs, optionkeywords):\n        \"\"\" addoptions(optionDefs) - add option def to option info \"\"\"\n        # Add additional options, providing the default value and the\n        # method to call when the value is changed.  See\n        # \"defineoptions\" for more details\n\n        # optimisations:\n        optionInfo = self._optionInfo\n        optionInfo_has_key = optionInfo.__contains__\n        keywords = self._constructorKeywords\n        keywords_has_key = keywords.__contains__\n        FUNCTION = DGG._OPT_FUNCTION\n\n        for name, default, function in optionDefs:\n            if '_' not in name:\n                default = optionkeywords.get(name, default)\n                # The option will already exist if it has been defined\n                # in a derived class.  In this case, do not override the\n                # default value of the option or the callback function\n                # if it is not None.\n                if not optionInfo_has_key(name):\n                    if keywords_has_key(name):\n                        # Overridden by keyword, use keyword value\n                        value = keywords[name][0]\n                        optionInfo[name] = [default, value, function]\n                        # Delete it from self._constructorKeywords\n                        del keywords[name]\n                    else:\n                        # Use optionDefs value\n                        value = default\n                        if isinstance(value, list):\n                            value = list(value)\n                        elif isinstance(value, dict):\n                            value = dict(value)\n                        optionInfo[name] = [default, value, function]\n                elif optionInfo[name][FUNCTION] is None:\n                    # Only override function if not defined by derived class\n                    optionInfo[name][FUNCTION] = function\n            else:\n                # This option is of the form \"component_option\".  If this is\n                # not already defined in self._constructorKeywords add it.\n                # This allows a derived class to override the default value\n                # of an option of a component of a base class.\n                if not keywords_has_key(name):\n                    keywords[name] = [default, 0]\n\n    def initialiseoptions(self, myClass):\n        \"\"\"\n        Call all initialisation functions to initialize widget\n        options to default of keyword value\n        \"\"\"\n        # This is to make sure this method class is only called by\n        # the most specific class in the class hierarchy\n        if self.__class__ is myClass:\n            # Call the configuration callback function for every option.\n            FUNCTION = DGG._OPT_FUNCTION\n            self.fInit = 1\n            for info in self._optionInfo.values():\n                func = info[FUNCTION]\n                if func is not None and func is not DGG.INITOPT:\n                    func()\n            self.fInit = 0\n\n            # Now check if anything is left over\n            unusedOptions = []\n            keywords = self._constructorKeywords\n            for name in keywords:\n                used = keywords[name][1]\n                if not used:\n                    # This keyword argument has not been used.  If it\n                    # does not refer to a dynamic group, mark it as\n                    # unused.\n                    index = name.find('_')\n                    if index < 0 or name[:index] not in self._dynamicGroups:\n                        unusedOptions.append(name)\n            self._constructorKeywords = {}\n            if len(unusedOptions) > 0:\n                if len(unusedOptions) == 1:\n                    text = 'Unknown option \"'\n                else:\n                    text = 'Unknown options \"'\n                raise KeyError(text + ', '.join(unusedOptions) + \\\n                        '\" for ' + myClass.__name__)\n            # Can now call post init func\n            self.postInitialiseFunc()\n\n    def postInitialiseFunc(self):\n        for func in self.postInitialiseFuncList:\n            func()\n\n    def isinitoption(self, option):\n        \"\"\"\n        Is this opition one that can only be specified at construction?\n        \"\"\"\n        return self._optionInfo[option][DGG._OPT_FUNCTION] is DGG.INITOPT\n\n    def options(self):\n        \"\"\"\n        Print out a list of available widget options.\n        Does not include subcomponent options.\n        \"\"\"\n        options = []\n        if hasattr(self, '_optionInfo'):\n            for option, info in self._optionInfo.items():\n                isinit = info[DGG._OPT_FUNCTION] is DGG.INITOPT\n                default = info[DGG._OPT_DEFAULT]\n                options.append((option, default, isinit))\n            options.sort()\n        return options\n\n    def configure(self, option=None, **kw):\n        \"\"\"\n        configure(option = None)\n        Query or configure the megawidget options.\n        \"\"\"\n        #\n        # If not empty, *kw* is a dictionary giving new\n        # values for some of the options of this gui item\n        # For options defined for this widget, set\n        # the value of the option to the new value and call the\n        # configuration callback function, if any.\n        #\n        # If *option* is None, return all gui item configuration\n        # options and settings.  Options are returned as standard 3\n        # element tuples\n        #\n        # If *option* is a string, return the 3 element tuple for the\n        # given configuration option.\n\n        # First, deal with the option queries.\n        if len(kw) == 0:\n            # This configure call is querying the values of one or all options.\n            # Return 3-tuples:\n            #     (optionName, default, value)\n            if option is None:\n                rtn = {}\n                for option, config in self._optionInfo.items():\n                    rtn[option] = (option,\n                                   config[DGG._OPT_DEFAULT],\n                                   config[DGG._OPT_VALUE])\n                return rtn\n            else:\n                config = self._optionInfo[option]\n                return (option, config[DGG._OPT_DEFAULT], config[DGG._OPT_VALUE])\n\n        # optimizations:\n        optionInfo = self._optionInfo\n        optionInfo_has_key = optionInfo.__contains__\n        componentInfo = self.__componentInfo\n        componentInfo_has_key = componentInfo.__contains__\n        componentAliases = self.__componentAliases\n        componentAliases_has_key = componentAliases.__contains__\n        VALUE = DGG._OPT_VALUE\n        FUNCTION = DGG._OPT_FUNCTION\n\n        # This will contain a list of options in *kw* which\n        # are known to this gui item.\n        directOptions = []\n\n        # This will contain information about the options in\n        # *kw* of the form <component>_<option>, where\n        # <component> is a component of this megawidget.  It is a\n        # dictionary whose keys are the configure method of each\n        # component and whose values are a dictionary of options and\n        # values for the component.\n        indirectOptions = {}\n        indirectOptions_has_key = indirectOptions.__contains__\n\n        for option, value in kw.items():\n            if optionInfo_has_key(option):\n                # This is one of the options of this gui item.\n                # Check it is an initialisation option.\n                if optionInfo[option][FUNCTION] is DGG.INITOPT:\n                    print('Cannot configure initialisation option \"' \\\n                          + option + '\" for ' + self.__class__.__name__)\n                    break\n                    #raise KeyError, \\\n                #           'Cannot configure initialisation option \"' \\\n                #           + option + '\" for ' + self.__class__.__name__\n                optionInfo[option][VALUE] = value\n                directOptions.append(option)\n            else:\n                index = option.find('_')\n                if index >= 0:\n                    # This option may be of the form <component>_<option>.\n                    # e.g. if alias ('efEntry', 'entryField_entry')\n                    # and option = efEntry_width\n                    # component = efEntry, componentOption = width\n                    component = option[:index]\n                    componentOption = option[(index + 1):]\n\n                    # Expand component alias\n                    if componentAliases_has_key(component):\n                        # component = entryField, subcomponent = entry\n                        component, subComponent = componentAliases[component]\n                        if subComponent is not None:\n                            # componentOption becomes entry_width\n                            componentOption = subComponent + '_' \\\n                                    + componentOption\n\n                        # Expand option string to write on error\n                        # option = entryField_entry_width\n                        option = component + '_' + componentOption\n\n                    # Does this component exist\n                    if componentInfo_has_key(component):\n                        # Get the configure func for the named component\n                        # component = entryField\n                        componentConfigFuncs = [componentInfo[component][1]]\n                    else:\n                        # Check if this is a group name and configure all\n                        # components in the group.\n                        componentConfigFuncs = []\n                        # For each component\n                        for info in componentInfo.values():\n                            # Check if it is a member of this group\n                            if info[4] == component:\n                                # Yes, append its config func\n                                componentConfigFuncs.append(info[1])\n\n                        if len(componentConfigFuncs) == 0 and \\\n                                component not in self._dynamicGroups:\n                            raise KeyError('Unknown option \"' + option + \\\n                                    '\" for ' + self.__class__.__name__)\n\n                    # Add the configure method(s) (may be more than\n                    # one if this is configuring a component group)\n                    # and option/value to dictionary.\n                    for componentConfigFunc in componentConfigFuncs:\n                        if not indirectOptions_has_key(componentConfigFunc):\n                            indirectOptions[componentConfigFunc] = {}\n                        # Create a dictionary of keyword/values keyed\n                        # on configuration function\n                        indirectOptions[componentConfigFunc][componentOption] \\\n                                = value\n                else:\n                    raise KeyError('Unknown option \"' + option + \\\n                            '\" for ' + self.__class__.__name__)\n\n        # Call the configure methods for any components.\n        # Pass in the dictionary of keyword/values created above\n        for func, options in indirectOptions.items():\n            func(**options)\n\n        # Call the configuration callback function for each option.\n        for option in directOptions:\n            info = optionInfo[option]\n            func = info[DGG._OPT_FUNCTION]\n            if func is not None:\n                func()\n\n    # Allow index style references\n    def __setitem__(self, key, value):\n        self.configure(**{key: value})\n\n    def cget(self, option):\n        \"\"\"\n        Get current configuration setting for this option\n        \"\"\"\n        # Return the value of an option, for example myWidget['font'].\n        if option in self._optionInfo:\n            return self._optionInfo[option][DGG._OPT_VALUE]\n        else:\n            index = option.find('_')\n            if index >= 0:\n                component = option[:index]\n                componentOption = option[(index + 1):]\n\n                # Expand component alias\n                if component in self.__componentAliases:\n                    component, subComponent = self.__componentAliases[\n                        component]\n                    if subComponent is not None:\n                        componentOption = subComponent + '_' + componentOption\n\n                    # Expand option string to write on error\n                    option = component + '_' + componentOption\n\n                if component in self.__componentInfo:\n                    # Call cget on the component.\n                    componentCget = self.__componentInfo[component][3]\n                    return componentCget(componentOption)\n                else:\n                    # If this is a group name, call cget for one of\n                    # the components in the group.\n                    for info in self.__componentInfo.values():\n                        if info[4] == component:\n                            componentCget = info[3]\n                            return componentCget(componentOption)\n\n        # Option not found\n        raise KeyError('Unknown option \"' + option + \\\n                '\" for ' + self.__class__.__name__)\n\n    # Allow index style refererences\n    __getitem__ = cget\n\n    def createcomponent(self, componentName, componentAliases, componentGroup,\n                        widgetClass, *widgetArgs, **kw):\n        \"\"\"\n        Create a component (during construction or later) for this widget.\n        \"\"\"\n        # Check for invalid component name\n        if '_' in componentName:\n            raise ValueError('Component name \"%s\" must not contain \"_\"' % componentName)\n\n        # Get construction keywords\n        if hasattr(self, '_constructorKeywords'):\n            keywords = self._constructorKeywords\n        else:\n            keywords = {}\n\n        for alias, component in componentAliases:\n            # Create aliases to the component and its sub-components.\n            index = component.find('_')\n            if index < 0:\n                # Just a shorter name for one of this widget's components\n                self.__componentAliases[alias] = (component, None)\n            else:\n                # An alias for a component of one of this widget's components\n                mainComponent = component[:index]\n                subComponent = component[(index + 1):]\n                self.__componentAliases[alias] = (mainComponent, subComponent)\n\n            # Remove aliases from the constructor keyword arguments by\n            # replacing any keyword arguments that begin with *alias*\n            # with corresponding keys beginning with *component*.\n            alias = alias + '_'\n            aliasLen = len(alias)\n            for option in keywords.copy():\n                if len(option) > aliasLen and option[:aliasLen] == alias:\n                    newkey = component + '_' + option[aliasLen:]\n                    keywords[newkey] = keywords[option]\n                    del keywords[option]\n\n        # Find any keyword arguments for this component\n        componentPrefix = componentName + '_'\n        nameLen = len(componentPrefix)\n\n        # First, walk through the option list looking for arguments\n        # than refer to this component's group.\n\n        for option in keywords:\n            # Check if this keyword argument refers to the group\n            # of this component.  If so, add this to the options\n            # to use when constructing the widget.  Mark the\n            # keyword argument as being used, but do not remove it\n            # since it may be required when creating another\n            # component.\n            index = option.find('_')\n            if index >= 0 and componentGroup == option[:index]:\n                rest = option[(index + 1):]\n                kw[rest] = keywords[option][0]\n                keywords[option][1] = 1\n\n        # Now that we've got the group arguments, walk through the\n        # option list again and get out the arguments that refer to\n        # this component specifically by name.  These are more\n        # specific than the group arguments, above; we walk through\n        # the list afterwards so they will override.\n\n        for option in keywords.copy():\n            if len(option) > nameLen and option[:nameLen] == componentPrefix:\n                # The keyword argument refers to this component, so add\n                # this to the options to use when constructing the widget.\n                kw[option[nameLen:]] = keywords[option][0]\n                # And delete it from main construction keywords\n                del keywords[option]\n\n        # Return None if no widget class is specified\n        if widgetClass is None:\n            return None\n        # Get arguments for widget constructor\n        if len(widgetArgs) == 1 and isinstance(widgetArgs[0], tuple):\n            # Arguments to the constructor can be specified as either\n            # multiple trailing arguments to createcomponent() or as a\n            # single tuple argument.\n            widgetArgs = widgetArgs[0]\n        # Create the widget\n        widget = widgetClass(*widgetArgs, **kw)\n        componentClass = widget.__class__.__name__\n        self.__componentInfo[componentName] = (widget, widget.configure,\n                componentClass, widget.cget, componentGroup)\n        return widget\n\n    def component(self, name):\n        # Return a component widget of the megawidget given the\n        # component's name\n        # This allows the user of a megawidget to access and configure\n        # widget components directly.\n\n        # Find the main component and any subcomponents\n        index = name.find('_')\n        if index < 0:\n            component = name\n            remainingComponents = None\n        else:\n            component = name[:index]\n            remainingComponents = name[(index + 1):]\n\n        # Expand component alias\n        # Example entry which is an alias for entryField_entry\n        if component in self.__componentAliases:\n            # component = entryField, subComponent = entry\n            component, subComponent = self.__componentAliases[component]\n            if subComponent is not None:\n                if remainingComponents is None:\n                    # remainingComponents = entry\n                    remainingComponents = subComponent\n                else:\n                    remainingComponents = subComponent + '_' \\\n                            + remainingComponents\n        # Get the component from __componentInfo dictionary\n        widget = self.__componentInfo[component][0]\n        if remainingComponents is None:\n            # Not looking for subcomponent\n            return widget\n        else:\n            # Recursive call on subcomponent\n            return widget.component(remainingComponents)\n\n    def components(self):\n        # Return a list of all components.\n        return sorted(self.__componentInfo)\n\n    def hascomponent(self, component):\n        return component in self.__componentInfo\n\n    def destroycomponent(self, name):\n        # Remove a megawidget component.\n        # This command is for use by megawidget designers to destroy a\n        # megawidget component.\n        self.__componentInfo[name][0].destroy()\n        del self.__componentInfo[name]\n\n    def destroy(self):\n        # Clean out any hooks\n        self.ignoreAll()\n        del self._optionInfo\n        del self.__componentInfo\n        del self.postInitialiseFuncList\n\n    def bind(self, event, command, extraArgs = []):\n        \"\"\"\n        Bind the command (which should expect one arg) to the specified\n        event (such as ENTER, EXIT, B1PRESS, B1CLICK, etc.)\n        See DirectGuiGlobals for possible events\n        \"\"\"\n        # Need to tack on gui item specific id\n        gEvent = event + self.guiId\n        if ConfigVariableBool('debug-directgui-msgs', False):\n            from direct.showbase.PythonUtil import StackTrace\n            print(gEvent)\n            print(StackTrace())\n        self.accept(gEvent, command, extraArgs = extraArgs)\n\n    def unbind(self, event):\n        \"\"\"\n        Unbind the specified event\n        \"\"\"\n        # Need to tack on gui item specific id\n        gEvent = event + self.guiId\n        self.ignore(gEvent)\n\n\ndef toggleGuiGridSnap():\n    DirectGuiWidget.snapToGrid = 1 - DirectGuiWidget.snapToGrid\n\n\ndef setGuiGridSpacing(spacing):\n    DirectGuiWidget.gridSpacing = spacing\n\n\nclass DirectGuiWidget(DirectGuiBase, NodePath):\n    # Toggle if you wish widget's to snap to grid when draggin\n    snapToGrid = 0\n    gridSpacing = 0.05\n\n    # Determine the default initial state for inactive (or\n    # unclickable) components.  If we are in edit mode, these are\n    # actually clickable by default.\n    guiEdit = ConfigVariableBool('direct-gui-edit', False)\n    if guiEdit:\n        inactiveInitState = DGG.NORMAL\n    else:\n        inactiveInitState = DGG.DISABLED\n\n    guiDict: dict[str, DirectGuiWidget] = {}\n\n    def __init__(self, parent = None, **kw):\n        # Direct gui widgets are node paths\n        # Direct gui widgets have:\n        # -  stateNodePaths (to hold visible representation of widget)\n        # State node paths can have:\n        # -  a frame of type (None, FLAT, RAISED, GROOVE, RIDGE)\n        # -  arbitrary geometry for each state\n        # They inherit from DirectGuiWidget\n        # -  Can create components (with aliases and groups)\n        # -  Can bind to mouse events\n        # They inherit from NodePath\n        # -  Can position/scale them\n        optiondefs = (\n            # Widget's constructor\n            ('pgFunc',         PGItem,       None),\n            ('numStates',      1,            None),\n            ('invertedFrames', (),           None),\n            ('sortOrder',      0,            None),\n            # Widget's initial state\n            ('state',          DGG.NORMAL,   self.setState),\n            # Widget's frame characteristics\n            ('relief',         DGG.FLAT,     self.setRelief),\n            ('borderWidth',    (.1, .1),     self.setBorderWidth),\n            ('borderUvWidth',  (.1, .1),     self.setBorderUvWidth),\n            ('frameSize',      None,         self.setFrameSize),\n            ('frameColor',     (.8, .8, .8, 1), self.setFrameColor),\n            ('frameTexture',   None,         self.setFrameTexture),\n            ('frameVisibleScale', (1, 1),     self.setFrameVisibleScale),\n            ('pad',            (0, 0),        self.resetFrameSize),\n            # Override button id (beware! your name may not be unique!)\n            ('guiId',          None,         DGG.INITOPT),\n            # Initial pos/scale of the widget\n            ('pos',            None,         DGG.INITOPT),\n            ('hpr',            None,         DGG.INITOPT),\n            ('scale',          None,         DGG.INITOPT),\n            ('color',          None,         DGG.INITOPT),\n            # Do events pass through this widget?\n            ('suppressMouse',  1,            DGG.INITOPT),\n            ('suppressKeys',   0,            DGG.INITOPT),\n            ('enableEdit',     1,            DGG.INITOPT),\n        )\n        # Merge keyword options with default options\n        self.defineoptions(kw, optiondefs)\n\n        # Initialize the base classes (after defining the options).\n        DirectGuiBase.__init__(self)\n        NodePath.__init__(self)\n        # Create a button\n        self.guiItem = self['pgFunc']('')\n        # Override automatically generated guiId\n        if self['guiId']:\n            self.guiItem.setId(self['guiId'])\n        self.guiId = self.guiItem.getId()\n\n        if ShowBaseGlobal.__dev__:\n            # track gui items by guiId for tracking down leaks\n            if _track_gui_items:\n                if not hasattr(ShowBase, 'guiItems'):\n                    ShowBase.guiItems = {}\n                if self.guiId in ShowBase.guiItems:\n                    ShowBase.notify.warning('duplicate guiId: %s (%s stomping %s)' %\n                                            (self.guiId, self,\n                                             ShowBase.guiItems[self.guiId]))\n                ShowBase.guiItems[self.guiId] = self\n\n        # Attach button to parent and make that self\n        if parent is None:\n            parent = ShowBaseGlobal.aspect2d\n\n        self.assign(parent.attachNewNode(self.guiItem, self['sortOrder']))\n        # Update pose to initial values\n        if self['pos']:\n            self.setPos(self['pos'])\n        if self['hpr']:\n            self.setHpr(self['hpr'])\n        if self['scale']:\n            self.setScale(self['scale'])\n        if self['color']:\n            self.setColor(self['color'])\n        # Initialize names\n        # Putting the class name in helps with debugging.\n        self.setName(\"%s-%s\" % (self.__class__.__name__, self.guiId))\n        # Create\n        self.stateNodePath = []\n        for i in range(self['numStates']):\n            self.stateNodePath.append(NodePath(self.guiItem.getStateDef(i)))\n        # Initialize frame style\n        self.frameStyle = []\n        for i in range(self['numStates']):\n            self.frameStyle.append(PGFrameStyle())\n        # For holding bounds info\n        self.ll = Point3(0)\n        self.ur = Point3(0)\n\n        # Is drag and drop enabled?\n        if self['enableEdit'] and self.guiEdit:\n            self.enableEdit()\n\n        # Set up event handling\n        suppressFlags = 0\n        if self['suppressMouse']:\n            suppressFlags |= MouseWatcherRegion.SFMouseButton\n            suppressFlags |= MouseWatcherRegion.SFMousePosition\n        if self['suppressKeys']:\n            suppressFlags |= MouseWatcherRegion.SFOtherButton\n        self.guiItem.setSuppressFlags(suppressFlags)\n\n        # Bind destroy hook\n        self.guiDict[self.guiId] = self\n        # self.bind(DGG.DESTROY, self.destroy)\n\n        # Update frame when everything has been initialized\n        self.postInitialiseFuncList.append(self.frameInitialiseFunc)\n\n        # Call option initialization functions\n        self.initialiseoptions(DirectGuiWidget)\n\n    def frameInitialiseFunc(self):\n        # Now allow changes to take effect\n        self.updateFrameStyle()\n        if not self['frameSize']:\n            self.resetFrameSize()\n\n    def enableEdit(self):\n        self.bind(DGG.B2PRESS, self.editStart)\n        self.bind(DGG.B2RELEASE, self.editStop)\n        self.bind(DGG.PRINT, self.printConfig)\n        # Can we move this to showbase\n        # Certainly we don't need to do this for every button!\n        #mb = base.mouseWatcherNode.getModifierButtons()\n        #mb.addButton(KeyboardButton.control())\n        #base.mouseWatcherNode.setModifierButtons(mb)\n\n    def disableEdit(self):\n        self.unbind(DGG.B2PRESS)\n        self.unbind(DGG.B2RELEASE)\n        self.unbind(DGG.PRINT)\n        #mb = base.mouseWatcherNode.getModifierButtons()\n        #mb.removeButton(KeyboardButton.control())\n        #base.mouseWatcherNode.setModifierButtons(mb)\n\n    def editStart(self, event):\n        taskMgr.remove('guiEditTask')\n        vWidget2render2d = self.getPos(ShowBaseGlobal.render2d)\n        vMouse2render2d = Point3(event.getMouse()[0], 0, event.getMouse()[1])\n        editVec = Vec3(vWidget2render2d - vMouse2render2d)\n        if base.mouseWatcherNode.getModifierButtons().isDown(\n                KeyboardButton.control()):\n            t = taskMgr.add(self.guiScaleTask, 'guiEditTask')\n            t.refPos = vWidget2render2d\n            t.editVecLen = editVec.length()\n            t.initScale = self.getScale()\n        else:\n            t = taskMgr.add(self.guiDragTask, 'guiEditTask')\n            t.editVec = editVec\n\n    def guiScaleTask(self, state):\n        mwn = base.mouseWatcherNode\n        if mwn.hasMouse():\n            vMouse2render2d = Point3(mwn.getMouse()[0], 0, mwn.getMouse()[1])\n            newEditVecLen = Vec3(state.refPos - vMouse2render2d).length()\n            self.setScale(state.initScale * (newEditVecLen/state.editVecLen))\n        return Task.cont\n\n    def guiDragTask(self, state):\n        mwn = base.mouseWatcherNode\n        if mwn.hasMouse():\n            vMouse2render2d = Point3(mwn.getMouse()[0], 0, mwn.getMouse()[1])\n            newPos = vMouse2render2d + state.editVec\n            self.setPos(ShowBaseGlobal.render2d, newPos)\n            if DirectGuiWidget.snapToGrid:\n                newPos = self.getPos()\n                newPos.set(\n                    ROUND_TO(newPos[0], DirectGuiWidget.gridSpacing),\n                    ROUND_TO(newPos[1], DirectGuiWidget.gridSpacing),\n                    ROUND_TO(newPos[2], DirectGuiWidget.gridSpacing))\n                self.setPos(newPos)\n        return Task.cont\n\n    def editStop(self, event):\n        taskMgr.remove('guiEditTask')\n\n    def setState(self):\n        if isinstance(self['state'], int):\n            self.guiItem.setActive(self['state'])\n        elif self['state'] == DGG.NORMAL or self['state'] == 'normal':\n            self.guiItem.setActive(1)\n        else:\n            self.guiItem.setActive(0)\n\n    def resetFrameSize(self):\n        if not self.fInit:\n            self.setFrameSize(fClearFrame = 1)\n\n    def setFrameSize(self, fClearFrame = 0):\n        # Use ready state to determine frame Type\n        frameType = self.getFrameType()\n        if self['frameSize']:\n            # Use user specified bounds\n            self.bounds = self['frameSize']\n            #print \"%s bounds = %s\" % (self.getName(), self.bounds)\n            bw = (0, 0)\n\n        else:\n            if fClearFrame and frameType != PGFrameStyle.TNone:\n                self.frameStyle[0].setType(PGFrameStyle.TNone)\n                self.guiItem.setFrameStyle(0, self.frameStyle[0])\n                # To force an update of the button\n                self.guiItem.getStateDef(0)\n            # Clear out frame before computing bounds\n            self.getBounds()\n            # Restore frame style if necessary\n            if frameType != PGFrameStyle.TNone:\n                self.frameStyle[0].setType(frameType)\n                self.guiItem.setFrameStyle(0, self.frameStyle[0])\n\n            if frameType != PGFrameStyle.TNone and \\\n               frameType != PGFrameStyle.TFlat:\n                bw = self['borderWidth']\n            else:\n                bw = (0, 0)\n\n        # Set frame to new dimensions\n        self.guiItem.setFrame(\n            self.bounds[0] - bw[0],\n            self.bounds[1] + bw[0],\n            self.bounds[2] - bw[1],\n            self.bounds[3] + bw[1])\n\n    def getBounds(self, state = 0):\n        self.stateNodePath[state].calcTightBounds(self.ll, self.ur)\n        # Scale bounds to give a pad around graphics\n        vec_right = Vec3.right()\n        vec_up = Vec3.up()\n        left = (vec_right[0] * self.ll[0]\n              + vec_right[1] * self.ll[1]\n              + vec_right[2] * self.ll[2])\n        right = (vec_right[0] * self.ur[0]\n               + vec_right[1] * self.ur[1]\n               + vec_right[2] * self.ur[2])\n        bottom = (vec_up[0] * self.ll[0]\n                + vec_up[1] * self.ll[1]\n                + vec_up[2] * self.ll[2])\n        top = (vec_up[0] * self.ur[0]\n             + vec_up[1] * self.ur[1]\n             + vec_up[2] * self.ur[2])\n        self.ll = Point3(left, 0.0, bottom)\n        self.ur = Point3(right, 0.0, top)\n        self.bounds = [self.ll[0] - self['pad'][0],\n                       self.ur[0] + self['pad'][0],\n                       self.ll[2] - self['pad'][1],\n                       self.ur[2] + self['pad'][1]]\n        return self.bounds\n\n    def getWidth(self):\n        return self.bounds[1] - self.bounds[0]\n\n    def getHeight(self):\n        return self.bounds[3] - self.bounds[2]\n\n    def getCenter(self):\n        x = self.bounds[0] + (self.bounds[1] - self.bounds[0])/2.0\n        y = self.bounds[2] + (self.bounds[3] - self.bounds[2])/2.0\n        return (x, y)\n\n    def getFrameType(self, state = 0):\n        return self.frameStyle[state].getType()\n\n    def updateFrameStyle(self):\n        if not self.fInit:\n            for i in range(self['numStates']):\n                self.guiItem.setFrameStyle(i, self.frameStyle[i])\n\n    def setRelief(self, fSetStyle = 1):\n        relief = self['relief']\n        # Convert None, and string arguments\n        if relief is None:\n            relief = PGFrameStyle.TNone\n        elif isinstance(relief, str):\n            # Convert string to frame style int\n            relief = DGG.FrameStyleDict[relief]\n        # Set style\n        if relief == DGG.RAISED:\n            for i in range(self['numStates']):\n                if i in self['invertedFrames']:\n                    self.frameStyle[1].setType(DGG.SUNKEN)\n                else:\n                    self.frameStyle[i].setType(DGG.RAISED)\n        elif relief == DGG.SUNKEN:\n            for i in range(self['numStates']):\n                if i in self['invertedFrames']:\n                    self.frameStyle[1].setType(DGG.RAISED)\n                else:\n                    self.frameStyle[i].setType(DGG.SUNKEN)\n        else:\n            for i in range(self['numStates']):\n                self.frameStyle[i].setType(relief)\n        # Apply styles\n        self.updateFrameStyle()\n\n    def setFrameColor(self):\n        # this might be a single color or a list of colors\n        colors = self['frameColor']\n        if isinstance(colors[0], (int, float)):\n            colors = (colors,)\n        for i in range(self['numStates']):\n            if i >= len(colors):\n                color = colors[-1]\n            else:\n                color = colors[i]\n            self.frameStyle[i].setColor(color[0], color[1], color[2], color[3])\n        self.updateFrameStyle()\n\n    def setFrameTexture(self):\n        # this might be a single texture or a list of textures\n        textures = self['frameTexture']\n        if textures is None or \\\n           isinstance(textures, (Texture, str)):\n            textures = (textures,) * self['numStates']\n        for i in range(self['numStates']):\n            if i >= len(textures):\n                texture = textures[-1]\n            else:\n                texture = textures[i]\n            if isinstance(texture, str):\n                texture = base.loader.loadTexture(texture)\n            if texture:\n                self.frameStyle[i].setTexture(texture)\n            else:\n                self.frameStyle[i].clearTexture()\n        self.updateFrameStyle()\n\n    def setFrameVisibleScale(self):\n        scale = self['frameVisibleScale']\n        for i in range(self['numStates']):\n            self.frameStyle[i].setVisibleScale(scale[0], scale[1])\n        self.updateFrameStyle()\n\n    def setBorderWidth(self):\n        width = self['borderWidth']\n        for i in range(self['numStates']):\n            self.frameStyle[i].setWidth(width[0], width[1])\n        self.updateFrameStyle()\n\n    def setBorderUvWidth(self):\n        uvWidth = self['borderUvWidth']\n        for i in range(self['numStates']):\n            self.frameStyle[i].setUvWidth(uvWidth[0], uvWidth[1])\n        self.updateFrameStyle()\n\n    def destroy(self):\n        if hasattr(self, \"frameStyle\"):\n            if ShowBaseGlobal.__dev__:\n                if hasattr(ShowBase, 'guiItems'):\n                    ShowBase.guiItems.pop(self.guiId, None)\n\n            # Destroy children\n            for child in self.getChildren():\n                childGui = self.guiDict.get(child.getName())\n                if childGui:\n                    childGui.destroy()\n                else:\n                    # RAU since we added the class to the name, try\n                    # it with the original name\n                    parts = child.getName().split('-')\n                    simpleChildGui = self.guiDict.get(parts[-1])\n                    if simpleChildGui:\n                        simpleChildGui.destroy()\n                # messenger.send(DESTROY + child.getName())\n            del self.guiDict[self.guiId]\n            del self.frameStyle\n            # Get rid of node path\n            self.removeNode()\n            for nodePath in self.stateNodePath:\n                nodePath.removeNode()\n            del self.stateNodePath\n            del self.guiItem\n            # Call superclass destruction method (clears out hooks)\n            DirectGuiBase.destroy(self)\n\n    def printConfig(self, indent = 0):\n        space = ' ' * indent\n        print('%s%s - %s' % (space, self.guiId, self.__class__.__name__))\n        print('%sPos:   %s' % (space, tuple(self.getPos())))\n        print('%sScale: %s' % (space, tuple(self.getScale())))\n        # Print out children info\n        for child in self.getChildren():\n            messenger.send(DGG.PRINT + child.getName(), [indent + 2])\n\n    def copyOptions(self, other):\n        \"\"\"\n        Copy other's options into our self so we look and feel like other\n        \"\"\"\n        for key, value in other._optionInfo.items():\n            self[key] = value[1]\n\n    def taskName(self, idString):\n        return idString + \"-\" + str(self.guiId)\n\n    def uniqueName(self, idString):\n        return idString + \"-\" + str(self.guiId)\n\n    def setProp(self, propString, value):\n        \"\"\"\n        Allows you to set a property like frame['text'] = 'Joe' in\n        a function instead of an assignment.\n        This is useful for setting properties inside function intervals\n        where must input a function and extraArgs, not an assignment.\n        \"\"\"\n        self[propString] = value\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/gui/DirectGuiBase.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/414a65d1_DirectGuiBase.json",
    "doc_id": "doc_78"
  }
}