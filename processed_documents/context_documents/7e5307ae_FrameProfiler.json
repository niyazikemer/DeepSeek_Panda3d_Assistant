{
  "content": "from panda3d.core import ConfigVariableBool, ClockObject\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.fsm.StatePush import FunctionCall\nfrom direct.showbase.PythonUtil import formatTimeExact, normalDistrib, serialNum\nfrom direct.showbase.PythonUtil import Functor\nfrom .Task import Task\nfrom .TaskManagerGlobal import taskMgr\n\n\nclass FrameProfiler:\n    notify = directNotify.newCategory('FrameProfiler')\n\n    # because of precision requirements, all times related to the profile/log\n    # schedule are stored as integers\n    Minute = 60\n    Hour = 60 * Minute\n    Day = 24 * Hour\n\n    def __init__(self):\n        Hour = FrameProfiler.Hour\n        # how long to wait between frame profiles\n        frequent_profiles = ConfigVariableBool('frequent-frame-profiles', False)\n        self._period = 2 * FrameProfiler.Minute\n        if frequent_profiles:\n            self._period = 1 * FrameProfiler.Minute\n        # used to prevent profile from being taken exactly every 'period' seconds\n        self._jitterMagnitude = self._period * .75\n        # when to log output\n        # each entry must be an integer multiple of all previous entries\n        # as well as an integer multiple of the period\n        self._logSchedule = [ 1 * FrameProfiler.Hour,\n                              4 * FrameProfiler.Hour,\n                             12 * FrameProfiler.Hour,\n                              1 * FrameProfiler.Day,\n                              ] # day schedule proceeds as 1, 2, 4, 8 days, etc.\n        if frequent_profiles:\n            self._logSchedule = [ 1  * FrameProfiler.Minute,\n                                  4  * FrameProfiler.Minute,\n                                  12 * FrameProfiler.Minute,\n                                  24 * FrameProfiler.Minute,\n                                  ]\n        for t in self._logSchedule:\n            #assert isInteger(t)\n            # make sure the period is evenly divisible into each element of the log schedule\n            assert (t % self._period) == 0\n        # make sure each element of the schedule is evenly divisible into each subsequent element\n        for i in range(len(self._logSchedule)):\n            e = self._logSchedule[i]\n            for j in range(i, len(self._logSchedule)):\n                assert (self._logSchedule[j] % e) == 0\n        #assert isInteger(self._period)\n        self._enableFC = FunctionCall(self._setEnabled, taskMgr.getProfileFramesSV())\n        self._enableFC.pushCurrentState()\n\n    def destroy(self):\n        self._enableFC.set(False)\n        self._enableFC.destroy()\n\n    def _setEnabled(self, enabled):\n        if enabled:\n            self.notify.info('frame profiler started')\n            self._startTime = ClockObject.getGlobalClock().getFrameTime()\n            self._profileCounter = 0\n            self._jitter = None\n            self._period2aggregateProfile = {}\n            self._id2session = {}\n            self._id2task = {}\n            # don't profile process startup\n            self._task = taskMgr.doMethodLater(self._period, self._scheduleNextProfileDoLater,\n                                               'FrameProfilerStart-%s' % serialNum())\n        else:\n            self._task.remove()\n            del self._task\n            for session in self._period2aggregateProfile.values():\n                session.release()\n            del self._period2aggregateProfile\n            for task in self._id2task.values():\n                task.remove()\n            del self._id2task\n            for session in self._id2session.values():\n                session.release()\n            del self._id2session\n            self.notify.info('frame profiler stopped')\n\n    def _scheduleNextProfileDoLater(self, task):\n        self._scheduleNextProfile()\n        return Task.done\n\n    def _scheduleNextProfile(self):\n        self._profileCounter += 1\n        self._timeElapsed = self._profileCounter * self._period\n        #assert isInteger(self._timeElapsed)\n        time = self._startTime + self._timeElapsed\n\n        # vary the actual delay between profiles by a random amount to prevent interaction\n        # with periodic events\n        jitter = self._jitter\n        if jitter is None:\n            jitter = normalDistrib(-self._jitterMagnitude, self._jitterMagnitude)\n            time += jitter\n        else:\n            time -= jitter\n            jitter = None\n        self._jitter = jitter\n\n        sessionId = serialNum()\n        session = taskMgr.getProfileSession('FrameProfile-%s' % sessionId)\n        self._id2session[sessionId] = session\n        taskMgr.profileFrames(num=1, session=session, callback=Functor(\n            self._analyzeResults, sessionId))\n\n        # schedule the next profile\n        delay = max(time - ClockObject.getGlobalClock().getFrameTime(), 0.)\n        self._task = taskMgr.doMethodLater(delay, self._scheduleNextProfileDoLater,\n                                           'FrameProfiler-%s' % serialNum())\n\n    def _analyzeResults(self, sessionId):\n        # do the analysis in a task 1) to separate the processing from the profiled frame,\n        # and 2) to get the processing to show up in a named task instead of in the taskMgr\n        self._id2task[sessionId] = taskMgr.add(\n            Functor(self._doAnalysis, sessionId), 'FrameProfilerAnalysis-%s' % sessionId)\n\n    def _doAnalysis(self, sessionId, task):\n        if hasattr(task, '_generator'):\n            gen = task._generator\n        else:\n            gen = self._doAnalysisGen(sessionId)\n            task._generator = gen\n        result = next(gen)\n        if result == Task.done:\n            del task._generator\n        return result\n\n    def _doAnalysisGen(self, sessionId):\n        # generator to limit max number of profile loggings per frame\n        p2ap = self._period2aggregateProfile\n\n        self._id2task.pop(sessionId)\n        session = self._id2session.pop(sessionId)\n\n        if session.profileSucceeded():\n            # always add this profile to the first aggregated profile\n            period = self._logSchedule[0]\n            if period not in self._period2aggregateProfile:\n                p2ap[period] = session.getReference()\n            else:\n                p2ap[period].aggregate(session)\n        else:\n            self.notify.warning('frame profile did not succeed')\n\n        session.release()\n        session = None\n\n        counter = 0\n\n        # log profiles when it's time, and aggregate them upwards into the\n        # next-longer profile\n        for pi in range(len(self._logSchedule)):\n            period = self._logSchedule[pi]\n            if (self._timeElapsed % period) == 0:\n                if period in p2ap:\n                    # delay until the next frame if we've already processed N profiles this frame\n                    if counter >= 3:\n                        counter = 0\n                        yield Task.cont\n                    self.notify.info('aggregate profile of sampled frames over last %s\\n%s' %\n                                     (formatTimeExact(period), p2ap[period].getResults()))\n                    counter += 1\n                    # aggregate this profile into the next larger profile\n                    nextIndex = pi + 1\n                    if nextIndex >= len(self._logSchedule):\n                        # if we're adding a new period to the end of the log period table,\n                        # set it to double the duration of the current longest period\n                        nextPeriod = period * 2\n                        self._logSchedule.append(nextPeriod)\n                    else:\n                        nextPeriod = self._logSchedule[nextIndex]\n                    if nextPeriod not in p2ap:\n                        p2ap[nextPeriod] = p2ap[period].getReference()\n                    else:\n                        p2ap[nextPeriod].aggregate(p2ap[period])\n                    # this profile is now represented in the next larger profile\n                    # throw it out\n                    p2ap[period].release()\n                    del p2ap[period]\n            else:\n                # current time is not divisible evenly into selected period, and all higher\n                # periods are multiples of this one\n                break\n\n        yield Task.done\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/task/FrameProfiler.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/7e5307ae_FrameProfiler.json",
    "doc_id": "doc_213"
  }
}