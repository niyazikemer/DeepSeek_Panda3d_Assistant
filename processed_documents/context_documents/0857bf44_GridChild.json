{
  "content": "from direct.distributed.DistributedSmoothNodeBase import DistributedSmoothNodeBase\nfrom direct.distributed.GridParent import GridParent\nfrom direct.showbase.PythonUtil import report, getBase\n\n\nclass GridChild:\n    \"\"\"\n    Any object that expects to be parented to a grid should inherit from this.\n    It works with GridParent to manage its grid cell hierarchy in the scenegraph.\n    \"\"\"\n    def __init__(self):\n        try:\n            self.__initiallized\n        except AttributeError:\n            self._gridParent = None\n\n            self._gridInterestEnabled = False\n            self._gridInterests = {}\n\n    def delete(self):\n        self.__setGridParent(None)\n        self.enableGridInterest(False)\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def setGridCell(self, grid, zoneId):\n        if not hasattr(self,'getParent'):\n            return\n        if grid is None:\n            self.__setGridParent(None)\n            self.__clearGridInterest()\n        else:\n            if not self._gridParent:\n                self.__setGridParent(GridParent(self))\n\n            # Does the (wrt)ReparentTo() operation\n            self._gridParent.setGridCell(grid, zoneId)\n\n            # Moves the grid interest along with this child\n            self.updateGridInterest(grid, zoneId)\n\n    def updateGridInterest(self, grid, zoneId):\n        # add additional grid interests (sometimes we want more\n        # than just one)\n        #if self._gridInterestEnabled:\n        self.__setGridInterest(grid, zoneId)\n\n    def enableGridInterest(self, enabled = True):\n        self._gridInterestEnabled = enabled\n        if enabled and self.isOnAGrid():\n            # enable all grid interests I may have\n            for currGridId, interestInfo in self._gridInterests.items():\n                currGrid = getBase().getRepository().doId2do.get(currGridId)\n                if currGrid:\n                    self.__setGridInterest(currGrid, interestInfo[1])\n                else:\n                    self.notify.warning(\"unknown grid interest %s\"%currGridId)\n        else:\n            for currGridId, interestInfo in self._gridInterests.items():\n                self.cr.removeTaggedInterest(interestInfo[0])\n            #self.__clearGridInterest()\n\n    def isOnAGrid(self):\n        return self._gridParent is not None\n\n    def getGrid(self):\n        if self._gridParent:\n            return self._gridParent.getGrid()\n        else:\n            return None\n\n    def getGridZone(self):\n        if self._gridParent:\n            return self._gridParent.getGridZone()\n        else:\n            return None\n\n    def __setGridParent(self, gridParent):\n        if self._gridParent and self._gridParent is not gridParent:\n            self._gridParent.delete()\n        self._gridParent = gridParent\n\n\n    def __setGridInterest(self, grid, zoneId):\n        assert not self.cr.noNewInterests()\n        if self.cr.noNewInterests():\n            self.notify.warning(\n                'startProcessVisibility(%s): tried to open a new interest during logout'\n                % self.doId)\n            return\n\n        gridDoId = grid.getDoId()\n        existingInterest = self._gridInterests.get(gridDoId)\n        if self._gridInterestEnabled:\n            if existingInterest and existingInterest[0]:\n                self.cr.alterInterest(existingInterest[0],\n                                      grid.getDoId(), zoneId)\n                existingInterest[1] = zoneId\n            else:\n                newInterest = self.cr.addTaggedInterest(gridDoId, zoneId,\n                                                        self.cr.ITAG_GAME,\n                                                        self.uniqueName('gridvis'))\n                self._gridInterests[gridDoId] = [newInterest,zoneId]\n        else:\n            # indicate we want this grid interest once gridInterestEnabled is True\n            if game.process == 'client':\n                # we only care about interests on the client\n                self._gridInterests[gridDoId] = [None,zoneId]\n\n    def getGridInterestIds(self):\n        return list(self._gridInterests.keys())\n\n    def getGridInterestZoneId(self,gridDoId):\n        return self._gridInterests.get(gridDoId,[None,None])[1]\n\n    def __clearGridInterest(self):\n        if self._gridInterestEnabled:\n            for currGridId, interestInfo in self._gridInterests.items():\n                self.cr.removeTaggedInterest(interestInfo[0])\n        self._gridInterests = {}\n\n\n\n\n\n\nclass SmoothGridChild(GridChild):\n    \"\"\"\n    SmoothNodes have a special requirement in that they need to send\n    their current cell along with their telemetry data stream. This\n    allows the distributed receiving objects to update their grid parent\n    according to this value, rather than the setLocation() data.\n\n    Use this instead of GridNode when you expect this object to send its\n    telemetry data out.\n    \"\"\"\n    def __init__(self):\n        GridChild.__init__(self)\n        assert isinstance(self, DistributedSmoothNodeBase), \\\n               'All GridChild objects must be instances of DistributedSmoothNodeBase'\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def setGridCell(self, grid, zoneId):\n        GridChild.setGridCell(self, grid, zoneId)\n        if grid and self.isGenerated(): # we get our cnode in DistributedSmoothNodeBase.generate()\n            self.cnode.setEmbeddedVal(zoneId)\n\n    @report(types = ['args'], dConfigParam = 'smoothnode')\n    def transformTelemetry(self, x, y, z, h, p, r, e):\n        # We don't really need to transform telemetry, but\n        # we do update our grid cell such that the new\n        # telemetry is correct now.\n        # We do this instead of overriding setSmPosHprE()\n        # because we're a mixin class.\n        if self.isOnAGrid():\n            self.setGridCell(self.getGrid(), e) # causes a wrtReparent() which updates\n                                                # all previous smooth positions\n        return x, y, z, h, p, r\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/GridChild.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/0857bf44_GridChild.json",
    "doc_id": "doc_337"
  }
}