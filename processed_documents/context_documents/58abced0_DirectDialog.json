{
  "content": "\"\"\"This module defines various dialog windows for the DirectGUI system.\n\nSee the :ref:`directdialog` page in the programming manual for a more\nin-depth explanation and an example of how to use this class.\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    'findDialog', 'cleanupDialog', 'DirectDialog', 'OkDialog',\n    'OkCancelDialog', 'YesNoDialog', 'YesNoCancelDialog', 'RetryCancelDialog',\n]\n\nfrom panda3d.core import NodePath, Point3, TextNode, VBase3\nfrom direct.showbase import ShowBaseGlobal\nfrom . import DirectGuiGlobals as DGG\nfrom .DirectFrame import DirectFrame\nfrom .DirectButton import DirectButton\n\n\ndef findDialog(uniqueName):\n    \"\"\"\n    Returns the panel whose uniqueName is given.  This is mainly\n    useful for debugging, to get a pointer to the current onscreen\n    panel of a particular type.\n    \"\"\"\n    if uniqueName in DirectDialog.AllDialogs:\n        return DirectDialog.AllDialogs[uniqueName]\n    return None\n\n\ndef cleanupDialog(uniqueName):\n    \"\"\"cleanupPanel(string uniqueName)\n\n    Cleans up (removes) the panel with the given uniqueName.  This\n    may be useful when some panels know about each other and know\n    that opening panel A should automatically close panel B, for\n    instance.\n    \"\"\"\n    if uniqueName in DirectDialog.AllDialogs:\n        # calling cleanup() will remove it out of the AllDialogs dict\n        # This way it will get removed from the dict even it we did\n        # not clean it up using this interface (ie somebody called\n        # self.cleanup() directly\n        DirectDialog.AllDialogs[uniqueName].cleanup()\n\n\nclass DirectDialog(DirectFrame):\n\n    AllDialogs: dict[str, DirectDialog] = {}\n    PanelIndex = 0\n\n    def __init__(self, parent=None, **kw):\n        \"\"\"Creates a popup dialog to alert and/or interact with user.\n        Some of the main keywords that can be used to customize the dialog:\n\n        Parameters:\n            text (str): Text message/query displayed to user\n            geom: Geometry to be displayed in dialog\n            buttonTextList: List of text to show on each button\n            buttonGeomList: List of geometry to show on each button\n            buttonImageList: List of images to show on each button\n            buttonValueList: List of values sent to dialog command for\n                each button.  If value is [] then the ordinal rank of\n                the button is used as its value.\n            buttonHotKeyList: List of hotkeys to bind to each button.\n                Typing the hotkey is equivalent to pressing the\n                corresponding button.\n            suppressKeys: Set to true if you wish to suppress keys\n                (i.e. Dialog eats key event), false if you wish Dialog\n                to pass along key event.\n            buttonSize: 4-tuple used to specify custom size for each\n                button (to make bigger then geom/text for example)\n            pad: Space between border and interior graphics\n            topPad: Extra space added above text/geom/image\n            midPad: Extra space added between text/buttons\n            sidePad: Extra space added to either side of text/buttons\n            buttonPadSF: Scale factor used to expand/contract button\n                horizontal spacing\n            command: Callback command used when a button is pressed.\n                Value supplied to command depends on values in\n                buttonValueList.\n\n        Note:\n            The number of buttons on the dialog depends on the maximum\n            length of any button[Text|Geom|Image|Value]List specified.\n            Values of None are substituted for lists that are shorter\n            than the max length\n         \"\"\"\n\n        # Inherits from DirectFrame\n        optiondefs = (\n            # Define type of DirectGuiWidget\n            ('dialogName',        'DirectDialog_' + repr(DirectDialog.PanelIndex),  DGG.INITOPT),\n            # Default position is slightly forward in Y, so as not to\n            # intersect the near plane, which is incorrectly set to 0\n            # in DX for some reason.\n            ('pos',               (0, 0.1, 0),   None),\n            ('pad',               (0.1, 0.1),    None),\n            ('text',              '',            None),\n            ('text_align',        TextNode.ALeft,   None),\n            ('text_scale',        0.06,          None),\n            ('image',             DGG.getDefaultDialogGeom(), None),\n            ('relief',            DGG.getDefaultDialogRelief(), None),\n            ('borderWidth',       (0.01, 0.01),  None),\n            ('buttonTextList',    [],            DGG.INITOPT),\n            ('buttonGeomList',    [],            DGG.INITOPT),\n            ('buttonImageList',   [],            DGG.INITOPT),\n            ('buttonValueList',   [],            DGG.INITOPT),\n            ('buttonHotKeyList',  [],            DGG.INITOPT),\n            ('button_borderWidth', (.01, .01),   None),\n            ('button_pad',        (.01, .01),    None),\n            ('button_relief',     DGG.RAISED,    None),\n            ('button_text_scale', 0.06,          None),\n            ('buttonSize',        None,          DGG.INITOPT),\n            ('topPad',            0.06,          DGG.INITOPT),\n            ('midPad',            0.12,          DGG.INITOPT),\n            ('sidePad',           0.,            DGG.INITOPT),\n            ('buttonPadSF',       1.1,           DGG.INITOPT),\n            # Alpha of fade screen behind dialog\n            ('fadeScreen',        0,             None),\n            ('command',           None,          None),\n            ('extraArgs',         [],            None),\n            ('sortOrder',    DGG.NO_FADE_SORT_INDEX, None),\n        )\n        # Merge keyword options with default options\n        self.defineoptions(kw, optiondefs, dynamicGroups = (\"button\",))\n\n        # Initialize superclasses\n        DirectFrame.__init__(self, parent)\n\n        #if not self['dialogName']:\n        #    self['dialogName'] = 'DirectDialog_' + repr(DirectDialog.PanelIndex)\n\n        # Clean up any previously existing panel with the same unique\n        # name.  We don't allow any two panels with the same name to\n        # coexist.\n        cleanupDialog(self['dialogName'])\n        # Store this panel in our map of all open panels.\n        DirectDialog.AllDialogs[self['dialogName']] = self\n        DirectDialog.PanelIndex += 1\n\n        # Determine number of buttons\n        self.numButtons = max(len(self['buttonTextList']),\n                              len(self['buttonGeomList']),\n                              len(self['buttonImageList']),\n                              len(self['buttonValueList']))\n        # Create buttons\n        self.buttonList = []\n        index = 0\n        for i in range(self.numButtons):\n            name = 'Button' + repr(i)\n            try:\n                text = self['buttonTextList'][i]\n            except IndexError:\n                text = None\n            try:\n                geom = self['buttonGeomList'][i]\n            except IndexError:\n                geom = None\n            try:\n                image = self['buttonImageList'][i]\n            except IndexError:\n                image = None\n            try:\n                value = self['buttonValueList'][i]\n            except IndexError:\n                value = i\n                self['buttonValueList'].append(i)\n            try:\n                hotKey = self['buttonHotKeyList'][i]\n            except IndexError:\n                hotKey = None\n            button = self.createcomponent(\n                name, (), \"button\",\n                DirectButton, (self,),\n                text = text,\n                geom = geom,\n                image = image,\n                suppressKeys = self['suppressKeys'],\n                frameSize = self['buttonSize'],\n                command = lambda s = self, v = value: s.buttonCommand(v)\n            )\n            self.buttonList.append(button)\n\n        # Update dialog when everything has been initialised\n        self.postInitialiseFuncList.append(self.configureDialog)\n        self.initialiseoptions(DirectDialog)\n\n    def configureDialog(self):\n        # Set up hot key bindings\n        bindList = zip(self.buttonList, self['buttonHotKeyList'],\n                       self['buttonValueList'])\n        for button, hotKey, value in bindList:\n            if isinstance(hotKey, (list, tuple)):\n                for key in hotKey:\n                    button.bind('press-' + key + '-', self.buttonCommand,\n                                extraArgs = [value])\n                    self.bind('press-' + key + '-', self.buttonCommand,\n                              extraArgs = [value])\n\n            else:\n                button.bind('press-' + hotKey + '-', self.buttonCommand,\n                            extraArgs = [value])\n                self.bind('press-' + hotKey + '-', self.buttonCommand,\n                          extraArgs = [value])\n        # Position buttons and text\n        pad = self['pad']\n        if self.hascomponent('image0'):\n            image = self.component('image0')\n        else:\n            image = None\n        # Get size of text/geom without image (for state 0)\n        if image:\n            image.reparentTo(ShowBaseGlobal.hidden)\n        bounds = self.stateNodePath[0].getTightBounds()\n        if image:\n            image.reparentTo(self.stateNodePath[0])\n        if bounds is None:\n            l = 0\n            r = 0\n            b = 0\n            t = 0\n        else:\n            l = bounds[0][0]\n            r = bounds[1][0]\n            b = bounds[0][2]\n            t = bounds[1][2]\n        # Center text and geom around origin\n        # How far is center of text from origin?\n        xOffset = -(l+r)*0.5\n        zOffset = -(b+t)*0.5\n        # Update bounds to reflect text movement\n        l += xOffset\n        r += xOffset\n        b += zOffset\n        t += zOffset\n        # Offset text and geom to center\n        if self['text']:\n            self['text_pos'] = (self['text_pos'][0] + xOffset,\n                                self['text_pos'][1] + zOffset)\n        if self['geom']:\n            self['geom_pos'] = Point3(self['geom_pos'][0] + xOffset,\n                                      self['geom_pos'][1],\n                                      self['geom_pos'][2] + zOffset)\n        if self.numButtons != 0:\n            bpad = self['button_pad']\n            # Get button size\n            if self['buttonSize']:\n                # Either use given size\n                buttonSize = self['buttonSize']\n                bl = buttonSize[0]\n                br = buttonSize[1]\n                bb = buttonSize[2]\n                bt = buttonSize[3]\n            else:\n                # Or get bounds of union of buttons\n                bl = br = bb = bt = 0\n                for button in self.buttonList:\n                    bounds = button.stateNodePath[0].getTightBounds()\n                    if bounds is None:\n                        bl = 0\n                        br = 0\n                        bb = 0\n                        bt = 0\n                    else:\n                        bl = min(bl, bounds[0][0])\n                        br = max(br, bounds[1][0])\n                        bb = min(bb, bounds[0][2])\n                        bt = max(bt, bounds[1][2])\n                bl -= bpad[0]\n                br += bpad[0]\n                bb -= bpad[1]\n                bt += bpad[1]\n                # Now resize buttons to match largest\n                for button in self.buttonList:\n                    button['frameSize'] = (bl, br, bb, bt)\n            # Must compensate for scale\n            scale = self['button_scale']\n            # Can either be a Vec3 or a tuple of 3 values\n            if isinstance(scale, (VBase3, list, tuple)):\n                sx = scale[0]\n                sz = scale[2]\n            elif isinstance(scale, (int, float)):\n                sx = sz = scale\n            else:\n                sx = sz = 1\n            bl *= sx\n            br *= sx\n            bb *= sz\n            bt *= sz\n            # Position buttons\n            # Calc button width and height\n            bHeight = bt - bb\n            bWidth = br - bl\n            # Add pad between buttons\n            bSpacing = self['buttonPadSF'] * bWidth\n            bPos = -bSpacing * (self.numButtons - 1)*0.5\n            index = 0\n            for button in self.buttonList:\n                button.setPos(bPos + index * bSpacing, 0,\n                              b - self['midPad'] - bpad[1] - bt)\n                index += 1\n            bMax = bPos + bSpacing * (self.numButtons - 1)\n        else:\n            bpad = 0\n            bl = br = bb = bt = 0\n            bPos = 0\n            bMax = 0\n            bpad = (0, 0)\n            bHeight = bWidth = 0\n        # Resize frame to fit text and buttons\n        l = min(bPos + bl, l) - pad[0]\n        r = max(bMax + br, r) + pad[0]\n        sidePad = self['sidePad']\n        l -= sidePad\n        r += sidePad\n        # reduce bottom by pad, button height and 2*button pad\n        b = min(b - self['midPad'] - bpad[1] - bHeight - bpad[1], b) - pad[1]\n        t = t + self['topPad'] + pad[1]\n        if self['frameSize'] is None:\n            self['frameSize'] = (l, r, b, t)\n        self['image_scale'] = (r - l, 1, t - b)\n        # Center frame about text and buttons\n        self['image_pos'] = ((l+r)*0.5, 0.0, (b+t)*0.5)\n        self.resetFrameSize()\n\n    def show(self):\n        if self['fadeScreen']:\n            base.transitions.fadeScreen(self['fadeScreen'])\n            self.setBin('gui-popup', 0)\n        NodePath.show(self)\n\n    def hide(self):\n        if self['fadeScreen']:\n            base.transitions.noTransitions()\n        NodePath.hide(self)\n\n    def buttonCommand(self, value, event = None):\n        if self['command']:\n            self['command'](value, *self['extraArgs'])\n\n    def setMessage(self, message):\n        self['text'] = message\n        self.configureDialog()\n\n    def cleanup(self):\n        # Remove this panel out of the AllDialogs list\n        uniqueName = self['dialogName']\n        if uniqueName in DirectDialog.AllDialogs:\n            del DirectDialog.AllDialogs[uniqueName]\n        self.destroy()\n\n    def destroy(self):\n        if self['fadeScreen']:\n            base.transitions.noTransitions()\n        for button in self.buttonList:\n            button.destroy()\n        DirectFrame.destroy(self)\n\n\nclass OkDialog(DirectDialog):\n    def __init__(self, parent = None, **kw):\n        # Inherits from DirectFrame\n        optiondefs = (\n            # Define type of DirectGuiWidget\n            ('buttonTextList',  ['OK'],       DGG.INITOPT),\n            ('buttonValueList', [DGG.DIALOG_OK],          DGG.INITOPT),\n        )\n        # Merge keyword options with default options\n        self.defineoptions(kw, optiondefs)\n        DirectDialog.__init__(self, parent)\n        self.initialiseoptions(OkDialog)\n\n\nclass OkCancelDialog(DirectDialog):\n    def __init__(self, parent = None, **kw):\n        # Inherits from DirectFrame\n        optiondefs = (\n            # Define type of DirectGuiWidget\n            ('buttonTextList',  ['OK','Cancel'],       DGG.INITOPT),\n            ('buttonValueList', [DGG.DIALOG_OK, DGG.DIALOG_CANCEL], DGG.INITOPT),\n        )\n        # Merge keyword options with default options\n        self.defineoptions(kw, optiondefs)\n        DirectDialog.__init__(self, parent)\n        self.initialiseoptions(OkCancelDialog)\n\n\nclass YesNoDialog(DirectDialog):\n    def __init__(self, parent = None, **kw):\n        # Inherits from DirectFrame\n        optiondefs = (\n            # Define type of DirectGuiWidget\n            ('buttonTextList',  ['Yes', 'No'],       DGG.INITOPT),\n            ('buttonValueList', [DGG.DIALOG_YES, DGG.DIALOG_NO], DGG.INITOPT),\n        )\n        # Merge keyword options with default options\n        self.defineoptions(kw, optiondefs)\n        DirectDialog.__init__(self, parent)\n        self.initialiseoptions(YesNoDialog)\n\n\nclass YesNoCancelDialog(DirectDialog):\n    def __init__(self, parent = None, **kw):\n        # Inherits from DirectFrame\n        optiondefs = (\n            # Define type of DirectGuiWidget\n            ('buttonTextList',  ['Yes', 'No', 'Cancel'],  DGG.INITOPT),\n            ('buttonValueList', [DGG.DIALOG_YES, DGG.DIALOG_NO, DGG.DIALOG_CANCEL],\n             DGG.INITOPT),\n        )\n        # Merge keyword options with default options\n        self.defineoptions(kw, optiondefs)\n        DirectDialog.__init__(self, parent)\n        self.initialiseoptions(YesNoCancelDialog)\n\n\nclass RetryCancelDialog(DirectDialog):\n    def __init__(self, parent = None, **kw):\n        # Inherits from DirectFrame\n        optiondefs = (\n            # Define type of DirectGuiWidget\n            ('buttonTextList',  ['Retry','Cancel'],   DGG.INITOPT),\n            ('buttonValueList', [DGG.DIALOG_RETRY, DGG.DIALOG_CANCEL], DGG.INITOPT),\n        )\n        # Merge keyword options with default options\n        self.defineoptions(kw, optiondefs)\n        DirectDialog.__init__(self, parent)\n        self.initialiseoptions(RetryCancelDialog)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/gui/DirectDialog.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/58abced0_DirectDialog.json",
    "doc_id": "doc_89"
  }
}