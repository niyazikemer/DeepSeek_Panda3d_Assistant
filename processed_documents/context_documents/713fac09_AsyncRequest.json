{
  "content": "from __future__ import annotations\n\n#from otp.ai.AIBaseGlobal import *\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom panda3d.core import ConfigVariableDouble, ConfigVariableInt, ConfigVariableBool\n\nASYNC_REQUEST_DEFAULT_TIMEOUT_IN_SECONDS = 8.0\nASYNC_REQUEST_INFINITE_RETRIES = -1\nASYNC_REQUEST_DEFAULT_NUM_RETRIES = 0\n\nif __debug__:\n    _overrideTimeoutTimeForAllAsyncRequests = ConfigVariableDouble(\"async-request-timeout\", -1.0)\n    _overrideNumRetriesForAllAsyncRequests = ConfigVariableInt(\"async-request-num-retries\", -1)\n    _breakOnTimeout = ConfigVariableBool(\"async-request-break-on-timeout\", False)\n\nclass AsyncRequest(DirectObject):\n    \"\"\"\n    This class is used to make asynchronous reads and creates to a database.\n\n    You can create a list of self.neededObjects and then ask for each to be\n    read or created, or if you only have one object that you need you can\n    skip the self.neededObjects because calling askForObject or createObject\n    will set the self.neededObjects value for you.\n\n    Once all the objects have been read or created, the self.finish() method\n    will be called.  You may override this function to run your code in a\n    derived class.\n\n    If you wish to queue up several items that you all need before the finish\n    method is called, you can put items in self.neededObjects and then call\n    askForObject or createObject afterwards.  That way the _checkCompletion\n    will not call finish until after all the requests have been done.\n\n    If you need to chain serveral object reads or creates, just add more\n    entries to the self.neededObjects dictionary in the self.finish function\n    and return without calling AsyncRequest.finish().  Your finish method\n    will be called again when the new self.neededObjects is complete.  You\n    may repeat this as necessary.\n    \"\"\"\n    _asyncRequests: dict[int, AsyncRequest] = {}\n\n    notify = DirectNotifyGlobal.directNotify.newCategory('AsyncRequest')\n\n    def __init__(self, air, replyToChannelId = None,\n                 timeoutTime = ASYNC_REQUEST_DEFAULT_TIMEOUT_IN_SECONDS,\n                 numRetries = ASYNC_REQUEST_DEFAULT_NUM_RETRIES):\n        \"\"\"\n        air is the AI Respository.\n        replyToChannelId may be an avatarId, an accountId, or a channelId.\n        timeoutTime is how many seconds to wait before aborting the request.\n        numRetries is the number of times to retry the request before giving up.\n        \"\"\"\n        assert AsyncRequest.notify.debugCall()\n        if __debug__:\n            if _overrideTimeoutTimeForAllAsyncRequests.getValue() >= 0.0:\n                timeoutTime = _overrideTimeoutTimeForAllAsyncRequests.getValue()\n            if _overrideNumRetriesForAllAsyncRequests.getValue() >= 0:\n                numRetries = _overrideNumRetriesForAllAsyncRequests.getValue()\n        AsyncRequest._asyncRequests[id(self)] = self\n        self.deletingMessage = \"AsyncRequest-deleting-%s\"%(id(self,))\n        self.air = air\n        self.replyToChannelId = replyToChannelId\n        self.timeoutTask = None\n        self.neededObjects = {}\n        self._timeoutTime = timeoutTime\n        self._initialNumRetries = numRetries\n\n    def delete(self):\n        assert AsyncRequest.notify.debugCall()\n        del AsyncRequest._asyncRequests[id(self)]\n        self.ignoreAll()\n        self._resetTimeoutTask(False)\n        messenger.send(self.deletingMessage, [])\n        del self.neededObjects\n        del self.air\n        del self.replyToChannelId\n\n    def askForObjectField(\n            self, dclassName, fieldName, doId, key = None, context = None):\n        \"\"\"\n        Request an already created object, i.e. read from database.\n        \"\"\"\n        assert AsyncRequest.notify.debugCall()\n        if key is None:\n            # default the dictionary key to the fieldName\n            key = fieldName\n        assert doId\n        if context is None:\n            context = self.air.allocateContext()\n        self.air.contextToClassName[context] = dclassName\n        self.acceptOnce(\n            \"doFieldResponse-%s\"%(context,),\n            self._checkCompletion, [key])\n\n        self.neededObjects[key] = None\n\n        self.air.queryObjectField(dclassName, fieldName, doId, context)\n        self._resetTimeoutTask()\n\n    def askForObjectFields(\n            self, dclassName, fieldNames, doId, key = None, context = None):\n        \"\"\"\n        Request an already created object, i.e. read from database.\n        \"\"\"\n        assert AsyncRequest.notify.debugCall()\n        if key is None:\n            # default the dictionary key to the fieldName\n            key = fieldNames[0]\n        assert doId\n        if context is None:\n            context = self.air.allocateContext()\n        self.air.contextToClassName[context] = dclassName\n        self.acceptOnce(\n            \"doFieldResponse-%s\"%(context,),\n            self._checkCompletion, [key])\n        self.air.queryObjectFields(dclassName, fieldNames, doId, context)\n        self._resetTimeoutTask()\n\n    def askForObjectFieldsByString(self, dbId, dclassName, objString, fieldNames, key=None, context=None):\n        assert AsyncRequest.notify.debugCall()\n        assert dbId\n        if key is None:\n            # default the dictionary key to the fieldNames\n            key = fieldNames\n        if context is None:\n            context=self.air.allocateContext()\n        self.air.contextToClassName[context]=dclassName\n        self.acceptOnce(\n            \"doFieldResponse-%s\"%(context,),\n            self._checkCompletion, [key])\n        self.air.queryObjectStringFields(dbId,dclassName,objString,fieldNames,context)\n        self._resetTimeoutTask()\n\n    def askForObject(self, doId, context = None):\n        \"\"\"\n        Request an already created object, i.e. read from database.\n        \"\"\"\n        assert AsyncRequest.notify.debugCall()\n        assert doId\n        if context is None:\n            context = self.air.allocateContext()\n        self.acceptOnce(\n            \"doRequestResponse-%s\"%(context,),\n            self._checkCompletion, [None])\n        self.air.queryObjectAll(doId, context)\n        self._resetTimeoutTask()\n\n    def createObject(self, name, className,\n            databaseId = None, values = None, context = None):\n        \"\"\"\n        Create a new database object.  You can get the doId from within\n        your self.finish() function.\n\n        This functions is different from createObjectId in that it does\n        generate the object when the response comes back.  The object is\n        added to the doId2do and so forth and treated as a full regular\n        object (which it is).  This is useful on the AI where we really\n        do want the object on the AI.\n        \"\"\"\n        assert AsyncRequest.notify.debugCall()\n        assert name\n        assert className\n        self.neededObjects[name] = None\n        if context is None:\n            context = self.air.allocateContext()\n        self.accept(\n            self.air.getDatabaseGenerateResponseEvent(context),\n            self._doCreateObject, [name, className, values])\n        self.air.requestDatabaseGenerate(\n            className, context, databaseId = databaseId, values = values)\n        self._resetTimeoutTask()\n\n    def createObjectId(self, name, className, values = None, context = None):\n        \"\"\"\n        Create a new database object.  You can get the doId from within\n        your self.finish() function.\n\n        This functions is different from createObject in that it does not\n        generate the object when the response comes back.  It only tells you\n        the doId.  This is useful on the UD where we don't really want the\n        object on the UD, we just want the object created and the UD wants\n        to send messages to it using the ID.\n        \"\"\"\n        assert AsyncRequest.notify.debugCall()\n        assert name\n        assert className\n        self.neededObjects[name] = None\n        if context is None:\n            context = self.air.allocateContext()\n        self.accept(\n            self.air.getDatabaseGenerateResponseEvent(context),\n            self._checkCompletion, [name, None])\n        self.air.requestDatabaseGenerate(className, context, values = values)\n        self._resetTimeoutTask()\n\n    def finish(self):\n        \"\"\"\n        This is the function that gets called when all of the needed objects\n        are in (i.e. all the askForObject and createObject requests have\n        been satisfied).\n        If the other requests timeout, finish will not be called.\n        \"\"\"\n        assert self.notify.debugCall()\n        self.delete()\n\n    def _doCreateObject(self, name, className, values, doId):\n        isInDoId2do = doId in self.air.doId2do\n        distObj = self.air.generateGlobalObject(doId, className, values)\n        if not isInDoId2do and game.name == 'uberDog':\n            # only remove doId if this is the uberdog?, in pirates this was\n            # causing traded inventory objects to be generated twice, once\n            # here and again later when it was noticed the doId was not in\n            # the doId2do list yet.\n            self.air.doId2do.pop(doId, None)\n        self._checkCompletion(name, None, distObj)\n\n    def _checkCompletion(self, name, context, distObj):\n        \"\"\"\n        This checks whether we have all the needed objects and calls\n        finish() if we do.\n        \"\"\"\n        if name is not None:\n            self.neededObjects[name] = distObj\n        else:\n            self.neededObjects[distObj.doId] = distObj\n        for i in self.neededObjects.values():\n            if i is None:\n                return\n        self.finish()\n\n    def _resetTimeoutTask(self, createAnew = True):\n        if self.timeoutTask:\n            taskMgr.remove(self.timeoutTask)\n            self.timeoutTask = None\n        if createAnew:\n            self.numRetries = self._initialNumRetries\n            self.timeoutTask = taskMgr.doMethodLater(\n                self._timeoutTime, self.timeout,\n                \"AsyncRequestTimer-%s\"%(id(self,)))\n\n    def timeout(self, task):\n        assert AsyncRequest.notify.debugCall(\n            \"neededObjects: %s\"%(self.neededObjects,))\n        if self.numRetries > 0:\n            assert AsyncRequest.notify.debug(\n                'Timed out. Trying %d more time(s) : %s' %\n                (self.numRetries + 1, repr(self.neededObjects)))\n            self.numRetries -= 1\n            return Task.again\n        else:\n            if __debug__:\n                if _breakOnTimeout:\n                    if hasattr(self, \"avatarId\"):\n                        print(\"\\n\\nself.avatarId =\", self.avatarId)\n                    print(\"\\nself.neededObjects =\", self.neededObjects)\n                    print(\"\\ntimed out after %s seconds.\\n\\n\"%(task.delayTime,))\n                    import pdb\n                    pdb.set_trace()\n            self.delete()\n            return Task.done\n\ndef cleanupAsyncRequests():\n    \"\"\"\n    Only call this when the application is shuting down.\n    \"\"\"\n    for asyncRequest in AsyncRequest._asyncRequests:\n        asyncRequest.delete()\n    assert not AsyncRequest._asyncRequests\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/AsyncRequest.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/713fac09_AsyncRequest.json",
    "doc_id": "doc_309"
  }
}