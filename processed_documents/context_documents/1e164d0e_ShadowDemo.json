{
  "content": "\"\"\"Create a cheesy shadow effect by rendering the view of an\nobject (e.g. the local avatar) from a special camera as seen from\nabove (as if from the sun), using a solid gray foreground and a\nsolid white background, and then multitexturing that view onto the\nworld.\n\nThis is meant primarily as a demonstration of multipass and\nmultitexture rendering techniques.  It's not a particularly great\nway to do shadows.\n\"\"\"\n\n__all__ = ['ShadowCaster', 'avatarShadow', 'piratesAvatarShadow', 'arbitraryShadow']\n\nfrom panda3d.core import Camera, NodePath, OrthographicLens, Texture, TextureStage, VBase4\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\n\nsc = None\n\nclass ShadowCaster:\n    texXSize = 128\n    texYSize = 128\n\n    def __init__(self, lightPath, objectPath, filmX, filmY):\n        self.lightPath = lightPath\n        self.objectPath = objectPath\n        self.groundPath = None\n\n        # Create an offscreen buffer to render the view of the avatar\n        # into a texture.\n        self.buffer = base.win.makeTextureBuffer(\n            'shadowBuffer', self.texXSize, self.texYSize)\n\n        # The background of this buffer--and the border of the\n        # texture--is pure white.\n        clearColor = VBase4(1, 1, 1, 1)\n        self.buffer.setClearColor(clearColor)\n        self.tex = self.buffer.getTexture()\n        self.tex.setBorderColor(clearColor)\n        self.tex.setWrapU(Texture.WMBorderColor)\n        self.tex.setWrapV(Texture.WMBorderColor)\n\n        # Set up a display region on this buffer, and create a camera.\n        dr = self.buffer.makeDisplayRegion()\n        self.camera = Camera('shadowCamera')\n        self.cameraPath = self.lightPath.attachNewNode(self.camera)\n        self.camera.setScene(self.objectPath)\n        dr.setCamera(self.cameraPath)\n\n        # Use a temporary NodePath to define the initial state for the\n        # camera.  The initial state will render everything in a\n        # flat-shaded gray, as if it were a shadow.\n        initial = NodePath('initial')\n        initial.setColor(0.6, 0.6, 0.6, 1, 1)\n        initial.setTextureOff(2)\n        initial.setLightOff(2)\n        self.camera.setInitialState(initial.getState())\n\n        # Use an orthographic lens for this camera instead of the\n        # usual perspective lens.  An orthographic lens is better to\n        # simulate sunlight, which is (almost) orthographic.  We set\n        # the film size large enough to render a typical avatar (but\n        # not so large that we lose detail in the texture).\n        self.lens = OrthographicLens()\n        self.lens.setFilmSize(filmX, filmY)\n        self.camera.setLens(self.lens)\n\n        # Finally, we'll need a unique TextureStage to apply this\n        # shadow texture to the world.\n        self.stage = TextureStage('shadow')\n\n        # Make sure the shadowing object doesn't get its own shadow\n        # applied to it.\n        self.objectPath.setTextureOff(self.stage)\n\n    def setGround(self, groundPath):\n        \"\"\" Specifies the part of the world that is to be considered\n        the ground: this is the part onto which the rendered texture\n        will be applied. \"\"\"\n\n        if self.groundPath:\n            self.groundPath.clearProjectTexture(self.stage)\n\n        self.groundPath = groundPath\n        self.groundPath.projectTexture(self.stage, self.tex, self.cameraPath)\n\n    def clear(self):\n        \"\"\" Undoes the effect of the ShadowCaster. \"\"\"\n        if self.groundPath:\n            self.groundPath.clearProjectTexture(self.stage)\n            self.groundPath = None\n\n        if self.lightPath:\n            self.lightPath.detachNode()\n            self.lightPath = None\n\n        if self.cameraPath:\n            self.cameraPath.detachNode()\n            self.cameraPath = None\n            self.camera = None\n            self.lens = None\n\n        if self.buffer:\n            base.graphicsEngine.removeWindow(self.buffer)\n            self.tex = None\n            self.buffer = None\n\ndef avatarShadow():\n    # Turn off the existing drop shadow.\n    # stash it so that when the game hides and shows it, it will still be gone\n    base.localAvatar.dropShadow.stash()\n\n    # Set up a new node to hold the \"light\": this is an abitrary point\n    # somewhere above the avatar, looking down, as if from the sun.\n    objectPath = base.localAvatar.getGeomNode()\n    shadowCamera = objectPath.attachNewNode('shadowCamera')\n    lightPath = shadowCamera.attachNewNode('lightPath')\n\n    # We can change this position at will to change the angle of the\n    # sun.\n    lightPath.setPos(5, 0, 7)\n\n    # We need a task to keep the shadowCamera rotated in the same\n    # direction relative to render (otherwise, the shadow seems to\n    # rotate when you rotate your avatar, which is strange).  We can't\n    # just use a compass effect, since that doesn't work on cameras.\n    def shadowCameraRotate(task, shadowCamera = shadowCamera):\n        shadowCamera.setHpr(render, 0, 0, 0)\n        lightPath.lookAt(shadowCamera, 0, 0, 3)\n        return Task.cont\n\n    taskMgr.remove('shadowCamera')\n    taskMgr.add(shadowCameraRotate, 'shadowCamera')\n\n    global sc\n    if sc is not None:\n        sc.clear()\n\n    sc = ShadowCaster(lightPath, objectPath, 4, 6)\n\n    # Naively, just apply the shadow to everything in the world.  It\n    # would probably be better to use a little restraint.\n    sc.setGround(render)\n\n    return sc\n\ndef piratesAvatarShadow():\n    a = avatarShadow()\n    # Force the lod to be 0 at all times\n    base.localAvatar.getGeomNode().getChild(0).node().forceSwitch(0)\n    return a\n\ndef arbitraryShadow(node):\n    # Turn off the existing drop shadow, if any\n    if hasattr(node, \"dropShadow\"):\n        # stash it so that when the game hides and shows it, it will still be gone\n        node.dropShadow.stash()\n\n    # Set up a new node to hold the \"light\": this is an abitrary point\n    # somewhere above the node, looking down, as if from the sun.\n    objectPath = node\n    shadowCamera = objectPath.attachNewNode('shadowCamera')\n    lightPath = shadowCamera.attachNewNode('lightPath')\n\n    # We can change this position at will to change the angle of the\n    # sun.\n    lightPath.setPos(50, 0, 50)\n\n    # We need a task to keep the shadowCamera rotated in the same\n    # direction relative to render (otherwise, the shadow seems to\n    # rotate when you rotate your avatar, which is strange).  We can't\n    # just use a compass effect, since that doesn't work on cameras.\n    def shadowCameraRotate(task, shadowCamera = shadowCamera):\n        shadowCamera.setHpr(render, 0, 0, 0)\n        lightPath.lookAt(shadowCamera, 0, 0, 3)\n        return Task.cont\n\n    taskMgr.remove('shadowCamera')\n    taskMgr.add(shadowCameraRotate, 'shadowCamera')\n\n    global sc\n    if sc is not None:\n        sc.clear()\n\n    sc = ShadowCaster(lightPath, objectPath, 100, 100)\n\n    # Naively, just apply the shadow to everything in the world.  It\n    # would probably be better to use a little restraint.\n    sc.setGround(render)\n\n    return sc\n\n##def testShadow():\n##    a = piratesAvatarShadow()\n##\n##from direct.showbase.ShadowDemo import *\n##from direct.interval.IntervalGlobal import *\n##b = loader.loadModel('/i/beta/PotC/Maya/Pirates/scenes/models/sets/buildings/spanish_buildings/TavernIntExt/tavern_ext/bar.egg')\n##bs = arbitraryShadow(b)\n##s = loader.loadModel('smiley')\n##s.reparentTo(bs.lightPath)\n##b.reparentTo((base.localAvatar))\n##a = AmbientLight('cloudAmbientHi')\n##a.setColor(Vec4(0.9, 0.9, 0.9, 1.000))\n##aNP = s.attachNewNode(a)\n##b.setLight(aNP)\n##d = DirectionalLight(\"chernabogDirectionalLight\")\n##d.setDirection(Vec3(0, 1, 0))\n##d.setColor(Vec4(1))\n###d.setColor(Vec4(0.9, 0.7, 0.7, 1.000))\n##dNP = s.attachNewNode(d)\n##b.setLight(dNP)\n##\n##ival = Sequence(LerpPosInterval(bs.lightPath, 0.0, Vec3(-200, 0, 50)),\n##                LerpPosInterval(bs.lightPath, 10.0, Vec3(-200, 0, 200)),\n##                LerpPosInterval(bs.lightPath, 10.0, Vec3(200, 0, 200)),\n##                LerpPosInterval(bs.lightPath, 10.0, Vec3(200, 0, 50)),\n##)\n##ival.loop()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/ShadowDemo.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/1e164d0e_ShadowDemo.json",
    "doc_id": "doc_282"
  }
}