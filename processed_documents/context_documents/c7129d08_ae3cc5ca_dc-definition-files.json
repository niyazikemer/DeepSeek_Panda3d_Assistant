{
  "content": "Distributed Class Definition\n\nThe .dc file defines what distributed objects, and their functions, are communicated across the network.\n\nA direct.dc file is shipped with the engine and placed in the direct/distributed/ path, which defines the necessary functionality for the distributed objects bundled with Panda3D. You may want to copy this file to a more convenient location related to your game to simplify the loading with the lists used in the repositories shown before.\n\nThe syntax is a mix of C++ and python.\n\nA simple example of such a dc file may look as follows.\n\nimport DGameObject/AI\nimport AIDGameObject/AI\n\nstruct gameDataModel {\n  string value_a;\n  uint8 value_b;\n  int8 value_c/100;\n}\n\ndclass DGameObject: DistributedObject {\n  sendGameData(gameDataModel data) p2p;\n};\n\ndclass AIDGameObject: DistributedObject {\n  setAnounceGenerate(string helloMsg) broadcast ram;\n  messageRoundtripToAI(gameDataModel data) p2p;\n  messageRoundtripToClient(gameDataModel data) p2p;\n}\n\nKeywords\n\nKeywords define the circumstances for propagating the data. They must be defined at the start of the file.\n\nPossible keywords are shown below:\n\nkeyword required;\nkeyword broadcast;\nkeyword ram;\nkeyword p2p;\nkeyword clsend;\n\nThe keywords are used for the following\n\nThe required statement at the end of a field determines that this field has to be set at the generation of the object. These fields have to be called set* as a convention as in the python representation of that class the set gets taken away at generation time and will be replaced with a get to call the set value with the get functions return value.\n\nFor example, taking the dc representation of an Avatar class as defined here\u2026\n\nimport Avatar\ndclass Avatar {\n  setName(string n) required;\n}\n\n\u2026we get this Python class:\n\nclass Avatar:\n    def getName(self):\n        return self.name\n\n    def setName(self, name):\n        self.name = name\n\n    def d_setName(self, name):\n        self.sendUpdate(\"setName\", [name])\n\n    def b_setName(self, name):\n        self.setName(name)\n        self.d_setName(name)\n\nNote if, for example, the name value gets changed locally after generation of the DO, it doesn't automatically change the value of the DO on the server. This has to be done manually. Though, calling the distributed versions of these functions (as defined in the dc file) will automatically call the corresponding functions of the representing python class on the client.\n\nPython Imports\n\nfrom direct.distributed import DistributedObject/AI\nfrom direct.distributed import TimeManager/AI\nfrom direct.distributed import DistributedNode/AI\nfrom direct.distributed import DistributedSmoothNode/AI\n\nAny Python objects to be mapped for distributed networking should be imported here. A modified python syntax is used. In the first line DistributedObject.py and DistributedObjectAI.py will be mapped.\n\nThe /AI can also be used for module/filenames like this.\n\nfrom someManager.DSomeManager/AI import DSomeManager/AI\n\nThis will import the DSomeManager class from someManager.DSomeManager.py and DSomeManagerAI from someManager.DsomeManagerAI.py.\n\nVariables\n\nint8, int16, int32, and int64: Signed integer values and bit size\n\nuint8, uint16, uint32, and uint64: For unsigned integers\n\nfloat64: A C double, for floating point numbers\n\nstring: An arbitrary string up to 64k in length. Obviously bandwidth intensive so avoid for frequent communication\n\nchar: Same as int8 but will be realized as a character\n\nblob: String but arbitrary byte sequence usually not intended for print or something encoded that is too complicated for the normal dc system\n\nStructures can also be identified as well.\n\nHint on floats: There only exists float64. For single precision floating point numbers you can use integers like:\n\nint16 foo/100\n\nTo conserve bandwidth when passing small float values it is possible to convert them into ints by multiplying them by the given value and dividing them again. int16 / 10 gives single-point precision for values between -3276.7 to 3276.7. int16 / 100 will give two-point precision for values between -327.67 and 327.67.\n\nStructs\n\nstruct BarrierData {\n  uint16 context;\n  string name;\n  uint32 avIds[];\n};\n\nYou can define C-style structs in addition to the dclass (defined below). This is really the same thing as a dclass, except it can be embedded in a message rather than created as an object in its own right. The struct may or may not correspond with a Python class of the same name. If the struct does have a Python representation, an instance of that class is created and passed in to functions that receive this kind of parameter; otherwise, a tuple with all of the fields is passed instead.\n\nArrays\n\nEach variable can be an array by appending [#] on the end of a value where # is the size of the array. You can also leave the value between the columns empty and it will become a dynamic array. So it could look like this for a fixed:\n\nint8[16] foo\n\nand a dynamic array:\n\nint8[] foo\n\nAllowed range and list of ranges\n\nIf you want to only have a specified range of numbers that is allowed to be send or set on a value, you can use it like this:\n\ndclass Foo{\n  setHam(int16(1-1000,2001-3000))\n}\n\nThis will only allow numbers from 1-1000 and 2001-3000. This can also be used in array declarations.\n\ndclass\n\ndclass DistributedNode: DistributedObject {\n\nHere the methods to be mapped in .DistributedNode and .DistributedNodeAI are defined. Note that this inherits the definition of DistributedObject. Multiple inheritance is also allowed.\n\nsetX(int16 / 10) broadcast ram;\nsetY(int16 / 10) broadcast ram;\nsetZ(int16 / 10) broadcast ram;\n\nHere are three function definitions. When a DistributedNode receives a message with the name \"setX\", .DistributedNode.setX() will be called and the values passed to the function.\n\nSyntax: functionName(container variable1 <, container variable 2,...>) <parameters>;\n\nsetH(int16 % 360 / 10) broadcast ram;\nsetP(int16 % 360 / 10) broadcast ram;\nsetR(int16 % 360 / 10) broadcast ram;\n\nsetPos: setX, setY, setZ;\nsetHpr: setH, setP, setR;\nsetPosHpr: setX, setY, setZ, setH, setP, setR;\nsetXY: setX, setY;\nsetXZ: setX, setZ;\nsetXYH: setX, setY, setH;\nsetXYZH: setX, setY, setZ, setH;\n\nThese messages are composed of previously defined messages. The message \"setPos\" will contain the message \"setX\", \"setY\", \"setZ\" and their appropriate values.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/ae3cc5ca_dc-definition-files.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/c7129d08_ae3cc5ca_dc-definition-files.json",
    "doc_id": "doc_411"
  }
}