{
  "content": "Client-Server Connection\n\nThe first step in network communication is to establish the client-server connection. This entails two sets of operations: one for the server side (which listens for incoming connections), and one for the client side (which establishes a connection to the server). Both of these processes are described below.\n\nPreparing the server for connection\n\nAn average Panda program acting as a server will need to create four classes:\n\nA .QueuedConnectionManager, which handles the low-level connection processes, establishes connections, and handles unexpected network termination\n\nA .QueuedConnectionListener, which waits for clients to request a connection\n\nA .QueuedConnectionReader, which buffers incoming data from an active connection\n\nA .ConnectionWriter, which allows PyDatagrams to be transmitted out along an active connection\n\nThe first step is to instantiate these four classes.\n\nfrom panda3d.core import QueuedConnectionManager\nfrom panda3d.core import QueuedConnectionListener\nfrom panda3d.core import QueuedConnectionReader\nfrom panda3d.core import ConnectionWriter\n\ncManager = QueuedConnectionManager()\ncListener = QueuedConnectionListener(cManager, 0)\ncReader = QueuedConnectionReader(cManager, 0)\ncWriter = ConnectionWriter(cManager, 0)\n\nactiveConnections = [] # We'll want to keep track of these later\n\nThis method of instantiation prepares the classes in single-thread mode, which that realtime communication requires them to be polled periodically.\n\nTo accept client connections, the server opens a special \"rendezvous\" socket at a specific port address. This port address must be known by both the client and the server. Additionally, a backlog is specified; this is the number of incoming connection requests that the connection will track before it starts rejecting connection attempts. The responsibility for managing the rendezvous socket is passed to the QueuedConnectionListener, and a task is spawned to periodically poll the listener.\n\nport_address = 9099 #No-other TCP/IP services are using this port\nbacklog = 1000 #If we ignore 1,000 connection attempts, something is wrong!\ntcpSocket = cManager.openTCPServerRendezvous(port_address,backlog)\n\ncListener.addConnection(tcpSocket)\n\nSince the network handlers we instantiated are polled, we'll create some tasks to do the polling.\n\ntaskMgr.add(tskListenerPolling, \"Poll the connection listener\", -39)\ntaskMgr.add(tskReaderPolling, \"Poll the connection reader\", -40)\n\nWhen a connection comes in, the tskListenerPolling function below handles the incoming connection and hands it to the QueuedConnectionReader. The connection is now established.\n\nfrom panda3d.core import PointerToConnection\nfrom panda3d.core import NetAddress\n\ndef tskListenerPolling(taskdata):\n    if cListener.newConnectionAvailable():\n\n        rendezvous = PointerToConnection()\n        netAddress = NetAddress()\n        newConnection = PointerToConnection()\n\n        if cListener.getNewConnection(rendezvous,netAddress,newConnection):\n            newConnection = newConnection.p()\n            activeConnections.append(newConnection) # Remember connection\n            cReader.addConnection(newConnection)     # Begin reading connection\n    return Task.cont\n\nOnce a connection has been opened, the QueuedConnectionReader may begin processing incoming packets. This is similar to the flow of the listener's task, but it is up to the server code to handle the incoming data.\n\nfrom panda3d.core import NetDatagram\n\ndef tskReaderPolling(taskdata):\n    if cReader.dataAvailable():\n        datagram = NetDatagram()  # catch the incoming data in this instance\n        # Check the return value; if we were threaded, someone else could have\n        # snagged this data before we did\n        if cReader.getData(datagram):\n            myProcessDataFunction(datagram)\n    return Task.cont\n\nNote that the QueuedConnectionReader retrieves data from all clients connected to the server. The NetDatagram can be queried using NetDatagram.getConnection to determine which client sent the message.\n\nIf the server wishes to send data to the client, it can use the ConnectionWriter to transmit back along the connection.\n\n# broadcast a message to all clients\nmyPyDatagram = myNewPyDatagram()  # build a datagram to send\nfor aClient in activeConnections:\n    cWriter.send(myPyDatagram,aClient)\n\nFinally, the server may terminate a connection by removing it from the QueuedConnectionReader's responsibility. It may also deactivate its listener so that no more connections are received.\n\n# terminate connection to all clients\n\nfor aClient in activeConnections:\n    cReader.removeConnection(aClient)\nactiveConnections = []\n\n# close down our listener\ncManager.closeConnection(tcpSocket)\n\nConnecting with a client\n\nThe process the client undertakes to connect to a server is extremely similar to the process the server undertakes to receive connections. Like the server, a client instantiates a QueuedConnectionManager, QueuedConnectionReader, and ConnectionWriter. However, there are some differences in the process. In general, a client has no need to open a rendezvous socket or create a QueuedConnectionListener, since it will be doing the connecting itself. Instead, the client connects to a specific server by specifying the server's IP address and the correct socket ID.\n\nport_address = 9099  # same for client and server\n\n# A valid server URL. You can also use a DNS name\n# if the server has one, such as \"localhost\" or \"panda3d.org\"\nip_address = \"192.168.0.50\"\n\n# How long, in milliseconds, until we give up trying to reach the server?\ntimeout = 3000  # 3 seconds\n\nmyConnection = cManager.openTCPClientConnection(ip_address, port_address, timeout)\nif myConnection:\n    cReader.addConnection(myConnection)  # receive messages from server\n\nWhen the client has finished communicating with the server, it can close the connection.\n\ncManager.closeConnection(myConnection)",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/4d684580_client-server-connection.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/88ca9d10_4d684580_client-server-connection.json",
    "doc_id": "doc_579"
  }
}