{
  "content": "\"\"\"SoundInterval module: contains the SoundInterval class\"\"\"\n\n__all__ = ['SoundInterval']\n\nfrom panda3d.direct import CInterval\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom . import Interval\nimport random\n\nclass SoundInterval(Interval.Interval):\n    # Name counter\n    soundNum = 1\n    # create SoundInterval DirectNotify category\n    notify = directNotify.newCategory('SoundInterval')\n    # Class methods\n    # Create a sound interval\n    # If loop = 0, sound will play once, duration of the interval\n    # equals the duration of the sound\n    # If loop = 1, the sound will loop for the specified duration\n    # If no duration is specified, sound will loop for the duration\n    # of the sound, i.e. it will only play once.....usually, there\n    # seems to be some timing in the audio such that the stop doesn't\n    # kill the looping sound until the next time around if duration\n    # of the interval equals duration of the sound\n    # seamlessloop will let the audio system loop the sound rather\n    # than explicitly restarting the sound every time around. This\n    # prevents a skip in the sound at every repetition (the gap in\n    # the sound is caused by the delay between the end of the sound\n    # and the next taskMgr cycle).\n    # RAU 03/01/07 add listenerNode in case we don't want to\n    # use base.camera as the listener, node must not be None\n    def __init__(self, sound, loop = 0, duration = 0.0, name = None,\n                 volume = 1.0, startTime = 0.0, node=None,\n                 seamlessLoop=True, listenerNode = None, cutOff = None):\n        \"\"\"__init__(sound, loop, name)\n        \"\"\"\n        # Generate unique name\n        id = 'Sound-%d' % SoundInterval.soundNum\n        SoundInterval.soundNum += 1\n        # Record instance variables\n        self.sound = sound\n        if sound:\n            self.soundDuration = sound.length()\n        else:\n            self.soundDuration = 0\n        self.fLoop = loop\n        self.volume = volume\n        self.startTime = startTime\n        self.node = node\n        self.listenerNode = listenerNode\n        self.cutOff = cutOff\n        self._seamlessLoop = seamlessLoop\n        if self._seamlessLoop:\n            self._fLoop = True\n        self._soundPlaying = False\n        self._reverse = False\n        # If no duration given use sound's duration as interval's duration\n        if float(duration) == 0.0 and self.sound is not None:\n            duration = max(self.soundDuration - self.startTime, 0)\n            #if duration == 0:\n            #    self.notify.warning('zero length duration!')\n\n\n        # Generate unique name if necessary\n        if name is None:\n            name = id\n        # Initialize superclass\n        Interval.Interval.__init__(self, name, duration)\n\n    def privInitialize(self, t):\n        # If it's within a 10th of a second of the start,\n        # start at the beginning\n        self._reverse = False\n        t1 = t + self.startTime\n        if t1 < 0.1:\n            t1 = 0.0\n        if t1 < self.soundDuration and not (self._seamlessLoop and self._soundPlaying):\n            base.sfxPlayer.playSfx(\n                self.sound, self.fLoop, 1, self.volume, t1, self.node,\n                listenerNode = self.listenerNode, cutoff = self.cutOff)\n            self._soundPlaying = True\n        self.state = CInterval.SStarted\n        self.currT = t\n\n    def privInstant(self):\n        pass\n\n    def privStep(self, t):\n        ## if self._reverse:\n        ##     # Don't attempt to play the sound backwards.\n        ##     return\n\n        if self.state == CInterval.SPaused:\n            # Restarting from a pause.\n            t1 = t + self.startTime\n            if t1 < self.soundDuration:\n                base.sfxPlayer.playSfx(\n                    self.sound, self.fLoop, 1, self.volume, t1, self.node,\n                    listenerNode = self.listenerNode)\n        if self.listenerNode and not self.listenerNode.isEmpty() and \\\n           self.node and not self.node.isEmpty():\n            base.sfxPlayer.setFinalVolume(self.sound, self.node, self.volume,\n                                          self.listenerNode, self.cutOff)\n\n        self.state = CInterval.SStarted\n        self.currT = t\n\n    def finish(self, *args, **kArgs):\n        self._inFinish = True\n        Interval.Interval.finish(self, *args, **kArgs)\n        del self._inFinish\n\n    def privFinalize(self):\n        # if we're just coming to the end of a seamlessloop, leave the sound alone,\n        # let the audio subsystem loop it\n        if self._seamlessLoop and self._soundPlaying and self.getLoop() and \\\n           not hasattr(self, '_inFinish'):\n            base.sfxPlayer.setFinalVolume(self.sound, self.node, self.volume,\n                                          self.listenerNode, self.cutOff)\n            return\n        elif self.sound is not None:\n            self.sound.stop()\n            self._soundPlaying = False\n        self.currT = self.getDuration()\n        self.state = CInterval.SFinal\n\n    def privReverseInitialize(self, t):\n        self._reverse = True\n\n    def privReverseInstant(self):\n        self.state = CInterval.SInitial\n\n    def privReverseFinalize(self):\n        self._reverse = False\n        self.state = CInterval.SInitial\n\n    def privInterrupt(self):\n        if self.sound is not None:\n            self.sound.stop()\n            self._soundPlaying = False\n        self.state = CInterval.SPaused\n\n    def loop(self, startT = 0.0, endT = -1.0, playRate = 1.0, stagger=False):\n        self.fLoop = 1\n        Interval.Interval.loop(self, startT, endT, playRate)\n        if stagger:\n            self.setT(random.random() * self.getDuration())\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/interval/SoundInterval.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/3a83844b_SoundInterval.json",
    "doc_id": "doc_155"
  }
}