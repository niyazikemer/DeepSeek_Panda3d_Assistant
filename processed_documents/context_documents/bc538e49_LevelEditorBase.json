{
  "content": "\"\"\"\nBase class for Level Editor\n\nYou should write your own LevelEditor class inheriting this.\nRefer LevelEditor.py for example.\n\"\"\"\n\nimport os\nimport wx\n\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.directtools.DirectUtil import useDirectRenderStyle\nfrom direct.gui.OnscreenText import OnscreenText\nfrom panda3d.core import BitMask32, ClockObject, Mat4, NodePath, Point3, TextNode, Vec4\n\nfrom . import ObjectGlobals as OG\nfrom .CurveEditor import CurveEditor\nfrom .FileMgr import FileMgr\nfrom .ActionMgr import (\n    ActionDeleteObj,\n    ActionDeselectAll,\n    ActionMgr,\n    ActionSelectObj,\n    ActionTransformObj,\n)\nfrom .MayaConverter import FROM_BAM_TO_MAYA, MayaConverter\n\n\nclass LevelEditorBase(DirectObject):\n    \"\"\" Base Class for Panda3D LevelEditor \"\"\"\n\n    def __init__(self):\n        #loadPrcFileData('startup', 'window-type none')\n        self.currentFile = None\n        self.fNeedToSave = False\n        self.actionEvents = []\n        #self.objectMgr = ObjectMgr(self)\n        self.curveEditor = CurveEditor(self)\n        self.fileMgr = FileMgr(self)\n        self.actionMgr = ActionMgr()\n\n        self.fMoveCamera = False\n\n        self.NPParent = base.render\n\n        # define your own config file in inherited class\n        self.settingsFile = None\n\n        # you can show/hide specific properties by using propertiesMask and this mode\n        self.BASE_MODE = BitMask32.bit(0)\n        self.CREATE_CURVE_MODE = BitMask32.bit(2)\n        self.EDIT_CURVE_MODE = BitMask32.bit(3)\n        self.ANIM_MODE = BitMask32.bit(4)\n        self.GRAPH_EDITOR = False\n\n        self.mode = self.BASE_MODE\n        self.preMode = None\n\n    def initialize(self):\n        \"\"\" You should call this in your __init__ method of inherited LevelEditor class \"\"\"\n        # specifiy what obj can be 'selected' as objects\n        base.direct.selected.addTag('OBJRoot')\n\n        self.actionEvents.extend([\n            # Node path events\n            ('DIRECT-select', self.select),\n            ('DIRECT-delete', self.handleDelete),\n            ('DIRECT-preDeselectAll', self.deselectAll),\n            ('DIRECT_deselectAll', self.deselectAllCB),\n            ('preRemoveNodePath', self.removeNodePathHook),\n            ('DIRECT_deselectedNodePath', self.deselectAllCB),\n            ('DIRECT_selectedNodePath_fMulti_fTag_fLEPane', self.selectedNodePathHook),\n            ('DIRECT_deselectAll', self.deselectAll),\n            ('LE-Undo', self.actionMgr.undo),\n            ('LE-Redo', self.actionMgr.redo),\n            ('LE-Duplicate', self.objectMgr.duplicateSelected),\n            ('DIRECT_manipulateObjectCleanup', self.cleanUpManipulating),\n            ('LE-MakeLive', self.objectMgr.makeSelectedLive),\n            ('LE-NewScene', self.ui.onNew),\n            ('LE-SaveScene', self.ui.onSave),\n            ('LE-OpenScene', self.ui.onOpen),\n            ('LE-Quit', self.ui.quit),\n            ('DIRECT-mouse1', self.handleMouse1),\n            ('DIRECT-mouse1Up', self.handleMouse1Up),\n            ('DIRECT-mouse2', self.handleMouse2),\n            ('DIRECT-mouse2Up', self.handleMouse2Up),\n            ('DIRECT-mouse3', self.handleMouse3),\n            ('DIRECT-mouse3Up', self.handleMouse3Up),\n            ('DIRECT-toggleWidgetVis', self.toggleWidget),\n        ])\n\n        # Add all the action events\n        for event in self.actionEvents:\n            if len(event) == 3:\n                self.accept(event[0], event[1], event[2])\n            else:\n                self.accept(event[0], event[1])\n\n        # editor state text display such as edit mode\n        self.statusReadout = OnscreenText(\n            pos = (-1.2, 0.9), bg=Vec4(1,1,1,1),\n            scale = 0.05, align = TextNode.ALeft,\n            mayChange = 1, font = TextNode.getDefaultFont())\n        self.statusReadout.setText(\"\")\n        # Make sure readout is never lit or drawn in wireframe\n        useDirectRenderStyle(self.statusReadout)\n        self.statusReadout.reparentTo(hidden)\n        self.statusLines = []\n        base.taskMgr.doMethodLater(5, self.updateStatusReadoutTimeouts, 'updateStatus')\n\n        self.loadSettings()\n        self.reset()\n\n    def setTitleWithFilename(self, filename=\"\"):\n        title = self.ui.appname\n        if filename != \"\":\n            filenameshort = os.path.basename(filename)\n            title = title + \" (%s)\"%filenameshort\n        self.ui.SetLabel(title)\n\n    def removeNodePathHook(self, nodePath):\n        if nodePath is None:\n            return\n        base.direct.deselect(nodePath)\n        self.objectMgr.removeObjectByNodePath(nodePath)\n\n        if base.direct.selected.last is not None and nodePath == base.direct.selected.last:\n            # if base.direct.selected.last is refering to this\n            # removed obj, clear the reference\n            if hasattr(__builtins__, 'last'):\n                __builtins__.last = None\n            else:\n                __builtins__['last'] = None\n            base.direct.selected.last = None\n\n    def toggleWidget(self):\n        if self.objectMgr.currNodePath:\n            obj = self.objectMgr.findObjectByNodePath(self.objectMgr.currNodePath)\n            if obj and not obj[OG.OBJ_DEF].movable:\n                return\n        base.direct.toggleWidgetVis()\n\n    def handleMouse1(self, modifiers):\n        if base.direct.fAlt or modifiers == 4:\n            self.fMoveCamera = True\n            return\n        if self.mode == self.CREATE_CURVE_MODE:\n            self.curveEditor.createCurve()\n\n    def handleMouse1Up(self):\n        self.fMoveCamera = False\n\n    def handleMouse2(self, modifiers):\n        if base.direct.fAlt or modifiers == 4:\n            self.fMoveCamera = True\n            return\n\n    def handleMouse2Up(self):\n        self.fMoveCamera = False\n\n    def handleMouse3(self, modifiers):\n        if base.direct.fAlt or modifiers == 4:\n            self.fMoveCamera = True\n            return\n\n        self.ui.onRightDown()\n\n    def handleMouse3Up(self):\n        self.fMoveCamera = False\n\n    def handleDelete(self):\n        oldSelectedNPs = base.direct.selected.getSelectedAsList()\n        oldUIDs = []\n        for oldNP in oldSelectedNPs:\n            obj = self.objectMgr.findObjectByNodePath(oldNP)\n            if obj:\n                oldUIDs.append(obj[OG.OBJ_UID])\n\n        action = ActionDeleteObj(self)\n        self.actionMgr.push(action)\n        action()\n\n        for uid in oldUIDs:\n            self.ui.sceneGraphUI.delete(uid)\n\n##         reply = wx.MessageBox(\"Do you want to delete selected?\", \"Delete?\",\n##                               wx.YES_NO | wx.ICON_QUESTION)\n##         if reply == wx.YES:\n##             base.direct.removeAllSelected()\n##         else:\n##             # need to reset COA\n##             dnp = base.direct.selected.last\n##             # Update camera controls coa to this point\n##             # Coa2Camera = Coa2Dnp * Dnp2Camera\n##             mCoa2Camera = dnp.mCoa2Dnp * dnp.getMat(base.direct.camera)\n##             row = mCoa2Camera.getRow(3)\n##             coa = Vec3(row[0], row[1], row[2])\n##             base.direct.cameraControl.updateCoa(coa)\n\n    def cleanUpManipulating(self, selectedNPs):\n        for np in selectedNPs:\n            obj = self.objectMgr.findObjectByNodePath(np)\n            if obj:\n                action = ActionTransformObj(self, obj[OG.OBJ_UID], Mat4(np.getMat()))\n                self.actionMgr.push(action)\n                action()\n\n    def select(self, nodePath, fMultiSelect=0, fSelectTag=1, fResetAncestry=1, fLEPane=0, fUndo=1):\n        if fUndo:\n            # Select tagged object if present\n            if fSelectTag:\n                for tag in base.direct.selected.tagList:\n                    if nodePath.hasNetTag(tag):\n                        nodePath = nodePath.findNetTag(tag)\n                        break\n            action = ActionSelectObj(self, nodePath, fMultiSelect)\n            self.actionMgr.push(action)\n            action()\n        else:\n            base.direct.selectCB(nodePath, fMultiSelect, fSelectTag, fResetAncestry, fLEPane, fUndo)\n\n    def selectedNodePathHook(self, nodePath, fMultiSelect = 0, fSelectTag = 1, fLEPane = 0):\n        # handle unpickable nodepath\n        if nodePath.getName() in base.direct.iRay.unpickable:\n            base.direct.deselect(nodePath)\n            return\n\n        if fMultiSelect == 0 and fLEPane == 0:\n            oldSelectedNPs = base.direct.selected.getSelectedAsList()\n            for oldNP in oldSelectedNPs:\n                obj = self.objectMgr.findObjectByNodePath(oldNP)\n                if obj:\n                    self.ui.sceneGraphUI.deSelect(obj[OG.OBJ_UID])\n        self.objectMgr.selectObject(nodePath, fLEPane)\n        self.ui.buildContextMenu(nodePath)\n\n        if self.mode == self.EDIT_CURVE_MODE:\n            base.taskMgr.add(self.curveEditor.editCurve, \"modify\")\n            self.curveEditor.accept(\"DIRECT-enter\", self.curveEditor.onBaseMode)\n\n    def deselectAll(self, np=None):\n        if len(base.direct.selected.getSelectedAsList()) ==0:\n            return\n        action = ActionDeselectAll(self)\n        self.actionMgr.push(action)\n        action()\n\n    def deselectAllCB(self, dnp=None):\n        self.objectMgr.deselectAll()\n\n    def reset(self):\n        if self.fNeedToSave:\n            reply = wx.MessageBox(\"Do you want to save current scene?\", \"Save?\",\n                               wx.YES_NO | wx.ICON_QUESTION)\n            if reply == wx.YES:\n                if not self.ui.onSave():\n                    return\n\n        base.direct.deselectAll()\n        base.direct.selected.last = None\n        self.ui.reset()\n        self.objectMgr.reset()\n        self.animMgr.reset()\n        self.actionMgr.reset()\n        self.ui.perspView.camera.setPos(-19, -19, 19)\n        self.ui.perspView.camera.lookAt(Point3(0, 0, 0))\n        self.ui.leftView.camera.setPos(600, 0, 0)\n        self.ui.frontView.camera.setPos(0, -600, 0)\n        self.ui.topView.camera.setPos(0, 0, 600)\n        self.resetOrthoCam(self.ui.topView)\n        self.resetOrthoCam(self.ui.frontView)\n        self.resetOrthoCam(self.ui.leftView)\n        self.fNeedToSave = False\n        self.setTitleWithFilename()\n\n    def resetOrthoCam(self, view):\n        base.direct.drList[base.camList.index(NodePath(view.camNode))].orthoFactor = 0.1\n        x = view.ClientSize.GetWidth() * 0.1\n        y = view.ClientSize.GetHeight() * 0.1\n        view.camLens.setFilmSize(x, y)\n\n    def save(self):\n        self.ui.SetCursor(wx.StockCursor(wx.CURSOR_WAIT))\n        if self.currentFile:\n            self.fileMgr.saveToFile(self.currentFile)\n        self.ui.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))\n\n    def saveAs(self, fileName):\n        self.ui.SetCursor(wx.StockCursor(wx.CURSOR_WAIT))\n        self.fileMgr.saveToFile(fileName)\n        self.currentFile = fileName\n        self.ui.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))\n\n    def load(self, fileName):\n        self.ui.SetCursor(wx.StockCursor(wx.CURSOR_WAIT))\n        self.reset()\n        self.fileMgr.loadFromFile(fileName)\n        self.currentFile = fileName\n        self.ui.SetCursor(wx.StockCursor(wx.CURSOR_ARROW))\n\n    def saveSettings(self):\n        if self.settingsFile is None:\n            return\n\n        try:\n            f = open(self.settingsFile, 'w')\n            f.write('gridSize\\n%f\\n'%self.ui.perspView.grid.gridSize)\n            f.write('gridSpacing\\n%f\\n'%self.ui.perspView.grid.gridSpacing)\n            f.write('hotKey\\n%s\\n'%base.direct.hotKeyMap)\n            f.close()\n        except:\n            pass\n\n    def loadSettings(self):\n        if self.settingsFile is None:\n            return\n\n        self.ui.SetCursor(wx.Cursor(wx.CURSOR_WAIT))\n        try:\n            f = open(self.settingsFile, 'r')\n            configLines = f.readlines()\n            f.close()\n\n            gridSize = 100.0\n            gridSpacing = 5.0\n            for i in range(0, len(configLines)):\n                line = configLines[i]\n                i = i + 1\n                if line.startswith('gridSize'):\n                    gridSize = float(configLines[i])\n                elif line.startswith('gridSpacing'):\n                    gridSpacing = float(configLines[i])\n                elif line.startswith('hotKey'):\n                    customHotKeyMap = eval(configLines[i])\n                    customHotKeyDict = {}\n                    for hotKey in customHotKeyMap.keys():\n                        desc = customHotKeyMap[hotKey]\n                        customHotKeyDict[desc[1]] = hotKey\n\n                    overriddenKeys = []\n                    for key in base.direct.hotKeyMap.keys():\n                        desc = base.direct.hotKeyMap[key]\n                        if desc[1] in customHotKeyDict.keys():\n                            overriddenKeys.append(key)\n\n                    for key in overriddenKeys:\n                        del base.direct.hotKeyMap[key]\n\n                    base.direct.hotKeyMap.update(customHotKeyMap)\n\n            self.ui.updateGrids(gridSize, gridSpacing)\n            self.ui.updateMenu()\n        except:\n            pass\n        self.ui.SetCursor(wx.Cursor(wx.CURSOR_ARROW))\n\n    def convertMaya(self, modelname, callBack, obj=None, isAnim=False):\n        if obj and isAnim:\n            mayaConverter = MayaConverter(self.ui, self, modelname, callBack, obj, isAnim)\n        else:\n            reply = wx.MessageBox(\"Is it an animation file?\", \"Animation?\",\n                              wx.YES_NO | wx.ICON_QUESTION)\n            if reply == wx.YES:\n                mayaConverter = MayaConverter(self.ui, self, modelname, callBack, None, True)\n            else:\n                mayaConverter = MayaConverter(self.ui, self, modelname, callBack, None, False)\n        mayaConverter.Show()\n\n    def convertFromMaya(self, modelname, callBack):\n        mayaConverter = MayaConverter(self.ui, self, modelname, callBack, None, False)\n        mayaConverter.Show()\n\n    def exportToMaya(self, mayaFileName):\n        exportRootNP = render\n        self.exportToMayaCB(mayaFileName, exportRootNP)\n\n    def exportToMayaCB(self, mayaFileName, exportRootNP):\n        bamFileName = mayaFileName + \".bam\"\n\n        if base.direct.selected.last:\n            obj = self.objectMgr.findObjectByNodePath(base.direct.selected.last)\n            if obj:\n                exportRootNP = obj[OG.OBJ_NP]\n\n        exportRootNP.writeBamFile(bamFileName)\n        mayaConverter = MayaConverter(self.ui, self, mayaFileName, None, None, False, FROM_BAM_TO_MAYA)\n        mayaConverter.Show()\n\n    def updateStatusReadout(self, status, color=None):\n        if status:\n            # add new status line, first check to see if it already exists\n            alreadyExists = False\n            for currLine in self.statusLines:\n                if status == currLine[1]:\n                    alreadyExists = True\n                    break\n            if not alreadyExists:\n                time = ClockObject.getGlobalClock().getRealTime() + 15\n                self.statusLines.append([time,status,color])\n\n        # update display of new status lines\n        self.statusReadout.reparentTo(base.aspect2d)\n        statusText = \"\"\n        lastColor = None\n        for currLine in self.statusLines:\n            statusText += currLine[1] + '\\n'\n            lastColor = currLine[2]\n        self.statusReadout.setText(statusText)\n        if lastColor:\n            self.statusReadout.textNode.setCardColor(\n                lastColor[0], lastColor[1], lastColor[2], lastColor[3])\n            self.statusReadout.textNode.setCardAsMargin(0.1, 0.1, 0.1, 0.1)\n        else:\n            self.statusReadout.textNode.setCardColor(1,1,1,1)\n            self.statusReadout.textNode.setCardAsMargin(0.1, 0.1, 0.1, 0.1)\n\n    def updateStatusReadoutTimeouts(self,task=None):\n        removalList = []\n        for currLine in self.statusLines:\n            if ClockObject.getGlobalClock().getRealTime() >= currLine[0]:\n                removalList.append(currLine)\n        for currRemoval in removalList:\n            self.statusLines.remove(currRemoval)\n        self.updateStatusReadout(None)\n        # perform doMethodLater again after delay\n        # This crashes when CTRL-C'ing, so this is a cheap hack.\n        #return 2\n        from direct.task import Task\n        return Task.again\n\n    def propMeetsReq(self, typeName, parentNP):\n        if self.ui.parentToSelectedMenuItem.IsChecked():\n            if base.direct.selected.last:\n                parent = base.le.objectMgr.findObjectByNodePath(base.direct.selected.last)\n                if parent:\n                    parentNP[0] = parent[OG.OBJ_NP]\n        else:\n            parentNP[0] = None\n        return True\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/leveleditor/LevelEditorBase.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/bc538e49_LevelEditorBase.json",
    "doc_id": "doc_27"
  }
}