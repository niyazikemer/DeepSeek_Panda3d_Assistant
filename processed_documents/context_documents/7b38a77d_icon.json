{
  "content": "from direct.directnotify.DirectNotifyGlobal import directNotify\nfrom panda3d.core import PNMImage, Filename, PNMFileTypeRegistry, StringStream\nimport struct\n\n\nclass Icon:\n    \"\"\" This class is used to create an icon for various platforms. \"\"\"\n    notify = directNotify.newCategory(\"Icon\")\n\n    def __init__(self):\n        self.images = {}\n\n    def addImage(self, image):\n        \"\"\" Adds an image to the icon.  Returns False on failure, True on success.\n        Only one image per size can be loaded, and the image size must be square. \"\"\"\n\n        if not isinstance(image, PNMImage):\n            fn = image\n            if not isinstance(fn, Filename):\n                fn = Filename.fromOsSpecific(fn)\n\n            image = PNMImage()\n            if not image.read(fn):\n                Icon.notify.warning(\"Image '%s' could not be read\" % fn.getBasename())\n                return False\n\n        if image.getXSize() != image.getYSize():\n            Icon.notify.warning(\"Ignoring image without square size\")\n            return False\n\n        self.images[image.getXSize()] = image\n\n        return True\n\n    def getLargestSize(self):\n        return max(self.images.keys())\n\n    def generateMissingImages(self):\n        \"\"\" Generates image sizes that should be present but aren't by scaling\n        from the next higher size. \"\"\"\n\n        for required_size in (256, 128, 48, 32, 16):\n            if required_size in self.images:\n                continue\n\n            sizes = sorted(self.images.keys())\n            if required_size * 2 in sizes:\n                from_size = required_size * 2\n            else:\n                from_size = 0\n                for from_size in sizes:\n                    if from_size > required_size:\n                        break\n\n            if from_size > required_size:\n                Icon.notify.warning(\"Generating %dx%d icon by scaling down %dx%d image\" % (required_size, required_size, from_size, from_size))\n\n                from_image = self.images[from_size]\n                image = PNMImage(required_size, required_size)\n                image.setColorType(from_image.getColorType())\n                if from_image.hasAlpha():\n                    image.addAlpha()\n                image.quickFilterFrom(from_image)\n                self.images[required_size] = image\n            else:\n                Icon.notify.warning(\"Cannot generate %dx%d icon; no higher resolution image available\" % (required_size, required_size))\n\n    def _write_bitmap(self, fp, image, size, bpp):\n        \"\"\" Writes the bitmap header and data of an .ico file. \"\"\"\n\n        fp.write(struct.pack('<IiiHHIIiiII', 40, size, size * 2, 1, bpp, 0, 0, 0, 0, 0, 0))\n\n        # XOR mask\n        if bpp == 24:\n            # Align rows to 4-byte boundary\n            rowalign = b'\\0' * (-(size * 3) & 3)\n            for y in range(size):\n                for x in range(size):\n                    r, g, b = image.getXel(x, size - y - 1)\n                    fp.write(struct.pack('<BBB', int(b * 255), int(g * 255), int(r * 255)))\n                fp.write(rowalign)\n\n        elif bpp == 32:\n            for y in range(size):\n                for x in range(size):\n                    r, g, b, a = image.getXelA(x, size - y - 1)\n                    fp.write(struct.pack('<BBBB', int(b * 255), int(g * 255), int(r * 255), int(a * 255)))\n\n        elif bpp == 8:\n            # We'll have to generate a palette of 256 colors.\n            hist = PNMImage.Histogram()\n            image2 = PNMImage(image)\n            if image2.hasAlpha():\n                image2.premultiplyAlpha()\n                image2.removeAlpha()\n            image2.quantize(256)\n            image2.make_histogram(hist)\n            colors = list(hist.get_pixels())\n            assert len(colors) <= 256\n\n            # Write the palette.\n            i = 0\n            while i < 256 and i < len(colors):\n                r, g, b, a = colors[i]\n                fp.write(struct.pack('<BBBB', b, g, r, 0))\n                i += 1\n            if i < 256:\n                # Fill the rest with zeroes.\n                fp.write(b'\\x00' * (4 * (256 - i)))\n\n            # Write indices.  Align rows to 4-byte boundary.\n            rowalign = b'\\0' * (-size & 3)\n            for y in range(size):\n                for x in range(size):\n                    pixel = image2.get_pixel(x, size - y - 1)\n                    index = colors.index(pixel)\n                    fp.write(struct.pack('<B', index))\n                fp.write(rowalign)\n        else:\n            raise ValueError(\"Invalid bpp %d\" % (bpp))\n\n        # Create an AND mask, aligned to 4-byte boundary\n        if image.hasAlpha() and bpp <= 8:\n            rowalign = b'\\0' * (-((size + 7) >> 3) & 3)\n            for y in range(size):\n                mask = 0\n                num_bits = 7\n                for x in range(size):\n                    a = image.get_alpha_val(x, size - y - 1)\n                    if a <= 1:\n                        mask |= (1 << num_bits)\n                    num_bits -= 1\n                    if num_bits < 0:\n                        fp.write(struct.pack('<B', mask))\n                        mask = 0\n                        num_bits = 7\n                if num_bits < 7:\n                    fp.write(struct.pack('<B', mask))\n                fp.write(rowalign)\n        else:\n            andsize = (size + 7) >> 3\n            if andsize % 4 != 0:\n                andsize += 4 - (andsize % 4)\n            fp.write(b'\\x00' * (andsize * size))\n\n    def makeICO(self, fn):\n        \"\"\" Writes the images to a Windows ICO file.  Returns True on success. \"\"\"\n\n        if not isinstance(fn, Filename):\n            fn = Filename.fromOsSpecific(fn)\n        fn.setBinary()\n\n        # ICO files only support resolutions up to 256x256.\n        count = 0\n        for size in self.images:\n            if size < 256:\n                count += 1\n            if size <= 256:\n                count += 1\n        dataoffs = 6 + count * 16\n\n        ico = open(fn, 'wb')\n        ico.write(struct.pack('<HHH', 0, 1, count))\n\n        # Write 8-bpp image headers for sizes under 256x256.\n        for size, image in self.images.items():\n            if size >= 256:\n                continue\n            ico.write(struct.pack('<BB', size, size))\n\n            # Calculate row sizes\n            xorsize = size\n            if xorsize % 4 != 0:\n                xorsize += 4 - (xorsize % 4)\n            andsize = (size + 7) >> 3\n            if andsize % 4 != 0:\n                andsize += 4 - (andsize % 4)\n            datasize = 40 + 256 * 4 + (xorsize + andsize) * size\n\n            ico.write(struct.pack('<BBHHII', 0, 0, 1, 8, datasize, dataoffs))\n            dataoffs += datasize\n\n        # Write 24/32-bpp image headers.\n        for size, image in self.images.items():\n            if size > 256:\n                continue\n            elif size == 256:\n                ico.write(b'\\0\\0')\n            else:\n                ico.write(struct.pack('<BB', size, size))\n\n            # Calculate the size so we can write the offset within the file.\n            if image.hasAlpha():\n                bpp = 32\n                xorsize = size * 4\n            else:\n                bpp = 24\n                xorsize = size * 3 + (-(size * 3) & 3)\n            andsize = (size + 7) >> 3\n            if andsize % 4 != 0:\n                andsize += 4 - (andsize % 4)\n            datasize = 40 + (xorsize + andsize) * size\n\n            ico.write(struct.pack('<BBHHII', 0, 0, 1, bpp, datasize, dataoffs))\n            dataoffs += datasize\n\n        # Now write the actual icon bitmap data.\n        for size, image in self.images.items():\n            if size < 256:\n                self._write_bitmap(ico, image, size, 8)\n\n        for size, image in self.images.items():\n            if size <= 256:\n                bpp = 32 if image.hasAlpha() else 24\n                self._write_bitmap(ico, image, size, bpp)\n\n        assert ico.tell() == dataoffs\n        ico.close()\n\n        return True\n\n    def makeICNS(self, fn):\n        \"\"\" Writes the images to an Apple ICNS file.  Returns True on success. \"\"\"\n\n        if not isinstance(fn, Filename):\n            fn = Filename.fromOsSpecific(fn)\n        fn.setBinary()\n\n        icns = open(fn, 'wb')\n        icns.write(b'icns\\0\\0\\0\\0')\n\n        icon_types = {16: b'is32', 32: b'il32', 48: b'ih32', 128: b'it32'}\n        mask_types = {16: b's8mk', 32: b'l8mk', 48: b'h8mk', 128: b't8mk'}\n        png_types = {256: b'ic08', 512: b'ic09', 1024: b'ic10'}\n\n        pngtype = PNMFileTypeRegistry.getGlobalPtr().getTypeFromExtension(\"png\")\n\n        for size, image in sorted(self.images.items(), key=lambda item:item[0]):\n            if size in png_types and pngtype is not None:\n                stream = StringStream()\n                image.write(stream, \"\", pngtype)\n                pngdata = stream.data\n\n                icns.write(png_types[size])\n                icns.write(struct.pack('>I', len(pngdata)))\n                icns.write(pngdata)\n\n            elif size in icon_types:\n                # If it has an alpha channel, we write out a mask too.\n                if image.hasAlpha():\n                    icns.write(mask_types[size])\n                    icns.write(struct.pack('>I', size * size + 8))\n\n                    for y in range(size):\n                        for x in range(size):\n                            icns.write(struct.pack('<B', int(image.getAlpha(x, y) * 255)))\n\n                icns.write(icon_types[size])\n                icns.write(struct.pack('>I', size * size * 4 + 8))\n\n                for y in range(size):\n                    for x in range(size):\n                        r, g, b = image.getXel(x, y)\n                        icns.write(struct.pack('>BBBB', 0, int(r * 255), int(g * 255), int(b * 255)))\n\n        length = icns.tell()\n        icns.seek(4)\n        icns.write(struct.pack('>I', length))\n        icns.close()\n\n        return True\n\n    def writeSize(self, required_size, fn):\n        if not isinstance(fn, Filename):\n            fn = Filename.fromOsSpecific(fn)\n        fn.setBinary()\n        fn.makeDir()\n\n        if required_size in self.images:\n            image = self.images[required_size]\n        else:\n            # Find the next size up.\n            sizes = sorted(self.images.keys())\n            if required_size * 2 in sizes:\n                from_size = required_size * 2\n            else:\n                from_size = 0\n                for from_size in sizes:\n                    if from_size > required_size:\n                        break\n\n            if from_size > required_size:\n                Icon.notify.warning(\"Generating %dx%d icon by scaling down %dx%d image\" % (required_size, required_size, from_size, from_size))\n            else:\n                Icon.notify.warning(\"Generating %dx%d icon by scaling up %dx%d image\" % (required_size, required_size, from_size, from_size))\n\n            from_image = self.images[from_size]\n            image = PNMImage(required_size, required_size)\n            image.setColorType(from_image.getColorType())\n            image.quickFilterFrom(from_image)\n\n        if not image.write(fn):\n            Icon.notify.error(\"Failed to write %dx%d to %s\" % (required_size, required_size, fn))\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/dist/icon.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/7b38a77d_icon.json",
    "doc_id": "doc_135"
  }
}