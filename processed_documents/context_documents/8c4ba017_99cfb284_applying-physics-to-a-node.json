{
  "content": "Applying physics to a node\n\nTo apply forces to a physical object, collect them into a ForceNode and then apply them to the object. The ForceNode is a node that specifies the \"context\" of the force; i.e. the local coordinate transform that determines the direction of the force. Because ForceNodes are separate from ActorNodes, a ForceNode can be placed in a different portion of the model tree from the ActorNode to which the forces applies. This allows for forces to be applied indirectly to a model (such as wind sweeping across the scene, or a mechanical impulse from an appendage of the model) without having to do the calculations necessary to transform from the ActorNode's coordinates to the coordinates of the force's source.\n\nTo add a force to a physical object, add the force using either the addLinearForce method (for translational forces) or the addAngularForce method (for rotational forces):\n\nactorNode.addLinearForce(pusherForce)\nactorNode.addAngularForce(spinnerForce)\n\nConversely, forces can be removed using the corresponding remove calls:\n\nactorNode.removeLinearForce(pusherForce)\nactorNode.removeAngularForce(spinnerForce)\n\nBy default, linear forces don't factor in the mass of the object upon which they act (meaning they are more like accelerations). To factor in the mass of the object when applying the linear force, use the following call to enable mass-dependent calculations:\n\npusherForce.setMassDependent(1)\n\nExample 1: Gravity\n\nTo apply a gravitational pull to the \"jetpack guy\" from the previous example:\n\ngravityFN=ForceNode('world-forces')\ngravityFNP=render.attachNewNode(gravityFN)\ngravityForce=LinearVectorForce(0,0,-9.81) #gravity acceleration\ngravityFN.addForce(gravityForce)\n\nbase.physicsMgr.addLinearForce(gravityForce)\n\nSince the gravitational force is relative to the entire world (and shouldn't change if, for example, the jetpack guy tumbles head-over-heels), the gravityForce vector was added to a ForceNode attached to render. So regardless of the orientation of the NodePath controlled by an, the force will always pull towards the bottom of the scene.\n\nSince all objects in the scene should be affected by gravity, the force was added to the set of forces managed by the PhysicsManager itself. Since forces ignore the mass of the objects they act upon by default, this force will pull all objects towards the ground at standard gravitational acceleration. The next example shows how to apply a force to a single object.\n\nExample 2: Rotary Thruster\n\nHere is another example of applying forces to objects and the way in which the ForceNode alters the effect:\n\nthruster=NodePath(\"thruster\") # make a thruster for the jetpack\nthruster.reparentTo(jetpackGuy)\nthruster.setPos(0,-2,3)\n\nthrusterFN=ForceNode('jetpackGuy-thruster') # Attach a thruster force\nthrusterFNP=thruster.attachNewNode(thrusterFN)\nthrusterForce=LinearVectorForce(0,0,4000)\nthrusterForce.setMassDependent(1)\nthrusterFN.addForce(thrusterForce)\n\nan.getPhysical(0).addLinearForce(thrusterForce)\n\nthruster.setP(-45) # bend the thruster nozzle out at 45 degrees\n\nWhen this force is applied to the jetpack guy, it will push upwards and forwards. If the thruster's pitch and roll were controlled (say, by a joystick), then the jetpack could be moved around merely by changing the pitch and roll values; the ForceNode would inherit the orientation of the thruster and automatically change the direction it pushes.\n\nThe effect that this thruster force has upon the jetpack guy should be dependent upon the mass of the system, so the setMassDependent call is used to factor mass into the acceleration analysis.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/99cfb284_applying-physics-to-a-node.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/8c4ba017_99cfb284_applying-physics-to-a-node.json",
    "doc_id": "doc_474"
  }
}