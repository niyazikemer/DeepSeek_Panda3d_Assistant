{
  "content": "from __future__ import annotations\n\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom panda3d.core import (\n    BitMask32,\n    CollisionHandlerEvent,\n    CollisionNode,\n    CollisionSphere,\n    CollisionTraverser,\n    NodePath,\n)\nfrom .PhasedObject import PhasedObject\n\n\nclass DistancePhasedNode(PhasedObject, DirectObject, NodePath):\n    \"\"\"\n    This class defines a PhasedObject,NodePath object that will handle\n    the phasing of an object in the scene graph according to its\n    distance from some other collider object(such as an avatar).\n\n    Since it's a NodePath, you can parent it to another object in the\n    scene graph, or even inherit from this class to get its functionality.\n\n    What you will need to define to use this class:\n\n     - The distances at which you want the phases to load/unload\n     - Whether you want the object to clean itself up or not when\n       exitting the largest distance sphere\n     - What the load/unload functions are\n     - What sort of events to listen for when a collision occurs\n     - (Optional) A collision bitmask for the phase collision spheres\n     - (Optional) A 'from' collision node to collide into our 'into' spheres\n\n    You specify the distances and function names by the phaseParamMap\n    parameter to `__init__()`.  For example::\n\n        phaseParamMap = {'Alias': distance, ...}\n        ...\n        def loadPhaseAlias(self):\n            pass\n        def unloadPhaseAlias(self):\n            pass\n\n    If the 'fromCollideNode' is supplied, we will set up our own\n    traverser and only traverse below this node.  It will send out\n    events of the form '<enterPrefix>%in' and '<exitPrefix>%in' in\n    order to match the main collision traverser's patterns.  Note\n    that this will only be used after a reset or phase change in\n    order to fully transition to the correct phase in a single pass.\n    Most of the time, it will be reacting to events from the main\n    collision traverser.\n\n    IMPORTANT:\n\n        The following only applies when ``autoCleanup is True``:\n        If you unload the last phase, by either calling `cleanup()` or\n        by exiting the last phase's distance, you will need to\n        explicitly call `reset()` to get the distance phasing to work\n        again. This was done so if either this node or the collider is\n        removed from the scene graph (e.g. avatar teleport), the phased\n        object will clean itself up automatically.\n    \"\"\"\n\n    notify = directNotify.newCategory(\"DistancePhasedObject\")\n    __InstanceSequence = 0\n    __InstanceDeque: list[int] = []\n\n    @staticmethod\n    def __allocateId():\n        \"\"\"\n        Give each phase node a unique id in order to filter out\n        collision events from other phase nodes.  We do it in\n        this manner so the client doesn't need to worry about\n        giving each phase node a unique name.\n        \"\"\"\n        if DistancePhasedNode.__InstanceDeque:\n            return DistancePhasedNode.__InstanceDeque.pop(0)\n        else:\n            id = DistancePhasedNode.__InstanceSequence\n            DistancePhasedNode.__InstanceSequence += 1\n            DistancePhasedNode.__InstanceSequence &= 65535\n            return id\n\n    @staticmethod\n    def __deallocateId(id):\n        \"\"\"\n        Reuse abandoned ids.\n        \"\"\"\n        if DistancePhasedNode is not None:\n            DistancePhasedNode.__InstanceDeque.append(id)\n\n    def __init__(self, name, phaseParamMap = {},\n                 autoCleanup = True,\n                 enterPrefix = 'enter', exitPrefix = 'exit',\n                 phaseCollideMask = BitMask32.allOn(),\n                 fromCollideNode = None):\n        NodePath.__init__(self, name)\n        self.phaseParamMap = phaseParamMap\n        self.phaseParamList = sorted(list(phaseParamMap.items()),\n                                     key = lambda x: x[1],\n                                     reverse = True)\n        PhasedObject.__init__(self,\n                              dict([(alias,phase) for (phase,alias) in enumerate([item[0] for item in self.phaseParamList])]))\n        self.__id = self.__allocateId()\n\n        self.autoCleanup = autoCleanup\n        self.enterPrefix = enterPrefix\n        self.exitPrefix = exitPrefix\n        self.phaseCollideMask = phaseCollideMask\n        self.cTrav = base.cTrav\n        self.fromCollideNode = fromCollideNode\n        self._colSpheres = []\n\n        self.reset()\n\n    def __del__(self):\n        self.__deallocateId(self.__id)\n\n    def __repr__(self):\n        outStr = 'DistancePhasedObject('\n        outStr += repr(self.getName())\n        for param, value in zip(('phaseParamMap', 'autoCleanup', 'enterPrefix', 'exitPrefix', 'phaseCollideMask', 'fromCollideNode'),\n                                ({}, True, 'enter', 'exit', BitMask32.allOn(), None)):\n            pv = getattr(self, param)\n            if pv != value:\n                outStr += ', %s = %r' % (param, pv)\n        outStr += ')'\n        return outStr\n\n    def __str__(self):\n        return '%s in phase \\'%s\\'' % (NodePath.__str__(self), self.getPhase())\n\n    def cleanup(self):\n        \"\"\"\n        Disables all collisions.\n        Ignores all owned event listeners.\n        Unloads all unloaded phases.\n        \"\"\"\n        self.__disableCollisions(cleanup = True)\n        for sphere in self._colSpheres:\n            sphere.remove()\n        self._colSpheres = []\n        PhasedObject.cleanup(self)\n\n    def setPhaseCollideMask(self, mask):\n        \"\"\"\n        Sets the intoCollideMasks for our collision spheres.\n        \"\"\"\n        self.phaseCollideMask = mask\n        for sphere in self._colSpheres:\n            self.colSphere.node().setIntoCollideMask(self.phaseCollideMask)\n\n    def reset(self):\n        \"\"\"\n        Unloads all loaded phases and puts the phase node\n        in the startup state is if it had just been initialized.\n        \"\"\"\n        self.cleanup()\n        self.__oneTimeCollide()\n        for name, dist in self.phaseParamList:\n            cSphere = CollisionSphere(0.0, 0.0, 0.0, dist)\n            cSphere.setTangible(0)\n            cName = 'PhaseNode%s-%d' % (name, self.__id)\n            cSphereNode = CollisionNode(cName)\n            cSphereNode.setIntoCollideMask(self.phaseCollideMask)\n            cSphereNode.setFromCollideMask(BitMask32.allOff())\n            cSphereNode.addSolid(cSphere)\n            cSphereNodePath = self.attachNewNode(cSphereNode)\n            cSphereNodePath.stash()\n            # cSphereNodePath.show() # For debugging\n            self._colSpheres.append(cSphereNodePath)\n        if self.fromCollideNode:\n            self.cTrav = CollisionTraverser()\n            cHandler = CollisionHandlerEvent()\n            cHandler.addInPattern(self.enterPrefix + '%in')\n            cHandler.addOutPattern(self.exitPrefix + '%in')\n            self.cTrav.addCollider(self.fromCollideNode,cHandler)\n\n        self.__enableCollisions(-1)\n\n    def setPhase(self, aPhase):\n        \"\"\"\n        See PhasedObject.setPhase()\n        \"\"\"\n        phase = self.getAliasPhase(aPhase)\n        PhasedObject.setPhase(self, aPhase)\n        self.__disableCollisions()\n        self.__enableCollisions(phase)\n\n        if phase == -1 and self.autoCleanup:\n            self.cleanup()\n        else:\n            self.__oneTimeCollide()\n\n    def __getEnterEvent(self, phaseName):\n        return '%sPhaseNode%s-%d' % (self.enterPrefix, phaseName, self.__id)\n\n    def __getExitEvent(self, phaseName):\n        return '%sPhaseNode%s-%d' % (self.exitPrefix, phaseName, self.__id)\n\n    def __enableCollisions(self, phase):\n        \"\"\"\n        Turns on collisions for the spheres bounding this\n        phase zone by unstashing their geometry.  Enables\n        the exit event for the larger and the enter event\n        for the smaller.  Handles the  extreme(end) phases\n        gracefully.\n        \"\"\"\n        if 0 <= phase:\n            phaseName = self.getPhaseAlias(phase)\n            self.accept(self.__getExitEvent(phaseName),\n                        self.__handleExitEvent,\n                        extraArgs = [phaseName])\n            self._colSpheres[phase].unstash()\n\n        if 0 <= phase+1 < len(self._colSpheres):\n            phaseName = self.getPhaseAlias(phase+1)\n            self.accept(self.__getEnterEvent(phaseName),\n                        self.__handleEnterEvent,\n                        extraArgs = [phaseName])\n            self._colSpheres[phase+1].unstash()\n\n    def __disableCollisions(self, cleanup = False):\n        \"\"\"\n        Disables all collision geometry by stashing\n        the geometry.  If autoCleanup == True and we're\n        not currently cleaning up, leave the exit event\n        and collision sphere active for the largest(thus lowest)\n        phase.  This is so that we can still cleanup if\n        the phase node exits the largest sphere.\n        \"\"\"\n        for x,sphere in enumerate(self._colSpheres):\n            phaseName = self.getPhaseAlias(x)\n            self.ignore(self.__getEnterEvent(phaseName))\n            if x > 0 or not self.autoCleanup or cleanup:\n                sphere.stash()\n                self.ignore(self.__getExitEvent(phaseName))\n\n    def __handleEnterEvent(self, phaseName, cEntry):\n        self.setPhase(phaseName)\n\n    def __handleExitEvent(self, phaseName, cEntry):\n        phase = self.getAliasPhase(phaseName) - 1\n        self.setPhase(phase)\n\n    def __oneTimeCollide(self):\n        \"\"\"\n        Fire off a one-time collision traversal of the\n        scene graph.  This allows us to process our entire\n        phasing process in one frame in the cases where\n        we cross more than one phase border.\n        \"\"\"\n        if self.cTrav:\n            if self.cTrav is base.cTrav:\n                # we use 'render'here since if we only try to\n                # traverse ourself, we end up calling exit\n                # events for the rest of the eventHandlers.\n                # Consider supplying the fromCollideNode parameter.\n                self.cTrav.traverse(render)\n            else:\n                # Only traverse ourself\n                self.cTrav.traverse(self)\n            base.eventMgr.doEvents()\n\n\nclass BufferedDistancePhasedNode(DistancePhasedNode):\n    \"\"\"\n    This class is similar to DistancePhasedNode except you can also\n    specify a buffer distance for each phase.  Upon entering that phase,\n    its distance will be increased by the buffer amount.  Conversely,\n    the distance will be decremented by that amount, back to its\n    original size, upon leaving.  In this manner, you can avoid the problem\n    of 'phase flicker' as someone repeatedly steps across a static phase\n    border.\n\n    You specify the buffer amount in the bufferParamMap parameter\n    to :meth:`__init__()`.  It has this format::\n\n        bufferParamMap = {'alias':(distance, bufferAmount), ...}\n    \"\"\"\n    notify = directNotify.newCategory(\"BufferedDistancePhasedObject\")\n\n    def __init__(self, name, bufferParamMap = {}, autoCleanup = True,\n                 enterPrefix = 'enter', exitPrefix = 'exit', phaseCollideMask = BitMask32.allOn(), fromCollideNode = None):\n        self.bufferParamMap = bufferParamMap\n        self.bufferParamList = sorted(list(bufferParamMap.items()),\n                                      key = lambda x: x[1],\n                                      reverse = True)\n\n        sParams = dict(bufferParamMap)\n        for key in sParams:\n            sParams[key] = sParams[key][0]\n\n        DistancePhasedNode.__init__(self, name = name,\n                                    phaseParamMap = sParams,\n                                    autoCleanup = autoCleanup,\n                                    enterPrefix = enterPrefix,\n                                    exitPrefix = exitPrefix,\n                                    phaseCollideMask = phaseCollideMask,\n                                    fromCollideNode = fromCollideNode)\n\n    def __repr__(self):\n        outStr = 'BufferedDistancePhasedNode('\n        outStr += repr(self.getName())\n        for param, value in zip(('bufferParamMap', 'autoCleanup', 'enterPrefix', 'exitPrefix', 'phaseCollideMask', 'fromCollideNode'),\n                                ({}, True, 'enter', 'exit', BitMask32.allOn(), None)):\n            pv = getattr(self, param)\n            if pv != value:\n                outStr += ', %s = %r' % (param, pv)\n        outStr += ')'\n        return outStr\n\n    def __str__(self):\n        return '%s in phase \\'%s\\'' % (NodePath.__str__(self), self.getPhase())\n\n    def setPhase(self, aPhase):\n        \"\"\"\n        see DistancePhasedNode.setPhase()\n        \"\"\"\n        DistancePhasedNode.setPhase(self, aPhase)\n        phase = self.getAliasPhase(aPhase)\n        self.__adjustCollisions(phase)\n\n    def __adjustCollisions(self, phase):\n        for x,sphere in enumerate(self._colSpheres[:phase+1]):\n            sphere.node().modifySolid(0).setRadius(self.bufferParamList[x][1][1])\n            sphere.node().markInternalBoundsStale()\n\n        for x,sphere in enumerate(self._colSpheres[phase+1:]):\n            sphere.node().modifySolid(0).setRadius(self.bufferParamList[x+phase+1][1][0])\n            sphere.node().markInternalBoundsStale()\n",
  "metadata": {
    "source": "_test_source_code/showbase/DistancePhasedNode.py",
    "doc_type": "python",
    "file_path": "processed_documents/5be12928_DistancePhasedNode.json",
    "doc_id": "doc_0"
  }
}