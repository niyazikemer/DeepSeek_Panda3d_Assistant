{
  "content": "from __future__ import annotations\n\nimport os\nimport time\nfrom typing import Iterable\n\n\nclass RotatingLog:\n    \"\"\"\n    An `open()` replacement that will automatically open and write\n    to a new file if the prior file is too large or after a time interval.\n    \"\"\"\n\n    def __init__(\n        self,\n        path: str = \"./log_file\",\n        hourInterval: int | None = 24,\n        megabyteLimit: int | None = 1024,\n    ) -> None:\n        \"\"\"\n        Args:\n            path: a full or partial path with file name.\n            hourInterval: the number of hours at which to rotate the file.\n            megabyteLimit: the number of megabytes of file size the log may\n                grow to, after which the log is rotated.  Note: The log file\n                may get a bit larger than limit do to writing out whole lines\n                (last line may exceed megabyteLimit or \"megabyteGuidline\").\n        \"\"\"\n        self.path = path\n        self.timeInterval = None\n        self.timeLimit = None\n        self.sizeLimit = None\n        if hourInterval is not None:\n            self.timeInterval = hourInterval*60*60\n            self.timeLimit = time.time()+self.timeInterval\n        if megabyteLimit is not None:\n            self.sizeLimit = megabyteLimit*1024*1024\n\n    def __del__(self) -> None:\n        self.close()\n\n    def close(self) -> None:\n        if hasattr(self, \"file\"):\n            self.file.flush()\n            self.file.close()\n            self.closed = self.file.closed\n            del self.file\n        else:\n            self.closed = True\n\n    def shouldRotate(self) -> bool:\n        \"\"\"\n        Returns a bool about whether a new log file should\n        be created and written to (while at the same time\n        stopping output to the old log file and closing it).\n        \"\"\"\n        if not hasattr(self, \"file\"):\n            return True\n        if self.timeLimit is not None and time.time() > self.timeLimit:\n            return True\n        if self.sizeLimit is not None and self.file.tell() > self.sizeLimit:\n            return True\n        return False\n\n    def filePath(self) -> str:\n        dateString = time.strftime(\"%Y_%m_%d_%H\", time.localtime())\n        for i in range(26):\n            limit = self.sizeLimit\n            path = \"%s_%s_%s.log\" % (self.path, dateString, chr(i+97))\n            if limit is None or not os.path.exists(path) or os.stat(path)[6] < limit:\n                return path\n        # Hmm, 26 files are full?  throw the rest in z:\n        # Maybe we should clear the self.sizeLimit here... maybe.\n        return path\n\n    def rotate(self) -> None:\n        \"\"\"\n        Rotate the log now.  You normally shouldn't need to call this.\n        See write().\n        \"\"\"\n        path=self.filePath()\n        file=open(path, \"a\")\n        if file:\n            self.close()\n            # This should be redundant with \"a\" open() mode,\n            # but on some platforms tell() will return 0\n            # until the first write:\n            file.seek(0, 2)\n            self.file=file\n\n            # Some of these data members may be expected by some of our clients:\n            self.closed = self.file.closed\n            self.mode = self.file.mode\n            self.name = self.file.name\n            #self.encoding = self.file.encoding # Python 2.3\n            #self.newlines = self.file.newlines # Python 2.3, maybe\n\n            if self.timeLimit is not None and time.time() > self.timeLimit:\n                assert self.timeInterval is not None\n                self.timeLimit=time.time()+self.timeInterval\n        else:\n            # We'll keep writing to the old file, if available.\n            print(\"RotatingLog error: Unable to open new log file \\\"%s\\\".\" % (path,))\n\n    def write(self, data: str) -> int | None:\n        \"\"\"\n        Write the data to either the current log or a new one,\n        depending on the return of shouldRotate() and whether\n        the new file can be opened.\n        \"\"\"\n        if self.shouldRotate():\n            self.rotate()\n        if hasattr(self, \"file\"):\n            r = self.file.write(data)\n            self.file.flush()\n            return r\n        return None\n\n    def flush(self) -> None:\n        return self.file.flush()\n\n    def fileno(self) -> int:\n        return self.file.fileno()\n\n    def isatty(self) -> bool:\n        return self.file.isatty()\n\n    def __next__(self):\n        return next(self.file)\n    next = __next__\n\n    def read(self, size):\n        return self.file.read(size)\n\n    def readline(self, size):\n        return self.file.readline(size)\n\n    def readlines(self, sizehint):\n        return self.file.readlines(sizehint)\n\n    def xreadlines(self):\n        return self.file.xreadlines()\n\n    def seek(self, offset: int, whence: int = 0) -> int:\n        return self.file.seek(offset, whence)\n\n    def tell(self) -> int:\n        return self.file.tell()\n\n    def truncate(self, size: int | None) -> int:\n        return self.file.truncate(size)\n\n    def writelines(self, sequence: Iterable[str]) -> None:\n        return self.file.writelines(sequence)\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/directnotify/RotatingLog.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/f7306926_RotatingLog.json",
    "doc_id": "doc_102"
  }
}