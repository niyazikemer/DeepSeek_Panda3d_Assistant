{
  "content": "Egg Syntax\n\nThe Egg Syntax\n\nThis is a condensed version of the Egg Syntax document, incorporating only syntax definitions in common use. For complete documentation, please see the Egg Syntax documentation from the Panda3D source code repository.\n\nGeneral Syntax\n\nEgg files consist of a series of sequential and hierarchically-nested entries. In general, the syntax of each entry is:\n\n<Entry-type>\u00a0name\u00a0{\u00a0contents\u00a0}\n\nComment text should be enclosed in quotation marks:\n\n<Comment>\u00a0{\u00a0text\u00a0}\n\nLocal Information Entries\n\nThese nodes contain information relevant to the current level of nesting only:\n\n<Scalar>\u00a0name\u00a0{\u00a0value\u00a0}\n\nScalars are attributes of the entry the Scalar is in. Name is the attribute name with value as the contents of that attribute.\n\nGlobal Information Entries\n\nThese nodes contain information relevant to the file as a whole. They can be nested along with geometry nodes, but this nesting is irrelevant and the only significant placement rule is that they should appear before they are referenced.\n\nCoordinate System\n\nThe coordinate system for the file is specified like so:\n\n\u00a0<CoordinateSystem>\u00a0{\u00a0string\u00a0}\n\nThis entry indicates the coordinate system used in the egg file; the egg loader will automatically make a conversion if necessary. The following strings are valid: Y-up, Z-up, Y-up-right, Z-up-right, Y-up-left, or Z-up-left. (Y-up is the same as Y-up-right, and Z-up is the same as Z-up-right.)\n\nTextures\n\nThis describes a texture file that can be referenced later with <TRef> { name }:\n\n<Texture> name {\n  filename\n  <Scalar> scalar1 { value1 }\n  <Scalar> scalar2 { value2 }\n}\n\nTexture Scalars\n\nThe following attributes are presently implemented for textures:\n\nMaterials\n\nThis defines a set of material attributes that may later be referenced with <MRef> { name }:\n\n<Material> name {\n  [scalars]\n}\n\nMaterial Scalars\n\n<Scalar>\u00a0diffr\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0diffg\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0diffb\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0diffa\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0ambr\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0ambg\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0ambb\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0amba\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0emitr\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0emitg\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0emitb\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0emita\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0specr\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0specg\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0specb\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0speca\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0shininess\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0local\u00a0{\u00a0flag\u00a0}\n\nVertex Pool\n\nA vertex pool is a set of vertices. All geometry is created by referring to vertices by number in a particular vertex pool. There may be one or several vertex pools in an egg file, but all vertices that make up a single polygon must come from the same vertex pool. The body of a <VertexPool> entry is simply a list of one or more <Vertex> entries, as follows:\n\n<VertexPool> name {\n  <Vertex> number1 {\n  }\n  <Vertex> numer2 {\n  }\n  ...\n}\n\nVertices\n\nA <Vertex> entry is only valid within a vertex pool definition. The number is the index by which this vertex will be referenced. It is optional; if it is omitted, the vertices are implicitly numbered consecutively beginning at one. If the number is supplied, the vertices need not be consecutive.\n\nThe vertex's coordinates are always given in world space, regardless of any transforms before the vertex pool or before the referencing geometry. If the vertex is referenced by geometry under a transform, the egg loader will do an inverse transform to move the vertex into the proper coordinate space without changing its position in world space. One exception is geometry under an <Instance> node; in this case the vertex coordinates are given in the space of the <Instance> node. (Another exception is a <DynamicVertexPool>; see below.)\n\n<Vertex> number {\n  x y z [w]\n  [attributes]\n}\n\nVertex Attributes\n\n<Normal>\u00a0{\u00a0x\u00a0y\u00a0z\u00a0[morph-list]\u00a0}\n<RGBA>\u00a0{\u00a0r\u00a0g\u00a0b\u00a0a\u00a0[morph-list]\u00a0}\n<UV>\u00a0[name]\u00a0{\u00a0u\u00a0v\u00a0[w]\u00a0[tangent]\u00a0[binormal]\u00a0[morph-list]\u00a0}\n<Dxyz>\u00a0target\u00a0{\u00a0x\u00a0y\u00a0z\u00a0}\n\nGeometry Entries\n\nGeometry entries reference Vertex pool entries to generate renderable geometry for Panda to use.\n\nPolygons\n\nA polygon consists of a sequence of vertices from a single vertex pool. Vertices are identified by pool-name and index number within the pool; indices is a list of vertex numbers within the given vertex pool. Vertices are listed in counterclockwise order. Although the vertices must all come from the same vertex pool, they may have been assigned to arbitrarily many different joints regardless of joint connectivity (there is no \"straddle-polygon\" limitation). See Joints, below.\n\nThe polygon syntax is quite verbose, and there isn't any way to specify a set of attributes that applies to a group of polygons--the attributes list must be repeated for each polygon. This is why egg files tend to be very large.\n\n<Polygon> name {\n    [attributes]\n    <VertexRef> {\n        indices\n        <Ref> { pool-name }\n    }\n}\n\nPolygon Attributes\n\n<TRef>\u00a0{\u00a0texture-name\u00a0}\n<Texture>\u00a0{\u00a0filename\u00a0}\n<MRef>\u00a0{\u00a0material-name\u00a0}\n<Normal>\u00a0{\u00a0x\u00a0y\u00a0z\u00a0[morph-list]\u00a0}\n<RGBA>\u00a0{\u00a0r\u00a0g\u00a0b\u00a0a\u00a0[morph-list]\u00a0}\n<BFace>\u00a0{\u00a0boolean-value\u00a0}\n<Scalar>\u00a0bin\u00a0{\u00a0bin-name\u00a0}\n<Scalar>\u00a0draw_order\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0visibility\u00a0{\u00a0hidden\u00a0|\u00a0normal\u00a0}\n\nGrouping Entries\n\nA <Group> node is the primary means of providing structure to the egg file. Groups can contain vertex pools and polygons, as well as other groups. The egg loader translates <Group> nodes directly into PandaNodes in the scene graph (although the egg loader reserves the right to arbitrarily remove nodes that it deems unimportant--see the <Model> flag, below to avoid this). In addition, the following entries can be given specifically within a <Group> node to specify attributes of the group.\n\n<Group> name {\n  [attributes]\n  [scalars]\n  [SwitchCondition]\n  [Tag]\n  [Collide]\n  [ObjectType]\n}\n\nGrouping Attributes\n\n<DCS>\u00a0{\u00a0boolean-value\u00a0}\n<DCS>\u00a0{\u00a0dcs-type\u00a0}\n<Model>\u00a0{\u00a0boolean-value\u00a0}\n<Dart>\u00a0{\u00a0boolean-value\u00a0}\n<Switch>\u00a0{\u00a0boolean-value\u00a0}\n\nGroup Scalars\n\nThe following scalars can be defined at the <Group> level:\n\n<Scalar>\u00a0fps\u00a0{\u00a0frame-rate\u00a0}\n<Scalar>\u00a0bin\u00a0{\u00a0bin-name\u00a0}\n<Scalar>\u00a0draw_order\u00a0{\u00a0number\u00a0}\n<Scalar>\u00a0visibility\u00a0{\u00a0hidden\u00a0|\u00a0normal\u00a0}\n<Scalar>\u00a0decal\u00a0{\u00a0boolean-value\u00a0}\n<Scalar>\u00a0decalbase\u00a0{\u00a0boolean-value\u00a0}\n<Scalar>\u00a0collide-mask\u00a0{\u00a0value\u00a0}\n<Scalar>\u00a0from-collide-mask\u00a0{\u00a0value\u00a0}\n<Scalar>\u00a0into-collide-mask\u00a0{\u00a0value\u00a0}\n<Scalar>\u00a0blend\u00a0{\u00a0mode\u00a0}\n<Scalar>\u00a0blendop-a\u00a0{\u00a0mode\u00a0}\n<Scalar>\u00a0blendop-b\u00a0{\u00a0mode\u00a0}\n<Scalar>\u00a0blendr\u00a0{\u00a0red-value\u00a0}\n<Scalar>\u00a0blendg\u00a0{\u00a0green-value\u00a0}\n<Scalar>\u00a0blendb\u00a0{\u00a0blue-value\u00a0}\n<Scalar>\u00a0blenda\u00a0{\u00a0alpha-value\u00a0}\n\nOther Group Attributes\n\nBillboard\n\n<Billboard>\u00a0{\u00a0type\u00a0}\n\nThis entry indicates that all geometry defined at or below this group level is part of a billboard that will rotate to face the camera. Type is either \"axis\" or \"point\", describing the type of rotation.\n\nBillboards rotate about their local axis. In the case of a Y-up file, the billboards rotate about the Y axis; in a Z-up file, they rotate about the Z axis. Point-rotation billboards rotate about the origin.\n\nThere is an implicit <Instance> around billboard geometry. This means that the geometry within a billboard is not specified in world coordinates, but in the local billboard space. Thus, a vertex drawn at point 0,0,0 will appear to be at the pivot point of the billboard, not at the origin of the scene.\n\nSwitchCondition\n\n\u00a0 <SwitchCondition>\u00a0{\n\u00a0 \u00a0\u00a0\u00a0<Distance>\u00a0{\n\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0in\u00a0out\u00a0[fade]\u00a0<Vertex>\u00a0{\u00a0x\u00a0y\u00a0z\u00a0}\n\u00a0 \u00a0\u00a0\u00a0}\n\u00a0 }\n\nThe subtree beginning at this node and below represents a single level of detail for a particular model. Sibling nodes represent the additional levels of detail. The geometry at this node will be visible when the point (x, y, z) is closer than \"in\" units, but further than \"out\" units, from the camera. \"fade\" is presently ignored.\n\nTag\n\n<Tag>\u00a0key\u00a0{\u00a0value\u00a0}\n\nThis attribute defines the indicated tag (as a key/value pair), retrievable via NodePath.get_tag() and related interfaces, on this node.\n\nCollide\n\n<Collide>\u00a0name\u00a0{\u00a0type\u00a0[flags]\u00a0}\n\nThis entry indicates that geometry defined at this group level is actually an invisible collision surface, and is not true geometry. The geometry is used to define the extents of the collision surface. If there is no geometry defined at this level, then a child is searched for with the same collision type specified, and its geometry is used to define the extent of the collision surface (unless the \"descend\" flag is given; see below).\n\nValid types so far are:\n\nThe flags may be any zero or more of:\n\nObjectType\n\n<ObjectType>\u00a0{\u00a0type\u00a0}\n\nThis is a short form to indicate one of several pre-canned sets of attributes. Type may be any word, and a Config definition will be searched for by the name \"egg-object-type-word\", where \"word\" is the type word. This definition may contain any arbitrary egg syntax to be parsed in at this group level.\n\nA number of predefined ObjectType definitions are provided:\n\nJoint Nodes\n\n<Joint> name {\n  [transform]\n  [ref-list]\n  [joint-list]\n}\n\nA joint is a highly specialized kind of grouping node. A tree of joints is used to specify the skeletal structure of an animated character.\n\nA joint may only contain one of three things. It may contain a <Transform> entry, as above, which defines the joint's unanimated (rest) position; it may contain lists of assigned vertices or CV's; and it may contain other joints.\n\nA tree of <Joint> nodes only makes sense within a character definition, which is created by applying the <DART> flag to a group. See <DART>, above.\n\nThe vertex assignment is crucial. This is how the geometry of a character is made to move with the joints. The character's geometry is actually defined outside the joint tree, and each vertex must be assigned to one or more joints within the tree.\n\nThis is done with zero or more <VertexRef> entries per joint, as the following:\n\n\u00a0<VertexRef>\u00a0{\u00a0indices\u00a0[<Scalar>\u00a0membership\u00a0{\u00a0m\u00a0}]\u00a0<Ref>\u00a0{\u00a0pool-name\u00a0}\u00a0}\n\nThis is syntactically similar to the way vertices are assigned to polygons. Each <VertexRef> entry can assign vertices from only one vertex pool (but there may be many <VertexRef> entries per joint). Indices is a list of vertex numbers from the specified vertex pool, in an arbitrary order.\n\nThe membership scalar is optional. If specified, it is a value between 0.0 and 1.0 that indicates the fraction of dominance this joint has over the vertices. This is used to implement soft-skinning, so that each vertex may have partial ownership in several joints.\n\nThe <VertexRef> entry may also be given to ordinary <Group> nodes. In this case, it treats the geometry as if it was parented under the group in the first place. Non-total membership assignments are meaningless.\n\nBundle and Table entries\n\nA table is a set of animated values for joints. A tree of tables with the same structure as the corresponding tree of joints must be defined for each character to be animated. Such a tree is placed under a <Bundle> node, which provides a handle within Panda to the tree as a whole.\n\nBundles may only contain tables; tables may contain more tables, bundles, or any one of the following (<Scalar> entries are optional, and default as shown):\n\n<S$Anim> name {\n  <Scalar> fps { 24 }\n  <V> { values }\n}",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/2644dc0c_syntax.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/fe5417d7_2644dc0c_syntax.json",
    "doc_id": "doc_400"
  }
}