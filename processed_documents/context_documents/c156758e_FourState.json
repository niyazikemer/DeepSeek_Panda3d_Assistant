{
  "content": "\"\"\"Contains the FourState class.\"\"\"\n\n__all__ = ['FourState']\n\nfrom direct.directnotify import DirectNotifyGlobal\n#import DistributedObject\nfrom . import ClassicFSM\nfrom . import State\n\n\nclass FourState:\n    \"\"\"\n    Generic four state ClassicFSM base class.\n\n    This is a mix-in class that expects that your derived class\n    is a DistributedObject.\n\n    Inherit from FourStateFSM and pass in your states.  Two of\n    the states should be oposites of each other and the other\n    two should be the transition states between the first two.\n    E.g::\n\n                    +--------+\n                 -->| closed | --\n                |   +--------+   |\n                |                |\n                |                v\n          +---------+       +---------+\n          | closing |<----->| opening |\n          +---------+       +---------+\n                ^                |\n                |                |\n                |    +------+    |\n                 ----| open |<---\n                     +------+\n\n    There is a fifth off state, but that is an implementation\n    detail (and that's why it's not called a five state ClassicFSM).\n\n    I found that this pattern repeated in several things I was\n    working on, so this base class was created.\n    \"\"\"\n    notify = DirectNotifyGlobal.directNotify.newCategory('FourState')\n\n    def __init__(self, names, durations = [0, 1, None, 1, 1]):\n        \"\"\"\n        Names is a list of state names.  Some examples are::\n\n            ['off', 'opening', 'open', 'closing', 'closed',]\n\n            ['off', 'locking', 'locked', 'unlocking', 'unlocked',]\n\n            ['off', 'deactivating', 'deactive', 'activating', 'activated',]\n\n        durations is a list of time values (floats) or None values.\n\n        Each list must have five entries.\n\n        .. rubric:: More Details\n\n        Here is a diagram showing the where the names from the list\n        are used::\n\n            +---------+\n            | 0 (off) |----> (any other state and vice versa).\n            +---------+\n\n                       +--------+\n                    -->| 4 (on) |---\n                   |   +--------+   |\n                   |                |\n                   |                v\n             +---------+       +---------+\n             | 3 (off) |<----->| 1 (off) |\n             +---------+       +---------+\n                   ^                |\n                   |                |\n                   |  +---------+   |\n                    --| 2 (off) |<--\n                      +---------+\n\n        Each states also has an associated on or off value.  The only\n        state that is 'on' is state 4.  So, the transition states\n        between off and on (states 1 and 3) are also considered\n        off (and so is state 2 which is oposite of 4 and therefore\n        oposite of 'on').\n        \"\"\"\n        self.stateIndex = 0\n        assert self.__debugPrint(\"FourState(names=%s)\"%(names))\n        self.track = None\n        self.stateTime = 0.0\n        self.names = names\n        self.durations = durations\n        self.states = {\n            0: State.State(names[0],\n                           self.enterState0,\n                           self.exitState0,\n                           [names[1],\n                           names[2],\n                           names[3],\n                           names[4]]),\n            1: State.State(names[1],\n                           self.enterState1,\n                           self.exitState1,\n                           [names[2], names[3]]),\n            2: State.State(names[2],\n                           self.enterState2,\n                           self.exitState2,\n                           [names[3]]),\n            3: State.State(names[3],\n                           self.enterState3,\n                           self.exitState3,\n                           [names[4], names[1]]),\n            4: State.State(names[4],\n                           self.enterState4,\n                           self.exitState4,\n                           [names[1]]),\n        }\n        self.fsm = ClassicFSM.ClassicFSM('FourState',\n                           list(self.states.values()),\n                           # Initial State\n                           names[0],\n                           # Final State\n                           names[0],\n                          )\n        self.fsm.enterInitialState()\n\n    def setTrack(self, track):\n        assert self.__debugPrint(\"setTrack(track=%s)\"%(track,))\n        if self.track is not None:\n            self.track.pause()\n            self.track = None\n        if track is not None:\n            track.start(self.stateTime)\n            self.track = track\n\n    def enterStateN(self, stateIndex):\n        self.stateIndex = stateIndex\n        self.duration = self.durations[stateIndex] or 0.0\n\n    # The AI is the authority on setting the On value.\n    # If the client wants the state changed it needs to\n    # send a request to the AI.\n    #def setIsOn(self, isOn):\n    #    assert self.__debugPrint(\"setIsOn(isOn=%s)\"%(isOn,))\n    #    pass\n\n    def isOn(self):\n        assert self.__debugPrint(\"isOn() returning %s (stateIndex=%s)\"%(self.stateIndex==4, self.stateIndex))\n        return self.stateIndex==4\n\n    def changedOnState(self, isOn):\n        \"\"\"\n        Allow derived classes to overide this.\n        \"\"\"\n        assert self.__debugPrint(\"changedOnState(isOn=%s)\"%(isOn,))\n\n    ##### state 0 #####\n\n    def enterState0(self):\n        assert self.__debugPrint(\"enter0()\")\n        self.enterStateN(0)\n\n    def exitState0(self):\n        assert self.__debugPrint(\"exit0()\")\n        # It's important for FourStates to broadcast their state\n        # when they are generated on the client. Before I put this in,\n        # if a door was generated and went directly to an 'open' state,\n        # it would not broadcast its state until it closed.\n        self.changedOnState(0)\n\n    ##### state 1 #####\n\n    def enterState1(self):\n        assert self.__debugPrint(\"enterState1()\")\n        self.enterStateN(1)\n\n    def exitState1(self):\n        assert self.__debugPrint(\"exitState1()\")\n\n    ##### state 2 #####\n\n    def enterState2(self):\n        assert self.__debugPrint(\"enterState2()\")\n        self.enterStateN(2)\n\n    def exitState2(self):\n        assert self.__debugPrint(\"exitState2()\")\n\n    ##### state 3 #####\n\n    def enterState3(self):\n        assert self.__debugPrint(\"enterState3()\")\n        self.enterStateN(3)\n\n    def exitState3(self):\n        assert self.__debugPrint(\"exitState3()\")\n\n    ##### state 4 #####\n\n    def enterState4(self):\n        assert self.__debugPrint(\"enterState4()\")\n        self.enterStateN(4)\n        self.changedOnState(1)\n\n    def exitState4(self):\n        assert self.__debugPrint(\"exitState4()\")\n        self.changedOnState(0)\n\n    if __debug__:\n        def __debugPrint(self, message):\n            \"\"\"for debugging\"\"\"\n            return self.notify.debug(\"%d (%d) %s\"%(\n                    id(self), self.stateIndex==4, message))\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/fsm/FourState.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/c156758e_FourState.json",
    "doc_id": "doc_151"
  }
}