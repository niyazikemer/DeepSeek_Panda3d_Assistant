{
  "content": "# ClockDelta provides the ability to use clock synchronization for\n# distributed objects\n\nfrom panda3d.core import ClockObject, ConfigVariableBool\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.showbase import DirectObject\nimport math\n\n# The following two parameters, NetworkTimeBits and\n# NetworkTimePrecision, define the number of bits required to store a\n# network time, and the number of ticks per second it represents,\n# respectively.  The tradeoff is the longest period of elapsed time we\n# can measure, vs. the precision with which we can measure it.\n\n# 16 and 100 give us precision to 1/100th of a second, with a range of\n# +/- 5 minutes in a 16-bit integer.  These are eminently tweakable,\n# but the parameter types in toon.dc must match the number of bits\n# specified here (i.e. int16 if NetworkTimeBits is 16; int32 if\n# NetworkTimeBits is 32).\nNetworkTimeBits = 16\nNetworkTimePrecision = 100.0\n\n\n# These values are derived from the above.\nNetworkTimeMask = (1 << NetworkTimeBits) - 1\nNetworkTimeSignedMask = NetworkTimeMask >> 1 # the max absolute value bits.\nNetworkTimeTopBits = 32 - NetworkTimeBits\nMaxTimeDelta = NetworkTimeSignedMask / NetworkTimePrecision\n\n# This is the maximum number of seconds by which we expect our clock\n# (or the server's clock) to drift over an hour.\nClockDriftPerHour = 1.0   # Is this generous enough?\n\n# And the above, scaled into a per-second value.\nClockDriftPerSecond = ClockDriftPerHour / 3600.0\n\n# How many seconds to insist on waiting before accepting a second\n# resync request from another client.\nP2PResyncDelay = 10.0\n\nclass ClockDelta(DirectObject.DirectObject):\n    \"\"\"\n    The ClockDelta object converts between universal (\"network\") time,\n    which is used for all network traffic, and local time (e.g. as\n    returned by getFrameTime() or getRealTime()), which is used for\n    everything else.\n    \"\"\"\n\n    notify = DirectNotifyGlobal.directNotify.newCategory('ClockDelta')\n\n    def __init__(self):\n        self.globalClock = ClockObject.getGlobalClock()\n\n        # self.delta is the relative delta from our clock to the\n        # server's clock.\n        self.delta = 0\n\n        # self.uncertainty represents the number of seconds plus or\n        # minus in which we are confident our delta matches the\n        # server's actual time.  The initial value, None, represents\n        # infinity--we have no idea.\n        self.uncertainty = None\n\n        # self.lastResync is the time at which self.uncertainty\n        # was measured.  It is important to remember because our\n        # uncertainty increases over time (due to relative clock\n        # drift).\n        self.lastResync = 0.0\n\n        self.accept(\"resetClock\", self.__resetClock)\n\n    def getDelta(self):\n        return self.delta\n\n    def getUncertainty(self):\n        # Returns our current uncertainty with our clock measurement,\n        # as a number of seconds plus or minus.  Returns None,\n        # representing infinite uncertainty, if we have never received\n        # a time measurement.\n\n        if self.uncertainty is None:\n            return None\n\n        now = self.globalClock.getRealTime()\n        elapsed = now - self.lastResync\n        return self.uncertainty + elapsed * ClockDriftPerSecond\n\n    def getLastResync(self):\n        # Returns the local time at which we last resynchronized the\n        # clock delta.\n        return self.lastResync\n\n    def __resetClock(self, timeDelta):\n        \"\"\"\n        this is called when the global clock gets adjusted\n        timeDelta is equal to the amount of time, in seconds,\n        that has been added to the global clock\n        \"\"\"\n        assert self.notify.debug(\n            \"adjusting timebase by %f seconds\" % timeDelta)\n        # adjust our timebase by the same amount\n        self.delta += timeDelta\n\n    def clear(self):\n        \"\"\"\n        Throws away any previous synchronization information.\n        \"\"\"\n        self.delta = 0\n        self.uncertainty = None\n        self.lastResync = 0.0\n\n    def resynchronize(self, localTime, networkTime, newUncertainty,\n                      trustNew = 1):\n        \"\"\"resynchronize(self, float localTime, int32 networkTime,\n                         float newUncertainty)\n\n        Accepts a new networkTime value, which is understood to\n        represent the same moment as localTime, plus or minus\n        uncertainty seconds.  Improves our current notion of the time\n        delta accordingly.\n        \"\"\"\n        newDelta = (float(localTime) -\n            (float(networkTime) / NetworkTimePrecision))\n        self.newDelta(\n            localTime, newDelta, newUncertainty, trustNew = trustNew)\n\n    def peerToPeerResync(self, avId, timestamp, serverTime, uncertainty):\n        \"\"\"\n        Accepts an AI time and uncertainty value from another client,\n        along with a local timestamp value of the message from this\n        client which prompted the other client to send us its delta\n        information.\n\n        The return value is true if the other client's measurement was\n        reasonably close to our own, or false if the other client's\n        time estimate was wildly divergent from our own; the return\n        value is negative if the test was not even considered (because\n        it happened too soon after another recent request).\n        \"\"\"\n\n        now = self.globalClock.getRealTime()\n        if now - self.lastResync < P2PResyncDelay:\n            # We can't process this request; it came in on the heels\n            # of some other request, and our local timestamp may have\n            # been resynced since then: ergo, the timestamp in this\n            # request is meaningless.\n            assert self.notify.debug(\n                \"Ignoring request for resync from %s within %.3f s.\" %\n                (avId, now - self.lastResync))\n            return -1\n\n        # The timestamp value will be a timestamp that we sent out\n        # previously, echoed back to us.  Therefore we can confidently\n        # convert it back into our local time, even though we suspect\n        # our clock delta might be off.\n        local = self.networkToLocalTime(timestamp, now)\n        elapsed = now - local\n        delta = (local + now) / 2.0 - serverTime\n\n        gotSync = 0\n        if elapsed <= 0 or elapsed > P2PResyncDelay:\n            # The elapsed time must be positive (the local timestamp\n            # must be in the past), and shouldn't be more than\n            # P2PResyncDelay.  If it does not meet these requirements,\n            # it must be very old indeed, or someone is playing tricks\n            # on us.\n            self.notify.info(\n                \"Ignoring old request for resync from %s.\" % (avId))\n        else:\n            # Now the other client has told us his delta and uncertainty\n            # information, which was generated somewhere in the range\n            # [-elapsed, 0] seconds ago.  That means our complete window\n            # is wider by that amount.\n            self.notify.info(\n                \"Got sync +/- %.3f s, elapsed %.3f s, from %s.\" %\n                (uncertainty, elapsed, avId))\n            delta -= elapsed / 2.0\n            uncertainty += elapsed / 2.0\n\n            gotSync = self.newDelta(local, delta, uncertainty, trustNew = 0)\n\n        return gotSync\n\n    def newDelta(self, localTime, newDelta, newUncertainty,\n                 trustNew = 1):\n        \"\"\"\n        Accepts a new delta and uncertainty pair, understood to\n        represent time as of localTime.  Improves our current notion\n        of the time delta accordingly.  The return value is true if\n        the new measurement was used, false if it was discarded.\n        \"\"\"\n        oldUncertainty = self.getUncertainty()\n        if oldUncertainty is not None:\n            self.notify.info(\n                'previous delta at %.3f s, +/- %.3f s.' %\n                (self.delta, oldUncertainty))\n            self.notify.info(\n                'new delta at %.3f s, +/- %.3f s.' %\n                (newDelta, newUncertainty))\n            # Our previous measurement was self.delta +/- oldUncertainty;\n            # our new measurement is newDelta +/- newUncertainty.  Take\n            # the intersection of both.\n\n            oldLow = self.delta - oldUncertainty\n            oldHigh = self.delta + oldUncertainty\n            newLow = newDelta - newUncertainty\n            newHigh = newDelta + newUncertainty\n\n            low = max(oldLow, newLow)\n            high = min(oldHigh, newHigh)\n\n            # If there is no intersection, whoops!  Either the old\n            # measurement or the new measurement is completely wrong.\n            if low > high:\n                if not trustNew:\n                    self.notify.info('discarding new delta.')\n                    return 0\n\n                self.notify.info('discarding previous delta.')\n            else:\n                newDelta = (low + high) / 2.0\n                newUncertainty = (high - low) / 2.0\n                self.notify.info(\n                    'intersection at %.3f s, +/- %.3f s.' %\n                    (newDelta, newUncertainty))\n\n        self.delta = newDelta\n        self.uncertainty = newUncertainty\n        self.lastResync = localTime\n\n        return 1\n\n    ### Primary interface functions ###\n\n    def networkToLocalTime(self, networkTime, now = None, bits = 16,\n                           ticksPerSec=NetworkTimePrecision):\n        \"\"\"networkToLocalTime(self, int networkTime)\n\n        Converts the indicated networkTime to the corresponding\n        localTime value.  The time is assumed to be within +/- 5\n        minutes of the current local time given in now, or\n        getRealTime() if now is not specified.\n        \"\"\"\n        if now is None:\n            now = self.globalClock.getRealTime()\n\n        # Are we in non-real-time mode (i.e. filming a movie)?  If you\n        # set movie-network-time 1, then we'll circumvent this logic\n        # and always return now.\n        if self.globalClock.getMode() == ClockObject.MNonRealTime and \\\n           ConfigVariableBool('movie-network-time', False):\n            return now\n\n        # First, determine what network time we have for 'now'.\n        ntime = int(math.floor(((now - self.delta) * ticksPerSec) + 0.5))\n\n        # The signed difference between these is the number of ticks\n        # by which the network time differs from 'now'.\n        if bits == 16:\n            diff = self.__signExtend(networkTime - ntime)\n        else:\n            # Assume the bits is either 16 or 32.  If it's 32, no need\n            # to sign-extend.  32 bits gives us about 227 days of\n            # continuous timestamp.\n\n            diff = networkTime - ntime\n\n        return now + float(diff) / ticksPerSec\n\n    def localToNetworkTime(self, localTime, bits = 16,\n                           ticksPerSec=NetworkTimePrecision):\n        \"\"\"localToNetworkTime(self, float localTime)\n\n        Converts the indicated localTime to the corresponding\n        networkTime value.\n        \"\"\"\n        ntime = int(math.floor(((localTime - self.delta) * ticksPerSec) + 0.5))\n        if bits == 16:\n            return self.__signExtend(ntime)\n        else:\n            # Assume the bits is either 16 or 32.  If it's 32, no need\n            # to sign-extend.  32 bits gives us about 227 days of\n            # continuous timestamp.\n            return ntime\n\n\n    ### Convenience functions ###\n\n    def getRealNetworkTime(self, bits=16,\n                           ticksPerSec=NetworkTimePrecision):\n        \"\"\"\n        Returns the current getRealTime() expressed as a network time.\n        \"\"\"\n        return self.localToNetworkTime(self.globalClock.getRealTime(),\n                                       bits=bits,\n                                       ticksPerSec=ticksPerSec)\n\n    def getFrameNetworkTime(self, bits=16,\n                            ticksPerSec=NetworkTimePrecision):\n        \"\"\"\n        Returns the current getFrameTime() expressed as a network time.\n        \"\"\"\n        return self.localToNetworkTime(self.globalClock.getFrameTime(),\n                                       bits=bits,\n                                       ticksPerSec=ticksPerSec)\n\n    def localElapsedTime(self, networkTime, bits=16,\n                         ticksPerSec=NetworkTimePrecision):\n        \"\"\"localElapsedTime(self, int networkTime)\n\n        Returns the amount of time elapsed (in seconds) on the client\n        since the server message was sent.  Negative values are\n        clamped to zero.\n        \"\"\"\n        now = self.globalClock.getFrameTime()\n        dt = now - self.networkToLocalTime(networkTime, now, bits=bits,\n                                           ticksPerSec=ticksPerSec)\n\n        return max(dt, 0.0)\n\n    ### Private functions ###\n\n    def __signExtend(self, networkTime):\n        \"\"\"__signExtend(self, int networkTime)\n\n        Preserves the lower NetworkTimeBits of the networkTime value,\n        and extends the sign bit all the way up.\n        \"\"\"\n        r = ((networkTime+32768) & NetworkTimeMask) - 32768\n        assert -32768 <= r <= 32767\n        return r\n\n\nglobalClockDelta = ClockDelta()\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/ClockDelta.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/dae38d8d_ClockDelta.json",
    "doc_id": "doc_315"
  }
}