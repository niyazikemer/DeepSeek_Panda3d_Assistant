{
  "content": "from panda3d.core import Vec3\n# Utility functions that are useful to both AI and client CartesianGrid code\n\nclass CartesianGridBase:\n    def isValidZone(self, zoneId):\n        def checkBounds(self=self, zoneId=zoneId):\n            if ((zoneId < self.startingZone) or\n                (zoneId > self.startingZone + self.gridSize * self.gridSize - 1)):\n                return 0\n            return 1\n        if self.style == \"Cartesian\":\n            return checkBounds()\n        elif self.style == \"CartesianStated\":\n            if zoneId >= 0 and zoneId < self.startingZone:\n                return 1\n            else:\n                return checkBounds()\n        else:\n            return 0\n\n    def getZoneFromXYZ(self, pos, wantRowAndCol=False):\n        # NOTE: pos should be relative to our own grid origin\n        # Convert a 3d position to a zone\n        dx = self.cellWidth * self.gridSize * .5\n        x = pos[0] + dx\n        y = pos[1] + dx\n        col = x // self.cellWidth\n        row = y // self.cellWidth\n        # Compute which zone we are in\n        zoneId = int(self.startingZone + ((row * self.gridSize) + col))\n\n        if wantRowAndCol:\n            return (zoneId, col, row)\n        else:\n            return zoneId\n\n    def getGridSizeFromSphereRadius(self, sphereRadius, cellWidth, gridRadius):\n        # NOTE: This ensures that the grid is at least a \"gridRadius\" number\n        # of cells larger than the trigger sphere that loads the grid.  This\n        # gives us some room to start setting interest to the grid before we\n        # expect to see any objects on it.\n        sphereRadius = max(sphereRadius, gridRadius*cellWidth)\n        return 2 * (sphereRadius // cellWidth)\n\n    def getGridSizeFromSphere(self, sphereRadius, spherePos, cellWidth, gridRadius):\n        # NOTE: This ensures that the grid is at least a \"gridRadius\" number\n        # of cells larger than the trigger sphere that loads the grid.  This\n        # gives us some room to start setting interest to the grid before we\n        # expect to see any objects on it.\n        xMax = abs(spherePos[0])+sphereRadius\n        yMax = abs(spherePos[1])+sphereRadius\n        sphereRadius = Vec3(xMax,yMax,0).length()\n\n        # sphereRadius = max(sphereRadius, gridRadius*cellWidth)\n        return max(2 * (sphereRadius // cellWidth), 1)\n\n    def getZoneCellOrigin(self, zoneId):\n        # It returns the origin of the zoneCell\n        # Origin is the top-left corner of zoneCell\n        dx = self.cellWidth * self.gridSize * .5\n        zone = zoneId - self.startingZone\n        row = zone // self.gridSize\n        col = zone % self.gridSize\n        x = col * self.cellWidth - dx\n        y = row * self.cellWidth - dx\n\n        return (x, y, 0)\n\n    def getZoneCellOriginCenter(self, zoneId):\n        # Variant of the getZoneCellOrigin. It\n        # returns the center of the zoneCell\n        dx = self.cellWidth * self.gridSize * .5\n        center = self.cellWidth * 0.5\n        zone = zoneId - self.startingZone\n        row = zone // self.gridSize\n        col = zone % self.gridSize\n        x = col * self.cellWidth - dx + center\n        y = row * self.cellWidth - dx + center\n\n        return (x, y, 0)\n\n    #--------------------------------------------------------------------------\n    # Function:   utility function to get all zones in a ring of given radius\n    #               around the given zoneId (so if given a zoneId 34342 and a\n    #               radius of 3, a list of all zones exactly 3 grids away from\n    #               zone 34342 will be returned)\n    # Parameters: zoneId, center zone to find surrounding zones of\n    #             radius, how far from zoneId to find zones of for it them\n    # Changes:\n    # Returns:\n    #--------------------------------------------------------------------------\n    def getConcentricZones(self, zoneId, radius):\n        zones = []\n        #currZone = zoneId + radius\n        #numZones = (2 * radius * 8) + 2\n        # start at upper left\n        zone = zoneId - self.startingZone\n        row = zone // self.gridSize\n        col = zone % self.gridSize\n\n        leftOffset = min(col, radius)\n        rightOffset = min(self.gridSize - (col + 1), radius)\n        topOffset = min(row, radius)\n        bottomOffset = min(self.gridSize - (row + 1), radius)\n\n        #print \"starting examination of grid circle of radius %s\"%radius\n        ulZone = zoneId - leftOffset - topOffset * self.gridSize\n        #print \"left offset is %s and radius is %s\"%(leftOffset,radius)\n        for currCol in range(int(rightOffset + leftOffset + 1)):\n            if ((currCol == 0 and leftOffset == radius) or (currCol == rightOffset + leftOffset and rightOffset == radius)):\n                # at either left or right edge of area, look at all rows\n                possibleRows = range(int(bottomOffset + topOffset + 1))\n            else:\n                # in a middle column, only look at top and bottom rows\n                possibleRows = []\n                if topOffset == radius:\n                    possibleRows.append(0)\n                if bottomOffset == radius:\n                    possibleRows.append(bottomOffset + topOffset)\n            #print \"on column %s and looking at rows %s\"%(currCol,possibleRows)\n            for currRow in possibleRows:\n                newZone = ulZone + (currRow * self.gridSize) + currCol\n                zones.append(int(newZone))\n                #print \"   examining zone %s\"%newZone\n        return zones\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/CartesianGridBase.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/8bef0ac2_CartesianGridBase.json",
    "doc_id": "doc_298"
  }
}