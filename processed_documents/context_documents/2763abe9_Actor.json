{
  "content": "\"\"\"Actor module: contains the Actor class.\n\nSee the :ref:`loading-actors-and-animations` page in the Programming Guide\nto learn more about loading animated models.\n\"\"\"\n\n__all__ = ['Actor']\n\nfrom panda3d.core import (\n    AnimBundleNode,\n    AnimControlCollection,\n    Character,\n    ConfigVariableBool,\n    DecalEffect,\n    Filename,\n    GlobPattern,\n    LineStream,\n    LoaderOptions,\n    LODNode,\n    ModelNode,\n    MovingPartBase,\n    MovingPartMatrix,\n    NodePath,\n    PandaNode,\n    PartBundle,\n    PartSubset,\n    Point3,\n    TransformState,\n    Vec3,\n    autoBind,\n)\nfrom panda3d.core import Loader as PandaLoader\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.showbase.Loader import Loader\nfrom direct.directnotify import DirectNotifyGlobal\nimport warnings\n\nclass Actor(DirectObject, NodePath):\n    \"\"\"\n    Actor class: Contains methods for creating, manipulating\n    and playing animations on characters\n    \"\"\"\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"Actor\")\n    partPrefix = \"__Actor_\"\n\n    modelLoaderOptions = LoaderOptions(LoaderOptions.LFSearch |\n                                       LoaderOptions.LFReportErrors |\n                                       LoaderOptions.LFConvertSkeleton)\n    animLoaderOptions =  LoaderOptions(LoaderOptions.LFSearch |\n                                       LoaderOptions.LFReportErrors |\n                                       LoaderOptions.LFConvertAnim)\n\n    validateSubparts = ConfigVariableBool('validate-subparts', True)\n    mergeLODBundles = ConfigVariableBool('merge-lod-bundles', True)\n    allowAsyncBind = ConfigVariableBool('allow-async-bind', True)\n\n    class PartDef:\n\n        \"\"\"Instances of this class are stored within the\n        PartBundleDict to track all of the individual PartBundles\n        associated with the Actor.  In general, each separately loaded\n        model file is a different PartBundle.  This can include the\n        multiple different LOD's, as well as the multiple different\n        pieces of a multipart Actor. \"\"\"\n\n        def __init__(self, partBundleNP, partBundleHandle, partModel):\n            # We also save the ModelRoot node along with the\n            # PartBundle, so that the reference count in the ModelPool\n            # will be accurate.\n            self.partBundleNP = partBundleNP\n            self.partBundleHandle = partBundleHandle\n            self.partModel = partModel\n\n        def getBundle(self):\n            return self.partBundleHandle.getBundle()\n\n        def __repr__(self):\n            return 'Actor.PartDef(%s, %s)' % (repr(self.partBundleNP), repr(self.partModel))\n\n\n        #snake_case alias:\n        get_bundle = getBundle\n\n    class AnimDef:\n\n        \"\"\"Instances of this class are stored within the\n        AnimControlDict to track all of the animations associated with\n        the Actor.  This includes animations that have already been\n        bound (these have a valid AnimControl) as well as those that\n        have not yet been bound (for these, self.animControl is None).\n\n        There is a different AnimDef for each different part or\n        sub-part, times each different animation in the AnimDict. \"\"\"\n\n        def __init__(self, filename = None, animBundle = None):\n            self.filename = filename\n            self.animBundle = animBundle\n            self.animControl = None\n\n        def makeCopy(self):\n            return Actor.AnimDef(self.filename, self.animBundle)\n\n        def __repr__(self):\n            return 'Actor.AnimDef(%s)' % (repr(self.filename))\n\n\n        #snake_case alias:\n        make_copy = makeCopy\n\n    class SubpartDef:\n\n        \"\"\"Instances of this class are stored within the SubpartDict\n        to track the existance of arbitrary sub-parts.  These are\n        designed to appear to the user to be identical to true \"part\"\n        of a multi-part Actor, but in fact each subpart represents a\n        subset of the joints of an existing part (which is accessible\n        via a different name). \"\"\"\n\n        def __init__(self, truePartName, subset = PartSubset()):\n            self.truePartName = truePartName\n            self.subset = subset\n\n        def makeCopy(self):\n            return Actor.SubpartDef(self.truePartName, PartSubset(self.subset))\n\n\n        def __repr__(self):\n            return 'Actor.SubpartDef(%s, %s)' % (repr(self.truePartName), repr(self.subset))\n\n    def __init__(self, models=None, anims=None, other=None, copy=True,\n                 lodNode = None, flattenable = True, setFinal = False,\n                 mergeLODBundles = None, allowAsyncBind = None,\n                 okMissing = None):\n        \"\"\"Actor constructor: can be used to create single or multipart\n        actors. If another Actor is supplied as an argument this\n        method acts like a copy constructor. Single part actors are\n        created by calling with a model and animation dictionary\n        ``(animName:animPath{})`` as follows::\n\n           a = Actor(\"panda-3k.egg\", {\"walk\":\"panda-walk.egg\",\n                                      \"run\":\"panda-run.egg\"})\n\n        This could be displayed and animated as such::\n\n           a.reparentTo(render)\n           a.loop(\"walk\")\n           a.stop()\n\n        Multipart actors expect a dictionary of parts and a dictionary\n        of animation dictionaries ``(partName:(animName:animPath{}){})``\n        as below::\n\n            a = Actor(\n\n                # part dictionary\n                {\"head\": \"char/dogMM/dogMM_Shorts-head-mod\",\n                 \"torso\": \"char/dogMM/dogMM_Shorts-torso-mod\",\n                 \"legs\": \"char/dogMM/dogMM_Shorts-legs-mod\"},\n\n                # dictionary of anim dictionaries\n                {\"head\":{\"walk\": \"char/dogMM/dogMM_Shorts-head-walk\",\n                         \"run\": \"char/dogMM/dogMM_Shorts-head-run\"},\n                 \"torso\":{\"walk\": \"char/dogMM/dogMM_Shorts-torso-walk\",\n                          \"run\": \"char/dogMM/dogMM_Shorts-torso-run\"},\n                 \"legs\":{\"walk\": \"char/dogMM/dogMM_Shorts-legs-walk\",\n                         \"run\": \"char/dogMM/dogMM_Shorts-legs-run\"}\n                 })\n\n        In addition multipart actor parts need to be connected together\n        in a meaningful fashion::\n\n            a.attach(\"head\", \"torso\", \"joint-head\")\n            a.attach(\"torso\", \"legs\", \"joint-hips\")\n\n        #\n        # ADD LOD COMMENT HERE!\n        #\n\n        Other useful Actor class functions::\n\n            #fix actor eye rendering\n            a.drawInFront(\"joint-pupil?\", \"eyes*\")\n\n            #fix bounding volumes - this must be done after drawing\n            #the actor for a few frames, otherwise it has no effect\n            a.fixBounds()\n        \"\"\"\n        if hasattr(self, 'Actor_initialized'):\n            return\n\n        self.Actor_initialized = 1\n\n        # initialize our NodePath essence\n        NodePath.__init__(self)\n\n        self.loader = PandaLoader.getGlobalPtr()\n\n        # Set the mergeLODBundles flag.  If this is true, all\n        # different LOD's will be merged into a single common bundle\n        # (joint hierarchy).  All LOD's will thereafter share the same\n        # skeleton, even though they may have been loaded from\n        # different egg files.  If this is false, LOD's will be kept\n        # completely isolated, and each LOD will have its own\n        # skeleton.\n\n        # When this flag is true, __animControlDict has only one key,\n        # ['common']; when it is false, __animControlDict has one key\n        # per each LOD name.\n\n        if mergeLODBundles is None:\n            # If this isn't specified, it comes from the Config.prc\n            # file.\n            self.mergeLODBundles = Actor.mergeLODBundles.getValue()\n        else:\n            self.mergeLODBundles = mergeLODBundles\n\n        # Set the allowAsyncBind flag.  If this is true, it enables\n        # asynchronous animation binding.  This requires that you have\n        # run \"egg-optchar -preload\" on your animation and models to\n        # generate the appropriate AnimPreloadTable.\n        if allowAsyncBind is None:\n            self.allowAsyncBind = Actor.allowAsyncBind.getValue()\n        else:\n            self.allowAsyncBind = allowAsyncBind\n\n        # create data structures\n        self.__commonBundleHandles = {}\n        self.__partBundleDict = {}\n        self.__subpartDict = {}\n        self.__sortedLODNames = []\n        self.__animControlDict = {}\n\n        self.__subpartsComplete = False\n\n        self.__LODNode = None\n        self.__LODAnimation = None\n        self.__LODCenter = Point3(0, 0, 0)\n        self.switches = None\n\n        if other is None:\n            # act like a normal constructor\n\n            # create base hierarchy\n            self.gotName = 0\n\n            if flattenable:\n                # If we want a flattenable Actor, don't create all\n                # those ModelNodes, and the GeomNode is the same as\n                # the root.\n                root = PandaNode('actor')\n                self.assign(NodePath(root))\n                self.setGeomNode(NodePath(self))\n\n            else:\n                # A standard Actor has a ModelNode at the root, and\n                # another ModelNode to protect the GeomNode.\n                root = ModelNode('actor')\n                root.setPreserveTransform(1)\n                self.assign(NodePath(root))\n                self.setGeomNode(self.attachNewNode(ModelNode('actorGeom')))\n\n            self.__hasLOD = 0\n\n            # load models\n            #\n            # four cases:\n            #\n            #   models, anims{} = single part actor\n            #   models{}, anims{} =  single part actor w/ LOD\n            #   models{}, anims{}{} = multi-part actor\n            #   models{}{}, anims{}{} = multi-part actor w/ LOD\n            #\n            # make sure we have models\n            if models:\n                # do we have a dictionary of models?\n                if isinstance(models, dict):\n                    # if this is a dictionary of dictionaries\n                    if isinstance(models[next(iter(models))], dict):\n                        # then it must be a multipart actor w/LOD\n                        self.setLODNode(node = lodNode)\n                        # preserve numerical order for lod's\n                        # this will make it easier to set ranges\n                        for lodName in sorted(models):\n                            # make a node under the LOD switch\n                            # for each lod (just because!)\n                            self.addLOD(str(lodName))\n                            # iterate over both dicts\n                            for modelName in models[lodName]:\n                                self.loadModel(models[lodName][modelName],\n                                               modelName, lodName, copy = copy,\n                                               okMissing = okMissing)\n                    # then if there is a dictionary of dictionaries of anims\n                    elif isinstance(anims[next(iter(anims))], dict):\n                        # then this is a multipart actor w/o LOD\n                        for partName in models:\n                            # pass in each part\n                            self.loadModel(models[partName], partName,\n                                           copy = copy, okMissing = okMissing)\n                    else:\n                        # it is a single part actor w/LOD\n                        self.setLODNode(node = lodNode)\n                        # preserve order of LOD's\n                        for lodName in sorted(models):\n                            self.addLOD(str(lodName))\n                            # pass in dictionary of parts\n                            self.loadModel(models[lodName], lodName=lodName,\n                                           copy = copy, okMissing = okMissing)\n                else:\n                    # else it is a single part actor\n                    self.loadModel(models, copy = copy, okMissing = okMissing)\n\n            # load anims\n            # make sure the actor has animations\n            if anims:\n                if len(anims) >= 1:\n                    # if so, does it have a dictionary of dictionaries?\n                    if isinstance(anims[next(iter(anims))], dict):\n                        # are the models a dict of dicts too?\n                        if isinstance(models, dict):\n                            if isinstance(models[next(iter(models))], dict):\n                                # then we have a multi-part w/ LOD\n                                for lodName in sorted(models):\n                                    # iterate over both dicts\n                                    for partName in anims:\n                                        self.loadAnims(\n                                            anims[partName], partName, lodName)\n                            else:\n                                # then it must be multi-part w/o LOD\n                                for partName in anims:\n                                    self.loadAnims(anims[partName], partName)\n                    elif isinstance(models, dict):\n                        # then we have single-part w/ LOD\n                        for lodName in sorted(models):\n                            self.loadAnims(anims, lodName=lodName)\n                    else:\n                        # else it is single-part w/o LOD\n                        self.loadAnims(anims)\n\n        else:\n            self.copyActor(other, True) # overwrite everything\n\n        if setFinal:\n            # If setFinal is true, the Actor will set its top bounding\n            # volume to be the \"final\" bounding volume: the bounding\n            # volumes below the top volume will not be tested.  If a\n            # cull test passes the top bounding volume, the whole\n            # Actor is rendered.\n\n            # We do this partly because an Actor is likely to be a\n            # fairly small object relative to the scene, and is pretty\n            # much going to be all onscreen or all offscreen anyway;\n            # and partly because of the Character bug that doesn't\n            # update the bounding volume for pieces that animate away\n            # from their original position.  It's disturbing to see\n            # someone's hands disappear; better to cull the whole\n            # object or none of it.\n            self.__geomNode.node().setFinal(1)\n\n    def delete(self):\n        if not hasattr(self, 'Actor_deleted'):\n            self.Actor_deleted = 1\n            self.cleanup()\n\n    def copyActor(self, other, overwrite=False):\n        # act like a copy constructor\n        self.gotName = other.gotName\n\n        # copy the scene graph elements of other\n        if overwrite:\n            otherCopy = other.copyTo(NodePath())\n            otherCopy.detachNode()\n            # assign these elements to ourselve (overwrite)\n            self.assign(otherCopy)\n        else:\n            # just copy these to ourselves\n            otherCopy = other.copyTo(self)\n        # masad: check if otherCopy has a geomNode as its first child\n        # if actor is initialized with flattenable, then otherCopy, not\n        # its first child, is the geom node; check __init__, for reference\n        if other.getGeomNode().getName() == other.getName():\n            self.setGeomNode(otherCopy)\n        else:\n            self.setGeomNode(otherCopy.getChild(0))\n\n        # copy the switches for lods\n        self.switches = other.switches\n        self.__LODNode = self.find('**/+LODNode')\n        self.__hasLOD = 0\n        if not self.__LODNode.isEmpty():\n            self.__hasLOD = 1\n\n\n        # copy the part dictionary from other\n        self.__copyPartBundles(other)\n        self.__copySubpartDict(other)\n        self.__subpartsComplete = other.__subpartsComplete\n\n        # copy the anim dictionary from other\n        self.__copyAnimControls(other)\n\n    def __cmp__(self, other):\n        # Actor inherits from NodePath, which inherits a definition of\n        # __cmp__ from FFIExternalObject that uses the NodePath's\n        # compareTo() method to compare different NodePaths.  But we\n        # don't want this behavior for Actors; Actors should only be\n        # compared pointerwise.  A NodePath that happens to reference\n        # the same node is still different from the Actor.\n        if self is other:\n            return 0\n        else:\n            return 1\n\n    def __str__(self):\n        \"\"\"\n        Actor print function\n        \"\"\"\n        return \"Actor %s, parts = %s, LODs = %s, anims = %s\" % \\\n               (self.getName(), self.getPartNames(), self.getLODNames(), self.getAnimNames())\n\n    def listJoints(self, partName=\"modelRoot\", lodName=\"lodRoot\"):\n        \"\"\"Handy utility function to list the joint hierarchy of the\n        actor. \"\"\"\n\n        if self.mergeLODBundles:\n            partBundleDict = self.__commonBundleHandles\n        else:\n            partBundleDict = self.__partBundleDict.get(lodName)\n            if not partBundleDict:\n                Actor.notify.error(\"no lod named: %s\" % (lodName))\n\n        subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n\n        partDef = partBundleDict.get(subpartDef.truePartName)\n        if partDef is None:\n            Actor.notify.error(\"no part named: %s\" % (partName))\n\n        self.__doListJoints(0, partDef.getBundle(),\n                            subpartDef.subset.isIncludeEmpty(), subpartDef.subset)\n\n    def __doListJoints(self, indentLevel, part, isIncluded, subset):\n        name = part.name\n        if subset.matchesInclude(name):\n            isIncluded = True\n        elif subset.matchesExclude(name):\n            isIncluded = False\n\n        if isIncluded:\n            value = ''\n            if hasattr(part, 'outputValue'):\n                lineStream = LineStream()\n                part.outputValue(lineStream)\n                value = lineStream.getLine()\n\n            print(' '.join((' ' * indentLevel, name, value)))\n\n        for child in part.children:\n            self.__doListJoints(indentLevel + 2, child, isIncluded, subset)\n\n\n    def getActorInfo(self):\n        \"\"\"\n        Utility function to create a list of information about an actor.\n        Useful for iterating over details of an actor.\n        \"\"\"\n        lodInfo = []\n        for lodName, partDict in self.__animControlDict.items():\n            if self.mergeLODBundles:\n                lodName = self.__sortedLODNames[0]\n\n            partInfo = []\n            for partName in partDict:\n                subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n                partBundleDict = self.__partBundleDict.get(lodName)\n                partDef = partBundleDict.get(subpartDef.truePartName)\n                partBundle = partDef.getBundle()\n                animDict = partDict[partName]\n                animInfo = []\n                for animName in animDict:\n                    file = animDict[animName].filename\n                    animControl = animDict[animName].animControl\n                    animInfo.append([animName, file, animControl])\n                partInfo.append([partName, partBundle, animInfo])\n            lodInfo.append([lodName, partInfo])\n        return lodInfo\n\n    def getAnimNames(self):\n        animNames = []\n        for lodName, lodInfo in self.getActorInfo():\n            for partName, bundle, animInfo in lodInfo:\n                for animName, file, animControl in animInfo:\n                    if animName not in animNames:\n                        animNames.append(animName)\n        return animNames\n\n    def pprint(self):\n        \"\"\"\n        Pretty print actor's details\n        \"\"\"\n        for lodName, lodInfo in self.getActorInfo():\n            print('LOD: %s' % lodName)\n            for partName, bundle, animInfo in lodInfo:\n                print('  Part: %s' % partName)\n                print('  Bundle: %r' % bundle)\n                for animName, file, animControl in animInfo:\n                    print('    Anim: %s' % animName)\n                    print('      File: %s' % file)\n                    if animControl is None:\n                        print(' (not loaded)')\n                    else:\n                        print('      NumFrames: %d PlayRate: %0.2f' %\n                               (animControl.getNumFrames(),\n                                animControl.getPlayRate()))\n\n    def cleanup(self):\n        \"\"\"\n        This method should be called when intending to destroy the Actor, and\n        cleans up any additional resources stored on the Actor class before\n        removing the underlying node using `removeNode()`.\n\n        Note that `removeNode()` itself is not sufficient to destroy actors,\n        which is why this method exists.\n        \"\"\"\n        self.stop(None)\n        self.clearPythonData()\n        self.flush()\n        if self.__geomNode:\n            self.__geomNode.removeNode()\n            self.__geomNode = None\n        if not self.isEmpty():\n            self.removeNode()\n\n    def removeNode(self):\n        \"\"\"\n        You should call `cleanup()` for Actor objects instead, since\n        :meth:`~panda3d.core.NodePath.removeNode()` is not sufficient for\n        completely destroying Actor objects.\n        \"\"\"\n        if self.__geomNode and (self.__geomNode.getNumChildren() > 0):\n            assert self.notify.warning(\"called actor.removeNode() on %s without calling cleanup()\" % self.getName())\n        NodePath.removeNode(self)\n\n    def clearPythonData(self):\n        self.__commonBundleHandles = {}\n        self.__partBundleDict = {}\n        self.__subpartDict = {}\n        self.__sortedLODNames = []\n        self.__animControlDict = {}\n\n    def flush(self):\n        \"\"\"\n        Actor flush function.  Used by `cleanup()`.\n        \"\"\"\n        self.clearPythonData()\n\n        if self.__LODNode and (not self.__LODNode.isEmpty()):\n            self.__LODNode.removeNode()\n            self.__LODNode = None\n\n        # remove all its children\n        if self.__geomNode:\n            self.__geomNode.getChildren().detach()\n\n        self.__hasLOD = 0\n\n    # accessing\n\n    def getAnimControlDict(self):\n        return self.__animControlDict\n\n    def removeAnimControlDict(self):\n        self.__animControlDict = {}\n\n    def getPartBundleDict(self):\n        return self.__partBundleDict\n\n    def getPartBundles(self, partName = None):\n        \"\"\" Returns a list of PartBundle objects for the entire Actor,\n        or for the indicated part only. \"\"\"\n\n        bundles = []\n\n        for lodName, partBundleDict in self.__partBundleDict.items():\n            if partName is None:\n                for partDef in partBundleDict.values():\n                    bundles.append(partDef.getBundle())\n\n            else:\n                subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n                partDef = partBundleDict.get(subpartDef.truePartName)\n                if partDef is not None:\n                    bundles.append(partDef.getBundle())\n                else:\n                    Actor.notify.warning(\"Couldn't find part: %s\" % (partName))\n\n        return bundles\n\n    def __updateSortedLODNames(self):\n        # Reverse sort the doing a string->int\n        def sortKey(x):\n            if not str(x).isdigit():\n                smap = {'h':3,\n                        'm':2,\n                        'l':1,\n                        'f':0}\n\n                #sx = smap.get(x[0], None)\n                #\n                #if sx is None:\n                #    self.notify.error('Invalid lodName: %s' % x)\n                return smap[x[0]]\n            else:\n                return int(x)\n\n        # Cache the sorted LOD names so we don't have to grab them\n        # and sort them every time somebody asks for the list\n        self.__sortedLODNames = sorted(self.__partBundleDict, key=sortKey, reverse=True)\n\n    def getLODNames(self):\n        \"\"\"\n        Return list of Actor LOD names. If not an LOD actor,\n        returns 'lodRoot'\n        Caution - this returns a reference to the list - not your own copy\n        \"\"\"\n        return self.__sortedLODNames\n\n    def getPartNames(self):\n        \"\"\"\n        Return list of Actor part names. If not an multipart actor,\n        returns 'modelRoot' NOTE: returns parts of arbitrary LOD\n        \"\"\"\n        partNames = []\n        if self.__partBundleDict:\n            partNames = list(next(iter(self.__partBundleDict.values())).keys())\n        return partNames + list(self.__subpartDict.keys())\n\n    def getGeomNode(self):\n        \"\"\"\n        Return the node that contains all actor geometry\n        \"\"\"\n        return self.__geomNode\n\n    def setGeomNode(self, node):\n        \"\"\"\n        Set the node that contains all actor geometry\n        \"\"\"\n        self.__geomNode = node\n\n    def getLODNode(self):\n        \"\"\"\n        Return the node that switches actor geometry in and out\"\"\"\n        return self.__LODNode.node()\n\n    def setLODNode(self, node=None):\n        \"\"\"\n        Set the node that switches actor geometry in and out.\n        If one is not supplied as an argument, make one\n        \"\"\"\n        if node is None:\n            node = LODNode.makeDefaultLod(\"lod\")\n\n        if self.__LODNode:\n            self.__LODNode = node\n        else:\n            self.__LODNode = self.__geomNode.attachNewNode(node)\n            self.__hasLOD = 1\n            self.switches = {}\n\n\n    def useLOD(self, lodName):\n        \"\"\"\n        Make the Actor ONLY display the given LOD\n        \"\"\"\n        # make sure we don't call this twice in a row\n        # and pollute the the switches dictionary\n        child = self.__LODNode.find(str(lodName))\n        index = self.__LODNode.node().findChild(child.node())\n        self.__LODNode.node().forceSwitch(index)\n\n    def printLOD(self):\n        sortedKeys = self.__sortedLODNames\n        for eachLod in sortedKeys:\n            print(\"python switches for %s: in: %d, out %d\" % (eachLod,\n                                              self.switches[eachLod][0],\n                                              self.switches[eachLod][1]))\n\n        switchNum = self.__LODNode.node().getNumSwitches()\n        for eachSwitch in range(0, switchNum):\n            print(\"c++ switches for %d: in: %d, out: %d\" % (eachSwitch,\n                   self.__LODNode.node().getIn(eachSwitch),\n                   self.__LODNode.node().getOut(eachSwitch)))\n\n\n    def resetLOD(self):\n        \"\"\"\n        Restore all switch distance info (usually after a useLOD call)\"\"\"\n        self.__LODNode.node().clearForceSwitch()\n\n    def addLOD(self, lodName, inDist=0, outDist=0, center=None):\n        \"\"\"addLOD(self, string)\n        Add a named node under the LODNode to parent all geometry\n        of a specific LOD under.\n        \"\"\"\n        self.__LODNode.attachNewNode(str(lodName))\n        # save the switch distance info\n        self.switches[lodName] = [inDist, outDist]\n        # add the switch distance info\n        self.__LODNode.node().addSwitch(inDist, outDist)\n        if center is not None:\n            self.setCenter(center)\n\n    def setLOD(self, lodName, inDist=0, outDist=0):\n        \"\"\"setLOD(self, string)\n        Set the switch distance for given LOD\n        \"\"\"\n        # save the switch distance info\n        self.switches[lodName] = [inDist, outDist]\n        # add the switch distance info\n        self.__LODNode.node().setSwitch(self.getLODIndex(lodName), inDist, outDist)\n\n    def getLODIndex(self, lodName):\n        \"\"\"getLODIndex(self)\n        safe method (but expensive) for retrieving the child index\n        \"\"\"\n        return list(self.__LODNode.getChildren()).index(self.getLOD(lodName))\n\n    def getLOD(self, lodName):\n        \"\"\"getLOD(self, string)\n        Get the named node under the LOD to which we parent all LOD\n        specific geometry to. Returns 'None' if not found\n        \"\"\"\n        if self.__LODNode:\n            lod = self.__LODNode.find(str(lodName))\n            if lod.isEmpty():\n                return None\n            else:\n                return lod\n        else:\n            return None\n\n    def getPlayMode(self, animName=None, partName=None):\n        if self.__animControlDict:\n            controls = self.getAnimControls(animName, partName, onlyPlaying=False)\n            if controls:\n                return controls[0].getPlayMode()\n        return None\n\n    def hasLOD(self):\n        \"\"\"\n        Return 1 if the actor has LODs, 0 otherwise\n        \"\"\"\n        return self.__hasLOD\n\n    def setCenter(self, center):\n        if center is None:\n            center = Point3(0, 0, 0)\n        self.__LODCenter = center\n        if self.__LODNode:\n            self.__LODNode.node().setCenter(self.__LODCenter)\n        if self.__LODAnimation:\n            self.setLODAnimation(*self.__LODAnimation)\n\n    def setLODAnimation(self, farDistance, nearDistance, delayFactor):\n        \"\"\" Activates a special mode in which the Actor animates less\n        frequently as it gets further from the camera.  This is\n        intended as a simple optimization to minimize the effort of\n        computing animation for lots of characters that may not\n        necessarily be very important to animate every frame.\n\n        If the character is closer to the camera than near_distance,\n        then it is animated its normal rate, every frame.  If the\n        character is exactly far_distance away, it is animated only\n        every delay_factor seconds (which should be a number greater\n        than 0).  If the character is between near_distance and\n        far_distance, its animation rate is linearly interpolated\n        according to its distance between the two.  The interpolation\n        function continues beyond far_distance, so that the character\n        is animated increasingly less frequently as it gets farther\n        away. \"\"\"\n\n        self.__LODAnimation = (farDistance, nearDistance, delayFactor)\n\n        for lodData in self.__partBundleDict.values():\n            for partData in lodData.values():\n                char = partData.partBundleNP\n                char.node().setLodAnimation(self.__LODCenter, farDistance, nearDistance, delayFactor)\n\n    def clearLODAnimation(self):\n        \"\"\" Description: Undoes the effect of a recent call to\n        set_lod_animation().  Henceforth, the character will animate\n        every frame, regardless of its distance from the camera.\n        \"\"\"\n\n        self.__LODAnimation = None\n\n        for lodData in self.__partBundleDict.values():\n            for partData in lodData.values():\n                char = partData.partBundleNP\n                char.node().clearLodAnimation()\n\n\n    def update(self, lod=0, partName=None, lodName=None, force=False):\n        \"\"\" Updates all of the Actor's joints in the indicated LOD.\n        The LOD may be specified by name, or by number, where 0 is the\n        highest level of detail, 1 is the next highest, and so on.\n\n        If force is True, this will update every joint, even if we\n        don't believe it's necessary.\n\n        Returns True if any joint has changed as a result of this,\n        False otherwise. \"\"\"\n\n        if lodName is None:\n            lodNames = self.getLODNames()\n        else:\n            lodNames = [lodName]\n\n        anyChanged = False\n        if lod < len(lodNames):\n            lodName = lodNames[lod]\n            if partName is None:\n                partBundleDict = self.__partBundleDict[lodName]\n                partNames = list(partBundleDict.keys())\n            else:\n                partNames = [partName]\n\n            for partName in partNames:\n                partBundle = self.getPartBundle(partName, lodNames[lod])\n                if force:\n                    if partBundle.forceUpdate():\n                        anyChanged = True\n                else:\n                    if partBundle.update():\n                        anyChanged = True\n        else:\n            self.notify.warning('update() - no lod: %d' % lod)\n\n        return anyChanged\n\n    def getFrameRate(self, animName=None, partName=None):\n        \"\"\"getFrameRate(self, string, string=None)\n        Return actual frame rate of given anim name and given part.\n        If no anim specified, use the currently playing anim.\n        If no part specified, return anim durations of first part.\n        NOTE: returns info only for an arbitrary LOD\n        \"\"\"\n        lodName = next(iter(self.__animControlDict))\n        controls = self.getAnimControls(animName, partName)\n        if len(controls) == 0:\n            return None\n\n        return controls[0].getFrameRate()\n\n    def getBaseFrameRate(self, animName=None, partName=None):\n        \"\"\"getBaseFrameRate(self, string, string=None)\n        Return frame rate of given anim name and given part, unmodified\n        by any play rate in effect.\n        \"\"\"\n        lodName = next(iter(self.__animControlDict))\n        controls = self.getAnimControls(animName, partName)\n        if len(controls) == 0:\n            return None\n\n        return controls[0].getAnim().getBaseFrameRate()\n\n    def getPlayRate(self, animName=None, partName=None):\n        \"\"\"\n        Return the play rate of given anim for a given part.\n        If no part is given, assume first part in dictionary.\n        If no anim is given, find the current anim for the part.\n        NOTE: Returns info only for an arbitrary LOD\n        \"\"\"\n        if self.__animControlDict:\n            # use the first lod\n            lodName = next(iter(self.__animControlDict))\n            controls = self.getAnimControls(animName, partName)\n            if controls:\n                return controls[0].getPlayRate()\n        return None\n\n    def setPlayRate(self, rate, animName, partName=None):\n        \"\"\"setPlayRate(self, float, string, string=None)\n        Set the play rate of given anim for a given part.\n        If no part is given, set for all parts in dictionary.\n\n        It used to be legal to let the animName default to the\n        currently-playing anim, but this was confusing and could lead\n        to the wrong anim's play rate getting set.  Better to insist\n        on this parameter.\n        NOTE: sets play rate on all LODs\"\"\"\n        for control in self.getAnimControls(animName, partName):\n            control.setPlayRate(rate)\n\n    def getDuration(self, animName=None, partName=None,\n                    fromFrame=None, toFrame=None):\n        \"\"\"\n        Return duration of given anim name and given part.\n        If no anim specified, use the currently playing anim.\n        If no part specified, return anim duration of first part.\n        NOTE: returns info for arbitrary LOD\n        \"\"\"\n        lodName = next(iter(self.__animControlDict))\n        controls = self.getAnimControls(animName, partName)\n        if len(controls) == 0:\n            return None\n\n        animControl = controls[0]\n        if fromFrame is None:\n            fromFrame = 0\n        if toFrame is None:\n            toFrame = animControl.getNumFrames()-1\n        return ((toFrame+1)-fromFrame) / animControl.getFrameRate()\n\n    def getNumFrames(self, animName=None, partName=None):\n        #lodName = next(iter(self.__animControlDict))\n        controls = self.getAnimControls(animName, partName)\n        if len(controls) == 0:\n            return None\n        return controls[0].getNumFrames()\n\n    def getFrameTime(self, anim, frame, partName=None):\n        numFrames = self.getNumFrames(anim,partName)\n        animTime = self.getDuration(anim,partName)\n        frameTime = animTime * float(frame) / numFrames\n        return frameTime\n\n    def getCurrentAnim(self, partName=None):\n        \"\"\"\n        Return the anim currently playing on the actor. If part not\n        specified return current anim of an arbitrary part in dictionary.\n        NOTE: only returns info for an arbitrary LOD\n        \"\"\"\n        if len(self.__animControlDict) == 0:\n            return\n\n        lodName, animControlDict = next(iter(self.__animControlDict.items()))\n        if partName is None:\n            partName, animDict = next(iter(animControlDict.items()))\n        else:\n            animDict = animControlDict.get(partName)\n            if animDict is None:\n                # part was not present\n                Actor.notify.warning(\"couldn't find part: %s\" % (partName))\n                return None\n\n        # loop through all anims for named part and find if any are playing\n        for animName, anim in animDict.items():\n            if anim.animControl and anim.animControl.isPlaying():\n                return animName\n\n        # we must have found none, or gotten an error\n        return None\n\n    def getCurrentFrame(self, animName=None, partName=None):\n        \"\"\"\n        Return the current frame number of the named anim, or if no\n        anim is specified, then the anim current playing on the\n        actor. If part not specified return current anim of first part\n        in dictionary.  NOTE: only returns info for an arbitrary LOD\n        \"\"\"\n        lodName, animControlDict = next(iter(self.__animControlDict.items()))\n        if partName is None:\n            partName, animDict = next(iter(animControlDict.items()))\n        else:\n            animDict = animControlDict.get(partName)\n            if animDict is None:\n                # part was not present\n                Actor.notify.warning(\"couldn't find part: %s\" % (partName))\n                return None\n\n        if animName:\n            anim = animDict.get(animName)\n            if not anim:\n                Actor.notify.warning(\"couldn't find anim: %s\" % (animName))\n            elif anim.animControl:\n                return anim.animControl.getFrame()\n        else:\n            # loop through all anims for named part and find if any are playing\n            for animName, anim in animDict.items():\n                if anim.animControl and anim.animControl.isPlaying():\n                    return anim.animControl.getFrame()\n\n        # we must have found none, or gotten an error\n        return None\n\n\n    # arranging\n\n    def getPart(self, partName, lodName=\"lodRoot\"):\n        \"\"\"\n        Find the named part in the optional named lod and return it, or\n        return None if not present\n        \"\"\"\n        partBundleDict = self.__partBundleDict.get(lodName)\n        if not partBundleDict:\n            Actor.notify.warning(\"no lod named: %s\" % (lodName))\n            return None\n        subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n        partDef = partBundleDict.get(subpartDef.truePartName)\n        if partDef is not None:\n            return partDef.partBundleNP\n        return None\n\n    def getPartBundle(self, partName, lodName=\"lodRoot\"):\n        \"\"\"\n        Find the named part in the optional named lod and return its\n        associated PartBundle, or return None if not present\n        \"\"\"\n        partBundleDict = self.__partBundleDict.get(lodName)\n        if not partBundleDict:\n            Actor.notify.warning(\"no lod named: %s\" % (lodName))\n            return None\n        subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n        partDef = partBundleDict.get(subpartDef.truePartName)\n        if partDef is not None:\n            return partDef.getBundle()\n        return None\n\n    def removePart(self, partName, lodName=\"lodRoot\"):\n        \"\"\"\n        Remove the geometry and animations of the named part of the\n        optional named lod if present.\n        NOTE: this will remove child geometry also!\n        \"\"\"\n        # find the corresponding part bundle dict\n        partBundleDict = self.__partBundleDict.get(lodName)\n        if not partBundleDict:\n            Actor.notify.warning(\"no lod named: %s\" % (lodName))\n            return\n\n        # remove the part\n        if partName in partBundleDict:\n            partBundleDict[partName].partBundleNP.removeNode()\n            del partBundleDict[partName]\n\n        # find the corresponding anim control dict\n        if self.mergeLODBundles:\n            lodName = 'common'\n        partDict = self.__animControlDict.get(lodName)\n        if not partDict:\n            Actor.notify.warning(\"no lod named: %s\" % (lodName))\n            return\n\n        # remove the animations\n        if partName in partDict:\n            del partDict[partName]\n\n    def hidePart(self, partName, lodName=\"lodRoot\"):\n        \"\"\"\n        Make the given part of the optionally given lod not render,\n        even though still in the tree.\n        NOTE: this will affect child geometry\n        \"\"\"\n        partBundleDict = self.__partBundleDict.get(lodName)\n        if not partBundleDict:\n            Actor.notify.warning(\"no lod named: %s\" % (lodName))\n            return\n        partDef = partBundleDict.get(partName)\n        if partDef:\n            partDef.partBundleNP.hide()\n        else:\n            Actor.notify.warning(\"no part named %s!\" % (partName))\n\n    def showPart(self, partName, lodName=\"lodRoot\"):\n        \"\"\"\n        Make the given part render while in the tree.\n        NOTE: this will affect child geometry\n        \"\"\"\n        partBundleDict = self.__partBundleDict.get(lodName)\n        if not partBundleDict:\n            Actor.notify.warning(\"no lod named: %s\" % (lodName))\n            return\n        partDef = partBundleDict.get(partName)\n        if partDef:\n            partDef.partBundleNP.show()\n        else:\n            Actor.notify.warning(\"no part named %s!\" % (partName))\n\n    def showAllParts(self, partName, lodName=\"lodRoot\"):\n        \"\"\"\n        Make the given part and all its children render while in the tree.\n        NOTE: this will affect child geometry\n        \"\"\"\n        partBundleDict = self.__partBundleDict.get(lodName)\n        if not partBundleDict:\n            Actor.notify.warning(\"no lod named: %s\" % (lodName))\n            return\n        partDef = partBundleDict.get(partName)\n        if partDef:\n            partDef.partBundleNP.show()\n            partDef.partBundleNP.getChildren().show()\n        else:\n            Actor.notify.warning(\"no part named %s!\" % (partName))\n\n    def exposeJoint(self, node, partName, jointName, lodName=\"lodRoot\",\n                    localTransform = 0):\n        \"\"\"exposeJoint(self, NodePath, string, string, key=\"lodRoot\")\n        Starts the joint animating the indicated node.  As the joint\n        animates, it will transform the node by the corresponding\n        amount.  This will replace whatever matrix is on the node each\n        frame.  The default is to expose the net transform from the root,\n        but if localTransform is true, only the node's local transform\n        from its parent is exposed.\"\"\"\n        partBundleDict = self.__partBundleDict.get(lodName)\n        if not partBundleDict:\n            Actor.notify.warning(\"no lod named: %s\" % (lodName))\n            return None\n\n        subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n\n        partDef = partBundleDict.get(subpartDef.truePartName)\n        if partDef:\n            bundle = partDef.getBundle()\n        else:\n            Actor.notify.warning(\"no part named %s!\" % (partName))\n            return None\n\n        # Get a handle to the joint.\n        joint = bundle.findChild(jointName)\n\n        if node is None:\n            node = partDef.partBundleNP.attachNewNode(jointName)\n\n        if joint:\n            if localTransform:\n                joint.addLocalTransform(node.node())\n            else:\n                joint.addNetTransform(node.node())\n        else:\n            Actor.notify.warning(\"no joint named %s!\" % (jointName))\n\n        return node\n\n    def stopJoint(self, partName, jointName, lodName=\"lodRoot\"):\n        \"\"\"stopJoint(self, string, string, key=\"lodRoot\")\n        Stops the joint from animating external nodes.  If the joint\n        is animating a transform on a node, this will permanently stop\n        it.  However, this does not affect vertex animations.\"\"\"\n        partBundleDict = self.__partBundleDict.get(lodName)\n        if not partBundleDict:\n            Actor.notify.warning(\"no lod named: %s\" % (lodName))\n            return None\n\n        subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n\n        partDef = partBundleDict.get(subpartDef.truePartName)\n        if partDef:\n            bundle = partDef.getBundle()\n        else:\n            Actor.notify.warning(\"no part named %s!\" % (partName))\n            return None\n\n        # Get a handle to the joint.\n        joint = bundle.findChild(jointName)\n\n        if joint:\n            joint.clearNetTransforms()\n            joint.clearLocalTransforms()\n        else:\n            Actor.notify.warning(\"no joint named %s!\" % (jointName))\n\n    def getJoints(self, partName = None, jointName = '*', lodName = None):\n        \"\"\" Returns the list of all joints, from the named part or\n        from all parts, that match the indicated jointName.  The\n        jointName may include pattern characters like \\\\*. \"\"\"\n\n        joints=[]\n        pattern = GlobPattern(jointName)\n\n        if lodName is None and self.mergeLODBundles:\n            # Get the common bundle.\n            partBundleDicts = [self.__commonBundleHandles]\n\n        elif lodName is None:\n            # Get all LOD's.\n            partBundleDicts = self.__partBundleDict.values()\n        else:\n            # Get one LOD.\n            partBundleDict = self.__partBundleDict.get(lodName)\n            if not partBundleDict:\n                Actor.notify.warning(\"couldn't find lod: %s\" % (lodName))\n                return []\n            partBundleDicts = [partBundleDict]\n\n        for partBundleDict in partBundleDicts:\n            parts = []\n            if partName:\n                subpartDef = self.__subpartDict.get(partName, None)\n                if not subpartDef:\n                    # Whole part\n                    subset = None\n                    partDef = partBundleDict.get(partName)\n                else:\n                    # Sub-part\n                    subset = subpartDef.subset\n                    partDef = partBundleDict.get(subpartDef.truePartName)\n                if not partDef:\n                    Actor.notify.warning(\"no part named %s!\" % (partName))\n                    return []\n                parts = [partDef]\n            else:\n                subset = None\n                parts = partBundleDict.values()\n\n            for partData in parts:\n                partBundle = partData.getBundle()\n\n                if not pattern.hasGlobCharacters() and not subset:\n                    # The simple case.\n                    joint = partBundle.findChild(jointName)\n                    if joint:\n                        joints.append(joint)\n                else:\n                    # The more complex case.\n                    isIncluded = True\n                    if subset:\n                        isIncluded = subset.isIncludeEmpty()\n                    self.__getPartJoints(joints, pattern, partBundle, subset, isIncluded)\n\n        return joints\n\n    def getOverlappingJoints(self, partNameA, partNameB, jointName = '*', lodName = None):\n        \"\"\" Returns the set of joints, matching jointName, that are\n        shared between partNameA and partNameB. \"\"\"\n        jointsA = set(self.getJoints(partName = partNameA, jointName = jointName, lodName = lodName))\n        jointsB = set(self.getJoints(partName = partNameB, jointName = jointName, lodName = lodName))\n\n        return jointsA & jointsB\n\n    def __getPartJoints(self, joints, pattern, part, subset, isIncluded):\n        \"\"\" Recursively walks the joint hierarchy to look for matching\n        joint names, implementing getJoints(). \"\"\"\n\n        name = part.name\n        if subset:\n            # Constrain the traversal just to the named subset.\n            if subset.matchesInclude(name):\n                isIncluded = True\n            elif subset.matchesExclude(name):\n                isIncluded = False\n\n        if isIncluded and pattern.matches(name) and isinstance(part, MovingPartBase):\n            joints.append(part)\n\n        for child in part.children:\n            self.__getPartJoints(joints, pattern, child, subset, isIncluded)\n\n    def getJointTransform(self, partName, jointName, lodName='lodRoot'):\n        partBundleDict=self.__partBundleDict.get(lodName)\n        if not partBundleDict:\n            Actor.notify.warning(\"no lod named: %s\" % (lodName))\n            return None\n\n        subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n        partDef = partBundleDict.get(subpartDef.truePartName)\n        if partDef:\n            bundle = partDef.getBundle()\n        else:\n            Actor.notify.warning(\"no part named %s!\" % (partName))\n            return None\n\n        joint = bundle.findChild(jointName)\n        if joint is None:\n            Actor.notify.warning(\"no joint named %s!\" % (jointName))\n            return None\n        return joint.getDefaultValue()\n\n    def getJointTransformState(self, partName, jointName, lodName='lodRoot'):\n        partBundleDict=self.__partBundleDict.get(lodName)\n        if not partBundleDict:\n            Actor.notify.warning(\"no lod named: %s\" % (lodName))\n            return None\n\n        subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n        partDef = partBundleDict.get(subpartDef.truePartName)\n        if partDef:\n            bundle = partDef.getBundle()\n        else:\n            Actor.notify.warning(\"no part named %s!\" % (partName))\n            return None\n\n        joint = bundle.findChild(jointName)\n        if joint is None:\n            Actor.notify.warning(\"no joint named %s!\" % (jointName))\n            return None\n        return joint.getTransformState()\n\n    def controlJoint(self, node, partName, jointName, lodName=\"lodRoot\"):\n        \"\"\"The converse of exposeJoint: this associates the joint with\n        the indicated node, so that the joint transform will be copied\n        from the node to the joint each frame.  This can be used for\n        programmer animation of a particular joint at runtime.\n\n        The parameter node should be the NodePath for the node whose\n        transform will animate the joint.  If node is None, a new node\n        will automatically be created and loaded with the joint's\n        initial transform.  In either case, the node used will be\n        returned.\n\n        It used to be necessary to call this before any animations\n        have been loaded and bound, but that is no longer so.\n        \"\"\"\n        subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n        trueName = subpartDef.truePartName\n        anyGood = False\n        for bundleDict in self.__partBundleDict.values():\n            bundle = bundleDict[trueName].getBundle()\n            if node is None:\n                node = self.attachNewNode(ModelNode(jointName))\n                joint = bundle.findChild(jointName)\n                if joint and isinstance(joint, MovingPartMatrix):\n                    node.setMat(joint.getDefaultValue())\n\n            if bundle.controlJoint(jointName, node.node()):\n                anyGood = True\n\n        if not anyGood:\n            self.notify.warning(\"Cannot control joint %s\" % (jointName))\n\n        return node\n\n    def freezeJoint(self, partName, jointName, transform = None,\n                    pos=Vec3(0,0,0), hpr=Vec3(0,0,0), scale=Vec3(1,1,1)):\n        \"\"\"Similar to controlJoint, but the transform assigned is\n        static, and may not be animated at runtime (without another\n        subsequent call to freezeJoint).  This is slightly more\n        optimal than controlJoint() for cases in which the transform\n        is not intended to be animated during the lifetime of the\n        Actor. \"\"\"\n        if transform is None:\n            transform = TransformState.makePosHprScale(pos, hpr, scale)\n\n        subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n        trueName = subpartDef.truePartName\n        anyGood = False\n        for bundleDict in self.__partBundleDict.values():\n            if bundleDict[trueName].getBundle().freezeJoint(jointName, transform):\n                anyGood = True\n\n        if not anyGood:\n            self.notify.warning(\"Cannot freeze joint %s\" % (jointName))\n\n    def releaseJoint(self, partName, jointName):\n        \"\"\"Undoes a previous call to controlJoint() or freezeJoint()\n        and restores the named joint to its normal animation. \"\"\"\n\n        subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n        trueName = subpartDef.truePartName\n        for bundleDict in self.__partBundleDict.values():\n            bundleDict[trueName].getBundle().releaseJoint(jointName)\n\n    def instance(self, path, partName, jointName, lodName=\"lodRoot\"):\n        \"\"\"instance(self, NodePath, string, string, key=\"lodRoot\")\n        Instance a nodePath to an actor part at a joint called jointName\"\"\"\n        partBundleDict = self.__partBundleDict.get(lodName)\n        if partBundleDict:\n            subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n            partDef = partBundleDict.get(subpartDef.truePartName)\n            if partDef:\n                joint = partDef.partBundleNP.find(\"**/\" + jointName)\n                if joint.isEmpty():\n                    Actor.notify.warning(\"%s not found!\" % (jointName))\n                else:\n                    return path.instanceTo(joint)\n            else:\n                Actor.notify.warning(\"no part named %s!\" % (partName))\n        else:\n            Actor.notify.warning(\"no lod named %s!\" % (lodName))\n\n    def attach(self, partName, anotherPartName, jointName, lodName=\"lodRoot\"):\n        \"\"\"attach(self, string, string, string, key=\"lodRoot\")\n        Attach one actor part to another at a joint called jointName\"\"\"\n        partBundleDict = self.__partBundleDict.get(lodName)\n        if partBundleDict:\n            subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n            partDef = partBundleDict.get(subpartDef.truePartName)\n            if partDef:\n                anotherPartDef = partBundleDict.get(anotherPartName)\n                if anotherPartDef:\n                    joint = anotherPartDef.partBundleNP.find(\"**/\" + jointName)\n                    if joint.isEmpty():\n                        Actor.notify.warning(\"%s not found!\" % (jointName))\n                    else:\n                        partDef.partBundleNP.reparentTo(joint)\n                else:\n                    Actor.notify.warning(\"no part named %s!\" % (anotherPartName))\n            else:\n                Actor.notify.warning(\"no part named %s!\" % (partName))\n        else:\n            Actor.notify.warning(\"no lod named %s!\" % (lodName))\n\n\n    def drawInFront(self, frontPartName, backPartName, mode,\n                    root=None, lodName=None):\n        \"\"\"drawInFront(self, string, int, string=None, key=None)\n\n        Arrange geometry so the frontPart(s) are drawn in front of\n        backPart.\n\n        If mode == -1, the geometry is simply arranged to be drawn in\n        the correct order, assuming it is already under a\n        direct-render scene graph (like the DirectGui system).  That\n        is, frontPart is reparented to backPart, and backPart is\n        reordered to appear first among its siblings.\n\n        If mode == -2, the geometry is arranged to be drawn in the\n        correct order, and depth test/write is turned off for\n        frontPart.\n\n        If mode == -3, frontPart is drawn as a decal onto backPart.\n        This assumes that frontPart is mostly coplanar with and does\n        not extend beyond backPart, and that backPart is mostly flat\n        (not self-occluding).\n\n        If mode > 0, the frontPart geometry is placed in the 'fixed'\n        bin, with the indicated drawing order.  This will cause it to\n        be drawn after almost all other geometry.  In this case, the\n        backPartName is actually unused.\n\n        Takes an optional argument root as the start of the search for the\n        given parts. Also takes optional lod name to refine search for the\n        named parts. If root and lod are defined, we search for the given\n        root under the given lod.\n        \"\"\"\n        # check to see if we are working within an lod\n        if lodName is not None:\n            # find the named lod node\n            lodRoot = self.__LODNode.find(str(lodName))\n            if root is None:\n                # no need to look further\n                root = lodRoot\n            else:\n                # look for root under lod\n                root = lodRoot.find(\"**/\" + root)\n        else:\n            # start search from self if no root and no lod given\n            if root is None:\n                root = self\n\n        frontParts = root.findAllMatches(\"**/\" + frontPartName)\n\n        if mode > 0:\n            # Use the 'fixed' bin instead of reordering the scene\n            # graph.\n            for part in frontParts:\n                part.setBin('fixed', mode)\n            return\n\n        if mode == -2:\n            # Turn off depth test/write on the frontParts.\n            for part in frontParts:\n                part.setDepthWrite(0)\n                part.setDepthTest(0)\n\n        # Find the back part.\n        backPart = root.find(\"**/\" + backPartName)\n        if backPart.isEmpty():\n            Actor.notify.warning(\"no part named %s!\" % (backPartName))\n            return\n\n        if mode == -3:\n            # Draw as a decal.\n            backPart.node().setEffect(DecalEffect.make())\n        else:\n            # Reorder the backPart to be the first of its siblings.\n            backPart.reparentTo(backPart.getParent(), -1)\n\n        #reparent all the front parts to the back part\n        frontParts.reparentTo(backPart)\n\n\n    def fixBounds(self, partName = None):\n        if partName is None:\n            #iterate through everything\n            for lodData in self.__partBundleDict.values():\n                for partData in lodData.values():\n                    char = partData.partBundleNP\n                    char.node().update()\n                    geomNodes = char.findAllMatches(\"**/+GeomNode\")\n                    for thisGeomNode in geomNodes:\n                        for thisGeom in thisGeomNode.node().getGeoms():\n                            thisGeom.markBoundsStale()\n                        thisGeomNode.node().markInternalBoundsStale()\n        else:\n            #iterate through for a specific part\n            for lodData in self.__partBundleDict.values():\n                partData = lodData.get(partName)\n                if partData:\n                    char = partData.partBundleNP\n                    char.node().update()\n                    geomNodes = char.findAllMatches(\"**/+GeomNode\")\n                    for thisGeomNode in geomNodes:\n                        for thisGeom in thisGeomNode.node().getGeoms():\n                            thisGeom.markBoundsStale()\n                        thisGeomNode.node().markInternalBoundsStale()\n\n    def fixBounds_old(self, part=None):\n        \"\"\"fixBounds(self, nodePath=None)\n        Force recomputation of bounding spheres for all geoms\n        in a given part. If no part specified, fix all geoms\n        in this actor\n        \"\"\"\n        # if no part name specified fix all parts\n        if part is None:\n            part = self\n\n        # update all characters first\n        charNodes = part.findAllMatches(\"**/+Character\")\n        for charNode in charNodes:\n            charNode.node().update()\n\n        # for each geomNode, iterate through all geoms and force update\n        # of bounding spheres by marking current bounds as stale\n        geomNodes = part.findAllMatches(\"**/+GeomNode\")\n        for nodeNum, thisGeomNode in enumerate(geomNodes):\n            for geomNum, thisGeom in enumerate(thisGeomNode.node().getGeoms()):\n                thisGeom.markBoundsStale()\n                assert Actor.notify.debug(\"fixing bounds for node %s, geom %s\" % \\\n                                          (nodeNum, geomNum))\n            thisGeomNode.node().markInternalBoundsStale()\n\n    def showAllBounds(self):\n        \"\"\"\n        Show the bounds of all actor geoms\n        \"\"\"\n        geomNodes = self.__geomNode.findAllMatches(\"**/+GeomNode\")\n\n        for node in geomNodes:\n            node.showBounds()\n\n    def hideAllBounds(self):\n        \"\"\"\n        Hide the bounds of all actor geoms\n        \"\"\"\n        geomNodes = self.__geomNode.findAllMatches(\"**/+GeomNode\")\n\n        for node in geomNodes:\n            node.hideBounds()\n\n\n    # actions\n    def animPanel(self):\n        # Don't use a regular import, to prevent ModuleFinder from picking\n        # it up as a dependency when building a .p3d package.\n        import importlib\n        AnimPanel = importlib.import_module('direct.tkpanels.AnimPanel')\n        return AnimPanel.AnimPanel(self)\n\n    def stop(self, animName=None, partName=None):\n        \"\"\"stop(self, string=None, string=None)\n        Stop named animation on the given part of the actor.\n        If no name specified then stop all animations on the actor.\n        NOTE: stops all LODs\"\"\"\n        for control in self.getAnimControls(animName, partName):\n            control.stop()\n\n    def play(self, animName, partName=None, fromFrame=None, toFrame=None):\n        \"\"\"play(self, string, string=None)\n        Play the given animation on the given part of the actor.\n        If no part is specified, try to play on all parts. NOTE:\n        plays over ALL LODs\"\"\"\n        if fromFrame is None:\n            for control in self.getAnimControls(animName, partName):\n                control.play()\n        else:\n            for control in self.getAnimControls(animName, partName):\n                if toFrame is None:\n                    control.play(fromFrame, control.getNumFrames() - 1)\n                else:\n                    control.play(fromFrame, toFrame)\n\n    def loop(self, animName, restart=1, partName=None,\n             fromFrame=None, toFrame=None):\n        \"\"\"loop(self, string, int=1, string=None)\n        Loop the given animation on the given part of the actor,\n        restarting at zero frame if requested. If no part name\n        is given then try to loop on all parts. NOTE: loops on\n        all LOD's\n        \"\"\"\n\n        if fromFrame is None:\n            for control in self.getAnimControls(animName, partName):\n                control.loop(restart)\n        else:\n            for control in self.getAnimControls(animName, partName):\n                if toFrame is None:\n                    control.loop(restart, fromFrame, control.getNumFrames() - 1)\n                else:\n                    control.loop(restart, fromFrame, toFrame)\n\n    def pingpong(self, animName, restart=1, partName=None,\n                 fromFrame=None, toFrame=None):\n        \"\"\"pingpong(self, string, int=1, string=None)\n        Loop the given animation on the given part of the actor,\n        restarting at zero frame if requested. If no part name\n        is given then try to loop on all parts. NOTE: loops on\n        all LOD's\"\"\"\n        if fromFrame is None:\n            fromFrame = 0\n\n        for control in self.getAnimControls(animName, partName):\n            if toFrame is None:\n                control.pingpong(restart, fromFrame, control.getNumFrames() - 1)\n            else:\n                control.pingpong(restart, fromFrame, toFrame)\n\n    def pose(self, animName, frame, partName=None, lodName=None):\n        \"\"\"pose(self, string, int, string=None)\n        Pose the actor in position found at given frame in the specified\n        animation for the specified part. If no part is specified attempt\n        to apply pose to all parts.\"\"\"\n        for control in self.getAnimControls(animName, partName, lodName):\n            control.pose(frame)\n\n    def setBlend(self, animBlend = None, frameBlend = None,\n                 blendType = None, partName = None):\n        \"\"\"\n        Changes the way the Actor handles blending of multiple\n        different animations, and/or interpolation between consecutive\n        frames.\n\n        The animBlend and frameBlend parameters are boolean flags.\n        You may set either or both to True or False.  If you do not\n        specify them, they do not change from the previous value.\n\n        When animBlend is True, multiple different animations may\n        simultaneously be playing on the Actor.  This means you may\n        call play(), loop(), or pose() on multiple animations and have\n        all of them contribute to the final pose each frame.\n\n        In this mode (that is, when animBlend is True), starting a\n        particular animation with play(), loop(), or pose() does not\n        implicitly make the animation visible; you must also call\n        setControlEffect() for each animation you wish to use to\n        indicate how much each animation contributes to the final\n        pose.\n\n        The frameBlend flag is unrelated to playing multiple\n        animations.  It controls whether the Actor smoothly\n        interpolates between consecutive frames of its animation (when\n        the flag is True) or holds each frame until the next one is\n        ready (when the flag is False).  The default value of\n        frameBlend is controlled by the interpolate-frames Config.prc\n        variable.\n\n        In either case, you may also specify blendType, which controls\n        the precise algorithm used to blend two or more different\n        matrix values into a final result.  Different skeleton\n        hierarchies may benefit from different algorithms.  The\n        default blendType is controlled by the anim-blend-type\n        Config.prc variable.\n        \"\"\"\n        for bundle in self.getPartBundles(partName = partName):\n            if blendType is not None:\n                bundle.setBlendType(blendType)\n            if animBlend is not None:\n                bundle.setAnimBlendFlag(animBlend)\n            if frameBlend is not None:\n                bundle.setFrameBlendFlag(frameBlend)\n\n    def enableBlend(self, blendType = PartBundle.BTNormalizedLinear, partName = None):\n        \"\"\"\n        Enables blending of multiple animations simultaneously.\n        After this is called, you may call play(), loop(), or pose()\n        on multiple animations and have all of them contribute to the\n        final pose each frame.\n\n        With blending in effect, starting a particular animation with\n        play(), loop(), or pose() does not implicitly make the\n        animation visible; you must also call setControlEffect() for\n        each animation you wish to use to indicate how much each\n        animation contributes to the final pose.\n\n        This method is deprecated.  You should use setBlend() instead.\n        \"\"\"\n        if __debug__:\n            warnings.warn(\"This method is deprecated.  You should use setBlend() instead.\", DeprecationWarning, stacklevel=2)\n        self.setBlend(animBlend = True, blendType = blendType, partName = partName)\n\n    def disableBlend(self, partName = None):\n        \"\"\"\n        Restores normal one-animation-at-a-time operation after a\n        previous call to enableBlend().\n\n        This method is deprecated.  You should use setBlend() instead.\n        \"\"\"\n        if __debug__:\n            warnings.warn(\"This method is deprecated.  You should use setBlend() instead.\", DeprecationWarning, stacklevel=2)\n        self.setBlend(animBlend = False, partName = partName)\n\n    def setControlEffect(self, animName, effect,\n                         partName = None, lodName = None):\n        \"\"\"\n        Sets the amount by which the named animation contributes to\n        the overall pose.  This controls blending of multiple\n        animations; it only makes sense to call this after a previous\n        call to setBlend(animBlend = True).\n        \"\"\"\n        for control in self.getAnimControls(animName, partName, lodName):\n            control.getPart().setControlEffect(control, effect)\n\n    def getAnimFilename(self, animName, partName='modelRoot'):\n        \"\"\"\n        getAnimFilename(self, animName)\n        return the animFilename given the animName\n        \"\"\"\n        if self.mergeLODBundles:\n            lodName = 'common'\n        elif self.switches:\n            lodName = str(next(iter(self.switches)))\n        else:\n            lodName = 'lodRoot'\n\n        partDict = self.__animControlDict.get(lodName)\n        if partDict is None:\n            return None\n\n        animDict = partDict.get(partName)\n        if animDict is None:\n            return None\n\n        anim = animDict.get(animName)\n        if anim is None:\n            return None\n\n        return anim.filename\n\n    def getAnimControl(self, animName, partName=None, lodName=None,\n                       allowAsyncBind = True):\n        \"\"\"\n        getAnimControl(self, string, string, string=\"lodRoot\")\n        Search the animControl dictionary indicated by lodName for\n        a given anim and part. If none specified, try the first part and lod.\n        Return the animControl if present, or None otherwise.\n        \"\"\"\n\n        if not partName:\n            partName = 'modelRoot'\n\n        if self.mergeLODBundles:\n            lodName = 'common'\n        elif not lodName:\n            if self.switches:\n                lodName = str(next(iter(self.switches)))\n            else:\n                lodName = 'lodRoot'\n\n        partDict = self.__animControlDict.get(lodName)\n        # if this assertion fails, named lod was not present\n        assert partDict is not None\n\n        animDict = partDict.get(partName)\n        if animDict is None:\n            # part was not present\n            Actor.notify.warning(\"couldn't find part: %s\" % (partName))\n        else:\n            anim = animDict.get(animName)\n            if anim is None:\n                # anim was not present\n                assert Actor.notify.debug(\"couldn't find anim: %s\" % (animName))\n            else:\n                # bind the animation first if we need to\n                if not anim.animControl:\n                    self.__bindAnimToPart(animName, partName, lodName,\n                                          allowAsyncBind = allowAsyncBind)\n                elif not allowAsyncBind:\n                    anim.animControl.waitPending()\n                return anim.animControl\n\n        return None\n\n    def getAnimControls(self, animName=None, partName=None, lodName=None,\n                        allowAsyncBind = True, onlyPlaying = True):\n        \"\"\"getAnimControls(self, string, string=None, string=None)\n\n        Returns a list of the AnimControls that represent the given\n        animation for the given part and the given lod.\n\n        If animName is None or omitted, the currently-playing\n        animation (or all currently-playing animations) is returned.\n        If animName is True, all animations are returned.  If animName\n        is a single string name, that particular animation is\n        returned.  If animName is a list of string names, all of the\n        names animations are returned.\n\n        If partName is None or omitted, all parts are returned (or\n        possibly the one overall Actor part, according to the\n        subpartsComplete flag).\n\n        If lodName is None or omitted, all LOD's are returned.\n        \"\"\"\n\n        if partName is None and self.__subpartsComplete:\n            # If we have the __subpartsComplete flag, and no partName\n            # is specified, it really means to play the animation on\n            # all subparts, not on the overall Actor.\n            partName = list(self.__subpartDict.keys())\n\n        controls = []\n        # build list of lodNames and corresponding animControlDicts\n        # requested.\n        if lodName is None or self.mergeLODBundles:\n            # Get all LOD's\n            animControlDictItems = self.__animControlDict.items()\n        else:\n            partDict = self.__animControlDict.get(lodName)\n            if partDict is None:\n                Actor.notify.warning(\"couldn't find lod: %s\" % (lodName))\n                animControlDictItems = []\n            else:\n                animControlDictItems = [(lodName, partDict)]\n\n        for lodName, partDict in animControlDictItems:\n            # Now, build the list of partNames and the corresponding\n            # animDicts.\n            if partName is None:\n                # Get all main parts, but not sub-parts.\n                animDictItems = []\n                for thisPart, animDict in partDict.items():\n                    if thisPart not in self.__subpartDict:\n                        animDictItems.append((thisPart, animDict))\n\n            else:\n                # Get exactly the named part or parts.\n                if isinstance(partName, str):\n                    partNameList = [partName]\n                else:\n                    partNameList = partName\n\n                animDictItems = []\n\n                for pName in partNameList:\n                    animDict = partDict.get(pName)\n                    if animDict is None:\n                        # Maybe it's a subpart that hasn't been bound yet.\n                        subpartDef = self.__subpartDict.get(pName)\n                        if subpartDef:\n                            animDict = {}\n                            partDict[pName] = animDict\n\n                    if animDict is None:\n                        # part was not present\n                        Actor.notify.warning(\"couldn't find part: %s\" % (pName))\n                    else:\n                        animDictItems.append((pName, animDict))\n\n            if animName is None:\n                # get all playing animations\n                for thisPart, animDict in animDictItems:\n                    for anim in animDict.values():\n                        if anim.animControl and (not onlyPlaying or anim.animControl.isPlaying()):\n                            controls.append(anim.animControl)\n            else:\n                # get the named animation(s) only.\n                if isinstance(animName, str):\n                    # A single animName\n                    animNameList = [animName]\n                else:\n                    # A list of animNames, or True to indicate all anims.\n                    animNameList = animName\n                for thisPart, animDict in animDictItems:\n                    names = animNameList\n                    if animNameList is True:\n                        names = animDict.keys()\n                    for animName in names:\n                        anim = animDict.get(animName)\n                        if anim is None and partName is not None:\n                            for pName in partNameList:\n                                # Maybe it's a subpart that hasn't been bound yet.\n                                subpartDef = self.__subpartDict.get(pName)\n                                if subpartDef:\n                                    truePartName = subpartDef.truePartName\n                                    anim = partDict[truePartName].get(animName)\n                                    if anim:\n                                        anim = anim.makeCopy()\n                                        animDict[animName] = anim\n\n                        if anim is None:\n                            # anim was not present\n                            assert Actor.notify.debug(\"couldn't find anim: %s\" % (animName))\n                        else:\n                            # bind the animation first if we need to\n                            animControl = anim.animControl\n                            if animControl is None:\n                                animControl = self.__bindAnimToPart(\n                                    animName, thisPart, lodName,\n                                    allowAsyncBind = allowAsyncBind)\n                            elif not allowAsyncBind:\n                                # Force the animation to load if it's\n                                # not already loaded.\n                                animControl.waitPending()\n\n                            if animControl:\n                                controls.append(animControl)\n\n        return controls\n\n    def loadModel(self, modelPath, partName=\"modelRoot\", lodName=\"lodRoot\",\n                  copy = True, okMissing = None, autoBindAnims = True):\n        \"\"\"Actor model loader. Takes a model name (ie file path), a part\n        name(defaults to \"modelRoot\") and an lod name(defaults to \"lodRoot\").\n        \"\"\"\n        assert partName not in self.__subpartDict\n\n        assert Actor.notify.debug(\"in loadModel: %s, part: %s, lod: %s, copy: %s\" % \\\n                                  (modelPath, partName, lodName, copy))\n\n        if isinstance(modelPath, NodePath):\n            # If we got a NodePath instead of a string, use *that* as\n            # the model directly.\n            if copy:\n                model = modelPath.copyTo(NodePath())\n            else:\n                model = modelPath\n        else:\n            # otherwise, we got the name of the model to load.\n            loaderOptions = self.modelLoaderOptions\n            if not copy:\n                # If copy = 0, then we should always hit the disk.\n                loaderOptions = LoaderOptions(loaderOptions)\n                loaderOptions.setFlags(loaderOptions.getFlags() & ~LoaderOptions.LFNoRamCache)\n\n            if okMissing is not None:\n                if okMissing:\n                    loaderOptions.setFlags(loaderOptions.getFlags() & ~LoaderOptions.LFReportErrors)\n                else:\n                    loaderOptions.setFlags(loaderOptions.getFlags() | LoaderOptions.LFReportErrors)\n\n            # Ensure that custom Python loader hooks are initialized.\n            Loader._loadPythonFileTypes()\n\n            # Pass loaderOptions to specify that we want to\n            # get the skeleton model.  This only matters to model\n            # files (like .mb) for which we can choose to extract\n            # either the skeleton or animation, or neither.\n            model = self.loader.loadSync(Filename(modelPath), loaderOptions)\n            if model is not None:\n                model = NodePath(model)\n\n        if model is None:\n            raise IOError(\"Could not load Actor model %s\" % (modelPath))\n\n        if model.node().isOfType(Character.getClassType()):\n            bundleNP = model\n        else:\n            bundleNP = model.find(\"**/+Character\")\n\n        if bundleNP.isEmpty():\n            Actor.notify.warning(\"%s is not a character!\" % (modelPath))\n            model.reparentTo(self.__geomNode)\n        else:\n            # Maybe the model file also included some animations.  If\n            # so, try to bind them immediately and put them into the\n            # animControlDict.\n            if autoBindAnims:\n                acc = AnimControlCollection()\n                autoBind(model.node(), acc, ~0)\n                numAnims = acc.getNumAnims()\n            else:\n                numAnims = 0\n\n            # Now extract out the Character and integrate it with\n            # the Actor.\n\n            if lodName != \"lodRoot\":\n                # parent to appropriate node under LOD switch\n                bundleNP.reparentTo(self.__LODNode.find(str(lodName)))\n            else:\n                bundleNP.reparentTo(self.__geomNode)\n            self.__prepareBundle(bundleNP, model.node(), partName, lodName)\n\n            # we rename this node to make Actor copying easier\n            bundleNP.node().setName(\"%s%s\"%(Actor.partPrefix,partName))\n\n            if numAnims != 0:\n                # If the model had some animations, store them in the\n                # dict so they can be played.\n                Actor.notify.info(\"model contains %s animations.\" % (numAnims))\n\n                # make sure this lod is in anim control dict\n                if self.mergeLODBundles:\n                    lodName = 'common'\n                self.__animControlDict.setdefault(lodName, {})\n                self.__animControlDict[lodName].setdefault(partName, {})\n\n                for i in range(numAnims):\n                    animControl = acc.getAnim(i)\n                    animName = acc.getAnimName(i)\n\n                    animDef = Actor.AnimDef()\n                    animDef.animBundle = animControl.getAnim()\n                    animDef.animControl = animControl\n                    self.__animControlDict[lodName][partName][animName] = animDef\n\n    def __prepareBundle(self, bundleNP, partModel,\n                        partName=\"modelRoot\", lodName=\"lodRoot\"):\n        assert partName not in self.__subpartDict\n\n        # Rename the node at the top of the hierarchy, if we\n        # haven't already, to make it easier to identify this\n        # actor in the scene graph.\n        if not self.gotName:\n            self.node().setName(bundleNP.node().getName())\n            self.gotName = 1\n\n        bundleDict = self.__partBundleDict.get(lodName, None)\n        if bundleDict is None:\n            # make a dictionary to store these parts in\n            bundleDict = {}\n            self.__partBundleDict[lodName] = bundleDict\n            self.__updateSortedLODNames()\n\n        node = bundleNP.node()\n        # A model loaded from disk will always have just one bundle.\n        assert node.getNumBundles() == 1\n        bundleHandle = node.getBundleHandle(0)\n\n        if self.mergeLODBundles:\n            loadedBundleHandle = self.__commonBundleHandles.get(partName, None)\n            if loadedBundleHandle:\n                # We've already got a bundle for this part; merge it.\n                node.mergeBundles(bundleHandle, loadedBundleHandle)\n                bundleHandle = loadedBundleHandle\n            else:\n                # We haven't already got a bundle for this part; store it.\n                self.__commonBundleHandles[partName] = bundleHandle\n\n        bundleDict[partName] = Actor.PartDef(bundleNP, bundleHandle, partModel)\n\n\n    def makeSubpart(self, partName, includeJoints, excludeJoints = (),\n                    parent=\"modelRoot\", overlapping = False):\n\n        \"\"\"Defines a new \"part\" of the Actor that corresponds to the\n        same geometry as the named parent part, but animates only a\n        certain subset of the joints.  This can be used for\n        partial-body animations, for instance to animate a hand waving\n        while the rest of the body continues to play its walking\n        animation.\n\n        includeJoints is a list of joint names that are to be animated\n        by the subpart.  Each name can include globbing characters\n        like '?' or '*', which will match one or any number of\n        characters, respectively.  Including a joint by naming it in\n        includeJoints implicitly includes all of the descendents of\n        that joint as well, except for excludeJoints, below.\n\n        excludeJoints is a list of joint names that are *not* to be\n        animated by the subpart.  As in includeJoints, each name can\n        include globbing characters.  If a joint is named by\n        excludeJoints, it will not be included (and neither will any\n        of its descendents), even if a parent joint was named by\n        includeJoints.\n\n        if overlapping is False, an error is raised (in the dev build)\n        if this subpart shares joints with any other subparts.  If\n        overlapping is True, no such error is raised.\n\n        parent is the actual partName that this subpart is based\n        on.\"\"\"\n\n        assert partName not in self.__subpartDict\n\n        subpartDef = self.__subpartDict.get(parent, Actor.SubpartDef(''))\n\n        subset = PartSubset(subpartDef.subset)\n        for name in includeJoints:\n            subset.addIncludeJoint(GlobPattern(name))\n        for name in excludeJoints:\n            subset.addExcludeJoint(GlobPattern(name))\n\n        self.__subpartDict[partName] = Actor.SubpartDef(parent, subset)\n\n        if __dev__ and not overlapping and self.validateSubparts.getValue():\n            # Without the overlapping flag True, we're not allowed to\n            # define overlapping sub-parts.  Verify that we haven't.\n            for otherPartName, otherPartDef in self.__subpartDict.items():\n                if otherPartName != partName and otherPartDef.truePartName == parent:\n                    joints = self.getOverlappingJoints(partName, otherPartName)\n                    if joints:\n                        raise Exception('Overlapping joints: %s and %s' % (partName, otherPartName))\n\n    def setSubpartsComplete(self, flag):\n\n        \"\"\"Sets the subpartsComplete flag.  This affects the behavior\n        of play(), loop(), stop(), etc., when no explicit parts are\n        specified.\n\n        When this flag is False (the default), play() with no parts\n        means to play the animation on the overall Actor, which is a\n        separate part that overlaps each of the subparts.  If you then\n        play a different animation on a subpart, it may stop the\n        overall animation (in non-blend mode) or blend with it (in\n        blend mode).\n\n        When this flag is True, play() with no parts means to play the\n        animation on each of the subparts--instead of on the overall\n        Actor.  In this case, you may then play a different animation\n        on a subpart, which replaces only that subpart's animation.\n\n        It makes sense to set this True when the union of all of your\n        subparts completely defines the entire Actor.\n        \"\"\"\n\n        self.__subpartsComplete = flag\n\n        if __dev__ and self.__subpartsComplete and self.validateSubparts.getValue():\n            # If we've specified any parts at all so far, make sure we've\n            # specified all of them.\n            if self.__subpartDict:\n                self.verifySubpartsComplete()\n\n\n    def getSubpartsComplete(self):\n        \"\"\"See setSubpartsComplete().\"\"\"\n\n        return self.__subpartsComplete\n\n    def verifySubpartsComplete(self, partName = None, lodName = None):\n        \"\"\" Ensures that each joint is defined by at least one\n        subPart.  Prints a warning if this is not the case. \"\"\"\n\n        if partName:\n            assert partName not in self.__subpartDict\n            partNames = [partName]\n        else:\n            if lodName:\n                partNames = self.__partBundleDict[lodName].keys()\n            else:\n                partNames = next(iter(self.__partBundleDict.values())).keys()\n\n        for partName in partNames:\n            subJoints = set()\n            for subPartName, subPartDef in self.__subpartDict.items():\n                if subPartName != partName and subPartDef.truePartName == partName:\n                    subJoints |= set(self.getJoints(partName = subPartName, lodName = lodName))\n\n            allJoints = set(self.getJoints(partName = partName, lodName = lodName))\n            diff = allJoints.difference(subJoints)\n            if diff:\n                self.notify.warning('Uncovered joints: %s' % (list(diff)))\n\n    def loadAnims(self, anims, partName=\"modelRoot\", lodName=\"lodRoot\"):\n        \"\"\"loadAnims(self, string:string{}, string='modelRoot',\n        string='lodRoot')\n        Actor anim loader. Takes an optional partName (defaults to\n        'modelRoot' for non-multipart actors) and lodName (defaults\n        to 'lodRoot' for non-LOD actors) and dict of corresponding\n        anims in the form animName:animPath{}\n        \"\"\"\n        reload = True\n        if self.mergeLODBundles:\n            lodNames = ['common']\n        elif lodName == 'all':\n            reload = False\n            lodNames = list(map(str, sorted(self.switches.keys())))\n        else:\n            lodNames = [lodName]\n\n        assert Actor.notify.debug(\"in loadAnims: %s, part: %s, lod: %s\" %\n                                  (anims, partName, lodNames[0]))\n\n        firstLoad = True\n        if not reload:\n            if lodNames[0] in self.__animControlDict and \\\n               partName in self.__animControlDict[lodNames[0]]:\n                firstLoad = False\n\n        for lName in lodNames:\n            if firstLoad:\n                self.__animControlDict.setdefault(lName, {})\n                self.__animControlDict[lName].setdefault(partName, {})\n\n        for animName, filename in anims.items():\n            # make sure this lod is in anim control dict\n            for lName in lodNames:\n                if firstLoad:\n                    self.__animControlDict[lName][partName][animName] = Actor.AnimDef()\n\n                if isinstance(filename, NodePath):\n                    # We were given a pre-load anim bundle, not a filename.\n                    assert not filename.isEmpty()\n                    if filename.node().isOfType(AnimBundleNode.getClassType()):\n                        animBundleNP = filename\n                    else:\n                        animBundleNP = filename.find('**/+AnimBundleNode')\n                    assert not animBundleNP.isEmpty()\n                    self.__animControlDict[lName][partName][animName].animBundle = animBundleNP.node().getBundle()\n\n                else:\n                    # We were given a filename that must be loaded.\n                    # Store the filename only; we will load and bind\n                    # it (and produce an AnimControl) when it is\n                    # played.\n                    self.__animControlDict[lName][partName][animName].filename = filename\n\n    def initAnimsOnAllLODs(self,partNames):\n        if self.mergeLODBundles:\n            lodNames = ['common']\n        else:\n            lodNames = self.__partBundleDict.keys()\n\n        for lod in lodNames:\n            for part in partNames:\n                self.__animControlDict.setdefault(lod,{})\n                self.__animControlDict[lod].setdefault(part, {})\n\n        #for animName, filename in anims.items():\n        #    # make sure this lod is in anim control dict\n        #    for lod in self.__partBundleDict.keys():\n        #        # store the file path only; we will bind it (and produce\n        #        # an AnimControl) when it is played\n        #\n        #        self.__animControlDict[lod][partName][animName] = Actor.AnimDef(filename)\n\n    def loadAnimsOnAllLODs(self, anims,partName=\"modelRoot\"):\n        \"\"\"loadAnims(self, string:string{}, string='modelRoot',\n        string='lodRoot')\n        Actor anim loader. Takes an optional partName (defaults to\n        'modelRoot' for non-multipart actors) and lodName (defaults\n        to 'lodRoot' for non-LOD actors) and dict of corresponding\n        anims in the form animName:animPath{}\n        \"\"\"\n        if self.mergeLODBundles:\n            lodNames = ['common']\n        else:\n            lodNames = self.__partBundleDict.keys()\n\n        for animName, filename in anims.items():\n            # make sure this lod is in anim control dict\n            for lod in lodNames:\n                # store the file path only; we will bind it (and produce\n                # an AnimControl) when it is played\n\n                self.__animControlDict[lod][partName][animName]= Actor.AnimDef(filename)\n\n    def postFlatten(self):\n        \"\"\"Call this after performing an aggressive flatten operation,\n        such as flattenStrong(), that involves the Actor.  This is\n        especially necessary when mergeLODBundles is true, since this\n        kind of actor may be broken after a flatten operation; this\n        method should restore proper Actor functionality. \"\"\"\n\n        if self.mergeLODBundles:\n            # Re-merge all bundles, and restore the common bundle map.\n            self.__commonBundleHandles = {}\n            for lodName, bundleDict in self.__partBundleDict.items():\n                for partName, partDef in bundleDict.items():\n                    loadedBundleHandle = self.__commonBundleHandles.get(partName, None)\n                    node = partDef.partBundleNP.node()\n                    if loadedBundleHandle:\n                        node.mergeBundles(partDef.partBundleHandle, loadedBundleHandle)\n                        partDef.partBundleHandle = loadedBundleHandle\n                    else:\n                        self.__commonBundleHandles[partName] = partDef.partBundleHandle\n\n        # Since we may have merged together some bundles, all of\n        # our anims are now suspect.  Force them to reload.\n        self.unloadAnims()\n\n    def unloadAnims(self, anims=None, partName=None, lodName=None):\n        \"\"\"unloadAnims(self, string:string{}, string='modelRoot',\n        string='lodRoot')\n        Actor anim unloader. Takes an optional partName (defaults to\n        'modelRoot' for non-multipart actors) and lodName (defaults to\n        'lodRoot' for non-LOD actors) and list of animation\n        names. Deletes the anim control for the given animation and\n        parts/lods.\n\n        If any parameter is None or omitted, it means all of them.\n        \"\"\"\n        assert Actor.notify.debug(\"in unloadAnims: %s, part: %s, lod: %s\" %\n                                  (anims, partName, lodName))\n\n        if lodName is None or self.mergeLODBundles:\n            lodNames = self.__animControlDict.keys()\n        else:\n            lodNames = [lodName]\n\n        if partName is None:\n            if len(lodNames) > 0:\n                partNames = self.__animControlDict[next(iter(lodNames))].keys()\n            else:\n                partNames = []\n        else:\n            partNames = [partName]\n\n        if anims is None:\n            for lodName in lodNames:\n                for partName in partNames:\n                    for animDef in self.__animControlDict[lodName][partName].values():\n                        if animDef.animControl is not None:\n                            # Try to clear any control effects before we let\n                            # our handle on them go. This is especially\n                            # important if the anim control was blending\n                            # animations.\n                            animDef.animControl.getPart().clearControlEffects()\n                            animDef.animControl = None\n        else:\n            for lodName in lodNames:\n                for partName in partNames:\n                    for anim in anims:\n                        animDef = self.__animControlDict[lodName][partName].get(anim)\n                        if animDef and animDef.animControl is not None:\n                            # Try to clear any control effects before we let\n                            # our handle on them go. This is especially\n                            # important if the anim control was blending\n                            # animations.\n                            animDef.animControl.getPart().setControlEffect(animDef.animControl, 0.0)\n                            animDef.animControl = None\n\n\n    def bindAnim(self, animName, partName = None, lodName = None,\n                 allowAsyncBind = False):\n        \"\"\"\n        Binds the named animation to the named part and/or lod.  If\n        allowAsyncBind is False, this guarantees that the animation is\n        bound immediately--the animation is never bound in a\n        sub-thread; it will be loaded and bound in the main thread, so\n        it will be available by the time this method returns.\n\n        The parameters are the same as that for getAnimControls().  In\n        fact, this method is a thin wrapper around that other method.\n\n        Use this method if you need to ensure that an animation is\n        available before you start to play it, and you don't mind\n        holding up the render for a frame or two until the animation\n        is available.\n        \"\"\"\n        self.getAnimControls(animName = animName, partName = partName,\n                             lodName = lodName,\n                             allowAsyncBind = allowAsyncBind)\n\n    def bindAllAnims(self, allowAsyncBind = False):\n        \"\"\"Loads and binds all animations that have been defined for\n        the Actor. \"\"\"\n        self.getAnimControls(animName = True, allowAsyncBind = allowAsyncBind)\n\n    def waitPending(self, partName = None):\n        \"\"\"Blocks until all asynchronously pending animations (that\n        are currently playing) have been loaded and bound the the\n        Actor.  Call this after calling play() if you are using\n        asynchronous binds, but you need this particular animation\n        to be loaded immediately. \"\"\"\n\n        for bundle in self.getPartBundles(partName = partName):\n            bundle.waitPending()\n\n    def __bindAnimToPart(self, animName, partName, lodName,\n                         allowAsyncBind = True):\n        \"\"\"\n        Binds the named animation to the named part/lod and returns\n        the associated animControl.  The animation is loaded and bound\n        in a sub-thread, if allowAsyncBind is True,\n        self.allowAsyncBind is True, threading is enabled, and the\n        animation has a preload table generated for it (e.g. via\n        \"egg-optchar -preload\").  Even though the animation may or may\n        not be yet bound at the time this function returns, a usable\n        animControl is returned, or None if the animation could not be\n        bound.\n        \"\"\"\n        # make sure this anim is in the dict\n        subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n\n        partDict = self.__animControlDict[lodName]\n        animDict = partDict.get(partName)\n        if animDict is None:\n            # It must be a subpart that hasn't been bound yet.\n            animDict = {}\n            partDict[partName] = animDict\n\n        anim = animDict.get(animName)\n        if anim is None:\n            # It must be a subpart that hasn't been bound yet.\n            anim = partDict[subpartDef.truePartName].get(animName)\n            anim = anim.makeCopy()\n            animDict[animName] = anim\n\n        if anim is None:\n            Actor.notify.error(\"actor has no animation %s\", animName)\n\n        # only bind if not already bound!\n        if anim.animControl:\n            return anim.animControl\n\n        if self.mergeLODBundles:\n            bundle = self.__commonBundleHandles[subpartDef.truePartName].getBundle()\n        else:\n            bundle = self.__partBundleDict[lodName][subpartDef.truePartName].getBundle()\n\n        if anim.animBundle:\n            # We already have a bundle; just bind it.\n            animControl = bundle.bindAnim(anim.animBundle, -1, subpartDef.subset)\n\n        else:\n            # Load and bind the anim.  This might be an asynchronous\n            # operation that will complete in the background, but if so it\n            # will still return a usable AnimControl.\n            animControl = bundle.loadBindAnim(\n                self.loader, Filename(anim.filename), -1,\n                subpartDef.subset, allowAsyncBind and self.allowAsyncBind)\n\n        if not animControl:\n            # Couldn't bind.  (This implies the binding operation was\n            # not attempted asynchronously.)\n            return None\n\n        # store the animControl\n        anim.animControl = animControl\n        assert Actor.notify.debug(\"binding anim: %s to part: %s, lod: %s\" %\n                                  (animName, partName, lodName))\n        return animControl\n\n    def __copyPartBundles(self, other):\n        \"\"\"__copyPartBundles(self, Actor)\n        Copy the part bundle dictionary from another actor as this\n        instance's own. NOTE: this method does not actually copy geometry\n        \"\"\"\n        for lodName in other.__partBundleDict:\n            # find the lod Asad\n            if lodName == 'lodRoot':\n                partLod = self\n            else:\n                partLod = self.__LODNode.find(str(lodName))\n            if partLod.isEmpty():\n                Actor.notify.warning(\"no lod named: %s\" % (lodName))\n                return None\n            for partName, partDef in other.__partBundleDict[lodName].items():\n                # We can really only copy from a non-flattened avatar.\n                assert partDef.partBundleNP.node().getNumBundles() == 1\n\n                # find the part in our tree\n                bundleNP = partLod.find(\"**/%s%s\"%(Actor.partPrefix,partName))\n                if bundleNP is not None:\n                    # store the part bundle\n                    self.__prepareBundle(bundleNP, partDef.partModel,\n                                         partName, lodName)\n                else:\n                    Actor.notify.error(\"lod: %s has no matching part: %s\" %\n                                       (lodName, partName))\n\n    def __copySubpartDict(self, other):\n        \"\"\"Copies the subpartDict from another as this instance's own.\n        This makes a deep copy of the map and all of the names and\n        PartSubset objects within it.  We can't use copy.deepcopy()\n        because of the included C++ PartSubset objects.\"\"\"\n\n        self.__subpartDict = {}\n        for partName, subpartDef in other.__subpartDict.items():\n            subpartDefCopy = subpartDef\n            if subpartDef:\n                subpartDef = subpartDef.makeCopy()\n            self.__subpartDict[partName] = subpartDef\n\n    def __copyAnimControls(self, other):\n        \"\"\"__copyAnimControls(self, Actor)\n        Get the anims from the anim control's in the anim control\n        dictionary of another actor. Bind these anim's to the part\n        bundles in our part bundle dict that have matching names, and\n        store the resulting anim controls in our own part bundle dict\"\"\"\n\n        assert other.mergeLODBundles == self.mergeLODBundles\n\n        for lodName in other.__animControlDict:\n            self.__animControlDict[lodName] = {}\n            for partName in other.__animControlDict[lodName]:\n                self.__animControlDict[lodName][partName] = {}\n                for animName in other.__animControlDict[lodName][partName]:\n                    anim = other.__animControlDict[lodName][partName][animName]\n                    anim = anim.makeCopy()\n                    self.__animControlDict[lodName][partName][animName] = anim\n\n\n    def actorInterval(self, *args, **kw):\n        from direct.interval import ActorInterval\n        return ActorInterval.ActorInterval(self, *args, **kw)\n\n    def getAnimBlends(self, animName=None, partName=None, lodName=None):\n        \"\"\"Returns a list of the form::\n\n           [ (lodName, [(animName, [(partName, effect), (partName, effect), ...]),\n                        (animName, [(partName, effect), (partName, effect), ...]),\n                        ...]),\n             (lodName, [(animName, [(partName, effect), (partName, effect), ...]),\n                        (animName, [(partName, effect), (partName, effect), ...]),\n                        ...]),\n              ... ]\n\n        This list reports the non-zero control effects for each\n        partName within a particular animation and LOD. \"\"\"\n\n        result = []\n\n        if animName is None:\n            animNames = self.getAnimNames()\n        else:\n            animNames = [animName]\n\n        if lodName is None:\n            lodNames = self.getLODNames()\n            if self.mergeLODBundles:\n                lodNames = lodNames[:1]\n        else:\n            lodNames = [lodName]\n\n        if partName is None and self.__subpartsComplete:\n            partNames = self.__subpartDict.keys()\n        else:\n            partNames = [partName]\n\n        for lodName in lodNames:\n            animList = []\n            for animName in animNames:\n                blendList = []\n                for partName in partNames:\n                    control = self.getAnimControl(animName, partName, lodName)\n                    if control:\n                        part = control.getPart()\n                        effect = part.getControlEffect(control)\n                        if effect > 0.:\n                            blendList.append((partName, effect))\n                if blendList:\n                    animList.append((animName, blendList))\n            if animList:\n                result.append((lodName, animList))\n\n        return result\n\n    def printAnimBlends(self, animName=None, partName=None, lodName=None):\n        for lodName, animList in self.getAnimBlends(animName, partName, lodName):\n            print('LOD %s:' % (lodName))\n            for animName, blendList in animList:\n                strings = []\n                for partName, effect in blendList:\n                    strings.append('%s:%.3f' % (partName, effect))\n                print('  %s: %s' % (animName, ', '.join(strings)))\n\n    def osdAnimBlends(self, animName=None, partName=None, lodName=None):\n        if not onScreenDebug.enabled:\n            return\n        # puts anim blending info into the on-screen debug panel\n        if animName is None:\n            animNames = self.getAnimNames()\n        else:\n            animNames = [animName]\n        for animName in animNames:\n            if animName == 'nothing':\n                continue\n            thisAnim = ''\n            totalEffect = 0.\n            controls = self.getAnimControls(animName, partName, lodName)\n            for control in controls:\n                part = control.getPart()\n                name = part.getName()\n                effect = part.getControlEffect(control)\n                if effect > 0.:\n                    totalEffect += effect\n                    thisAnim += ('%s:%.3f, ' % (name, effect))\n            thisAnim += \"\\n\"\n            for control in controls:\n                part = control.getPart()\n                name = part.getName()\n                rate = control.getPlayRate()\n                thisAnim += ('%s:%.1f, ' % (name, rate))\n            # don't display anything if this animation is not being played\n            itemName = 'anim %s' % animName\n            if totalEffect > 0.:\n                onScreenDebug.add(itemName, thisAnim)\n            else:\n                if onScreenDebug.has(itemName):\n                    onScreenDebug.remove(itemName)\n\n    # these functions compensate for actors that are modeled facing the viewer but need\n    # to face away from the camera in the game\n    def faceAwayFromViewer(self):\n        self.getGeomNode().setH(180)\n    def faceTowardsViewer(self):\n        self.getGeomNode().setH(0)\n\n    def renamePartBundles(self, partName, newBundleName):\n        subpartDef = self.__subpartDict.get(partName, Actor.SubpartDef(partName))\n        for partBundleDict in self.__partBundleDict.values():\n            partDef = partBundleDict.get(subpartDef.truePartName)\n            partDef.getBundle().setName(newBundleName)\n\n    #snake_case alias:\n    control_joint = controlJoint\n    set_lod_animation = setLODAnimation\n    get_anim_control_dict = getAnimControlDict\n    get_actor_info = getActorInfo\n    clear_lod_animation = clearLODAnimation\n    reset_lod = resetLOD\n    fix_bounds = fixBounds\n    get_anim_filename = getAnimFilename\n    get_subparts_complete = getSubpartsComplete\n    verify_subparts_complete = verifySubpartsComplete\n    get_play_rate = getPlayRate\n    clear_python_data = clearPythonData\n    load_anims = loadAnims\n    set_subparts_complete = setSubpartsComplete\n    draw_in_front = drawInFront\n    get_lod_node = getLODNode\n    hide_part = hidePart\n    get_joint_transform_state = getJointTransformState\n    set_control_effect = setControlEffect\n    get_anim_controls = getAnimControls\n    release_joint = releaseJoint\n    print_anim_blends = printAnimBlends\n    get_lod = getLOD\n    disable_blend = disableBlend\n    show_part = showPart\n    get_joint_transform = getJointTransform\n    face_away_from_viewer = faceAwayFromViewer\n    set_lod = setLOD\n    osd_anim_blends = osdAnimBlends\n    get_current_frame = getCurrentFrame\n    set_play_rate = setPlayRate\n    bind_all_anims = bindAllAnims\n    unload_anims = unloadAnims\n    remove_part = removePart\n    use_lod = useLOD\n    get_anim_blends = getAnimBlends\n    get_lod_index = getLODIndex\n    get_num_frames = getNumFrames\n    post_flatten = postFlatten\n    get_lod_names = getLODNames\n    list_joints = listJoints\n    make_subpart = makeSubpart\n    get_anim_control = getAnimControl\n    get_part_bundle = getPartBundle\n    get_part_bundle_dict = getPartBundleDict\n    get_duration = getDuration\n    has_lod = hasLOD\n    print_lod = printLOD\n    fix_bounds_old = fixBounds_old\n    get_anim_names = getAnimNames\n    get_part_bundles = getPartBundles\n    anim_panel = animPanel\n    stop_joint = stopJoint\n    actor_interval = actorInterval\n    hide_all_bounds = hideAllBounds\n    show_all_bounds = showAllBounds\n    init_anims_on_all_lods = initAnimsOnAllLODs\n    get_part = getPart\n    add_lod = addLOD\n    show_all_parts = showAllParts\n    get_joints = getJoints\n    get_overlapping_joints = getOverlappingJoints\n    enable_blend = enableBlend\n    face_towards_viewer = faceTowardsViewer\n    bind_anim = bindAnim\n    set_blend = setBlend\n    get_frame_time = getFrameTime\n    remove_node = removeNode\n    wait_pending = waitPending\n    expose_joint = exposeJoint\n    set_lod_node = setLODNode\n    get_frame_rate = getFrameRate\n    get_current_anim = getCurrentAnim\n    get_part_names = getPartNames\n    freeze_joint = freezeJoint\n    set_center = setCenter\n    rename_part_bundles = renamePartBundles\n    get_geom_node = getGeomNode\n    set_geom_node = setGeomNode\n    load_model = loadModel\n    copy_actor = copyActor\n    get_base_frame_rate = getBaseFrameRate\n    remove_anim_control_dict = removeAnimControlDict\n    load_anims_on_all_lods = loadAnimsOnAllLODs\n    get_play_mode = getPlayMode\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/actor/Actor.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/2763abe9_Actor.json",
    "doc_id": "doc_177"
  }
}