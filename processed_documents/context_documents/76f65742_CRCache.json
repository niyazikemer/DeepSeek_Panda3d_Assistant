{
  "content": "\"\"\"CRCache module: contains the CRCache class\"\"\"\n\nfrom direct.directnotify import DirectNotifyGlobal\nfrom direct.showbase.MessengerGlobal import messenger\nfrom direct.showbase.PythonUtil import safeRepr, itype\nfrom . import DistributedObject\n\n\nclass CRCache:\n    notify = DirectNotifyGlobal.directNotify.newCategory(\"CRCache\")\n\n    def __init__(self, maxCacheItems=10):\n        self.maxCacheItems = maxCacheItems\n        self.storedCacheItems = maxCacheItems\n        self.dict = {}\n        self.fifo = []\n\n    def isEmpty(self):\n        return len(self.fifo) == 0\n\n    def flush(self):\n        \"\"\"\n        Delete each item in the cache then clear all references to them\n        \"\"\"\n        assert self.checkCache()\n        CRCache.notify.debug(\"Flushing the cache\")\n        # NOTE: delayDeleted objects should no longer get into the cache in the first place\n        # give objects a chance to clean themselves up before checking for DelayDelete leaks\n        messenger.send('clientCleanup')\n        # some of these objects might be holding delayDeletes on others\n        # track each object that is delayDeleted after it gets its chance to delete,\n        # and check them after all objects have had a chance to delete\n        delayDeleted = []\n        for distObj in self.dict.values():\n            distObj.deleteOrDelay()\n            if distObj.getDelayDeleteCount() != 0:\n                delayDeleted.append(distObj)\n            if distObj.getDelayDeleteCount() <= 0:\n                # make sure we're not leaking\n                distObj.detectLeaks()\n        # now that all objects have had a chance to delete, are there any objects left\n        # that are still delayDeleted?\n        delayDeleteLeaks = []\n        for distObj in delayDeleted:\n            if distObj.getDelayDeleteCount() != 0:\n                delayDeleteLeaks.append(distObj)\n        if len(delayDeleteLeaks) > 0:\n            s = 'CRCache.flush:'\n            for obj in delayDeleteLeaks:\n                s += ('\\n  could not delete %s (%s), delayDeletes=%s' %\n                      (safeRepr(obj), itype(obj), obj.getDelayDeleteNames()))\n            self.notify.error(s)\n        # Null out all references to the objects so they will get gcd\n        self.dict = {}\n        self.fifo = []\n\n    def cache(self, distObj):\n        # Only distributed objects are allowed in the cache\n        assert isinstance(distObj, DistributedObject.DistributedObject)\n        assert self.checkCache()\n        # Get the doId\n        doId = distObj.getDoId()\n        # Error check\n        success = False\n        if doId in self.dict:\n            CRCache.notify.warning(\"Double cache attempted for distObj \"\n                                   + str(doId))\n        else:\n            # Call disable on the distObj\n            distObj.disableAndAnnounce()\n\n            # Put the distObj in the fifo and the dict\n            self.fifo.append(distObj)\n            self.dict[doId] = distObj\n\n            success = True\n\n            if len(self.fifo) > self.maxCacheItems:\n                # if the cache is full, pop the oldest item\n                oldestDistObj = self.fifo.pop(0)\n                # and remove it from the dictionary\n                del self.dict[oldestDistObj.getDoId()]\n                # and delete it\n                oldestDistObj.deleteOrDelay()\n                if oldestDistObj.getDelayDeleteCount() <= 0:\n                    # make sure we're not leaking\n                    oldestDistObj.detectLeaks()\n\n        # Make sure that the fifo and the dictionary are sane\n        assert len(self.dict) == len(self.fifo)\n        return success\n\n    def retrieve(self, doId):\n        assert self.checkCache()\n        if doId in self.dict:\n            # Find the object\n            distObj = self.dict[doId]\n            # Remove it from the dictionary\n            del self.dict[doId]\n            # Remove it from the fifo\n            self.fifo.remove(distObj)\n            # return the distObj\n            return distObj\n        else:\n            # If you can't find it, return None\n            return None\n\n    def contains(self, doId):\n        return doId in self.dict\n\n    def delete(self, doId):\n        assert self.checkCache()\n        assert doId in self.dict\n        # Look it up\n        distObj = self.dict[doId]\n        # Remove it from the dict and fifo\n        del self.dict[doId]\n        self.fifo.remove(distObj)\n        # and delete it\n        distObj.deleteOrDelay()\n        if distObj.getDelayDeleteCount() <= 0:\n            # make sure we're not leaking\n            distObj.detectLeaks()\n\n    def checkCache(self):\n        # For debugging; this verifies that the cache is sensible and\n        # returns true if so.\n        from panda3d.core import NodePath\n        for obj in self.dict.values():\n            if isinstance(obj, NodePath):\n                assert not obj.isEmpty() and obj.getTopNode() != render.node()\n        return 1\n\n    def turnOff(self):\n        self.flush()\n        self.storedMaxCache = self.maxCacheItems\n        self.maxCacheItems = 0\n\n    def turnOn(self):\n        self.maxCacheItems = self.storedMaxCache\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/CRCache.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/76f65742_CRCache.json",
    "doc_id": "doc_299"
  }
}