{
  "content": "\"\"\"RelatedObjectMgr module: contains the RelatedObjectMgr class\"\"\"\n\n# from direct.showbase.ShowBaseGlobal import *\nfrom direct.showbase import DirectObject\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.directnotify import DirectNotifyGlobal\n\n\nclass RelatedObjectMgr(DirectObject.DirectObject):\n    \"\"\"\n    This class manages a relationship between DistributedObjects that\n    know about each other, and are expected to be generated together.\n    Ideally, we should be able to guarantee the ordering of the\n    generate calls, but there are certain cases in which the objects\n    may not be generated in the correct order as defined by the\n    toon.dc file.\n\n    To handle cases like these robustly, it is necessary for each\n    object to deal with the possibility that its companion object has\n    not yet been generated.  This may mean deferring some operations\n    until the expected companion object has been generated.\n\n    This class helps manage that process.  To use it, an object should\n    register its desire to be associated with the other object's doId.\n    When the other object is generated (or immediately, if the object\n    already exists), the associated callback will be called.  There is\n    also a timeout callback in case the object never appears.\n    \"\"\"\n    notify = DirectNotifyGlobal.directNotify.newCategory('RelatedObjectMgr')\n\n    doLaterSequence = 1\n\n    def __init__(self, cr):\n        self.cr = cr\n        self.pendingObjects = {}\n\n    def destroy(self):\n        self.abortAllRequests()\n        del self.cr\n        del self.pendingObjects\n\n    def requestObjects(self, doIdList, allCallback = None, eachCallback = None,\n                       timeout = None, timeoutCallback = None):\n        \"\"\"\n        Requests a callback to be called when the objects in the\n        doIdList are generated.  The allCallback will be called only\n        when all the objects have been generated (and it receives a\n        list of objects, in the order given in doIdList).  The\n        eachCallback is called as each object is generated, and\n        receives only the object itself.\n\n        If the objects already exist, the appropriate callback is\n        called immediately.\n\n        If all of the objects are not generated within the indicated\n        timeout time, the timeoutCallback is called instead, with the\n        original doIdList as the parameter.  If the timeoutCallback is\n        None, then allCallback is called on timeout, with the list of\n        objects that have been generated so far, and None for objects\n        that have not been generated.\n\n        If any element of doIdList is None or 0, it is ignored, and\n        None is passed in its place in the object list passed to the\n        callback.\n\n        The return value may be saved and passed to a future call to\n        abortRequest(), in order to abort a pending request before the\n        timeout expires.\n\n        Actually, you should be careful to call abortRequest() if you\n        have made a call to requestObjects() that has not been resolved.\n        To find examples, do a search for abortRequest() to find out\n        how other code is using it.  A common idiom is to store the\n        result from requestObjects() and call abortRequest() if delete()\n        or destroy() is called on the requesting object.\n\n        See Also: abortRequest()\n        \"\"\"\n        assert self.notify.debug(\"requestObjects(%s, timeout=%s)\" % (doIdList, timeout))\n\n        # First, see if we have all of the objects already.\n        objects, doIdsPending = self.__generateObjectList(doIdList)\n\n        # Call the eachCallback immediately on any objects we already\n        # have.\n        if eachCallback:\n            for object in objects:\n                if object:\n                    eachCallback(object)\n\n        if len(doIdsPending) == 0:\n            # All the objects exist, so just call the callback\n            # immediately.\n            assert self.notify.debug(\"All objects already exist.\")\n            if allCallback:\n                allCallback(objects)\n            return\n\n        # Some objects don't exist yet, so start listening for them, and\n        # also set a timeout in case they don't come.\n        assert self.notify.debug(\"Some objects pending: %s\" % (doIdsPending))\n\n        # Make a copy of the original doIdList, so we can save it over\n        # a period of time without worrying about the caller modifying\n        # it.\n        doIdList = doIdList[:]\n\n        doLaterName = None\n        if timeout is not None:\n            doLaterName = \"RelatedObject-%s\" % (RelatedObjectMgr.doLaterSequence)\n            assert self.notify.debug(\"doLaterName = %s\" % (doLaterName))\n\n            RelatedObjectMgr.doLaterSequence += 1\n\n        tuple = (allCallback, eachCallback, timeoutCallback,\n                 doIdsPending, doIdList, doLaterName)\n\n        for doId in doIdsPending:\n            pendingList = self.pendingObjects.get(doId)\n            if pendingList is None:\n                pendingList = []\n                self.pendingObjects[doId] = pendingList\n                self.__listenFor(doId)\n\n            pendingList.append(tuple)\n\n        if doLaterName:\n            # Now spawn a do-later to catch the timeout.\n            taskMgr.doMethodLater(timeout, self.__timeoutExpired, doLaterName,\n                                  extraArgs = [tuple])\n\n        return tuple\n\n    def abortRequest(self, tuple):\n        \"\"\"\n        Aborts a previous request.  The parameter is the return value\n        from a previous call to requestObjects().  The pending request\n        is removed from the queue and no further callbacks will be called.\n\n        See Also: requestObjects()\n        \"\"\"\n        if tuple:\n            allCallback, eachCallback, timeoutCallback, doIdsPending, doIdList, doLaterName = tuple\n            assert self.notify.debug(\"aborting request for %s (remaining: %s)\" % (doIdList, doIdsPending))\n\n            if doLaterName:\n                taskMgr.remove(doLaterName)\n            self.__removePending(tuple, doIdsPending)\n\n    def abortAllRequests(self):\n        \"\"\"\n        Call this method to abruptly abort all pending requests, but\n        leave the RelatedObjectMgr in a state for accepting more\n        requests.\n        \"\"\"\n\n        # Stop listening for all events.\n        self.ignoreAll()\n\n        # Iterate through all the pendingObjects and stop any pending\n        # tasks.\n        for pendingList in self.pendingObjects.values():\n            for tuple in pendingList:\n                allCallback, eachCallback, timeoutCallback, doIdsPending, doIdList, doLaterName = tuple\n                if doLaterName:\n                    taskMgr.remove(doLaterName)\n\n        self.pendingObjects = {}\n\n\n    def __timeoutExpired(self, tuple):\n        allCallback, eachCallback, timeoutCallback, doIdsPending, doIdList, doLaterName = tuple\n        assert self.notify.debug(\"timeout expired for %s (remaining: %s)\" % (doIdList, doIdsPending))\n\n        self.__removePending(tuple, doIdsPending)\n        if timeoutCallback:\n            timeoutCallback(doIdList)\n        else:\n            objects, doIdsPending = self.__generateObjectList(doIdList)\n            if allCallback:\n                allCallback(objects)\n\n    def __removePending(self, tuple, doIdsPending):\n        # Removes all the pending events for the doIdsPending list.\n        while len(doIdsPending) > 0:\n            # We pop doId's off the list instead of simply iterating\n            # through the list, so that we will shorten the list (and\n            # all other outstanding instances of the list) as we go.\n            doId = doIdsPending.pop()\n            pendingList = self.pendingObjects[doId]\n            pendingList.remove(tuple)\n            if len(pendingList) == 0:\n                del self.pendingObjects[doId]\n                self.__noListenFor(doId)\n\n\n    def __listenFor(self, doId):\n        # Start listening for the indicated object to be generated.\n        assert self.notify.debug(\"Now listening for generate from %s\" % (doId))\n        announceGenerateName = \"generate-%s\" % (doId)\n        self.acceptOnce(announceGenerateName, self.__generated)\n\n    def __noListenFor(self, doId):\n        # Stop listening for the indicated object to be generated.\n        assert self.notify.debug(\"No longer listening for generate from %s\" % (doId))\n        announceGenerateName = \"generate-%s\" % (doId)\n        self.ignore(announceGenerateName)\n\n    def __generated(self, object):\n        # The indicated object has been generated.\n        doId = object.doId\n        assert self.notify.debug(\"Got generate from %s\" % (doId))\n        pendingList = self.pendingObjects[doId]\n        del self.pendingObjects[doId]\n\n        for tuple in pendingList:\n            allCallback, eachCallback, timeoutCallback, doIdsPending, doIdList, doLaterName = tuple\n\n            # Here we are depending on Python to unify this one list\n            # across all objects that share it.  When we remove our\n            # doId from our reference to the list, it is also removed\n            # from all the other references.\n            doIdsPending.remove(doId)\n\n            if eachCallback:\n                eachCallback(object)\n\n            if len(doIdsPending) == 0:\n                # That was the last doId on the list.  Call the\n                # allCallback!\n                assert self.notify.debug(\"All objects generated on list: %s\" % (doIdList,))\n                if doLaterName:\n                    taskMgr.remove(doLaterName)\n\n                objects, doIdsPending = self.__generateObjectList(doIdList)\n                if None in objects:\n                    assert self.notify.warning('calling %s with None.\\n objects=%s\\n doIdsPending=%s\\n doIdList=%s\\n' % (allCallback,objects,doIdsPending,doIdList))\n                if allCallback:\n                    allCallback(objects)\n\n            else:\n                assert self.notify.debug(\"Objects still pending: %s\" % (doIdsPending))\n\n    def __generateObjectList(self, doIdList):\n        objects = []\n        doIdsPending = []\n\n        for doId in doIdList:\n            if doId:\n                object = self.cr.doId2do.get(doId)\n                objects.append(object)\n                if object is None:\n                    doIdsPending.append(doId)\n            else:\n                objects.append(None)\n\n        return objects, doIdsPending\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/distributed/RelatedObjectMgr.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/31b2f9c4_RelatedObjectMgr.json",
    "doc_id": "doc_308"
  }
}