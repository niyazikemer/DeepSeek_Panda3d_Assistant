{
  "content": "\"\"\"Class used to create and control VRPN devices.\"\"\"\n\nfrom direct.showbase.DirectObject import DirectObject\nfrom panda3d.core import (\n    AnalogNode,\n    ButtonNode,\n    ConfigVariableDouble,\n    ConfigVariableString,\n    DialNode,\n    TrackerNode,\n)\nfrom panda3d.vrpn import VrpnClient\n\nANALOG_MIN = -0.95\nANALOG_MAX = 0.95\nANALOG_DEADBAND = 0.125\nANALOG_CENTER = 0.0\n\n\nclass DirectDeviceManager(VrpnClient, DirectObject):\n    def __init__(self, server = None):\n\n        # Determine which server to use\n        if server is not None:\n            # One given as constructor argument\n            self.server = server\n        else:\n            # Check config file, if that fails, use default\n            self.server = ConfigVariableString('vrpn-server', 'spacedyne').getValue()\n\n        # Create a vrpn client\n        VrpnClient.__init__(self, self.server)\n\n    def createButtons(self, device):\n        return DirectButtons(self, device)\n\n    def createAnalogs(self, device):\n        return DirectAnalogs(self, device)\n\n    def createTracker(self, device):\n        return DirectTracker(self, device)\n\n    def createDials(self, device):\n        return DirectDials(self, device)\n\n    def createTimecodeReader(self, device):\n        return DirectTimecodeReader(self, device)\n\nclass DirectButtons(ButtonNode, DirectObject):\n    buttonCount = 0\n    def __init__(self, vrpnClient, device):\n        # Keep track of number of buttons created\n        DirectButtons.buttonCount += 1\n        # Create a new button node for the given device\n        ButtonNode.__init__(self, vrpnClient, device)\n        # Create a unique name for this button object\n        self.name = 'DirectButtons-' + repr(DirectButtons.buttonCount)\n\n        # Attach node to data graph\n        try:\n            self._base = base\n        except NameError:\n            self._base = simbase\n        self.nodePath = self._base.dataRoot.attachNewNode(self)\n\n    def __getitem__(self, index):\n        if (index < 0) or (index >= self.getNumButtons()):\n            raise IndexError\n        return self.getButtonState(index)\n\n    def __len__(self):\n        return self.getNumButtons()\n\n    def enable(self):\n        self.nodePath.reparentTo(self._base.dataRoot)\n\n    def disable(self):\n        self.nodePath.reparentTo(self._base.dataUnused)\n\n    def getName(self):\n        return self.name\n\n    def getNodePath(self):\n        return self.nodePath\n\n    def __repr__(self):\n        string = self.name + ': '\n        for val in self:\n            string = string + '%d' % val + ' '\n        return string\n\nclass DirectAnalogs(AnalogNode, DirectObject):\n    analogCount = 0\n\n    _analogDeadband = ConfigVariableDouble('vrpn-analog-deadband', ANALOG_DEADBAND)\n    _analogMin = ConfigVariableDouble('vrpn-analog-min', ANALOG_MIN)\n    _analogMax = ConfigVariableDouble('vrpn-analog-max', ANALOG_MAX)\n    _analogCenter = ConfigVariableDouble('vrpn-analog-center', ANALOG_CENTER)\n\n    def __init__(self, vrpnClient, device):\n        # Keep track of number of analogs created\n        DirectAnalogs.analogCount += 1\n        # Create a new analog node for the given device\n        AnalogNode.__init__(self, vrpnClient, device)\n        # Create a unique name for this analog object\n        self.name = 'DirectAnalogs-' + repr(DirectAnalogs.analogCount)\n\n        # Attach node to data graph\n        try:\n            self._base = base\n        except NameError:\n            self._base = simbase\n        self.nodePath = self._base.dataRoot.attachNewNode(self)\n\n        # See if any of the general analog parameters are dconfig'd\n        self.analogDeadband = self._analogDeadband.getValue()\n        self.analogMin = self._analogMin.getValue()\n        self.analogMax = self._analogMax.getValue()\n        self.analogCenter = self._analogCenter.getValue()\n        self.analogRange = self.analogMax - self.analogMin\n\n    def __getitem__(self, index):\n        if (index < 0) or (index >= self.getNumControls()):\n            raise IndexError\n        return self.getControlState(index)\n\n    def __len__(self):\n        return self.getNumControls()\n\n    def enable(self):\n        self.nodePath.reparentTo(self._base.dataRoot)\n\n    def disable(self):\n        self.nodePath.reparentTo(self._base.dataUnused)\n\n    def normalizeWithoutCentering(self, val, minVal = -1, maxVal = 1):\n        #\n        # This is the old code that doesn't incorporate the centering fix\n        #\n        # First record sign\n        if val < 0:\n            sign = -1\n        else:\n            sign = 1\n        # Zero out values in deadband\n        val = sign * max(abs(val) - self.analogDeadband, 0.0)\n        # Clamp value between analog range min and max and scale about center\n        val = min(max(val, self.analogMin), self.analogMax)\n        # Normalize values to given minVal and maxVal range\n        return (((maxVal - minVal) *\n                 ((val - self.analogMin) / float(self.analogRange))) + minVal)\n\n\n    def normalize(self, rawValue, minVal = -1, maxVal = 1, sf = 1.0):\n        aMax = self.analogMax\n        aMin = self.analogMin\n        center = self.analogCenter\n        deadband = self.analogDeadband\n\n        # Zero out values in deadband\n        if abs(rawValue - center) <= deadband:\n            return 0.0\n        # Clamp value between aMin and aMax and scale around center\n        if rawValue >= center:\n            # Convert positive values to range 0 to 1\n            val = min(rawValue * sf, aMax)\n            percentVal = ((val - (center + deadband))/\n                          float(aMax - (center + deadband)))\n        else:\n            # Convert negative values to range -1 to 0\n            val = max(rawValue * sf, aMin)\n            percentVal = -((val - (center - deadband))/\n                           float(aMin - (center - deadband)))\n        # Normalize values to given minVal and maxVal range\n        return ((maxVal - minVal) * ((percentVal + 1)/2.0)) + minVal\n\n    def normalizeChannel(self, chan, minVal = -1, maxVal = 1, sf = 1.0):\n        try:\n            return self.normalize(self[chan], minVal, maxVal, sf)\n        except IndexError:\n            return 0.0\n\n    def getName(self):\n        return self.name\n\n    def getNodePath(self):\n        return self.nodePath\n\n    def __repr__(self):\n        string = self.name + ': '\n        for val in self:\n            string = string + '%.3f' % val + ' '\n        return string\n\nclass DirectTracker(TrackerNode, DirectObject):\n    trackerCount = 0\n\n    def __init__(self, vrpnClient, device):\n        # Keep track of number of trackers created\n        DirectTracker.trackerCount += 1\n        # Create a new tracker node for the given device\n        TrackerNode.__init__(self, vrpnClient, device)\n        # Create a unique name for this tracker object\n        self.name = 'DirectTracker-' + repr(DirectTracker.trackerCount)\n\n        # Attach node to data graph\n        try:\n            self._base = base\n        except NameError:\n            self._base = simbase\n        self.nodePath = self._base.dataRoot.attachNewNode(self)\n\n    def enable(self):\n        self.nodePath.reparentTo(self._base.dataRoot)\n\n    def disable(self):\n        self.nodePath.reparentTo(self._base.dataUnused)\n\n    def getName(self):\n        return self.name\n\n    def getNodePath(self):\n        return self.nodePath\n\n    def __repr__(self):\n        return self.name\n\nclass DirectDials(DialNode, DirectObject):\n    dialCount = 0\n    def __init__(self, vrpnClient, device):\n        # Keep track of number of dials created\n        DirectDials.dialCount += 1\n        # Create a new dial node for the given device\n        DialNode.__init__(self, vrpnClient, device)\n        # Create a unique name for this dial object\n        self.name = 'DirectDials-' + repr(DirectDials.dialCount)\n\n        # Attach node to data graph\n        try:\n            self._base = base\n        except NameError:\n            self._base = simbase\n        self.nodePath = self._base.dataRoot.attachNewNode(self)\n\n    def __getitem__(self, index):\n        \"\"\"\n        if (index < 0) or (index >= self.getNumDials()):\n            raise IndexError\n        \"\"\"\n        return self.readDial(index)\n\n    def __len__(self):\n        return self.getNumDials()\n\n    def enable(self):\n        self.nodePath.reparentTo(self._base.dataRoot)\n\n    def disable(self):\n        self.nodePath.reparentTo(self._base.dataUnused)\n\n    def getName(self):\n        return self.name\n\n    def getNodePath(self):\n        return self.nodePath\n\n    def __repr__(self):\n        string = self.name + ': '\n        for i in range(self.getNumDials()):\n            string = string + '%.3f' % self[i] + ' '\n        return string\n\nclass DirectTimecodeReader(AnalogNode, DirectObject):\n    timecodeReaderCount = 0\n    def __init__(self, vrpnClient, device):\n        # Keep track of number of timecodeReader created\n        DirectTimecodeReader.timecodeReaderCount += 1\n        # Create a new dial node for the given device\n        AnalogNode.__init__(self, vrpnClient, device)\n        # Create a unique name for this dial object\n        self.name = ('DirectTimecodeReader-' +\n                     repr(DirectTimecodeReader.timecodeReaderCount))\n        # Initialize components of timecode\n        self.frames = 0\n        self.seconds = 0\n        self.minutes = 0\n        self.hours = 0\n\n        # Attach node to data graph\n        try:\n            self._base = base\n        except NameError:\n            self._base = simbase\n        self.nodePath = self._base.dataRoot.attachNewNode(self)\n\n    def enable(self):\n        self.nodePath.reparentTo(self._base.dataRoot)\n\n    def disable(self):\n        self.nodePath.reparentTo(self._base.dataUnused)\n\n    def getName(self):\n        return self.name\n\n    def getNodePath(self):\n        return self.nodePath\n\n    def getTime(self):\n        # Assume only one card, use channel 0\n        timeBits = int(self.getControlState(0))\n        self.frames = ((timeBits & 0xF) +\n                       (((timeBits & 0xF0) >> 4) * 10))\n        self.seconds = (((timeBits & 0x0F00) >> 8) +\n                        (((timeBits & 0xF000) >> 12) * 10))\n        self.minutes = (((timeBits & 0x0F0000) >> 16) +\n                        (((timeBits & 0xF00000) >> 20) * 10))\n        self.hours = (((timeBits & 0xF000000) >> 24) +\n                      (((timeBits & 0xF0000000) >> 28) * 10))\n        self.totalSeconds = ((self.hours * 3600) +\n                             (self.minutes * 60) +\n                             self.seconds +\n                             (self.frames / 30.0))\n        return (self.hours, self.minutes, self.seconds, self.frames,\n                self.totalSeconds)\n\n    def __repr__(self):\n        string = ('%s: %d:%d:%d:%d' % ((self.name,) + self.getTime()[:-1]))\n        return string\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/directdevices/DirectDeviceManager.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/37437624_DirectDeviceManager.json",
    "doc_id": "doc_112"
  }
}