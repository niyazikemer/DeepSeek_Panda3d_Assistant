{
  "content": "Texture Transforms\n\nIt is possible to apply a matrix to transform the (u, v) texture coordinates of a model before rendering. In this way, you can adjust the position, rotation, or scale of a texture, sliding the texture around to suit your particular needs.\n\nUse the following .NodePath methods to do this:\n\nnodePath.setTexOffset(TextureStage, uOffset, vOffset)\nnodePath.setTexScale(TextureStage, uScale, vScale)\nnodePath.setTexRotate(TextureStage, degrees)\n\nIf you don't have a particular TextureStage, use .TextureStage.get_default() as the first parameter.\n\nNote that the operation in each case is applied to the (u, v) texture coordinates, not to the texture; so it will have the opposite effect on the texture. For instance, the call nodePath.set_tex_scale(ts, 2, 2) <.NodePath.set_tex_scale> will effectively double the values of the texture coordinates on the model, which doubles the space over which the texture is applied, and thus makes the texture appear half as large.\n\nThe above methods apply a 2-d transform to your texture coordinates, which is appropriate, since texture coordinates are usually two-dimensional. However, sometimes you are working with 3-d texture coordinates <3d-textures>, and you really do want to apply a 3-d transform. For those cases, there are the following methods:\n\nnodePath.setTexPos(TextureStage, uOffset, vOffset, wOffset)\nnodePath.setTexScale(TextureStage, uScale, vScale, wScale)\nnodePath.setTexHpr(TextureStage, h, p, r)\n\nAnd there is also one generic form:\n\nnodePath.setTexTransform(TextureStage, transform);\n\nThis last method sets a generic TransformState object. This is the same kind of 4x4 transform matrix object that you can get from a NodePath via e.g., .NodePath.get_transform(). You can also construct a new TransformState via a number of methods like TransformState::make_pos(VBase3(0, 1, 0)) <.TransformState.make_pos>. If you intend to apply a 2-d transform only, you should restrict yourself to methods like TransformState::make_pos2d(VBase2(0, 1)) <.TransformState.make_pos2d>; using only 2-d operations may allow the graphics backend to use a slightly simpler calculation.\n\nNote that the texture transform is associated with a particular TextureStage; it is not a fixed property of the model or its texture coordinates. You can therefore apply a different texture transform to each different TextureStage, so that if you have multiple textures in effect on a particular node, they need not all be in the same place, even if they all use the same texture coordinates. For instance, this technique was used to generate the sample images in the Texture Blend Modes <texture-modes> section. In fact, the following code was used to place this sample texture (excerpted):\n\nsmiley = loader.loadModel('smiley.egg')\nts = TextureStage('ts')\npattern = loader.loadTexture('color_pattern.png')\nsmiley.setTexture(ts, pattern)\nsmiley.setTexScale(ts, 8, 4)\nsmiley.setTexOffset(ts, -4, -2)\n\nand the resulting texture:\n\nIn the above example, we have applied a scale of (8, 4) to reduce the size of the decal image substantially, and then we specified an offset of (-4, -2) to slide it around in the positive (u, v) direction to smiley's face (since the (0, 0) coordinate happens to be on smiley's backside). However, these operations affect only the decal image; the original smiley texture is unchanged from its normal position, even though both textures are using the same texture coordinates.",
  "metadata": {
    "source": "corpus_panda3d/collected_docs/acc9476d_texture-transforms.rst",
    "doc_type": "rst",
    "file_path": "processed_documents/context_documents/e7c8839c_acc9476d_texture-transforms.json",
    "doc_id": "doc_546"
  }
}