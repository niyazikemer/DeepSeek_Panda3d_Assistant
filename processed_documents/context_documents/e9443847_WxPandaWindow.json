{
  "content": "\"\"\" This module implements a Panda3D window that can be embedded\nwithin a wx.Frame.  The window itself is either an embedded window,\nwhich is a wx.Window with the Panda window attached to it, or it is a\nwxgl.GLCanvas, with Panda directed to draw into it, depending on the\nplatform.  In either case, you may simply embed this window into a\nwx.Frame of your choosing, using sizers or whatever you like. \"\"\"\n\nimport wx\nimport platform\n\ntry:\n    import wx.glcanvas as wxgl\nexcept ImportError:\n    wxgl = None\n\nfrom panda3d.core import (\n    CallbackGraphicsWindow,\n    ConfigVariableBool,\n    FrameBufferProperties,\n    KeyboardButton,\n    MouseButton,\n    WindowProperties,\n)\n\n__all__ = ['WxPandaWindow']\n\n\nclass EmbeddedPandaWindow(wx.Window):\n    \"\"\" This class implements a Panda3D window that is directly\n    embedded within the frame.  It is fully supported on Windows,\n    partially supported on Linux, and not at all on OSX. \"\"\"\n\n    def __init__(self, *args, **kw):\n        gsg = None\n        if 'gsg' in kw:\n            gsg = kw['gsg']\n            del kw['gsg']\n\n        base.startWx()\n        wx.Window.__init__(self, *args, **kw)\n\n        wp = WindowProperties.getDefault()\n        if platform.system() != 'Darwin':\n            try:\n                wp.setParentWindow(self.GetHandle())\n            except OverflowError:\n                # Sheesh, a negative value from GetHandle().  This can\n                # only happen on 32-bit Windows.\n                wp.setParentWindow(self.GetHandle() & 0xffffffff)\n\n        self.win = base.openWindow(props = wp, gsg = gsg, type = 'onscreen',\n                                   unexposedDraw = False)\n        self.Bind(wx.EVT_SIZE, self.onSize)\n\n        # This doesn't actually do anything, since wx won't call\n        # EVT_CLOSE on a child window, only on the toplevel window\n        # that contains it.\n        self.Bind(wx.EVT_CLOSE, self.__closeEvent)\n\n    def __closeEvent(self, event):\n        self.cleanup()\n        event.Skip()\n\n    def cleanup(self):\n        \"\"\" Parent windows should call cleanup() to clean up the\n        wxPandaWindow explicitly (since we can't catch EVT_CLOSE\n        directly). \"\"\"\n        if self.win:\n            base.closeWindow(self.win)\n            self.win = None\n\n    def onSize(self, event):\n        if self.win:\n            wp = WindowProperties()\n            wp.setOrigin(0, 0)\n            wp.setSize(*self.GetClientSize())\n            self.win.requestProperties(wp)\n        event.Skip()\n\n\nif not hasattr(wxgl, 'GLCanvas'):\n    OpenGLPandaWindow = None\nelse:\n    class OpenGLPandaWindow(wxgl.GLCanvas):  # type: ignore[no-redef]\n        \"\"\" This class implements a Panda3D \"window\" that actually draws\n        within the wx GLCanvas object.  It is supported whenever OpenGL is\n        Panda's rendering engine, and GLCanvas is available in wx. \"\"\"\n\n        removeCallbackWindow = ConfigVariableBool('remove-callback-window', True)\n\n        Keymap = {\n            wx.WXK_BACK: KeyboardButton.backspace(),\n            wx.WXK_TAB: KeyboardButton.tab(),\n            wx.WXK_RETURN: KeyboardButton.enter(),\n            wx.WXK_ESCAPE: KeyboardButton.escape(),\n            wx.WXK_DELETE: KeyboardButton._del(),  # del is a Python keyword\n            wx.WXK_SHIFT: KeyboardButton.shift(),\n            wx.WXK_ALT: KeyboardButton.alt(),\n            wx.WXK_CONTROL: KeyboardButton.control(),\n            wx.WXK_MENU: KeyboardButton.meta(),\n            wx.WXK_PAUSE: KeyboardButton.pause(),\n            wx.WXK_END: KeyboardButton.end(),\n            wx.WXK_HOME: KeyboardButton.home(),\n            wx.WXK_LEFT: KeyboardButton.left(),\n            wx.WXK_UP: KeyboardButton.up(),\n            wx.WXK_RIGHT: KeyboardButton.right(),\n            wx.WXK_DOWN: KeyboardButton.down(),\n            wx.WXK_PRINT: KeyboardButton.printScreen(),\n            wx.WXK_INSERT: KeyboardButton.insert(),\n            wx.WXK_F1: KeyboardButton.f1(),\n            wx.WXK_F2: KeyboardButton.f2(),\n            wx.WXK_F3: KeyboardButton.f3(),\n            wx.WXK_F4: KeyboardButton.f4(),\n            wx.WXK_F5: KeyboardButton.f5(),\n            wx.WXK_F6: KeyboardButton.f6(),\n            wx.WXK_F7: KeyboardButton.f7(),\n            wx.WXK_F8: KeyboardButton.f8(),\n            wx.WXK_F9: KeyboardButton.f9(),\n            wx.WXK_F10: KeyboardButton.f10(),\n            wx.WXK_F11: KeyboardButton.f11(),\n            wx.WXK_F12: KeyboardButton.f12(),\n            wx.WXK_NUMLOCK: KeyboardButton.numLock(),\n            wx.WXK_SCROLL: KeyboardButton.scrollLock(),\n            wx.WXK_PAGEUP: KeyboardButton.pageUp(),\n            wx.WXK_PAGEDOWN: KeyboardButton.pageDown(),\n            wx.WXK_COMMAND: KeyboardButton.meta(),\n        }\n\n        def __init__(self, *args, **kw):\n            gsg = None\n            if 'gsg' in kw:\n                gsg = kw['gsg']\n                del kw['gsg']\n\n            fbprops = kw.get('fbprops', None)\n            if fbprops is None:\n                fbprops = FrameBufferProperties.getDefault()\n\n            attribList = kw.get('attribList', None)\n            if attribList is None:\n                attribList = [\n                    wxgl.WX_GL_RGBA, True,\n                    wxgl.WX_GL_LEVEL, 0,\n                ]\n                if not fbprops.isSingleBuffered():\n                    attribList.append(wxgl.WX_GL_DOUBLEBUFFER)\n                    attribList.append(True)\n                if fbprops.getDepthBits() > 0:\n                    attribList.append(wxgl.WX_GL_DEPTH_SIZE)\n                    if fbprops.getDepthBits() <= 16:\n                        attribList.append(16)\n                    elif fbprops.getDepthBits() <= 24:\n                        attribList.append(24)\n                    else:\n                        attribList.append(32)\n\n                kw['attribList'] = attribList\n\n            base.startWx()\n            wxgl.GLCanvas.__init__(self, *args, **kw)\n            self.visible = False\n\n            # Can't share the GSG when a new wxgl.GLContext is created\n            # automatically.\n            gsg = None\n\n            callbackWindowDict = {\n                'Events': self.__eventsCallback,\n                'Properties': self.__propertiesCallback,\n                'Render': self.__renderCallback,\n            }\n\n            # Make sure we have an OpenGL GraphicsPipe.\n            if not base.pipe:\n                base.makeDefaultPipe()\n            pipe = base.pipe\n            if pipe.getInterfaceName() != 'OpenGL':\n                base.makeAllPipes()\n                for pipe in base.pipeList:\n                    if pipe.getInterfaceName() == 'OpenGL':\n                        break\n\n            if pipe.getInterfaceName() != 'OpenGL':\n                raise Exception(\"Couldn't get an OpenGL pipe.\")\n\n            self.win = base.openWindow(callbackWindowDict = callbackWindowDict, pipe = pipe, gsg = gsg, type = 'onscreen')\n            self.hasCapture = False\n            self.inputDevice = None\n            if hasattr(self.win, 'getInputDevice'):\n                self.inputDevice = self.win.getInputDevice(0)\n\n            self.Bind(wx.EVT_SIZE, self.onSize)\n            self.Bind(wx.EVT_PAINT, self.onPaint)\n            self.Bind(wx.EVT_IDLE, self.onIdle)\n\n            if self.inputDevice:\n                self.Bind(wx.EVT_LEFT_DOWN, lambda event: self.__buttonDown(MouseButton.one()))\n                self.Bind(wx.EVT_LEFT_UP, lambda event: self.__buttonUp(MouseButton.one()))\n                self.Bind(wx.EVT_MIDDLE_DOWN, lambda event: self.__buttonDown(MouseButton.two()))\n                self.Bind(wx.EVT_MIDDLE_UP, lambda event: self.__buttonUp(MouseButton.two()))\n                self.Bind(wx.EVT_RIGHT_DOWN, lambda event: self.__buttonDown(MouseButton.three()))\n                self.Bind(wx.EVT_RIGHT_UP, lambda event: self.__buttonUp(MouseButton.three()))\n                self.Bind(wx.EVT_MOTION, self.__mouseMotion)\n                self.Bind(wx.EVT_MOUSEWHEEL, self.__mouseWheel)\n                self.Bind(wx.EVT_LEAVE_WINDOW, self.__mouseLeaveWindow)\n                self.Bind(wx.EVT_KEY_DOWN, self.__keyDown)\n                self.Bind(wx.EVT_KEY_UP, self.__keyUp)\n                self.Bind(wx.EVT_CHAR, self.__keystroke)\n\n            # This doesn't actually do anything, since wx won't call\n            # EVT_CLOSE on a child window, only on the toplevel window\n            # that contains it.\n            self.Bind(wx.EVT_CLOSE, self.__closeEvent)\n\n        def __closeEvent(self, event):\n            self.cleanup()\n            event.Skip()\n\n        def cleanup(self):\n            \"\"\" Parent windows should call cleanup() to clean up the\n            wxPandaWindow explicitly (since we can't catch EVT_CLOSE\n            directly). \"\"\"\n            if self.win:\n                self.win.clearEventsCallback()\n                self.win.clearPropertiesCallback()\n                self.win.clearRenderCallback()\n                base.closeWindow(self.win, removeWindow = self.removeCallbackWindow)\n                self.win = None\n\n        def __buttonDown(self, button):\n            self.SetFocus()\n            if not self.hasCapture:\n                self.CaptureMouse()\n                self.hasCapture = True\n            self.inputDevice.buttonDown(button)\n\n        def __buttonUp(self, button):\n            if self.hasCapture:\n                self.ReleaseMouse()\n                self.hasCapture = False\n            self.inputDevice.buttonUp(button)\n\n        def __mouseMotion(self, event):\n            self.inputDevice.setPointerInWindow(*event.GetPosition())\n\n        def __mouseWheel(self, event):\n            amount = event.GetWheelRotation()\n            if amount > 0.0:\n                self.inputDevice.buttonDown(MouseButton.wheelUp())\n                self.inputDevice.buttonUp(MouseButton.wheelUp())\n            elif amount < 0.0:\n                self.inputDevice.buttonDown(MouseButton.wheelDown())\n                self.inputDevice.buttonUp(MouseButton.wheelDown())\n\n        def __mouseLeaveWindow(self, event):\n            self.inputDevice.setPointerOutOfWindow()\n\n        def __keyDown(self, event):\n            key = self.__getkey(event)\n            if key:\n                self.inputDevice.buttonDown(key)\n\n        def __keyUp(self, event):\n            key = self.__getkey(event)\n            if key:\n                self.inputDevice.buttonUp(key)\n\n        def __getkey(self, event):\n            code = event.GetKeyCode()\n            key = self.Keymap.get(code, None)\n            if key is not None:\n                return key\n\n            if code >= 0x41 and code <= 0x5a:\n                # wxWidgets returns uppercase letters, but Panda expects\n                # lowercase letters.\n                return KeyboardButton.asciiKey(code + 0x20)\n            if code >= 0x20 and code <= 0x80:\n                # Other ASCII keys are treated the same way in wx and Panda.\n                return KeyboardButton.asciiKey(code)\n\n            return None\n\n        def __keystroke(self, event):\n            if hasattr(event, 'GetUnicodeKey'):\n                code = event.GetUnicodeKey()\n            else:\n                code = event.GetKeyCode()\n                if code < 0x20 or code >= 0x80:\n                    return\n\n            self.inputDevice.keystroke(code)\n\n        def __eventsCallback(self, data):\n            data.upcall()\n\n        def __propertiesCallback(self, data):\n            data.upcall()\n\n        def __renderCallback(self, data):\n            cbType = data.getCallbackType()\n            if cbType == CallbackGraphicsWindow.RCTBeginFrame:\n                if not self.visible:\n                    data.setRenderFlag(False)\n                    return\n                self.SetCurrent()\n\n                # Don't upcall() in this case.\n                return\n\n            elif cbType == CallbackGraphicsWindow.RCTEndFlip:\n                self.SwapBuffers()\n\n                # Now that we've swapped, ask for a refresh, so we'll\n                # get another paint message if the window is still\n                # visible onscreen.\n                self.Refresh()\n                self.visible = False\n\n            data.upcall()\n\n        def onSize(self, event):\n            wp = WindowProperties()\n            wp.setSize(*self.GetClientSize())\n            self.win.requestProperties(wp)\n\n            # Apparently, sometimes on Linux we get the onSize event\n            # before the size has actually changed, and the size we\n            # report in GetClientSize() is the *previous* size.  To\n            # work around this unfortunate circumstance, we'll also\n            # ensure an idle event comes in later, and check the size\n            # again then.\n            wx.WakeUpIdle()\n\n            event.Skip()\n\n        def onPaint(self, event):\n            \"\"\" This is called whenever we get the first paint event,\n            at which point we can conclude that the window has\n            actually been manifested onscreen.  (In X11, there appears\n            to be no way to know this otherwise.) \"\"\"\n            self.visible = True\n\n            # Important not to Skip this event, so the window\n            # subsystem believes we've drawn the window.\n            #event.Skip()\n\n        def onIdle(self, event):\n            if self.win:\n                size = None\n                properties = self.win.getProperties()\n                if properties.hasSize():\n                    size = (properties.getXSize(), properties.getYSize())\n\n                if tuple(self.GetClientSize()) != size:\n                    # The window has changed size during the idle call.\n                    # This seems to be possible in Linux.\n                    wp = WindowProperties()\n                    wp.setSize(*self.GetClientSize())\n                    self.win.requestProperties(wp)\n\n            event.Skip()\n\n# Choose the best implementation of WxPandaWindow for the platform.\nWxPandaWindow = None\nif platform.system() == 'Darwin' or platform.system() == 'Linux':\n    WxPandaWindow = OpenGLPandaWindow\n\nif not WxPandaWindow:\n    WxPandaWindow = EmbeddedPandaWindow\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/wxwidgets/WxPandaWindow.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/e9443847_WxPandaWindow.json",
    "doc_id": "doc_16"
  }
}