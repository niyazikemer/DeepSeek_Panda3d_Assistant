{
  "content": "\"\"\"Contains the BufferViewer class, which is used as a debugging aid\nwhen debugging render-to-texture effects.  It shows different views at\nthe bottom of the screen showing the various render targets.\n\nWhen using ShowBase, the normal way to enable the BufferViewer is using the\nfollowing code::\n\n    base.bufferViewer.toggleEnable()\n\nOr, you can enable the following variable in your Config.prc::\n\n    show-buffers true\n\"\"\"\n\n__all__ = ['BufferViewer']\n\nfrom panda3d.core import (\n    CardMaker,\n    ConfigVariableBool,\n    ConfigVariableDouble,\n    ConfigVariableString,\n    Geom,\n    GeomNode,\n    GeomTriangles,\n    GeomVertexData,\n    GeomVertexFormat,\n    GeomVertexWriter,\n    GraphicsEngine,\n    GraphicsOutput,\n    NodePath,\n    Point3,\n    SamplerState,\n    Texture,\n    Vec3,\n    Vec3F,\n)\nfrom direct.task import Task\nfrom direct.task.TaskManagerGlobal import taskMgr\nfrom direct.directnotify.DirectNotifyGlobal import directNotify\nfrom direct.showbase.DirectObject import DirectObject\nimport math\n\n\nclass BufferViewer(DirectObject):\n    notify = directNotify.newCategory('BufferViewer')\n\n    def __init__(self, win, parent):\n        \"\"\"Access: private.  Constructor.\"\"\"\n        self.enabled = 0\n        size = ConfigVariableDouble('buffer-viewer-size', '0 0')\n        self.sizex = size[0]\n        self.sizey = size[1]\n        self.position = ConfigVariableString('buffer-viewer-position', \"lrcorner\").getValue()\n        self.layout = ConfigVariableString('buffer-viewer-layout', \"hline\").getValue()\n        self.include = \"all\"\n        self.exclude = \"none\"\n        self.cullbin = \"fixed\"\n        self.cullsort = 10000\n        self.win = win\n        self.engine = GraphicsEngine.getGlobalPtr()\n        self.renderParent = parent\n        self.cards = []\n        self.cardindex = 0\n        self.cardmaker = CardMaker(\"cubemaker\")\n        self.cardmaker.setFrame(-1,1,-1,1)\n        self.task = 0\n        self.dirty = 1\n        self.accept(\"render-texture-targets-changed\", self.refreshReadout)\n        if ConfigVariableBool(\"show-buffers\", 0):\n            self.enable(1)\n\n    def refreshReadout(self):\n        \"\"\"Force the readout to be refreshed.  This is usually invoked\n        by GraphicsOutput::add_render_texture (via an event handler).\n        However, it is also possible to invoke it manually.  Currently,\n        the only time I know of that this is necessary is after a\n        window resize (and I ought to fix that).\"\"\"\n        self.dirty = 1\n\n        # Call enabled again, mainly to ensure that the task has been\n        # started.\n        self.enable(self.enabled)\n\n    def isValidTextureSet(self, x):\n        \"\"\"Access: private. Returns true if the parameter is a\n        list of GraphicsOutput and Texture, or the keyword 'all'.\"\"\"\n        if isinstance(x, list):\n            for elt in x:\n                if not self.isValidTextureSet(elt):\n                    return 0\n        else:\n            return x == \"all\" or isinstance(x, Texture) or isinstance(x, GraphicsOutput)\n\n    def isEnabled(self):\n        \"\"\"Returns true if the buffer viewer is currently enabled.\"\"\"\n        return self.enabled\n\n    def enable(self, x):\n        \"\"\"Turn the buffer viewer on or off.  The initial state of the\n        buffer viewer depends on the Config variable 'show-buffers'.\"\"\"\n        if x != 0 and x != 1:\n            BufferViewer.notify.error('invalid parameter to BufferViewer.enable')\n            return\n        self.enabled = x\n        self.dirty = 1\n        if (x and self.task == 0):\n            self.task = taskMgr.add(self.maintainReadout, \"buffer-viewer-maintain-readout\",\n                                    priority=1)\n\n    def toggleEnable(self):\n        \"\"\"Toggle the buffer viewer on or off.  The initial state of the\n        enable flag depends on the Config variable 'show-buffers'.\"\"\"\n        self.enable(1-self.enabled)\n\n    def setCardSize(self, x, y):\n        \"\"\"Set the size of each card.  The units are relative to\n        render2d (ie, 1x1 card is not square).  If one of the\n        dimensions is zero, then the viewer will choose a value\n        for that dimension so as to ensure that the aspect ratio\n        of the card matches the aspect ratio of the source-window.\n        If both dimensions are zero, the viewer uses a heuristic\n        to choose a reasonable size for the card.  The initial\n        value is (0, 0).\"\"\"\n        if x < 0 or y < 0:\n            BufferViewer.notify.error('invalid parameter to BufferViewer.setCardSize')\n            return\n        self.sizex = x\n        self.sizey = y\n        self.dirty = 1\n\n    def setPosition(self, pos):\n        \"\"\"Set the position of the cards.  The valid values are:\n\n        - *llcorner* - put them in the lower-left  corner of the window\n        - *lrcorner* - put them in the lower-right corner of the window\n        - *ulcorner* - put them in the upper-left  corner of the window\n        - *urcorner* - put them in the upper-right corner of the window\n        - *window* - put them in a separate window\n\n        The initial value is 'lrcorner'.\"\"\"\n        valid = [\"llcorner\", \"lrcorner\", \"ulcorner\", \"urcorner\", \"window\"]\n        if valid.count(pos) == 0:\n            BufferViewer.notify.error('invalid parameter to BufferViewer.setPosition')\n            BufferViewer.notify.error('valid parameters are: llcorner, lrcorner, ulcorner, urcorner, window')\n            return\n        if pos == \"window\":\n            BufferViewer.notify.error('BufferViewer.setPosition - \"window\" mode not implemented yet.')\n            return\n        self.position = pos\n        self.dirty = 1\n\n    def setLayout(self, lay):\n        \"\"\"Set the layout of the cards.  The valid values are:\n\n        - *vline* - display them in a vertical line\n        - *hline* - display them in a horizontal line\n        - *vgrid* - display them in a vertical grid\n        - *hgrid* - display them in a horizontal grid\n        - *cycle* - display one card at a time, using selectCard/advanceCard\n\n        The default value is 'hline'.\"\"\"\n        valid=[\"vline\", \"hline\", \"vgrid\", \"hgrid\", \"cycle\"]\n        if valid.count(lay) == 0:\n            BufferViewer.notify.error('invalid parameter to BufferViewer.setLayout')\n            BufferViewer.notify.error('valid parameters are: vline, hline, vgrid, hgrid, cycle')\n            return\n        self.layout = lay\n        self.dirty = 1\n\n    def selectCard(self, i):\n        \"\"\"Only useful when using setLayout('cycle').  Sets the index\n        that selects which card to display.  The index is taken modulo\n        the actual number of cards.\"\"\"\n        self.cardindex = i\n        self.dirty = 1\n\n    def advanceCard(self):\n        \"\"\"Only useful when using setLayout('cycle').  Increments the index\n        that selects which card to display.  The index is taken modulo\n        the actual number of cards.\"\"\"\n        self.cardindex += 1\n        self.dirty = 1\n\n    def setInclude(self, x):\n        \"\"\"Set the include-set for the buffer viewer.  The include-set\n        specifies which of the render-to-texture targets to display.\n        Valid inputs are the string 'all' (display every render-to-texture\n        target), or a list of GraphicsOutputs or Textures.  The initial\n        value is 'all'.\"\"\"\n        if not self.isValidTextureSet(x):\n            BufferViewer.notify.error('setInclude: must be list of textures and buffers, or \"all\"')\n            return\n        self.include = x\n        self.dirty = 1\n\n    def setExclude(self, x):\n        \"\"\"Set the exclude-set for the buffer viewer.  The exclude-set\n        should be a list of GraphicsOutputs and Textures to ignore.\n        The exclude-set is subtracted from the include-set (so the excludes\n        effectively override the includes.)  The initial value is the\n        empty list.\"\"\"\n        if not self.isValidTextureSet(x):\n            BufferViewer.notify.error('setExclude: must be list of textures and buffers')\n            return\n        self.exclude = x\n        self.dirty = 1\n\n    def setSort(self, bin, sort):\n        \"\"\"Set the cull-bin and sort-order for the output cards.  The\n        default value is 'fixed', 10000.\"\"\"\n        self.cullbin = bin\n        self.cullsort = sort\n        self.dirty = 1\n\n    def setRenderParent(self, renderParent):\n        \"\"\"Set the scene graph root to which the output cards should\n        be parented.  The default is render2d. \"\"\"\n        self.renderParent = renderParent\n        self.dirty = 1\n\n    def analyzeTextureSet(self, x, set):\n        \"\"\"Access: private.  Converts a list of GraphicsObject,\n        GraphicsEngine, and Texture into a table of Textures.\"\"\"\n\n        if isinstance(x, list):\n            for elt in x:\n                self.analyzeTextureSet(elt, set)\n        elif isinstance(x, Texture):\n            set[x] = 1\n        elif isinstance(x, GraphicsOutput):\n            for itex in range(x.countTextures()):\n                tex = x.getTexture(itex)\n                set[tex] = 1\n        elif isinstance(x, GraphicsEngine):\n            for iwin in range(x.getNumWindows()):\n                win = x.getWindow(iwin)\n                self.analyzeTextureSet(win, set)\n        elif x == \"all\":\n            self.analyzeTextureSet(self.engine, set)\n        else:\n            return\n\n    def makeFrame(self, sizex, sizey):\n        \"\"\"Access: private.  Each texture card is displayed with\n        a two-pixel wide frame (a ring of black and a ring of white).\n        This routine builds the frame geometry.  It is necessary to\n        be precise so that the frame exactly aligns to pixel\n        boundaries, and so that it doesn't overlap the card at all.\"\"\"\n\n        format = GeomVertexFormat.getV3c()\n        vdata = GeomVertexData('card-frame', format, Geom.UHDynamic)\n\n        vwriter = GeomVertexWriter(vdata, 'vertex')\n        cwriter = GeomVertexWriter(vdata, 'color')\n\n        ringoffset = [0, 1, 1, 2]\n        ringbright = [0, 0, 1, 1]\n        for ring in range(4):\n            offsetx = (ringoffset[ring]*2.0) / float(sizex)\n            offsety = (ringoffset[ring]*2.0) / float(sizey)\n            bright = ringbright[ring]\n            vwriter.addData3f(Vec3F.rfu(-1 - offsetx, 0, -1 - offsety))\n            vwriter.addData3f(Vec3F.rfu( 1 + offsetx, 0, -1 - offsety))\n            vwriter.addData3f(Vec3F.rfu( 1 + offsetx, 0,  1 + offsety))\n            vwriter.addData3f(Vec3F.rfu(-1 - offsetx, 0,  1 + offsety))\n            cwriter.addData3f(bright, bright, bright)\n            cwriter.addData3f(bright, bright, bright)\n            cwriter.addData3f(bright, bright, bright)\n            cwriter.addData3f(bright, bright, bright)\n\n        triangles = GeomTriangles(Geom.UHStatic)\n        for i in range(2):\n            delta = i*8\n            triangles.addVertices(0 + delta, 4 + delta, 1 + delta)\n            triangles.addVertices(1 + delta, 4 + delta, 5 + delta)\n            triangles.addVertices(1 + delta, 5 + delta, 2 + delta)\n            triangles.addVertices(2 + delta, 5 + delta, 6 + delta)\n            triangles.addVertices(2 + delta, 6 + delta, 3 + delta)\n            triangles.addVertices(3 + delta, 6 + delta, 7 + delta)\n            triangles.addVertices(3 + delta, 7 + delta, 0 + delta)\n            triangles.addVertices(0 + delta, 7 + delta, 4 + delta)\n        triangles.closePrimitive()\n\n        geom = Geom(vdata)\n        geom.addPrimitive(triangles)\n        geomnode=GeomNode(\"card-frame\")\n        geomnode.addGeom(geom)\n        return NodePath(geomnode)\n\n    def maintainReadout(self, task):\n        \"\"\"Access: private.  Whenever necessary, rebuilds the entire\n        display from scratch.  This is only done when the configuration\n        parameters have changed.\"\"\"\n\n        # If nothing has changed, don't update.\n        if not self.dirty:\n            return Task.cont\n        self.dirty = 0\n\n        # Delete the old set of cards.\n        for card in self.cards:\n            card.removeNode()\n        self.cards = []\n\n        # If not enabled, return.\n        if not self.enabled:\n            self.task = 0\n            return Task.done\n\n        # Generate the include and exclude sets.\n        exclude = {}\n        include = {}\n        self.analyzeTextureSet(self.exclude, exclude)\n        self.analyzeTextureSet(self.include, include)\n\n        # Use a custom sampler when applying the textures.  This fixes\n        # wrap issues and prevents depth compare on shadow maps.\n        sampler = SamplerState()\n        sampler.setWrapU(SamplerState.WM_clamp)\n        sampler.setWrapV(SamplerState.WM_clamp)\n        sampler.setWrapW(SamplerState.WM_clamp)\n        sampler.setMinfilter(SamplerState.FT_linear)\n        sampler.setMagfilter(SamplerState.FT_nearest)\n\n        # Generate a list of cards and the corresponding windows.\n        cards = []\n        wins = []\n        for iwin in range(self.engine.getNumWindows()):\n            win = self.engine.getWindow(iwin)\n            for itex in range(win.countTextures()):\n                tex = win.getTexture(itex)\n                if (tex in include) and (tex not in exclude):\n                    if tex.getTextureType() == Texture.TTCubeMap:\n                        for face in range(6):\n                            self.cardmaker.setUvRangeCube(face)\n                            card = NodePath(self.cardmaker.generate())\n                            card.setTexture(tex, sampler)\n                            cards.append(card)\n                    elif tex.getTextureType() == Texture.TT2dTextureArray:\n                        for layer in range(tex.getZSize()):\n                            self.cardmaker.setUvRange((0, 1, 1, 0), (0, 0, 1, 1),\\\n                                                      (layer, layer, layer, layer))\n                            card = NodePath(self.cardmaker.generate())\n                            # 2D texture arrays are not supported by\n                            # the fixed-function pipeline, so we need to\n                            # enable the shader generator to view them.\n                            card.setShaderAuto()\n                            card.setTexture(tex, sampler)\n                            cards.append(card)\n                    else:\n                        card = win.getTextureCard()\n                        card.setTexture(tex, sampler)\n                        cards.append(card)\n                    wins.append(win)\n                    exclude[tex] = 1\n        self.cards = cards\n        if len(cards) == 0:\n            self.task = 0\n            return Task.done\n        ncards = len(cards)\n\n        # Decide how many rows and columns to use for the layout.\n        if self.layout == \"hline\":\n            rows = 1\n            cols = ncards\n        elif self.layout == \"vline\":\n            rows = ncards\n            cols = 1\n        elif self.layout == \"hgrid\":\n            rows = int(math.sqrt(ncards))\n            cols = rows\n            if rows * cols < ncards:\n                cols += 1\n            if rows * cols < ncards:\n                rows += 1\n        elif self.layout == \"vgrid\":\n            rows = int(math.sqrt(ncards))\n            cols = rows\n            if rows * cols < ncards:\n                rows += 1\n            if rows * cols < ncards:\n                cols += 1\n        elif self.layout == \"cycle\":\n            rows = 1\n            cols = 1\n        else:\n            BufferViewer.notify.error('shouldnt ever get here in BufferViewer.maintainReadout')\n\n        # Choose an aspect ratio for the cards.  All card size\n        # calculations are done in pixel-units, using integers,\n        # in order to ensure that everything ends up neatly on\n        # a pixel boundary.\n\n        aspectx = wins[0].getXSize()\n        aspecty = wins[0].getYSize()\n        for win in wins:\n            if win.getXSize() * aspecty != win.getYSize() * aspectx:\n                aspectx = 1\n                aspecty = 1\n\n        # Choose a card size.  If the user didn't specify a size,\n        # use a heuristic, otherwise, just follow orders.  The\n        # heuristic uses an initial card size of 42.66666667% of\n        # the screen vertically, which comes to 256 pixels on\n        # an 800x600 display.  Then, it double checks that the\n        # readout will fit on the screen, and if not, it shrinks it.\n\n        bordersize = 4.0\n\n        if float(self.sizex) == 0.0 and float(self.sizey) == 0.0:\n            sizey = int(0.4266666667 * self.win.getYSize())\n            sizex = (sizey * aspectx) // aspecty\n            v_sizey = (self.win.getYSize() - (rows - 1) - (rows * 2)) // rows\n            v_sizex = (v_sizey * aspectx) // aspecty\n            if (v_sizey < sizey) or (v_sizex < sizex):\n                sizey = v_sizey\n                sizex = v_sizex\n\n            adjustment = 2\n            h_sizex = float(self.win.getXSize() - adjustment) / float(cols)\n\n            h_sizex -= bordersize\n            if h_sizex < 1.0:\n                h_sizex = 1.0\n\n            h_sizey = (h_sizex * aspecty) // aspectx\n            if h_sizey < sizey or h_sizex < sizex:\n                sizey = h_sizey\n                sizex = h_sizex\n        else:\n            sizex = int(self.sizex * 0.5 * self.win.getXSize())\n            sizey = int(self.sizey * 0.5 * self.win.getYSize())\n            if sizex == 0:\n                sizex = (sizey * aspectx) // aspecty\n            if sizey == 0:\n                sizey = (sizex * aspecty) // aspectx\n\n        # Convert from pixels to render2d-units.\n        fsizex = (2.0 * sizex) / float(self.win.getXSize())\n        fsizey = (2.0 * sizey) / float(self.win.getYSize())\n        fpixelx = 2.0 / float(self.win.getXSize())\n        fpixely = 2.0 / float(self.win.getYSize())\n\n        # Choose directional offsets\n        if self.position == \"llcorner\":\n            dirx = -1.0\n            diry = -1.0\n        elif self.position == \"lrcorner\":\n            dirx =  1.0\n            diry = -1.0\n        elif self.position == \"ulcorner\":\n            dirx = -1.0\n            diry =  1.0\n        elif self.position == \"urcorner\":\n            dirx =  1.0\n            diry =  1.0\n        else:\n            BufferViewer.notify.error('window mode not implemented yet')\n\n        # Create the frame\n        frame = self.makeFrame(sizex, sizey)\n\n        # Now, position the cards on the screen.\n        # For each card, create a frame consisting of eight quads.\n\n        for r in range(rows):\n            for c in range(cols):\n                index = c + r * cols\n                if index < ncards:\n                    index = (index + self.cardindex) % len(cards)\n\n                    posx = dirx * (1.0 - ((c + 0.5) * (fsizex + fpixelx * bordersize))) - (fpixelx * dirx)\n                    posy = diry * (1.0 - ((r + 0.5) * (fsizey + fpixely * bordersize))) - (fpixely * diry)\n                    placer = NodePath(\"card-structure\")\n                    placer.setPos(Point3.rfu(posx, 0, posy))\n                    placer.setScale(Vec3.rfu(fsizex * 0.5, 1.0, fsizey * 0.5))\n                    placer.setBin(self.cullbin, self.cullsort)\n                    placer.reparentTo(self.renderParent)\n                    frame.instanceTo(placer)\n                    cards[index].reparentTo(placer)\n                    cards[index] = placer\n\n        return Task.cont\n\n    # Snake-case aliases, for people who prefer these.\n    advance_card = advanceCard\n    analyze_texture_set = analyzeTextureSet\n    is_enabled = isEnabled\n    is_valid_texture_set = isValidTextureSet\n    maintain_readout = maintainReadout\n    make_frame = makeFrame\n    refresh_readout = refreshReadout\n    select_card = selectCard\n    set_card_size = setCardSize\n    set_exclude = setExclude\n    set_include = setInclude\n    set_layout = setLayout\n    set_position = setPosition\n    set_render_parent = setRenderParent\n    set_sort = setSort\n    toggle_enable = toggleEnable\n",
  "metadata": {
    "source": "corpus_panda3d/source_code/direct/src/showbase/BufferViewer.py",
    "doc_type": "python",
    "file_path": "processed_documents/context_documents/05ee60a9_BufferViewer.json",
    "doc_id": "doc_239"
  }
}