{
  "content": "The provided code chunk is part of a function responsible for resolving references during automatic documentation processing. This function checks if a specific function exists within a module, determines its type (e.g., constructor or method), and adjusts the reference path accordingly, particularly in Python domains where methods are scoped under their class definitions.\n\n```python\ndef resolve_reference(modname, search):\n    \"\"\"Resolve a reference to a function or constructor in the given module.\n    \n    This function checks if the specified function exists in the module. If it does,\n    it processes the function name based on its domain (cpp or py). For Python functions,\n    it identifies if the function is a method and adjusts the reference path to point to\n    the containing class, especially for constructors where the function name matches\n    the class name.\n    \n    Args:\n        modname: The module name where the function is located.\n        search: The function or constructor to resolve.\n        \n    Returns:\n        A tuple indicating the type of reference ('func' or 'class') and the resolved name.\n    \"\"\"\n    # (Code chunk as provided)\n```\n\nifunc = idb.lookup_function(modname, search)\n        if ifunc:\n            if domain == 'cpp':\n                func_name = interrogate_function_scoped_name(ifunc)\n                return ('func', func_name)\n            elif domain == 'py':\n                # Grab the mangled function name.\n                func_name = idb.get_function_name(ifunc, scoped=False, mangle=True)\n                if interrogate_function_is_method(ifunc):\n                    outer = interrogate_function_class(ifunc)\n                    prefix = interrogate_type_module_name(outer)\n                    if prefix:\n                        prefix += '.'\n                    type_name = idb.get_type_name(outer, mangle=False, scoped=True)\n                    if len(refpath) == 1 and interrogate_function_name(ifunc).lstrip('~') == interrogate_type_name(outer):\n                        # This matches a constructor, but we want the class.\n                        return ('class', prefix + type_name)",
  "metadata": {
    "doc_type": "python",
    "doc_id": "doc_4",
    "parent": "processed_documents/context_documents/5d34b79e_f7df0e75_6676e524_conf.json",
    "chunk_number": 60
  }
}