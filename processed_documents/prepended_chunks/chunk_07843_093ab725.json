{
  "content": "\"\"\"\nThis section introduces the fundamental concepts of Bullet collision filtering in Panda3D, explaining how by default all Bullet collision objects interact and collide with each other. It defines what constitutes a \"collision object,\" including rigid bodies, ghost nodes, and soft body nodes, while clarifying that these do not interact with visible geometry (GeomNode objects). The section emphasizes the importance of proper collision filtering through bitmask assignments to control interactions between objects and provides an example using BitMask32 in Python. This sets the stage for more advanced topics like group assignment and multiple group memberships discussed later in the document.\n\"\"\"\n\nBullet Collision Filtering\n\nBy default all Bullet collision objects collide with all other Bullet collision objects. Here the term \"collision objects\" refers to objects which are derived from .BulletBodyNode, namely .BulletRigidBodyNode, .BulletGhostNode, and .BulletSoftBodyNode.\n\nBullet collision objects won't collide with visible geometry, that is objects of type .GeomNode!\n\nSometime we need more control over who collides with whom. This can be achieved by setting up collision filtering properly. Collision filtering is done using bitmasks, which get assigned to every collision object.\n\nBit Masks\n\nBullet makes use of the regular Panda3D collide masks, which are instances of .BitMask32. Two objects collide if the two masks have at least one bit in common. The following example shows a selection of common ways to set up a bit mask. For more information please refer to the manual page on collision-bitmasks.\n\npython\n\nfrom panda3d.core import BitMask32",
  "metadata": {
    "doc_type": "rst",
    "doc_id": "doc_726",
    "parent": "processed_documents/context_documents/d4378174_cadceabb_collision-filtering.json",
    "chunk_number": 7843
  }
}