{
  "content": "This chunk discusses how to dynamically access attributes on nodes in a real-world scenario when dealing with multiple node types. It explains using Python tags to retrieve subclass instances and demonstrates testing for attribute presence or type compatibility to enable flexible application behavior.\n\n# and finally we fetch the variable we were\n# interested in all along:\nprint(theInstanceOfMyNewNode.aVariable)\n\nIn the real world\n\nIn a real-world scenario, while dealing with many nodes of arbitrary types, things get only marginally more difficult. Ultimately you'll want to access attributes that you know are present on nodes of one or more new subclasses. For this purpose, once you have a handle to the subclass instance, you can either test for the type you are expecting (safe but makes the application more static) or you can test for the presence of the attribute itself (less safe but creates potentially more dynamic, expandable application).\n\nFor example:\n\n# here we setup the scene\naNodePath = render.attachNewNode(anInstanceOfMyNewSubclass)\naPandaNode = aNodePath.node()",
  "metadata": {
    "doc_type": "rst",
    "doc_id": "doc_628",
    "parent": "processed_documents/context_documents/0cbeff75_8d61bbfe_subclassing.json",
    "chunk_number": 7339
  }
}